#NoTrayIcon
#RequireAdmin
#pragma compile(ProductName, My Bot)
#pragma compile(Out, MyBot.run.exe) ; Required
#pragma compile(Icon, "Images\MyBot.ico")
#pragma compile(FileDescription, Clash of Clans Bot - A Free Clash of Clans bot - https://mybot.run)
#pragma compile(ProductVersion, 7.7)
#pragma compile(FileVersion, 7.7.3)
#pragma compile(LegalCopyright, © https://mybot.run)
#Au3Stripper_Off
#Au3Stripper_On
Global $g_sBotVersion = "v7.7.3"
Global $g_sModVersion = "v2.0"
Global $g_sModSupportUrl = "https://github.com/NguyenAnhHD/MyBot.Run-AIO-MOD/releases"
Opt("MustDeclareVars", 1)
Global $g_sBotTitle = ""
Global $g_hFrmBot = 0
Global Const $WAIT_TIMEOUT = 258
Global Const $WS_OVERLAPPED = 0
Global Const $WS_MAXIMIZEBOX = 0x00010000
Global Const $WS_MINIMIZEBOX = 0x00020000
Global Const $WS_TABSTOP = 0x00010000
Global Const $WS_GROUP = 0x00020000
Global Const $WS_SIZEBOX = 0x00040000
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 0x00080000
Global Const $WS_HSCROLL = 0x00100000
Global Const $WS_VSCROLL = 0x00200000
Global Const $WS_DLGFRAME = 0x00400000
Global Const $WS_BORDER = 0x00800000
Global Const $WS_CAPTION = 0x00C00000
Global Const $WS_MAXIMIZE = 0x01000000
Global Const $WS_CLIPCHILDREN = 0x02000000
Global Const $WS_CLIPSIBLINGS = 0x04000000
Global Const $WS_DISABLED = 0x08000000
Global Const $WS_VISIBLE = 0x10000000
Global Const $WS_MINIMIZE = 0x20000000
Global Const $WS_CHILD = 0x40000000
Global Const $WS_POPUP = 0x80000000
Global Const $WS_POPUPWINDOW = 0x80880000
Global Const $DS_MODALFRAME = 0x0080
Global Const $WS_EX_APPWINDOW = 0x00040000
Global Const $WS_EX_CONTROLPARENT = 0x10000
Global Const $WS_EX_LAYERED = 0x00080000
Global Const $WS_EX_MDICHILD = 0x00000040
Global Const $WS_EX_NOACTIVATE = 0x08000000
Global Const $WS_EX_RIGHT = 0x00001000
Global Const $WS_EX_STATICEDGE = 0x00020000
Global Const $WS_EX_TOOLWINDOW = 0x00000080
Global Const $WS_EX_TOPMOST = 0x00000008
Global Const $WS_EX_TRANSPARENT = 0x00000020
Global Const $WS_EX_WINDOWEDGE = 0x00000100
Global Const $WM_MOVE = 0x0003
Global Const $WM_SETFOCUS = 0x0007
Global Const $WM_KILLFOCUS = 0x0008
Global Const $WM_SETREDRAW = 0x000B
Global Const $WM_CLOSE = 0x0010
Global Const $WM_ACTIVATEAPP = 0x001C
Global Const $WM_GETFONT = 0x0031
Global Const $WM_NOTIFY = 0x004E
Global Const $WM_SETICON = 0x0080
Global Const $WM_NCACTIVATE = 0x0086
Global Const $WM_KEYDOWN = 0x0100
Global Const $WM_KEYUP = 0x0101
Global Const $WM_SYSKEYDOWN = 0x0104
Global Const $WM_SYSKEYUP = 0x0105
Global Const $WM_COMMAND = 0x0111
Global Const $WM_SYSCOMMAND = 0x0112
Global Const $WM_MOUSEMOVE = 0x0200
Global Const $WM_LBUTTONDOWN = 0x0201
Global Const $WM_LBUTTONUP = 0x0202
Global Const $WM_LBUTTONDBLCLK = 0x0203
Global Const $WM_RBUTTONDOWN = 0x0204
Global Const $WM_RBUTTONUP = 0x0205
Global Const $WM_MBUTTONDOWN = 0x0207
Global Const $WM_MOUSEWHEEL = 0x020A
Global Const $WM_MOUSEHWHEEL = 0x020E
Global Const $SM_CYCAPTION = 4
Global Const $SRCCOPY = 0x00CC0020
Global Const $RDW_ERASE = 0x0004
Global Const $RDW_FRAME = 0x0400
Global Const $RDW_INVALIDATE = 0x0001
Global Const $RDW_UPDATENOW = 0x0100
Global Const $RDW_ALLCHILDREN = 0x0080
Global Const $STARTF_USESHOWWINDOW = 0x1
Global Const $STARTF_USESTDHANDLES = 0x100
Global Const $SD_SHUTDOWN = 1
Global Const $SD_REBOOT = 2
Global Const $SD_FORCE = 4
Global Const $SD_STANDBY = 32
Global Const $STDIN_CHILD = 1
Global Const $STDERR_MERGED = 8
Global Const $UBOUND_DIMENSIONS = 0
Global Const $UBOUND_ROWS = 1
Global Const $UBOUND_COLUMNS = 2
Global Const $HWND_BOTTOM = 1
Global Const $HWND_NOTOPMOST = -2
Global Const $HWND_TOP = 0
Global Const $HWND_TOPMOST = -1
Global Const $SWP_NOSIZE = 0x0001
Global Const $SWP_NOMOVE = 0x0002
Global Const $SWP_NOZORDER = 0x0004
Global Const $SWP_NOACTIVATE = 0x0010
Global Const $SWP_FRAMECHANGED = 0x0020
Global Const $SWP_SHOWWINDOW = 0x0040
Global Const $SWP_HIDEWINDOW = 0x0080
Global Const $SWP_NOOWNERZORDER = 0x0200
Global Const $SWP_NOREPOSITION = 0x0200
Global Const $SWP_NOSENDCHANGING = 0x0400
Global Const $ASSIGN_EXISTFAIL = 4
Global Const $DIR_REMOVE= 1
Global Const $FC_NOOVERWRITE = 0
Global Const $FC_OVERWRITE = 1
Global Const $FC_CREATEPATH = 8
Global Const $FT_MODIFIED = 0
Global Const $FT_CREATED = 1
Global Const $FT_STRING = 1
Global Const $FSF_NEWDIALOG = 2
Global Const $FO_READ = 0
Global Const $FO_APPEND = 1
Global Const $FO_OVERWRITE = 2
Global Const $FO_CREATEPATH = 8
Global Const $FO_BINARY = 16
Global Const $FO_UTF16_LE = 32
Global Const $FO_UTF8_NOBOM = 256
Global Const $FD_FILEMUSTEXIST = 1
Global Const $CREATE_NEW = 1
Global Const $CREATE_ALWAYS = 2
Global Const $OPEN_EXISTING = 3
Global Const $OPEN_ALWAYS = 4
Global Const $TRUNCATE_EXISTING = 5
Global Const $FILE_ATTRIBUTE_READONLY = 0x00000001
Global Const $FILE_ATTRIBUTE_HIDDEN = 0x00000002
Global Const $FILE_ATTRIBUTE_SYSTEM = 0x00000004
Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x00000020
Global Const $FILE_SHARE_READ = 0x00000001
Global Const $FILE_SHARE_WRITE = 0x00000002
Global Const $FILE_SHARE_DELETE = 0x00000004
Global Const $GENERIC_EXECUTE = 0x20000000
Global Const $GENERIC_WRITE = 0x40000000
Global Const $GENERIC_READ = 0x80000000
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FLTA_FILESFOLDERS = 0
Global Const $FLTA_FILES = 1
Global Const $FLTA_FOLDERS = 2
Global Const $FLTAR_FILESFOLDERS = 0
Global Const $FLTAR_FILES = 1
Global Const $FLTAR_NOHIDDEN = 4
Global Const $FLTAR_NORECUR = 0
Global Const $FLTAR_RECUR = 1
Global Const $FLTAR_NOSORT = 0
Global Const $FLTAR_SORT = 1
Global Const $FLTAR_NOPATH = 0
Global Const $FLTAR_RELPATH = 1
Global Const $MB_OK = 0
Global Const $MB_OKCANCEL = 1
Global Const $MB_YESNO = 4
Global Const $MB_ICONWARNING = 48
Global Const $MB_ICONINFORMATION = 64
Global Const $MB_APPLMODAL = 0
Global Const $MB_SYSTEMMODAL = 4096
Global Const $MB_TOPMOST = 0x00040000
Global Const $IDOK = 1
Global Const $IDYES = 6
Global Const $SE_PRIVILEGE_ENABLED = 0x00000002
Global Enum $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
Global Const $TOKEN_QUERY = 0x00000008
Global Const $TOKEN_ADJUST_PRIVILEGES = 0x00000020
Func _WinAPI_GetLastError(Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $aResult = DllCall("kernel32.dll", "dword", "GetLastError")
Return SetError($_iCurrentError, $_iCurrentExtended, $aResult[0])
EndFunc
Func _WinAPI_SetLastError($iErrorCode, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
DllCall("kernel32.dll", "none", "SetLastError", "dword", $iErrorCode)
Return SetError($_iCurrentError, $_iCurrentExtended, Null)
EndFunc
Func _Security__AdjustTokenPrivileges($hToken, $bDisableAll, $tNewState, $iBufferLen, $tPrevState = 0, $pRequired = 0)
Local $aCall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $hToken, "bool", $bDisableAll, "struct*", $tNewState, "dword", $iBufferLen, "struct*", $tPrevState, "struct*", $pRequired)
If @error Then Return SetError(@error, @extended, False)
Return Not($aCall[0] = 0)
EndFunc
Func _Security__ImpersonateSelf($iLevel = $SECURITYIMPERSONATION)
Local $aCall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $iLevel)
If @error Then Return SetError(@error, @extended, False)
Return Not($aCall[0] = 0)
EndFunc
Func _Security__LookupPrivilegeValue($sSystem, $sName)
Local $aCall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $sSystem, "wstr", $sName, "int64*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenThreadToken($iAccess, $hThread = 0, $bOpenAsSelf = False)
If $hThread = 0 Then
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error + 10, @extended, 0)
$hThread = $aResult[0]
EndIf
Local $aCall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hThread, "dword", $iAccess, "bool", $bOpenAsSelf, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[4]
EndFunc
Func _Security__OpenThreadTokenEx($iAccess, $hThread = 0, $bOpenAsSelf = False)
Local $hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then
Local Const $ERROR_NO_TOKEN = 1008
If _WinAPI_GetLastError() <> $ERROR_NO_TOKEN Then Return SetError(20, _WinAPI_GetLastError(), 0)
If Not _Security__ImpersonateSelf() Then Return SetError(@error + 10, _WinAPI_GetLastError(), 0)
$hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then Return SetError(@error, _WinAPI_GetLastError(), 0)
EndIf
Return $hToken
EndFunc
Func _Security__SetPrivilege($hToken, $sPrivilege, $bEnable)
Local $iLUID = _Security__LookupPrivilegeValue("", $sPrivilege)
If $iLUID = 0 Then Return SetError(@error + 10, @extended, False)
Local Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Local $tCurrState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iCurrState = DllStructGetSize($tCurrState)
Local $tPrevState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iPrevState = DllStructGetSize($tPrevState)
Local $tRequired = DllStructCreate("int Data")
DllStructSetData($tCurrState, "Count", 1)
DllStructSetData($tCurrState, "LUID", $iLUID)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tCurrState, $iCurrState, $tPrevState, $tRequired) Then Return SetError(2, @error, False)
DllStructSetData($tPrevState, "Count", 1)
DllStructSetData($tPrevState, "LUID", $iLUID)
Local $iAttributes = DllStructGetData($tPrevState, "Attributes")
If $bEnable Then
$iAttributes = BitOR($iAttributes, $SE_PRIVILEGE_ENABLED)
Else
$iAttributes = BitAND($iAttributes, BitNOT($SE_PRIVILEGE_ENABLED))
EndIf
DllStructSetData($tPrevState, "Attributes", $iAttributes)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tPrevState, $iPrevState, $tCurrState, $tRequired) Then Return SetError(3, @error, False)
Return True
EndFunc
Func _SendMessage($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Global Const $STR_NOCASESENSE = 0
Global Const $STR_CASESENSE = 1
Global Const $STR_NOCASESENSEBASIC = 2
Global Const $STR_STRIPLEADING = 1
Global Const $STR_STRIPTRAILING = 2
Global Const $STR_STRIPSPACES = 4
Global Const $STR_STRIPALL = 8
Global Const $STR_CHRSPLIT = 0
Global Const $STR_ENTIRESPLIT = 1
Global Const $STR_NOCOUNT = 2
Global Const $STR_REGEXPMATCH = 0
Global Const $STR_REGEXPARRAYMATCH = 1
Global Const $STR_REGEXPARRAYGLOBALMATCH = 3
Global Const $STR_ENDISSTART = 0
Global Const $STR_ENDNOTSTART = 1
Global Const $tagPOINT = "struct;long X;long Y;endstruct"
Global Const $tagRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagSIZE = "struct;long X;long Y;endstruct"
Global Const $tagFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $tagGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $tagGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $tagGDIPENCODERPARAMS = "uint Count;" & $tagGDIPENCODERPARAM
Global Const $tagGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $tagGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $tagGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $tagMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" &((@OSVersion = "WIN_XP") ? "" : ";" & $tagRECT & ";uint uChevronState")
Global Const $tagBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
Global Const $tagSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
Global Const $HGDI_ERROR = Ptr(-1)
Global Const $INVALID_HANDLE_VALUE = Ptr(-1)
Global Const $DEFAULT_GUI_FONT = 17
Global Const $ULW_ALPHA = 0x02
Global Const $WH_CBT = 5
Global Const $KF_EXTENDED = 0x0100
Global Const $KF_ALTDOWN = 0x2000
Global Const $KF_UP = 0x8000
Global Const $LLKHF_EXTENDED = BitShift($KF_EXTENDED, 8)
Global Const $LLKHF_ALTDOWN = BitShift($KF_ALTDOWN, 8)
Global Const $LLKHF_UP = BitShift($KF_UP, 8)
Global Const $DI_MASK = 0x0001
Global Const $DI_IMAGE = 0x0002
Global Const $DI_NORMAL = 0x0003
Global Const $DI_COMPAT = 0x0004
Global Const $DI_DEFAULTSIZE = 0x0008
Global Const $DI_NOMIRROR = 0x0010
Global Const $GW_HWNDNEXT = 2
Global Const $GW_CHILD = 5
Global Const $GWL_WNDPROC = 0xFFFFFFFC
Global Const $GWL_HWNDPARENT = 0xFFFFFFF8
Global Const $GWL_STYLE = 0xFFFFFFF0
Global Const $GWL_EXSTYLE = 0xFFFFFFEC
Global Const $IMAGE_ICON = 1
Global Const $LOAD_LIBRARY_AS_DATAFILE = 0x02
Global Const $S_OK = 0x00000000
Global Const $LR_DEFAULTCOLOR = 0x0000
Global Const $LR_LOADFROMFILE = 0x0010
Global $__g_aInProcess_WinAPI[64][2] = [[0, 0]]
Global $__g_aWinList_WinAPI[64][2] = [[0, 0]]
Global Const $__WINAPICONSTANT_WM_SETFONT = 0x0030
Global Const $__WINAPICONSTANT_FW_NORMAL = 400
Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 1
Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0
Global Const $tagCURSORINFO = "dword Size;dword Flags;handle hCursor;" & $tagPOINT
Global Const $tagICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Func _WinAPI_BitBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $iROP)
Local $aResult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hDestDC, "int", $iXDest, "int", $iYDest, "int", $iWidth, "int", $iHeight, "handle", $hSrcDC, "int", $iXSrc, "int", $iYSrc, "dword", $iROP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CallNextHookEx($hHook, $iCode, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hHook, "int", $iCode, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_CallWindowProc($pPrevWndFunc, $hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pPrevWndFunc, "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_ClientToScreen($hWnd, ByRef $tPoint)
Local $aRet = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hWnd, "struct*", $tPoint)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_CloseHandle($hObject)
Local $aResult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CopyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hDC, "int", $iWidth, "int", $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleDC($hDC)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFile($sFileName, $iCreation, $iAccess = 4, $iShare = 0, $iAttributes = 0, $tSecurity = 0)
Local $iDA = 0, $iSM = 0, $iCD = 0, $iFA = 0
If BitAND($iAccess, 1) <> 0 Then $iDA = BitOR($iDA, $GENERIC_EXECUTE)
If BitAND($iAccess, 2) <> 0 Then $iDA = BitOR($iDA, $GENERIC_READ)
If BitAND($iAccess, 4) <> 0 Then $iDA = BitOR($iDA, $GENERIC_WRITE)
If BitAND($iShare, 1) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_DELETE)
If BitAND($iShare, 2) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_READ)
If BitAND($iShare, 4) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_WRITE)
Switch $iCreation
Case 0
$iCD = $CREATE_NEW
Case 1
$iCD = $CREATE_ALWAYS
Case 2
$iCD = $OPEN_EXISTING
Case 3
$iCD = $OPEN_ALWAYS
Case 4
$iCD = $TRUNCATE_EXISTING
EndSwitch
If BitAND($iAttributes, 1) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_ARCHIVE)
If BitAND($iAttributes, 2) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_HIDDEN)
If BitAND($iAttributes, 4) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_READONLY)
If BitAND($iAttributes, 8) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_SYSTEM)
Local $aResult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sFileName, "dword", $iDA, "dword", $iSM, "struct*", $tSecurity, "dword", $iCD, "dword", $iFA, "ptr", 0)
If @error Or($aResult[0] = $INVALID_HANDLE_VALUE) Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFont($iHeight, $iWidth, $iEscape = 0, $iOrientn = 0, $iWeight = $__WINAPICONSTANT_FW_NORMAL, $bItalic = False, $bUnderline = False, $bStrikeout = False, $iCharset = $__WINAPICONSTANT_DEFAULT_CHARSET, $iOutputPrec = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $iClipPrec = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $iQuality = $__WINAPICONSTANT_DEFAULT_QUALITY, $iPitch = 0, $sFace = 'Arial')
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iHeight, "int", $iWidth, "int", $iEscape, "int", $iOrientn, "int", $iWeight, "dword", $bItalic, "dword", $bUnderline, "dword", $bStrikeout, "dword", $iCharset, "dword", $iOutputPrec, "dword", $iClipPrec, "dword", $iQuality, "dword", $iPitch, "wstr", $sFace)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFontIndirect($tLogFont)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tLogFont)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateWindowEx($iExStyle, $sClass, $sName, $iStyle, $iX, $iY, $iWidth, $iHeight, $hParent, $hMenu = 0, $hInstance = 0, $pParam = 0)
If $hInstance = 0 Then $hInstance = _WinAPI_GetModuleHandle("")
Local $aResult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iExStyle, "wstr", $sClass, "wstr", $sName, "dword", $iStyle, "int", $iX, "int", $iY, "int", $iWidth, "int", $iHeight, "hwnd", $hParent, "handle", $hMenu, "handle", $hInstance, "struct*", $pParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteDC($hDC)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteObject($hObject)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIcon($hDC, $iX, $iY, $hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIconEx($hDC, $iX, $iY, $hIcon, $iWidth = 0, $iHeight = 0, $iStep = 0, $hBrush = 0, $iFlags = 3)
Local $iOptions
Switch $iFlags
Case 1
$iOptions = $DI_MASK
Case 2
$iOptions = $DI_IMAGE
Case 3
$iOptions = $DI_NORMAL
Case 4
$iOptions = $DI_COMPAT
Case 5
$iOptions = $DI_DEFAULTSIZE
Case Else
$iOptions = $DI_NOMIRROR
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon, "int", $iWidth, "int", $iHeight, "uint", $iStep, "handle", $hBrush, "uint", $iOptions)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_EnableWindow($hWnd, $bEnable = True)
Local $aResult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hWnd, "bool", $bEnable)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __WinAPI_EnumWindowsAdd($hWnd, $sClass = "")
If $sClass = "" Then $sClass = _WinAPI_GetClassName($hWnd)
$__g_aWinList_WinAPI[0][0] += 1
Local $iCount = $__g_aWinList_WinAPI[0][0]
If $iCount >= $__g_aWinList_WinAPI[0][1] Then
ReDim $__g_aWinList_WinAPI[$iCount + 64][2]
$__g_aWinList_WinAPI[0][1] += 64
EndIf
$__g_aWinList_WinAPI[$iCount][0] = $hWnd
$__g_aWinList_WinAPI[$iCount][1] = $sClass
EndFunc
Func __WinAPI_EnumWindowsInit()
ReDim $__g_aWinList_WinAPI[64][2]
$__g_aWinList_WinAPI[0][0] = 0
$__g_aWinList_WinAPI[0][1] = 64
EndFunc
Func _WinAPI_EnumWindowsTop()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then __WinAPI_EnumWindowsAdd($hWnd)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_ExtractIconEx($sFilePath, $iIndex, $paLarge, $paSmall, $iIcons)
Local $aResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sFilePath, "int", $iIndex, "struct*", $paLarge, "struct*", $paSmall, "uint", $iIcons)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FatalAppExit($sMessage)
DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $sMessage)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_FindWindow($sClassName, $sWindowName)
Local $aResult = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sClassName, "wstr", $sWindowName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FreeLibrary($hModule)
Local $aResult = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hModule)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetAncestor($hWnd, $iFlags = 1)
Local $aResult = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hWnd, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClassName($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, '')
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetClientHeight($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetClientWidth($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_GetClientRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThreadId()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCursorInfo()
Local $tCursor = DllStructCreate($tagCURSORINFO)
Local $iCursor = DllStructGetSize($tCursor)
DllStructSetData($tCursor, "Size", $iCursor)
Local $aRet = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tCursor)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aCursor[5]
$aCursor[0] = True
$aCursor[1] = DllStructGetData($tCursor, "Flags") <> 0
$aCursor[2] = DllStructGetData($tCursor, "hCursor")
$aCursor[3] = DllStructGetData($tCursor, "X")
$aCursor[4] = DllStructGetData($tCursor, "Y")
Return $aCursor
EndFunc
Func _WinAPI_GetDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDesktopWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDeviceCaps($hDC, $iIndex)
Local $aResult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDlgCtrlID($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetFileSizeEx($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hFile, "int64*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, -1)
Return $aResult[2]
EndFunc
Func _WinAPI_GetFocus()
Local $aResult = DllCall("user32.dll", "hwnd", "GetFocus")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetForegroundWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetGuiResources($iFlag = 0, $hProcess = -1)
If $hProcess = -1 Then $hProcess = _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hProcess, "dword", $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetIconInfo($hIcon)
Local $tInfo = DllStructCreate($tagICONINFO)
Local $aRet = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hIcon, "struct*", $tInfo)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aIcon[6]
$aIcon[0] = True
$aIcon[1] = DllStructGetData($tInfo, "Icon") <> 0
$aIcon[2] = DllStructGetData($tInfo, "XHotSpot")
$aIcon[3] = DllStructGetData($tInfo, "YHotSpot")
$aIcon[4] = DllStructGetData($tInfo, "hMask")
$aIcon[5] = DllStructGetData($tInfo, "hColor")
Return $aIcon
EndFunc
Func _WinAPI_GetModuleHandle($sModuleName)
Local $sModuleNameType = "wstr"
If $sModuleName = "" Then
$sModuleName = 0
$sModuleNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $sModuleNameType, $sModuleName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetObject($hObject, $iSize, $pObject)
Local $aResult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hObject, "int", $iSize, "struct*", $pObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetParent($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetStockObject($iObject)
Local $aResult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetStdHandle($iStdHandle)
If $iStdHandle < 0 Or $iStdHandle > 2 Then Return SetError(2, 0, -1)
Local Const $aHandle[3] = [-10, -11, -12]
Local $aResult = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $aHandle[$iStdHandle])
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSystemMetrics($iIndex)
Local $aResult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindow($hWnd, $iCmd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hWnd, "uint", $iCmd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowLong($hWnd, $iIndex)
Local $sFuncName = "GetWindowLongW"
If @AutoItX64 Then $sFuncName = "GetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowThreadProcessId($hWnd, ByRef $iPID)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
$iPID = $aResult[2]
Return $aResult[0]
EndFunc
Func _WinAPI_GetXYFromPoint(ByRef $tPoint, ByRef $iX, ByRef $iY)
$iX = DllStructGetData($tPoint, "X")
$iY = DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_GUIDFromString($sGUID)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_GUIDFromStringEx($sGUID, $tGUID)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $tGUID
EndFunc
Func _WinAPI_GUIDFromStringEx($sGUID, $tGUID)
Local $aResult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sGUID, "struct*", $tGUID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_HiWord($iLong)
Return BitShift($iLong, 16)
EndFunc
Func _WinAPI_InProcess($hWnd, ByRef $hLastWnd)
If $hWnd = $hLastWnd Then Return True
For $iI = $__g_aInProcess_WinAPI[0][0] To 1 Step -1
If $hWnd = $__g_aInProcess_WinAPI[$iI][0] Then
If $__g_aInProcess_WinAPI[$iI][1] Then
$hLastWnd = $hWnd
Return True
Else
Return False
EndIf
EndIf
Next
Local $iPID
_WinAPI_GetWindowThreadProcessId($hWnd, $iPID)
Local $iCount = $__g_aInProcess_WinAPI[0][0] + 1
If $iCount >= 64 Then $iCount = 1
$__g_aInProcess_WinAPI[0][0] = $iCount
$__g_aInProcess_WinAPI[$iCount][0] = $hWnd
$__g_aInProcess_WinAPI[$iCount][1] =($iPID = @AutoItPID)
Return $__g_aInProcess_WinAPI[$iCount][1]
EndFunc
Func _WinAPI_IsClassName($hWnd, $sClassName)
Local $sSeparator = Opt("GUIDataSeparatorChar")
Local $aClassName = StringSplit($sClassName, $sSeparator)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sClassCheck = _WinAPI_GetClassName($hWnd)
For $x = 1 To UBound($aClassName) - 1
If StringUpper(StringMid($sClassCheck, 1, StringLen($aClassName[$x]))) = StringUpper($aClassName[$x]) Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsWindowVisible($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_InvalidateRect($hWnd, $tRECT = 0, $bErase = True)
Local $aResult = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hWnd, "struct*", $tRECT, "bool", $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadImage($hInstance, $sImage, $iType, $iXDesired, $iYDesired, $iLoad)
Local $aResult, $sImageType = "int"
If IsString($sImage) Then $sImageType = "wstr"
$aResult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hInstance, $sImageType, $sImage, "uint", $iType, "int", $iXDesired, "int", $iYDesired, "uint", $iLoad)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadLibraryEx($sFileName, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sFileName, "ptr", 0, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoWord($iLong)
Return BitAND($iLong, 0xFFFF)
EndFunc
Func _WinAPI_MakeLong($iLo, $iHi)
Return BitOR(BitShift($iHi, -16), BitAND($iLo, 0xFFFF))
EndFunc
Func _WinAPI_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
_WinAPI_CloseHandle($hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func _WinAPI_PointFromRect(ByRef $tRECT, $bCenter = True)
Local $iX1 = DllStructGetData($tRECT, "Left")
Local $iY1 = DllStructGetData($tRECT, "Top")
Local $iX2 = DllStructGetData($tRECT, "Right")
Local $iY2 = DllStructGetData($tRECT, "Bottom")
If $bCenter Then
$iX1 = $iX1 +(($iX2 - $iX1) / 2)
$iY1 = $iY1 +(($iY2 - $iY1) / 2)
EndIf
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iX1)
DllStructSetData($tPoint, "Y", $iY1)
Return $tPoint
EndFunc
Func _WinAPI_PostMessage($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ReadFile($hFile, $pBuffer, $iToRead, ByRef $iRead, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToRead, "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[4]
Return $aResult[0]
EndFunc
Func _WinAPI_RedrawWindow($hWnd, $tRECT = 0, $hRegion = 0, $iFlags = 5)
Local $aResult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hWnd, "struct*", $tRECT, "handle", $hRegion, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RegisterWindowMessage($sMessage)
Local $aResult = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMessage)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_ReleaseDC($hWnd, $hDC)
Local $aResult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SelectObject($hDC, $hGDIObj)
Local $aResult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hGDIObj)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFilePointer($hFile, $iPos, $iMethod = 0)
Local $aResult = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hFile, "long", $iPos, "ptr", 0, "long", $iMethod)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFocus($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFont($hWnd, $hFont, $bRedraw = True)
_SendMessage($hWnd, $__WINAPICONSTANT_WM_SETFONT, $hFont, $bRedraw, 0, "hwnd")
EndFunc
Func _WinAPI_SetHandleInformation($hObject, $iMask, $iFlags)
Local $aResult = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hObject, "dword", $iMask, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetParent($hWndChild, $hWndParent)
Local $aResult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hWndChild, "hwnd", $hWndParent)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetProcessAffinityMask($hProcess, $iMask)
Local $aResult = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hProcess, "ulong_ptr", $iMask)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowLong($hWnd, $iIndex, $iValue)
_WinAPI_SetLastError(0)
Local $sFuncName = "SetWindowLongW"
If @AutoItX64 Then $sFuncName = "SetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex, "long_ptr", $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPos($hWnd, $hAfter, $iX, $iY, $iCX, $iCY, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hWnd, "hwnd", $hAfter, "int", $iX, "int", $iY, "int", $iCX, "int", $iCY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowsHookEx($iHook, $pProc, $hDll, $iThreadId = 0)
Local $aResult = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $iHook, "ptr", $pProc, "handle", $hDll, "dword", $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowText($hWnd, $sText)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hWnd, "wstr", $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowWindow($hWnd, $iCmdShow = 5)
Local $aResult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hWnd, "int", $iCmdShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_StringFromGUID($tGUID)
Local $aResult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tGUID, "wstr", "", "int", 40)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_UnhookWindowsHookEx($hHook)
Local $aResult = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hHook)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateLayeredWindow($hWnd, $hDestDC, $tPTDest, $tSize, $hSrcDC, $tPTSrce, $iRGB, $tBlend, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hWnd, "handle", $hDestDC, "struct*", $tPTDest, "struct*", $tSize, "handle", $hSrcDC, "struct*", $tPTSrce, "dword", $iRGB, "struct*", $tBlend, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForSingleObject($hHandle, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hHandle, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WideCharToMultiByte($vUnicode, $iCodePage = 0, $bRetString = True)
Local $sUnicodeType = "wstr"
If Not IsString($vUnicode) Then $sUnicodeType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, "")
Local $tMultiByte = DllStructCreate("char[" & $aResult[0] & "]")
$aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1, "struct*", $tMultiByte, "int", $aResult[0], "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
If $bRetString Then Return DllStructGetData($tMultiByte, 1)
Return $tMultiByte
EndFunc
Func _WinAPI_WriteFile($hFile, $pBuffer, $iToWrite, ByRef $iWritten, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToWrite, "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[4]
Return $aResult[0]
EndFunc
Global $__g_vEnum, $__g_vExt = 0
Global $__g_hHeap = 0, $__g_iRGBMode = 1
Global Const $tagOSVERSIONINFO = 'struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct'
Global Const $__WINVER = __WINVER()
Func _WinAPI_CreatePoint($iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
DllStructSetData($tPOINT, 1, $iX)
DllStructSetData($tPOINT, 2, $iY)
Return $tPOINT
EndFunc
Func _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iLeft)
DllStructSetData($tRECT, 2, $iTop)
DllStructSetData($tRECT, 3, $iRight)
DllStructSetData($tRECT, 4, $iBottom)
Return $tRECT
EndFunc
Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iX)
DllStructSetData($tRECT, 2, $iY)
DllStructSetData($tRECT, 3, $iX + $iWidth)
DllStructSetData($tRECT, 4, $iY + $iHeight)
Return $tRECT
EndFunc
Func _WinAPI_CreateSize($iWidth, $iHeight)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, $iWidth)
DllStructSetData($tSIZE, 2, $iHeight)
Return $tSIZE
EndFunc
Func _WinAPI_FatalExit($iCode)
DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_GetBitmapDimension($hBitmap)
Local Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return _WinAPI_CreateSize(DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'))
EndFunc
Func _WinAPI_IsBadReadPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadReadPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadWritePtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadWritePtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MoveMemory($pDestination, $pSource, $iLength)
If _WinAPI_IsBadReadPtr($pSource, $iLength) Then Return SetError(10, @extended, 0)
If _WinAPI_IsBadWritePtr($pDestination, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'struct*', $pDestination, 'struct*', $pSource, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_StrLen($pString, $bUnicode = True)
Local $W = ''
If $bUnicode Then $W = 'W'
Local $aRet = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'struct*', $pString)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SwitchColor($iColor)
If $iColor = -1 Then Return $iColor
Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc
Func _WinAPI_ZeroMemory($pMemory, $iLength)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlZeroMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func __CheckErrorArrayBounds(Const ByRef $aData, ByRef $iStart, ByRef $iEnd, $nDim = 1, $iDim = $UBOUND_DIMENSIONS)
If Not IsArray($aData) Then Return SetError(1, 0, 1)
If UBound($aData, $iDim) <> $nDim Then Return SetError(2, 0, 1)
If $iStart < 0 Then $iStart = 0
Local $iUBound = UBound($aData) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart > $iEnd Then Return SetError(4, 0, 1)
Return 0
EndFunc
Func __CheckErrorCloseHandle($aRet, $hFile, $bLastError = 0, $iCurErr = @error, $iCurExt = @extended)
If Not $iCurErr And Not $aRet[0] Then $iCurErr = 10
Local $iLastError = _WinAPI_GetLastError()
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iCurErr Then _WinAPI_SetLastError($iLastError)
If $bLastError Then $iCurExt = $iLastError
Return SetError($iCurErr, $iCurExt, $iCurErr)
EndFunc
Func __EnumWindowsProc($hWnd, $bVisible)
Local $aResult
If $bVisible Then
$aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If Not $aResult[0] Then
Return 1
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hWnd
$aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
$__g_vEnum[$__g_vEnum[0][0]][1] = $aResult[2]
Return 1
EndFunc
Func __FatalExit($iCode, $sText = '')
If $sText Then MsgBox($MB_SYSTEMMODAL, 'AutoIt', $sText)
_WinAPI_FatalExit($iCode)
EndFunc
Func __HeapAlloc($iSize, $bAbort = False)
Local $aRet
If Not $__g_hHeap Then
$aRet = DllCall('kernel32.dll', 'handle', 'HeapCreate', 'dword', 0, 'ulong_ptr', 0, 'ulong_ptr', 0)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
$__g_hHeap = $aRet[0]
EndIf
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 30, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func __HeapReAlloc($pMemory, $iSize, $bAmount = False, $bAbort = False)
Local $aRet, $pRet
If __HeapValidate($pMemory) Then
If $bAmount And(__HeapSize($pMemory) >= $iSize) Then Return SetExtended(1, Ptr($pMemory))
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapReAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ptr', $pMemory, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 20, @extended, Ptr($pMemory))
EndIf
$pRet = $aRet[0]
Else
$pRet = __HeapAlloc($iSize, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
EndIf
Return $pRet
EndFunc
Func __HeapSize($pMemory, $bCheck = False)
If $bCheck And(Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'ulong_ptr', 'HeapSize', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or($aRet[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
Return $aRet[0]
EndFunc
Func __HeapValidate($pMemory)
If(Not $__g_hHeap) Or(Not Ptr($pMemory)) Then Return SetError(9, 0, False)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapValidate', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func __Inc(ByRef $aData, $iIncrement = 100)
Select
Case UBound($aData, $UBOUND_COLUMNS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0][0] + 1][UBound($aData, $UBOUND_COLUMNS)]
Else
$aData[0][0] += 1
If $aData[0][0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, $UBOUND_COLUMNS)]
EndIf
EndIf
Case UBound($aData, $UBOUND_ROWS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0] + 1]
Else
$aData[0] += 1
If $aData[0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0] + $iIncrement]
EndIf
EndIf
Case Else
Return 0
EndSelect
Return 1
EndFunc
Func __Iif($bTest, $vTrue, $vFalse)
Return $bTest ? $vTrue : $vFalse
EndFunc
Func __Init($dData)
Local $iLength = BinaryLen($dData)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'VirtualAlloc', 'ptr', 0, 'ulong_ptr', $iLength, 'dword', 0x00001000, 'dword', 0x00000040)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
Local $tData = DllStructCreate('byte[' & $iLength & "]", $aRet[0])
DllStructSetData($tData, 1, $dData)
Return $aRet[0]
EndFunc
Func __RGB($iColor)
If $__g_iRGBMode Then
$iColor = _WinAPI_SwitchColor($iColor)
EndIf
Return $iColor
EndFunc
Func __WINVER()
Local $tOSVI = DllStructCreate($tagOSVERSIONINFO)
DllStructSetData($tOSVI, 1, DllStructGetSize($tOSVI))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVI)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return BitOR(BitShift(DllStructGetData($tOSVI, 2), -8), DllStructGetData($tOSVI, 3))
EndFunc
Func _WinAPI_DeleteFile($sFilePath)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeleteFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Global Const $HANDLE_FLAG_INHERIT = 0x00000001
Global Const $MAPVK_VK_TO_CHAR = 2
Global Const $HSHELL_WINDOWACTIVATED = 4
Func _WinAPI_DeregisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'DeregisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GetActiveWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetVersion()
Return BitAND(BitShift($__WINVER, 8), 0xFF) & '.' & BitAND($__WINVER, 0xFF)
EndFunc
Func _WinAPI_IsIconic($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsIconic', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MapVirtualKey($iCode, $iType, $hLocale = 0)
Local $aRet = DllCall('user32.dll', 'INT', 'MapVirtualKeyExW', 'uint', $iCode, 'uint', $iType, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryPerformanceCounter()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceCounter', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_QueryPerformanceFrequency()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceFrequency', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_RegisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func __EnumDefaultProc($pData, $lParam)
#forceref $lParam
Local $iLength = _WinAPI_StrLen($pData)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' &($iLength + 1) & ']', $pData), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = ''
EndIf
Return 1
EndFunc
Func __EnumPageFilesProc($iSize, $pInfo, $pFile)
Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' &(_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
For $i = 1 To 3
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
Next
Return 1
EndFunc
Global Const $PROCESS_VM_OPERATION = 0x00000008
Global Const $PROCESS_VM_READ = 0x00000010
Global Const $PROCESS_VM_WRITE = 0x00000020
Global Const $PROCESS_QUERY_INFORMATION = 0x00000400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
Global Const $PROCESS_ALL_ACCESS = 0x001F0FFF
Func _Max($iNum1, $iNum2)
If Not IsNumber($iNum1) Then Return SetError(1, 0, 0)
If Not IsNumber($iNum2) Then Return SetError(2, 0, 0)
Return($iNum1 > $iNum2) ? $iNum1 : $iNum2
EndFunc
Func _Min($iNum1, $iNum2)
If Not IsNumber($iNum1) Then Return SetError(1, 0, 0)
If Not IsNumber($iNum2) Then Return SetError(2, 0, 0)
Return($iNum1 > $iNum2) ? $iNum2 : $iNum1
EndFunc
Global Const $BS_DEFPUSHBUTTON = 0x0001
Global Const $BS_MULTILINE = 0x2000
Global Const $BS_PUSHLIKE = 0x1000
Global Const $BS_VCENTER = 0x0C00
Global Const $BS_ICON = 0x0040
Global Const $BCM_FIRST = 0x1600
Global Const $BCM_SETIMAGELIST =($BCM_FIRST + 0x0002)
Global Const $CB_ERR = -1
Global Const $CBS_AUTOHSCROLL = 0x40
Global Const $CBS_DROPDOWN = 0x2
Global Const $CBS_DROPDOWNLIST = 0x3
Global Const $CB_FINDSTRINGEXACT = 0x158
Global Const $CB_GETCOUNT = 0x146
Global Const $CB_GETCURSEL = 0x147
Global Const $CB_GETLBTEXT = 0x148
Global Const $CB_GETLBTEXTLEN = 0x149
Global Const $CB_RESETCONTENT = 0x14B
Global Const $CB_SELECTSTRING = 0x14D
Global Const $CB_SETCURSEL = 0x14E
Global Const $CBN_SELCHANGE = 1
Global Const $__COMBOBOXCONSTANT_WM_USER = 0X400
Global Const $CBEM_GETCOMBOCONTROL =($__COMBOBOXCONSTANT_WM_USER + 6)
Global Const $CBEM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $CBEM_INSERTITEMA =($__COMBOBOXCONSTANT_WM_USER + 1)
Global Const $CBEM_INSERTITEMW =($__COMBOBOXCONSTANT_WM_USER + 11)
Global Const $CBEM_SETIMAGELIST =($__COMBOBOXCONSTANT_WM_USER + 2)
Global Const $CBEIF_DI_SETITEM = 0x10000000
Global Const $CBEIF_IMAGE = 0x2
Global Const $CBEIF_INDENT = 0x10
Global Const $CBEIF_LPARAM = 0x20
Global Const $CBEIF_OVERLAY = 0x8
Global Const $CBEIF_SELECTEDIMAGE = 0x4
Global Const $CBEIF_TEXT = 0x1
Global Const $ES_LEFT = 0
Global Const $ES_CENTER = 1
Global Const $ES_MULTILINE = 4
Global Const $ES_UPPERCASE = 8
Global Const $ES_PASSWORD = 32
Global Const $ES_AUTOVSCROLL = 64
Global Const $ES_AUTOHSCROLL = 128
Global Const $ES_READONLY = 2048
Global Const $ES_WANTRETURN = 4096
Global Const $ES_NUMBER = 8192
Global Const $EM_REPLACESEL = 0xC2
Global Const $EM_SETREADONLY = 0xCF
Global Const $EM_SETSEL = 0xB1
Global Const $GUI_SS_DEFAULT_EDIT = 0x003010c0
Global Const $GUI_SS_DEFAULT_INPUT = 0x00000080
Global Const $GUI_EVENT_CLOSE = -3
Global Const $GUI_EVENT_MINIMIZE = -4
Global Const $GUI_EVENT_RESTORE = -5
Global Const $GUI_EVENT_PRIMARYDOWN = -7
Global Const $GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $GUI_CHECKED = 1
Global Const $GUI_UNCHECKED = 4
Global Const $GUI_SHOW = 16
Global Const $GUI_HIDE = 32
Global Const $GUI_ENABLE = 64
Global Const $GUI_DISABLE = 128
Global Const $GUI_FOCUS = 256
Global Const $GUI_FONTNORMAL = 0
Global Const $GUI_FONTUNDER = 4
Global Const $GUI_DOCKLEFT = 0x0002
Global Const $GUI_DOCKBOTTOM = 0x0040
Global Const $GUI_DOCKWIDTH = 0x0100
Global Const $GUI_DOCKHEIGHT = 0x0200
Global Const $GUI_DOCKALL = 0x0322
Global Const $GUI_DOCKBORDERS = 0x0066
Global Const $GUI_BKCOLOR_TRANSPARENT = -2
Global Const $_UDF_GlobalIDs_OFFSET = 2
Global Const $_UDF_GlobalID_MAX_WIN = 16
Global Const $_UDF_STARTID = 10000
Global Const $_UDF_GlobalID_MAX_IDS = 55535
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 0x00010000
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 0x10000000
Global Const $__UDFGUICONSTANT_WS_CHILD = 0x40000000
Global $__g_aUDF_GlobalIDs_Used[$_UDF_GlobalID_MAX_WIN][$_UDF_GlobalID_MAX_IDS + $_UDF_GlobalIDs_OFFSET + 1]
Func __UDF_GetNextGlobalID($hWnd)
Local $nCtrlID, $iUsedIndex = -1, $bAllUsed = True
If Not WinExists($hWnd) Then Return SetError(-1, -1, 0)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] <> 0 Then
If Not WinExists($__g_aUDF_GlobalIDs_Used[$iIndex][0]) Then
For $x = 0 To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Next
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
EndIf
EndIf
Next
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
If $iUsedIndex = -1 Then
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = 0 Then
$__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
EndIf
If $iUsedIndex = -1 And $bAllUsed Then Return SetError(16, 0, 0)
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] = $_UDF_STARTID + $_UDF_GlobalID_MAX_IDS Then
For $iIDIndex = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = 0 Then
$nCtrlID =($iIDIndex - $_UDF_GlobalIDs_OFFSET) + 10000
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = $nCtrlID
Return $nCtrlID
EndIf
Next
Return SetError(-1, $_UDF_GlobalID_MAX_IDS, 0)
EndIf
$nCtrlID = $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1]
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] += 1
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][($nCtrlID - 10000) + $_UDF_GlobalIDs_OFFSET] = $nCtrlID
Return $nCtrlID
EndFunc
Func __UDF_FreeGlobalID($hWnd, $iGlobalID)
If $iGlobalID - $_UDF_STARTID < 0 Or $iGlobalID - $_UDF_STARTID > $_UDF_GlobalID_MAX_IDS Then Return SetError(-1, 0, False)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
For $x = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][$x] = $iGlobalID Then
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Return True
EndIf
Next
Return SetError(-3, 0, False)
EndIf
Next
Return SetError(-2, 0, False)
EndFunc
Global Const $tagBUTTON_IMAGELIST = "ptr ImageList;" & $tagRECT & ";uint Align"
Global Const $__BUTTONCONSTANT_ClassName = "Button"
Func _GUICtrlButton_Enable($hWnd, $bEnable = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_EnableWindow($hWnd, $bEnable) = $bEnable
EndFunc
Func _GUICtrlButton_SetImageList($hWnd, $hImage, $iAlign = 0, $iLeft = 1, $iTop = 1, $iRight = 1, $iBottom = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $iAlign < 0 Or $iAlign > 4 Then $iAlign = 0
Local $tBUTTON_IMAGELIST = DllStructCreate($tagBUTTON_IMAGELIST)
DllStructSetData($tBUTTON_IMAGELIST, "ImageList", $hImage)
DllStructSetData($tBUTTON_IMAGELIST, "Left", $iLeft)
DllStructSetData($tBUTTON_IMAGELIST, "Top", $iTop)
DllStructSetData($tBUTTON_IMAGELIST, "Right", $iRight)
DllStructSetData($tBUTTON_IMAGELIST, "Bottom", $iBottom)
DllStructSetData($tBUTTON_IMAGELIST, "Align", $iAlign)
Local $bEnabled = _GUICtrlButton_Enable($hWnd, False)
Local $iRet = _SendMessage($hWnd, $BCM_SETIMAGELIST, 0, $tBUTTON_IMAGELIST, 0, "wparam", "struct*") <> 0
_GUICtrlButton_Enable($hWnd)
If Not $bEnabled Then _GUICtrlButton_Enable($hWnd, False)
Return $iRet
EndFunc
Global Const $COLOR_AQUA = 0x00FFFF
Global Const $COLOR_BLACK = 0x000000
Global Const $COLOR_BLUE = 0x0000FF
Global Const $COLOR_FUCHSIA = 0xFF00FF
Global Const $COLOR_GRAY = 0x808080
Global Const $COLOR_GREEN = 0x008000
Global Const $COLOR_MAROON = 0x8B1C62
Global Const $COLOR_MEDGRAY = 0xA0A0A4
Global Const $COLOR_MONEYGREEN = 0xC0DCC0
Global Const $COLOR_NAVY = 0x000080
Global Const $COLOR_PURPLE = 0x800080
Global Const $COLOR_RED = 0xFF0000
Global Const $COLOR_WHITE = 0xFFFFFF
Global Const $COLOR_YELLOW = 0xFFFF00
Global Const $ILC_MASK = 0x00000001
Global Const $ILC_COLOR = 0x00000000
Global Const $ILC_COLORDDB = 0x000000FE
Global Const $ILC_COLOR4 = 0x00000004
Global Const $ILC_COLOR8 = 0x00000008
Global Const $ILC_COLOR16 = 0x00000010
Global Const $ILC_COLOR24 = 0x00000018
Global Const $ILC_COLOR32 = 0x00000020
Global Const $ILC_MIRROR = 0x00002000
Global Const $ILC_PERITEMMIRROR = 0x00008000
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0
Func _GUIImageList_Add($hWnd, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_Add", "handle", $hWnd, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddBitmap($hWnd, $sImage, $sMask = "")
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Local $hImage = _WinAPI_LoadImage(0, $sImage, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hImage = 0 Then Return SetError(_WinAPI_GetLastError(), 1, -1)
Local $hMask = 0
If $sMask <> "" Then
$hMask = _WinAPI_LoadImage(0, $sMask, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hMask = 0 Then Return SetError(_WinAPI_GetLastError(), 2, -1)
EndIf
Local $iRet = _GUIImageList_Add($hWnd, $hImage, $hMask)
_WinAPI_DeleteObject($hImage)
If $hMask <> 0 Then _WinAPI_DeleteObject($hMask)
Return $iRet
EndFunc
Func _GUIImageList_AddIcon($hWnd, $sFilePath, $iIndex = 0, $bLarge = False)
Local $iRet, $tIcon = DllStructCreate("handle Handle")
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, 0, $tIcon, 1)
EndIf
If $iRet <= 0 Then Return SetError(-1, $iRet, -1)
Local $hIcon = DllStructGetData($tIcon, "Handle")
$iRet = _GUIImageList_ReplaceIcon($hWnd, -1, $hIcon)
_WinAPI_DestroyIcon($hIcon)
If $iRet = -1 Then Return SetError(-2, $iRet, -1)
Return $iRet
EndFunc
Func _GUIImageList_Create($iCX = 16, $iCY = 16, $iColor = 4, $iOptions = 0, $iInitial = 4, $iGrow = 4)
Local Const $aColor[7] = [$ILC_COLOR, $ILC_COLOR4, $ILC_COLOR8, $ILC_COLOR16, $ILC_COLOR24, $ILC_COLOR32, $ILC_COLORDDB]
Local $iFlags = 0
If BitAND($iOptions, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MASK)
If BitAND($iOptions, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MIRROR)
If BitAND($iOptions, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILC_PERITEMMIRROR)
$iFlags = BitOR($iFlags, $aColor[$iColor])
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", $iCX, "int", $iCY, "uint", $iFlags, "int", $iInitial, "int", $iGrow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Destroy($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_GetIconSize($hWnd)
Local $aSize[2]
Local $tPoint = _GUIImageList_GetIconSizeEx($hWnd)
$aSize[0] = DllStructGetData($tPoint, "X")
$aSize[1] = DllStructGetData($tPoint, "Y")
Return $aSize
EndFunc
Func _GUIImageList_GetIconSizeEx($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $pPointX = DllStructGetPtr($tPoint, "X")
Local $pPointY = DllStructGetPtr($tPoint, "Y")
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetIconSize", "hwnd", $hWnd, "struct*", $pPointX, "struct*", $pPointY)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tPoint)
EndFunc
Func _GUIImageList_ReplaceIcon($hWnd, $iIndex, $hIcon)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hWnd, "int", $iIndex, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Global Const $GMEM_MOVEABLE = 0x0002
Global Const $MEM_COMMIT = 0x00001000
Global Const $MEM_RESERVE = 0x00002000
Global Const $PAGE_READWRITE = 0x00000004
Global Const $PAGE_EXECUTE_READWRITE = 0x00000040
Global Const $MEM_RELEASE = 0x00008000
Global Const $tagMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
Func _MemFree(ByRef $tMemMap)
Local $pMemory = DllStructGetData($tMemMap, "Mem")
Local $hProcess = DllStructGetData($tMemMap, "hProc")
Local $bResult = _MemVirtualFreeEx($hProcess, $pMemory, 0, $MEM_RELEASE)
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $bResult
EndFunc
Func _MemGlobalAlloc($iBytes, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iFlags, "ulong_ptr", $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalLock($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalUnlock($hMemory)
Local $aResult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemInit($hWnd, $iSize, ByRef $tMemMap)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $iProcessID = $aResult[2]
If $iProcessID = 0 Then Return SetError(1, 0, 0)
Local $iAccess = BitOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
Local $hProcess = __Mem_OpenProcess($iAccess, False, $iProcessID, True)
Local $iAlloc = BitOR($MEM_RESERVE, $MEM_COMMIT)
Local $pMemory = _MemVirtualAllocEx($hProcess, 0, $iSize, $iAlloc, $PAGE_READWRITE)
If $pMemory = 0 Then Return SetError(2, 0, 0)
$tMemMap = DllStructCreate($tagMEMMAP)
DllStructSetData($tMemMap, "hProc", $hProcess)
DllStructSetData($tMemMap, "Size", $iSize)
DllStructSetData($tMemMap, "Mem", $pMemory)
Return $pMemory
EndFunc
Func _MemRead(ByRef $tMemMap, $pSrce, $pDest, $iSize)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"), "ptr", $pSrce, "struct*", $pDest, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemWrite(ByRef $tMemMap, $pSrce, $pDest = 0, $iSize = 0, $sSrce = "struct*")
If $pDest = 0 Then $pDest = DllStructGetData($tMemMap, "Mem")
If $iSize = 0 Then $iSize = DllStructGetData($tMemMap, "Size")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"), "ptr", $pDest, $sSrce, $pSrce, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualAlloc($pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualAllocEx($hProcess, $pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualFree($pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualFreeEx($hProcess, $pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __Mem_OpenProcess($iAccess, $bInherit, $iProcessID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iProcessID)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return 0
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 20, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iLastError = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iProcessID)
$iError = @error
$iLastError = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 30
$iLastError = @extended
EndIf
Else
$iError = @error + 40
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iLastError, $iRet)
EndFunc
Global Const $__STATUSBARCONSTANT_WM_USER = 0X400
Global Const $SB_GETUNICODEFORMAT = 0x2000 + 6
Global Const $SB_ISSIMPLE =($__STATUSBARCONSTANT_WM_USER + 14)
Global Const $SB_SETPARTS =($__STATUSBARCONSTANT_WM_USER + 4)
Global Const $SB_SETTEXTA =($__STATUSBARCONSTANT_WM_USER + 1)
Global Const $SB_SETTEXTW =($__STATUSBARCONSTANT_WM_USER + 11)
Global Const $SB_SETTEXT = $SB_SETTEXTA
Global Const $SB_SIMPLE =($__STATUSBARCONSTANT_WM_USER + 9)
Global Const $SB_SIMPLEID = 0xff
Global $__g_hSBLastWnd
Global Const $__STATUSBARCONSTANT_ClassName = "msctls_statusbar32"
Global Const $__STATUSBARCONSTANT_WM_SIZE = 0x05
Func _GUICtrlStatusBar_Create($hWnd, $vPartEdge = -1, $vPartText = "", $iStyles = -1, $iExStyles = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If $iStyles = -1 Then $iStyles = 0x00000000
If $iExStyles = -1 Then $iExStyles = 0x00000000
Local $aPartWidth[1], $aPartText[1]
If @NumParams > 1 Then
If IsArray($vPartEdge) Then
$aPartWidth = $vPartEdge
Else
$aPartWidth[0] = $vPartEdge
EndIf
If @NumParams = 2 Then
ReDim $aPartText[UBound($aPartWidth)]
Else
If IsArray($vPartText) Then
$aPartText = $vPartText
Else
$aPartText[0] = $vPartText
EndIf
If UBound($aPartWidth) <> UBound($aPartText) Then
Local $iLast
If UBound($aPartWidth) > UBound($aPartText) Then
$iLast = UBound($aPartText)
ReDim $aPartText[UBound($aPartWidth)]
Else
$iLast = UBound($aPartWidth)
ReDim $aPartWidth[UBound($aPartText)]
For $x = $iLast To UBound($aPartWidth) - 1
$aPartWidth[$x] = $aPartWidth[$x - 1] + 75
Next
$aPartWidth[UBound($aPartText) - 1] = -1
EndIf
EndIf
EndIf
If Not IsHWnd($hWnd) Then $hWnd = HWnd($hWnd)
If @NumParams > 3 Then $iStyle = BitOR($iStyle, $iStyles)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hWndSBar = _WinAPI_CreateWindowEx($iExStyles, $__STATUSBARCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
If @error Then Return SetError(@error, @extended, 0)
If @NumParams > 1 Then
_GUICtrlStatusBar_SetParts($hWndSBar, UBound($aPartWidth), $aPartWidth)
For $x = 0 To UBound($aPartText) - 1
_GUICtrlStatusBar_SetText($hWndSBar, $aPartText[$x], $x)
Next
EndIf
Return $hWndSBar
EndFunc
Func _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $SB_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlStatusBar_IsSimple($hWnd)
Return _SendMessage($hWnd, $SB_ISSIMPLE) <> 0
EndFunc
Func _GUICtrlStatusBar_Resize($hWnd)
_SendMessage($hWnd, $__STATUSBARCONSTANT_WM_SIZE)
EndFunc
Func _GUICtrlStatusBar_SetParts($hWnd, $aParts = -1, $aPartWidth = 25)
Local $tParts, $iParts = 1
If IsArray($aParts) <> 0 Then
$aParts[UBound($aParts) - 1] = -1
$iParts = UBound($aParts)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $aParts[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf IsArray($aPartWidth) <> 0 Then
$iParts = UBound($aPartWidth)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $aPartWidth[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf $aParts > 1 Then
$iParts = $aParts
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 1 To $iParts - 1
DllStructSetData($tParts, 1, $aPartWidth * $x, $x)
Next
DllStructSetData($tParts, 1, -1, $iParts)
Else
$tParts = DllStructCreate("int")
DllStructSetData($tParts, $iParts, -1)
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $tParts, 0, "wparam", "struct*")
Else
Local $iSize = DllStructGetSize($tParts)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tParts)
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
_GUICtrlStatusBar_Resize($hWnd)
Return True
EndFunc
Func _GUICtrlStatusBar_SetSimple($hWnd, $bSimple = True)
_SendMessage($hWnd, $SB_SIMPLE, $bSimple)
EndFunc
Func _GUICtrlStatusBar_SetText($hWnd, $sText = "", $iPart = 0, $iUFlag = 0)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tText
If $bUnicode Then
$tText = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tText = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tText, "Text", $sText)
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iPart = $SB_SIMPLEID
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $tText, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tText)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $SB_SETTEXT, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Global Const $TTF_IDISHWND = 0x00000001
Global Const $TTF_SUBCLASS = 0x00000010
Global Const $__TOOLTIPCONSTANTS_WM_USER = 0X400
Global Const $TTM_SETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 24
Global Const $TTM_ADDTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 50
Global Const $TTM_GETTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 56
Global Const $TTS_ALWAYSTIP = 0x00000001
Global Const $TTS_NOPREFIX = 0x00000002
Global Const $__EDITCONSTANT_WM_GETTEXTLENGTH = 0x000E
Global Const $__EDITCONSTANT_WM_SETTEXT = 0x000C
Func _GUICtrlEdit_AppendText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLength = _GUICtrlEdit_GetTextLen($hWnd)
_GUICtrlEdit_SetSel($hWnd, $iLength, $iLength)
_SendMessage($hWnd, $EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_GetTextLen($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_GETTEXTLENGTH)
EndFunc
Func _GUICtrlEdit_SetReadOnly($hWnd, $bReadOnly)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETREADONLY, $bReadOnly) <> 0
EndFunc
Func _GUICtrlEdit_SetSel($hWnd, $iStart, $iEnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETSEL, $iStart, $iEnd)
EndFunc
Func _GUICtrlEdit_SetText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $__EDITCONSTANT_WM_SETTEXT, 0, $sText, 0, "wparam", "wstr")
EndFunc
Global Const $__COMBOBOXCONSTANT_DEFAULT_GUI_FONT = 17
Func _GUICtrlComboBox_FindStringExact($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_FINDSTRINGEXACT, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_GetCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCOUNT)
EndFunc
Func _GUICtrlComboBox_GetCurSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCURSEL)
EndFunc
Func _GUICtrlComboBox_GetLBText($hWnd, $iIndex, ByRef $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLen = _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
Local $tBuffer = DllStructCreate("wchar Text[" & $iLen + 1 & "]")
Local $iRet = _SendMessage($hWnd, $CB_GETLBTEXT, $iIndex, $tBuffer, 0, "wparam", "struct*")
If($iRet == $CB_ERR) Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
$sText = DllStructGetData($tBuffer, "Text")
Return $iRet
EndFunc
Func _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETLBTEXTLEN, $iIndex)
EndFunc
Func _GUICtrlComboBox_GetList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Local $sResult = "", $sItem
For $i = 0 To _GUICtrlComboBox_GetCount($hWnd) - 1
_GUICtrlComboBox_GetLBText($hWnd, $i, $sItem)
$sResult &= $sItem & $sDelimiter
Next
Return StringTrimRight($sResult, StringLen($sDelimiter))
EndFunc
Func _GUICtrlComboBox_GetListArray($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Return StringSplit(_GUICtrlComboBox_GetList($hWnd), $sDelimiter)
EndFunc
Func _GUICtrlComboBox_ResetContent($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_RESETCONTENT)
EndFunc
Func _GUICtrlComboBox_SelectString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SELECTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_SetCurSel($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETCURSEL, $iIndex)
EndFunc
Global $__g_hCBExLastWnd
Global Const $__COMBOBOXEXCONSTANT_ClassName = "ComboBoxEx32"
Global Const $__COMBOBOXEXCONSTANT_WM_SIZE = 0x05
Func _GUICtrlComboBoxEx_AddString($hWnd, $sText, $iImage = -1, $iSelectedImage = -1, $iOverlayImage = -1, $iIndent = -1, $iParam = -1)
Return _GUICtrlComboBoxEx_InsertString($hWnd, $sText, -1, $iImage, $iSelectedImage, $iOverlayImage, $iIndent, $iParam)
EndFunc
Func _GUICtrlComboBoxEx_Create($hWnd, $sText, $iX, $iY, $iWidth = 100, $iHeight = 200, $iStyle = 0x00200002, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
If $iWidth = -1 Then $iWidth = 100
If $iHeight = -1 Then $iHeight = 200
Local Const $WS_VSCROLL = 0x00200000
If $iStyle = -1 Then $iStyle = BitOR($WS_VSCROLL, $CBS_DROPDOWN)
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hCombo = _WinAPI_CreateWindowEx($iExStyle, $__COMBOBOXEXCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hCombo, _WinAPI_GetStockObject($__COMBOBOXCONSTANT_DEFAULT_GUI_FONT))
If StringLen($sText) Then
Local $aText = StringSplit($sText, $sDelimiter)
For $x = 1 To $aText[0]
_GUICtrlComboBoxEx_AddString($hCombo, $aText[$x])
Next
EndIf
Return $hCombo
EndFunc
Func _GUICtrlComboBoxEx_FindStringExact($hWnd, $sText, $iIndex = -1)
Return _SendMessage($hWnd, $CB_FINDSTRINGEXACT, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBoxEx_GetComboControl($hWnd)
Return HWnd(_SendMessage($hWnd, $CBEM_GETCOMBOCONTROL))
EndFunc
Func _GUICtrlComboBoxEx_GetCount($hWnd)
Return _SendMessage($hWnd, $CB_GETCOUNT)
EndFunc
Func _GUICtrlComboBoxEx_GetUnicode($hWnd)
Return _SendMessage($hWnd, $CBEM_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlComboBoxEx_InsertString($hWnd, $sText, $iIndex = -1, $iImage = -1, $iSelectedImage = -1, $iOverlayImage = -1, $iIndent = -1, $iParam = -1)
Local $iBuffer = 0, $iMask, $iRet
Local $bUnicode = _GUICtrlComboBoxEx_GetUnicode($hWnd)
Local $tItem = DllStructCreate($tagCOMBOBOXEXITEM)
If $sText <> -1 Then
$iMask = BitOR($CBEIF_TEXT, $CBEIF_LPARAM)
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", $iBuffer)
Else
$iMask = BitOR($CBEIF_DI_SETITEM, $CBEIF_LPARAM)
EndIf
If $iImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_IMAGE)
If $iSelectedImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_SELECTEDIMAGE)
If $iOverlayImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_OVERLAY)
If $iIndent >= 1 Then $iMask = BitOR($iMask, $CBEIF_INDENT)
If $iParam = -1 Then $iParam = _GUICtrlComboBoxEx_GetCount($hWnd)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "SelectedImage", $iSelectedImage)
DllStructSetData($tItem, "OverlayImage", $iOverlayImage)
DllStructSetData($tItem, "Indent", $iIndent)
DllStructSetData($tItem, "Param", $iParam)
If _WinAPI_InProcess($hWnd, $__g_hCBExLastWnd) Or($sText = -1) Then
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUICtrlComboBoxEx_SetCurSel($hWnd, $iIndex = -1)
Return _SendMessage($hWnd, $CB_SETCURSEL, $iIndex)
EndFunc
Func _GUICtrlComboBoxEx_SetImageList($hWnd, $hHandle)
Local $hResult = _SendMessage($hWnd, $CBEM_SETIMAGELIST, 0, $hHandle, 0, "wparam", "handle", "handle")
_SendMessage($hWnd, $__COMBOBOXEXCONSTANT_WM_SIZE)
Return $hResult
EndFunc
Global Const $__SLIDERCONSTANT_WM_USER = 0x400
Global Const $TBM_SETTICFREQ = $__SLIDERCONSTANT_WM_USER + 20
Global Const $TBM_SETTIPSIDE = $__SLIDERCONSTANT_WM_USER + 31
Global Const $TBTS_BOTTOM = 2
Global Const $TBS_AUTOTICKS = 0x0001
Global Const $TBS_TOOLTIPS = 0x100
Func _GUICtrlSlider_SetTicFreq($hWnd, $iFreg)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTICFREQ, $iFreg)
EndFunc
Func _GUICtrlSlider_SetTipSide($hWnd, $iLocation)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTIPSIDE, $iLocation)
EndFunc
Global Const $PBS_SMOOTH = 1
Global Const $SS_LEFT = 0x0
Global Const $SS_CENTER = 0x1
Global Const $SS_RIGHT = 0x2
Global Const $SS_BLACKRECT = 0x4
Global Const $SS_GRAYRECT = 0x5
Global Const $SS_BITMAP = 0xE
Global Const $SS_SUNKEN = 0x1000
Global Const $STM_SETIMAGE = 0x0172
Global Const $TCS_MULTILINE = 0x00000200
Global Const $TCS_RIGHTJUSTIFY = 0x00000000
Global Const $TCM_FIRST = 0x1300
Global Const $TCCM_FIRST = 0X2000
Global Const $TCM_GETITEMRECT =($TCM_FIRST + 10)
Global Const $TCM_SETCURFOCUS =($TCM_FIRST + 48)
Global Const $TCM_SETIMAGELIST = $TCM_FIRST + 3
Func _WinAPI_CreateStreamOnHGlobal($hGlobal = 0, $bDeleteOnRelease = True)
Local $aReturn = DllCall('ole32.dll', 'long', 'CreateStreamOnHGlobal', 'handle', $hGlobal, 'bool', $bDeleteOnRelease, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[3]
EndFunc
Func _WinAPI_ReleaseStream($pStream)
Local $aReturn = DllCall('oleaut32.dll', 'long', 'DispCallFunc', 'ptr', $pStream, 'ulong_ptr', 8 *(1 + @AutoItX64), 'uint', 4, 'ushort', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
Func _WinAPI_CreateMutex($sMutex, $bInitial = True, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateMutexW', 'struct*', $tSecurity, 'bool', $bInitial, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateSemaphoreW', 'struct*', $tSecurity, 'long', $iInitial, 'long', $iMaximum, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EmptyWorkingSet($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000500, 0x00001100), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EmptyWorkingSet', 'handle', $hProcess[0])
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EnumProcessThreads($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local Const $tagTHREADENTRY32 = 'dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags'
Local $tTHREADENTRY32 = DllStructCreate($tagTHREADENTRY32)
Local $aResult[101] = [0]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Thread32First', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
While Not @error And $aRet[0]
If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Thread32Next', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0] Then Return SetError(1, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessWindows($iPID = 0, $bVisible = True)
Local $aThreads = _WinAPI_EnumProcessThreads($iPID)
If @error Then Return SetError(@error, @extended, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
For $i = 1 To $aThreads[0]
DllCall('user32.dll', 'bool', 'EnumThreadWindows', 'dword', $aThreads[$i], 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $bVisible)
If @error Then
ExitLoop
EndIf
Next
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then Return SetError(11, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_GetExitCodeProcess($hProcess)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetExitCodeProcess', 'handle', $hProcess, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_ReleaseMutex($hMutex)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseMutex', 'handle', $hMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseSemaphore', 'handle', $hSemaphore, 'long', $iIncrease, 'long*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[3]
EndFunc
Global Const $LOCALE_SDATE = 0x001D
Global Const $LOCALE_STIME = 0x001E
Global Const $LOCALE_SSHORTDATE = 0x001F
Global Const $LOCALE_SLONGDATE = 0x0020
Global Const $LOCALE_STIMEFORMAT = 0x1003
Global Const $LOCALE_S1159 = 0x0028
Global Const $LOCALE_S2359 = 0x0029
Global Const $LOCALE_INVARIANT = 0x007F
Global Const $LOCALE_USER_DEFAULT = 0x0400
Global Const $DIB_RGB_COLORS = 0
Global Const $BI_RGB = 0
Global Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Global Const $tagBITMAPV5HEADER = 'struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct'
Global Const $tagDIBSECTION = $tagBITMAP & ';' & $tagBITMAPINFOHEADER & ';dword dsBitfields[3];ptr dshSection;dword dsOffset'
Func _WinAPI_CopyBitmap($hBitmap)
$hBitmap = _WinAPI_CopyImage($hBitmap, 0, 0, 0, 0x2000)
Return SetError(@error, @extended, $hBitmap)
EndFunc
Func _WinAPI_CopyImage($hImage, $iType = 0, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CopyImage', 'handle', $hImage, 'uint', $iType, 'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_Create32BitHBITMAP($hIcon, $bDib = False, $bDelete = False)
Local $hBitmap = 0
Local $aDIB[2] = [0, 0]
Local $hTemp = _WinAPI_Create32BitHICON($hIcon)
If @error Then Return SetError(@error, @extended, 0)
Local $iError = 0
Do
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hTemp, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
For $i = 0 To 1
$aDIB[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($aDIB[0], DllStructGetSize($tBITMAP), $tBITMAP) Then
$iError = @error + 20
ExitLoop
EndIf
If $bDib Then
$hBitmap = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
_WinAPI_DrawIconEx($hDC, 0, 0, $hTemp)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = $aDIB[1]
$aDIB[1] = 0
EndIf
Until 1
For $i = 0 To 1
If $aDIB[$i] Then
_WinAPI_DeleteObject($aDIB[$i])
EndIf
Next
_WinAPI_DestroyIcon($hTemp)
If $iError Then Return SetError($iError, 0, 0)
If Not $hBitmap Then Return SetError(12, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hBitmap
EndFunc
Func _WinAPI_Create32BitHICON($hIcon, $bDelete = False)
Local $ahBitmap[2], $hResult = 0
Local $aDIB[2][2] = [[0, 0], [0, 0]]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
If _WinAPI_IsAlphaBitmap($ahBitmap[1]) Then
$aDIB[0][0] = _WinAPI_CreateANDBitmap($ahBitmap[1])
If Not @error Then
$hResult = _WinAPI_CreateIconIndirect($ahBitmap[1], $aDIB[0][0])
EndIf
Else
Local $tSIZE = _WinAPI_GetBitmapDimension($ahBitmap[1])
Local $aSize[2]
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tSIZE, $i + 1)
Next
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv, $hDstSv
For $i = 0 To 1
$aDIB[$i][0] = _WinAPI_CreateDIB($aSize[0], $aSize[1])
$aDIB[$i][1] = $__g_vExt
$hSrcSv = _WinAPI_SelectObject($hSrcDC, $ahBitmap[$i])
$hDstSv = _WinAPI_SelectObject($hDstDC, $aDIB[$i][0])
_WinAPI_BitBlt($hDstDC, 0, 0, $aSize[0], $aSize[1], $hSrcDC, 0, 0, 0x00C000CA)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_SelectObject($hDstDC, $hDstSv)
Next
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_DeleteDC($hDstDC)
$aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __XORProc(), 'ptr', 0, 'uint', $aSize[0] * $aSize[1] * 4, 'wparam', $aDIB[0][1], 'lparam', $aDIB[1][1])
If Not @error And $aRet[0] Then
$hResult = _WinAPI_CreateIconIndirect($aDIB[1][0], $ahBitmap[0])
EndIf
EndIf
For $i = 0 To 1
_WinAPI_DeleteObject($ahBitmap[$i])
If $aDIB[$i][0] Then
_WinAPI_DeleteObject($aDIB[$i][0])
EndIf
Next
If Not $hResult Then Return SetError(11, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CreateANDBitmap($hBitmap)
Local $iError = 0, $hDib = 0
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Do
Local $atDIB[2]
$atDIB[0] = DllStructCreate($tagDIBSECTION)
If(Not _WinAPI_GetObject($hBitmap, DllStructGetSize($atDIB[0]), $atDIB[0])) Or(DllStructGetData($atDIB[0], 'bmBitsPixel') <> 32) Or(DllStructGetData($atDIB[0], 'biCompression')) Then
$iError = 10
ExitLoop
EndIf
$atDIB[1] = DllStructCreate($tagBITMAP)
$hDib = _WinAPI_CreateDIB(DllStructGetData($atDIB[0], 'bmWidth'), DllStructGetData($atDIB[0], 'bmHeight'), 1)
If Not _WinAPI_GetObject($hDib, DllStructGetSize($atDIB[1]), $atDIB[1]) Then
$iError = 11
ExitLoop
EndIf
Local $aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __ANDProc(), 'ptr', 0, 'uint', 0, 'wparam', DllStructGetPtr($atDIB[0]), 'lparam', DllStructGetPtr($atDIB[1]))
If @error Then
$iError = @error
ExitLoop
EndIf
If Not $aRet[0] Then
$iError = 12
ExitLoop
EndIf
$iError = 0
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
$hDib = 0
EndIf
Return SetError($iError, 0, $hDib)
EndFunc
Func _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel = 32, $tColorTable = 0, $iColorCount = 0)
Local $aRGBQ[2], $iColors, $tagRGBQ
Switch $iBitsPerPel
Case 1
$iColors = 2
Case 4
$iColors = 16
Case 8
$iColors = 256
Case Else
$iColors = 0
EndSwitch
If $iColors Then
If Not IsDllStruct($tColorTable) Then
Switch $iBitsPerPel
Case 1
$aRGBQ[0] = 0
$aRGBQ[1] = 0xFFFFFF
$tColorTable = _WinAPI_CreateDIBColorTable($aRGBQ)
Case Else
EndSwitch
Else
If $iColors > $iColorCount Then
$iColors = $iColorCount
EndIf
If(Not $iColors) Or((4 * $iColors) > DllStructGetSize($tColorTable)) Then
Return SetError(20, 0, 0)
EndIf
EndIf
$tagRGBQ = ';dword aRGBQuad[' & $iColors & ']'
Else
$tagRGBQ = ''
EndIf
Local $tBITMAPINFO = DllStructCreate($tagBITMAPINFOHEADER & $tagRGBQ)
DllStructSetData($tBITMAPINFO, 'biSize', 40)
DllStructSetData($tBITMAPINFO, 'biWidth', $iWidth)
DllStructSetData($tBITMAPINFO, 'biHeight', $iHeight)
DllStructSetData($tBITMAPINFO, 'biPlanes', 1)
DllStructSetData($tBITMAPINFO, 'biBitCount', $iBitsPerPel)
DllStructSetData($tBITMAPINFO, 'biCompression', 0)
DllStructSetData($tBITMAPINFO, 'biSizeImage', 0)
DllStructSetData($tBITMAPINFO, 'biXPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biYPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biClrUsed', $iColors)
DllStructSetData($tBITMAPINFO, 'biClrImportant', 0)
If $iColors Then
If IsDllStruct($tColorTable) Then
_WinAPI_MoveMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), $tColorTable, 4 * $iColors)
Else
_WinAPI_ZeroMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), 4 * $iColors)
EndIf
EndIf
Local $hBitmap = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $__g_vExt)
If Not $hBitmap Then Return SetError(@error, @extended, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateDIBColorTable(Const ByRef $aColorTable, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aColorTable, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tColorTable = DllStructCreate('dword[' &($iEnd - $iStart + 1) & ']')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tColorTable, 1, _WinAPI_SwitchColor(__RGB($aColorTable[$i])), $iCount)
$iCount += 1
Next
Return $tColorTable
EndFunc
Func _WinAPI_CreateDIBSection($hDC, $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)
$pBits = 0
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBSection', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'uint', $iUsage, 'ptr*', 0, 'handle', $hSection, 'dword', $iOffset)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBits = $aRet[4]
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIconIndirect($hBitmap, $hMask, $iXHotspot = 0, $iYHotspot = 0, $bIcon = True)
Local $tICONINFO = DllStructCreate($tagICONINFO)
DllStructSetData($tICONINFO, 1, $bIcon)
DllStructSetData($tICONINFO, 2, $iXHotspot)
DllStructSetData($tICONINFO, 3, $iYHotspot)
DllStructSetData($tICONINFO, 4, $hMask)
DllStructSetData($tICONINFO, 5, $hBitmap)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIconIndirect', 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DwmEnableComposition($bEnable)
If $bEnable Then $bEnable = 1
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableComposition', 'uint', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmIsCompositionEnabled()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmIsCompositionEnabled', 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[1]
EndFunc
Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmQueryThumbnailSourceSize', 'handle', $hThumbnail, 'struct*', $tSIZE)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tSIZE
EndFunc
Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[3]
EndFunc
Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUnregisterThumbnail', 'handle', $hThumbnail)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $bVisible = True, $bClientAreaOnly = False, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)
Local Const $tagDWM_THUMBNAIL_PROPERTIES = 'struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct'
Local $tTHUMBNAILPROPERTIES = DllStructCreate($tagDWM_THUMBNAIL_PROPERTIES)
Local $tSIZE, $iFlags = 0
If Not IsDllStruct($tRectDest) Then
$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
If @error Then
Return SetError(@error + 10, @extended, 0)
EndIf
$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
EndIf
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 2, DllStructGetData($tRectDest, $i), $i)
Next
If IsDllStruct($tRectSrc) Then
$iFlags += 2
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 3, DllStructGetData($tRectSrc, $i), $i)
Next
EndIf
DllStructSetData($tTHUMBNAILPROPERTIES, 1, BitOR($iFlags, 0x1D))
DllStructSetData($tTHUMBNAILPROPERTIES, 4, $iOpacity)
DllStructSetData($tTHUMBNAILPROPERTIES, 5, $bVisible)
DllStructSetData($tTHUMBNAILPROPERTIES, 6, $bClientAreaOnly)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUpdateThumbnailProperties', 'handle', $hThumbnail, 'struct*', $tTHUMBNAILPROPERTIES)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_GetPixel($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetPixel', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Or($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_IsAlphaBitmap($hBitmap)
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Local $aRet, $iError = 0
Do
Local $tDIB = DllStructCreate($tagDIBSECTION)
If(Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or(DllStructGetData($tDIB, 'bmBitsPixel') <> 32) Or(DllStructGetData($tDIB, 'biCompression')) Then
$iError = 1
ExitLoop
EndIf
$aRet = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __AlphaProc(), 'ptr', 0, 'uint', 0, 'struct*', $tDIB, 'ptr', 0)
If @error Or($aRet[0] = -1) Then
$iError = @error + 10
ExitLoop
EndIf
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRectEx($iX, $iY, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tPOINT = _WinAPI_CreatePoint($iX, $iY)
Local $aRet = DllCall('user32.dll', 'bool', 'PtInRect', 'struct*', $tRECT, 'struct', $tPOINT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func __AlphaProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary( '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' & '48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883' & '7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB' & '034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B' & '6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24' & '287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080' & '7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB' & '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary( '0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D' & '1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407' & 'B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302' & '83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00' & '007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __ANDProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary( '0x48894C240848895424104C894424184C894C2420554157415648C7C009000000' & '4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405' & '4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405' & '4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405' & '4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405' & '4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048' & '21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000' & 'EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7' & '44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100' & '0048C74424380000000048C74424400000000048C744244800000000488BAC24' & 'A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B' & '7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440' & '4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24' & '4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7' & '442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C' & '24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845' & '0048FF4424604883442458F871B948C74424380000000048C744244000000000' & '48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7' & 'D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C' & '244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D' & '184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24' & '585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0' & '010000004863C0EB034831C04883C470415E415F5DC3'))
Else
$pProc = __Init(Binary( '0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05' & 'B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24' & '38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0' & 'EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000' & '00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7' & '042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000' & 'C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B' & '3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480' & '7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24' & '0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000' & '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' & 'FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424' & '0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3' & '8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000' & '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' & 'FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8' & '01000000EB0231C083C4205F5B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __XORProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary( '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' & '48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074' & '054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0' & '4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C' & '3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405' & '4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C' & '897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB' & '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary( '0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074' & '0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB' & '5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B' & '6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303' & '895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D' & 'C21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func _WinAPI_GetFileVersionInfo($sFilePath, ByRef $pBuffer, $iFlags = 0)
Local $aRet
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeExW', 'dword', BitAND($iFlags, 0x03), 'wstr', $sFilePath, 'ptr', 0)
Else
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFilePath, 'ptr', 0)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $iNbByte = $aRet[0]
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoExW', 'dword', BitAND($iFlags, 0x07), 'wstr', $sFilePath, 'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
Else
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoW', 'wstr', $sFilePath, 'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iNbByte
EndFunc
Func _WinAPI_VerQueryValue($pData, $sValues = '')
$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $sValues Then
$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$sValues = StringSplit($sValues, '|', $STR_NOCOUNT)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, 0, 0)
Local $iLength = Floor($aRet[4] / 4)
Local $tLang = DllStructCreate('dword[' & $iLength & ']', $aRet[3])
If @error Then Return SetError(@error + 20, 0, 0)
Local $sCP, $aInfo[101][UBound($sValues) + 1] = [[0]]
For $i = 1 To $iLength
__Inc($aInfo)
$aInfo[$aInfo[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
$sCP = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tLang, 1, $i)), _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))), 8)
For $j = 0 To UBound($sValues) - 1
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $sValues[$j], 'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$aInfo[$aInfo[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$aInfo[$aInfo[0][0]][$j + 1] = ''
EndIf
Next
Next
__Inc($aInfo, -1)
Return $aInfo
EndFunc
Global Const $GDIP_EPGCOLORDEPTH = '{66087055-AD66-4C7C-9A18-38A2310B8337}'
Global Const $GDIP_EPGCOMPRESSION = '{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}'
Global Const $GDIP_EPGQUALITY = '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}'
Global Const $GDIP_EPTLONG = 4
Global Const $GDIP_EVTCOMPRESSIONLZW = 2
Global Const $GDIP_ILMREAD = 0x0001
Global Const $GDIP_PXF24RGB = 0x00021808
Global Const $GDIP_PXF32RGB = 0x00022009
Global Const $GDIP_PXF32ARGB = 0x0026200A
Global Const $GDIP_SMOOTHINGMODE_DEFAULT = 0
Global Const $GDIP_SMOOTHINGMODE_HIGHQUALITY = 2
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 5
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 7
Global $__g_hGDIPBrush = 0
Global $__g_hGDIPDll = 0
Global $__g_hGDIPPen = 0
Global $__g_iGDIPRef = 0
Global $__g_iGDIPToken = 0
Global $__g_bGDIP_V1_0 = True
Func _GDIPlus_BitmapCloneArea($hBitmap, $nLeft, $nTop, $nWidth, $nHeight, $iFormat = 0x00021808)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneBitmapArea", "float", $nLeft, "float", $nTop, "float", $nWidth, "float", $nHeight, "int", $iFormat, "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
Local $aRet = DllCall($__g_hGDIPDll, "uint", "GdipGetImageDimension", "handle", $hBitmap, "float*", 0, "float*", 0)
If @error Or $aRet[0] Then Return SetError(@error + 10, $aRet[0], 0)
Local $tData = _GDIPlus_BitmapLockBits($hBitmap, 0, 0, $aRet[2], $aRet[3], $GDIP_ILMREAD, $GDIP_PXF32ARGB)
Local $pBits = DllStructGetData($tData, "Scan0")
If Not $pBits Then Return 0
Local $tBIHDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIHDR, "bV5Size", DllStructGetSize($tBIHDR))
DllStructSetData($tBIHDR, "bV5Width", $aRet[2])
DllStructSetData($tBIHDR, "bV5Height", $aRet[3])
DllStructSetData($tBIHDR, "bV5Planes", 1)
DllStructSetData($tBIHDR, "bV5BitCount", 32)
DllStructSetData($tBIHDR, "bV5Compression", 0)
DllStructSetData($tBIHDR, "bV5SizeImage", $aRet[3] * DllStructGetData($tData, "Stride"))
DllStructSetData($tBIHDR, "bV5AlphaMask", 0xFF000000)
DllStructSetData($tBIHDR, "bV5RedMask", 0x00FF0000)
DllStructSetData($tBIHDR, "bV5GreenMask", 0x0000FF00)
DllStructSetData($tBIHDR, "bV5BlueMask", 0x000000FF)
DllStructSetData($tBIHDR, "bV5CSType", 2)
DllStructSetData($tBIHDR, "bV5Intent", 4)
Local $hHBitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $tBIHDR, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
If Not @error And $hHBitmapv5[0] Then
DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hHBitmapv5[0], "dword", $aRet[2] * $aRet[3] * 4, "ptr", DllStructGetData($tData, "Scan0"))
$hHBitmapv5 = $hHBitmapv5[0]
Else
$hHBitmapv5 = 0
EndIf
_GDIPlus_BitmapUnlockBits($hBitmap, $tData)
$tData = 0
$tBIHDR = 0
Return $hHBitmapv5
EndFunc
Func _GDIPlus_BitmapCreateFromFile($sFileName)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateFromHBITMAP($hBitmap, $hPal = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hBitmap, "handle", $hPal, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $iPixelFormat = $GDIP_PXF32ARGB, $iStride = 0, $pScan0 = 0)
Local $aResult = DllCall($__g_hGDIPDll, "uint", "GdipCreateBitmapFromScan0", "int", $iWidth, "int", $iHeight, "int", $iStride, "int", $iPixelFormat, "struct*", $pScan0, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_BitmapCreateFromStream($pStream)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapDispose($hBitmap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_BitmapLockBits($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $iFlags = $GDIP_ILMREAD, $iFormat = $GDIP_PXF32RGB)
Local $tData = DllStructCreate($tagGDIPBITMAPDATA)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iWidth)
DllStructSetData($tRECT, "Bottom", $iHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapLockBits", "handle", $hBitmap, "struct*", $tRECT, "uint", $iFlags, "int", $iFormat, "struct*", $tData)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tData
EndFunc
Func _GDIPlus_BitmapUnlockBits($hBitmap, $tBitmapData)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapUnlockBits", "handle", $hBitmap, "struct*", $tBitmapData)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BrushCreateSolid($iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateSolidFill", "int", $iARGB, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushDispose($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteBrush", "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Encoders()
Local $iCount = _GDIPlus_EncodersGetCount()
Local $iSize = _GDIPlus_EncodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_EncodersGetCLSID($sFileExtension)
Local $aEncoders = _GDIPlus_Encoders()
If @error Then Return SetError(@error, 0, "")
For $iI = 1 To $aEncoders[0][0]
If StringInStr($aEncoders[$iI][6], "*." & $sFileExtension) > 0 Then Return $aEncoders[$iI][1]
Next
Return SetError(-1, -1, "")
EndFunc
Func _GDIPlus_EncodersGetCount()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[1]
EndFunc
Func _GDIPlus_EncodersGetSize()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_FontCreate($hFamily, $fSize, $iStyle = 0, $iUnit = 3)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFont", "handle", $hFamily, "float", $fSize, "int", $iStyle, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_FontDispose($hFont)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFont", "handle", $hFont)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyCreate($sFamily, $pCollection = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFamily, "ptr", $pCollection, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyDispose($hFamily)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFontFamily", "handle", $hFamily)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsClear($hGraphics, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGraphicsClear", "handle", $hGraphics, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsCreateFromHDC($hDC)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHDC", "handle", $hDC, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsDispose($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteGraphics", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawEllipse", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRect($hGraphics, $hImage, $nX, $nY, $nW, $nH)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRect", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY, "float", $nW, "float", $nH)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawLine($hGraphics, $nX1, $nY1, $nX2, $nY2, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawLine", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawRectangle", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawString($hGraphics, $sString, $nX, $nY, $sFont = "Arial", $fSize = 10, $iFormat = 0)
Local $hBrush = _GDIPlus_BrushCreateSolid()
Local $hFormat = _GDIPlus_StringFormatCreate($iFormat)
Local $hFamily = _GDIPlus_FontFamilyCreate($sFont)
Local $hFont = _GDIPlus_FontCreate($hFamily, $fSize)
Local $tLayout = _GDIPlus_RectFCreate($nX, $nY, 0.0, 0.0)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult = _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
Local $iError = @error, $iExtended = @extended
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
Return SetError($iError, $iExtended, $aResult)
EndFunc
Func _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $tLayout, $hFormat, $hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont, "struct*", $tLayout, "handle", $hFormat, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillRectangle", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMeasureString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont, "struct*", $tLayout, "handle", $hFormat, "struct*", $tRECTF, "int*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $aInfo[3]
$aInfo[0] = $tRECTF
$aInfo[1] = $aResult[8]
$aInfo[2] = $aResult[9]
Return $aInfo
EndFunc
Func _GDIPlus_GraphicsSetInterpolationMode($hGraphics, $iInterpolationMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetInterpolationMode", "handle", $hGraphics, "int", $iInterpolationMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetSmoothingMode($hGraphics, $iSmooth)
If $iSmooth < $GDIP_SMOOTHINGMODE_DEFAULT Or $iSmooth > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 Then $iSmooth = $GDIP_SMOOTHINGMODE_DEFAULT
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetSmoothingMode", "handle", $hGraphics, "int", $iSmooth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageDispose($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hImage)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageGetGraphicsContext($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageGraphicsContext", "handle", $hImage, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetHeight($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageHeight", "handle", $hImage, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetWidth($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageWidth", "handle", $hImage, "uint*", -1)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageSaveToFile($hImage, $sFileName)
Local $sExt = __GDIPlus_ExtractFileExt($sFileName)
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-1, 0, False)
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, 0)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sEncoder, $tParams = 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToFile", "handle", $hImage, "wstr", $sFileName, "struct*", $tGUID, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageResize($hImage, $iNewWidth, $iNewHeight, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iNewWidth, $iNewHeight)
If @error Then Return SetError(1, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
If @error Then
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(2, @extended, 0)
EndIf
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(3, @extended, 0)
EndIf
_GDIPlus_GraphicsDrawImageRect($hBmpCtxt, $hImage, 0, 0, $iNewWidth, $iNewHeight)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, @extended, 0)
EndIf
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func _GDIPlus_ParamAdd(ByRef $tParams, $sGUID, $iNbOfValues, $iType, $pValues)
Local $iCount = DllStructGetData($tParams, "Count")
Local $pGUID = DllStructGetPtr($tParams, "GUID") +($iCount * _GDIPlus_ParamSize())
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM, $pGUID)
_WinAPI_GUIDFromStringEx($sGUID, $pGUID)
DllStructSetData($tParam, "Type", $iType)
DllStructSetData($tParam, "NumberOfValues", $iNbOfValues)
DllStructSetData($tParam, "Values", $pValues)
DllStructSetData($tParams, "Count", $iCount + 1)
EndFunc
Func _GDIPlus_ParamInit($iCount)
Local $sStruct = $tagGDIPENCODERPARAMS
For $i = 2 To $iCount
$sStruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
Next
Return DllStructCreate($sStruct)
EndFunc
Func _GDIPlus_ParamSize()
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM)
Return DllStructGetSize($tParam)
EndFunc
Func _GDIPlus_PenCreate($iARGB = 0xFF000000, $nWidth = 1, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePen1", "dword", $iARGB, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PenDispose($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePen", "handle", $hPen)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RectFCreate($nX = 0, $nY = 0, $nWidth = 0, $nHeight = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
DllStructSetData($tRECTF, "X", $nX)
DllStructSetData($tRECTF, "Y", $nY)
DllStructSetData($tRECTF, "Width", $nWidth)
DllStructSetData($tRECTF, "Height", $nHeight)
Return $tRECTF
EndFunc
Func _GDIPlus_Shutdown()
If $__g_hGDIPDll = 0 Then Return SetError(-1, -1, False)
$__g_iGDIPRef -= 1
If $__g_iGDIPRef = 0 Then
DllCall($__g_hGDIPDll, "none", "GdiplusShutdown", "ulong_ptr", $__g_iGDIPToken)
DllClose($__g_hGDIPDll)
$__g_hGDIPDll = 0
EndIf
Return True
EndFunc
Func _GDIPlus_Startup($sGDIPDLL = Default, $bRetDllHandle = False)
$__g_iGDIPRef += 1
If $__g_iGDIPRef > 1 Then Return True
If $sGDIPDLL = Default Then $sGDIPDLL = "gdiplus.dll"
$__g_hGDIPDll = DllOpen($sGDIPDLL)
If $__g_hGDIPDll = -1 Then
$__g_iGDIPRef = 0
Return SetError(1, 2, False)
EndIf
Local $sVer = FileGetVersion($sGDIPDLL)
$sVer = StringSplit($sVer, ".")
If $sVer[1] > 5 Then $__g_bGDIP_V1_0 = False
Local $tInput = DllStructCreate($tagGDIPSTARTUPINPUT)
Local $tToken = DllStructCreate("ulong_ptr Data")
DllStructSetData($tInput, "Version", 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdiplusStartup", "struct*", $tToken, "struct*", $tInput, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
$__g_iGDIPToken = DllStructGetData($tToken, "Data")
If $bRetDllHandle Then Return $__g_hGDIPDll
Return SetExtended($sVer[1], True)
EndFunc
Func _GDIPlus_StringFormatCreate($iFormat = 0, $iLangID = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateStringFormat", "int", $iFormat, "word", $iLangID, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_StringFormatDispose($hFormat)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteStringFormat", "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func __GDIPlus_BrushDefCreate(ByRef $hBrush)
If $hBrush = 0 Then
$__g_hGDIPBrush = _GDIPlus_BrushCreateSolid()
$hBrush = $__g_hGDIPBrush
EndIf
EndFunc
Func __GDIPlus_BrushDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPBrush <> 0 Then
_GDIPlus_BrushDispose($__g_hGDIPBrush)
$__g_hGDIPBrush = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func __GDIPlus_ExtractFileExt($sFileName, $bNoDot = True)
Local $iIndex = __GDIPlus_LastDelimiter(".\:", $sFileName)
If($iIndex > 0) And(StringMid($sFileName, $iIndex, 1) = '.') Then
If $bNoDot Then
Return StringMid($sFileName, $iIndex + 1)
Else
Return StringMid($sFileName, $iIndex)
EndIf
Else
Return ""
EndIf
EndFunc
Func __GDIPlus_LastDelimiter($sDelimiters, $sString)
Local $sDelimiter, $iN
For $iI = 1 To StringLen($sDelimiters)
$sDelimiter = StringMid($sDelimiters, $iI, 1)
$iN = StringInStr($sString, $sDelimiter, 0, -1)
If $iN > 0 Then Return $iN
Next
EndFunc
Func __GDIPlus_PenDefCreate(ByRef $hPen)
If $hPen = 0 Then
$__g_hGDIPPen = _GDIPlus_PenCreate()
$hPen = $__g_hGDIPPen
EndIf
EndFunc
Func __GDIPlus_PenDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPPen <> 0 Then
_GDIPlus_PenDispose($__g_hGDIPPen)
$__g_hGDIPPen = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Global $__g_iBMPFormat = $GDIP_PXF24RGB
Global $__g_iJPGQuality = 100
Global $__g_iTIFColorDepth = 24
Global $__g_iTIFCompression = $GDIP_EVTCOMPRESSIONLZW
Global Const $__SCREENCAPTURECONSTANT_SM_CXSCREEN = 0
Global Const $__SCREENCAPTURECONSTANT_SM_CYSCREEN = 1
Global Const $__SCREENCAPTURECONSTANT_SRCCOPY = 0x00CC0020
Func _ScreenCapture_Capture($sFileName = "", $iLeft = 0, $iTop = 0, $iRight = -1, $iBottom = -1, $bCursor = True)
Local $bRet = False
If $iRight = -1 Then $iRight = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CXSCREEN) - 1
If $iBottom = -1 Then $iBottom = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CYSCREEN) - 1
If $iRight < $iLeft Then Return SetError(-1, 0, $bRet)
If $iBottom < $iTop Then Return SetError(-2, 0, $bRet)
Local $iW =($iRight - $iLeft) + 1
Local $iH =($iBottom - $iTop) + 1
Local $hWnd = _WinAPI_GetDesktopWindow()
Local $hDDC = _WinAPI_GetDC($hWnd)
Local $hCDC = _WinAPI_CreateCompatibleDC($hDDC)
Local $hBMP = _WinAPI_CreateCompatibleBitmap($hDDC, $iW, $iH)
_WinAPI_SelectObject($hCDC, $hBMP)
_WinAPI_BitBlt($hCDC, 0, 0, $iW, $iH, $hDDC, $iLeft, $iTop, $__SCREENCAPTURECONSTANT_SRCCOPY)
If $bCursor Then
Local $aCursor = _WinAPI_GetCursorInfo()
If Not @error And $aCursor[1] Then
$bCursor = True
Local $hIcon = _WinAPI_CopyIcon($aCursor[2])
Local $aIcon = _WinAPI_GetIconInfo($hIcon)
If Not @error Then
_WinAPI_DeleteObject($aIcon[4])
If $aIcon[5] <> 0 Then _WinAPI_DeleteObject($aIcon[5])
_WinAPI_DrawIcon($hCDC, $aCursor[3] - $aIcon[2] - $iLeft, $aCursor[4] - $aIcon[3] - $iTop, $hIcon)
EndIf
_WinAPI_DestroyIcon($hIcon)
EndIf
EndIf
_WinAPI_ReleaseDC($hWnd, $hDDC)
_WinAPI_DeleteDC($hCDC)
If $sFileName = "" Then Return $hBMP
$bRet = _ScreenCapture_SaveImage($sFileName, $hBMP, True)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _ScreenCapture_SaveImage($sFileName, $hBitmap, $bFreeBmp = True)
_GDIPlus_Startup()
If @error Then Return SetError(-1, -1, False)
Local $sExt = StringUpper(__GDIPlus_ExtractFileExt($sFileName))
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-2, -2, False)
Local $hImage = _GDIPlus_BitmapCreateFromHBITMAP($hBitmap)
If @error Then Return SetError(-3, -3, False)
Local $tData, $tParams
Switch $sExt
Case "BMP"
Local $iX = _GDIPlus_ImageGetWidth($hImage)
Local $iY = _GDIPlus_ImageGetHeight($hImage)
Local $hClone = _GDIPlus_BitmapCloneArea($hImage, 0, 0, $iX, $iY, $__g_iBMPFormat)
_GDIPlus_ImageDispose($hImage)
$hImage = $hClone
Case "JPG", "JPEG"
$tParams = _GDIPlus_ParamInit(1)
$tData = DllStructCreate("int Quality")
DllStructSetData($tData, "Quality", $__g_iJPGQuality)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGQUALITY, 1, $GDIP_EPTLONG, DllStructGetPtr($tData))
Case "TIF", "TIFF"
$tParams = _GDIPlus_ParamInit(2)
$tData = DllStructCreate("int ColorDepth;int Compression")
DllStructSetData($tData, "ColorDepth", $__g_iTIFColorDepth)
DllStructSetData($tData, "Compression", $__g_iTIFCompression)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGCOLORDEPTH, 1, $GDIP_EPTLONG, DllStructGetPtr($tData, "ColorDepth"))
_GDIPlus_ParamAdd($tParams, $GDIP_EPGCOMPRESSION, 1, $GDIP_EPTLONG, DllStructGetPtr($tData, "Compression"))
EndSwitch
Local $pParams = 0
If IsDllStruct($tParams) Then $pParams = $tParams
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, $pParams)
_GDIPlus_ImageDispose($hImage)
If $bFreeBmp Then _WinAPI_DeleteObject($hBitmap)
_GDIPlus_Shutdown()
Return SetError($bRet = False, 0, $bRet)
EndFunc
Global Enum $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER, $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING
Func _ArrayAdd(ByRef $aArray, $vValue, $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
EndSwitch
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + 1]
$aArray[$iDim_1] = $vValue
Return $iDim_1
EndIf
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
EndIf
$vValue = $aTmp
EndIf
Local $iAdd = UBound($vValue, $UBOUND_ROWS)
ReDim $aArray[$iDim_1 + $iAdd]
For $i = 0 To $iAdd - 1
If IsFunc($hDataType) Then
$aArray[$iDim_1 + $i] = $hDataType($vValue[$i])
Else
$aArray[$iDim_1 + $i] = $vValue[$i]
EndIf
Next
Return $iDim_1 + $iAdd - 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(4, 0, -1)
Local $iValDim_1, $iValDim_2 = 0, $iColCount
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(5, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
Local $aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
Local $aTmp[$iValDim_1][0], $aSplit_2
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iColCount = UBound($aSplit_2)
If $iColCount > $iValDim_2 Then
$iValDim_2 = $iColCount
ReDim $aTmp[$iValDim_1][$iValDim_2]
EndIf
For $j = 0 To $iColCount - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1 + $iValDim_1][$iDim_2]
For $iWriteTo_Index = 0 To $iValDim_1 - 1
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
Else
If IsFunc($hDataType) Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = $hDataType($vValue[$iWriteTo_Index][$j - $iStart])
Else
$aArray[$iWriteTo_Index + $iDim_1][$j] = $vValue[$iWriteTo_Index][$j - $iStart]
EndIf
EndIf
Next
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS) - 1
EndFunc
Func _ArrayBinarySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iColumn = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iColumn = Default Then $iColumn = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iDim_1 = 0 Then Return SetError(6, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_1 - 1 Then $iEnd = $iDim_1 - 1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Local $iMid = Int(($iEnd + $iStart) / 2)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $aArray[$iStart] > $vValue Or $aArray[$iEnd] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid]
If $vValue < $aArray[$iMid] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(7, 0, -1)
If $aArray[$iStart][$iColumn] > $vValue Or $aArray[$iEnd][$iColumn] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid][$iColumn]
If $vValue < $aArray[$iMid][$iColumn] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case Else
Return SetError(5, 0, -1)
EndSwitch
Return $iMid
EndFunc
Func _ArrayColInsert(ByRef $aArray, $iColumn)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aTempArray[$iDim_1][2]
Switch $iColumn
Case 0, 1
For $i = 0 To $iDim_1 - 1
$aTempArray[$i][(Not $iColumn)] = $aArray[$i]
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
$aArray = $aTempArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1][$iDim_2 + 1]
For $i = 0 To $iDim_1 - 1
For $j = $iDim_2 To $iColumn + 1 Step -1
$aArray[$i][$j] = $aArray[$i][$j - 1]
Next
$aArray[$i][$iColumn] = ""
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayConcatenate(ByRef $aArrayTarget, Const ByRef $aArraySource, $iStart = 0)
If $iStart = Default Then $iStart = 0
If Not IsArray($aArrayTarget) Then Return SetError(1, 0, -1)
If Not IsArray($aArraySource) Then Return SetError(2, 0, -1)
Local $iDim_Total_Tgt = UBound($aArrayTarget, $UBOUND_DIMENSIONS)
Local $iDim_Total_Src = UBound($aArraySource, $UBOUND_DIMENSIONS)
Local $iDim_1_Tgt = UBound($aArrayTarget, $UBOUND_ROWS)
Local $iDim_1_Src = UBound($aArraySource, $UBOUND_ROWS)
If $iStart < 0 Or $iStart > $iDim_1_Src - 1 Then Return SetError(6, 0, -1)
Switch $iDim_Total_Tgt
Case 1
If $iDim_Total_Src <> 1 Then Return SetError(4, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart]
For $i = $iStart To $iDim_1_Src - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart] = $aArraySource[$i]
Next
Case 2
If $iDim_Total_Src <> 2 Then Return SetError(4, 0, -1)
Local $iDim_2_Tgt = UBound($aArrayTarget, $UBOUND_COLUMNS)
If UBound($aArraySource, $UBOUND_COLUMNS) <> $iDim_2_Tgt Then Return SetError(5, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart][$iDim_2_Tgt]
For $i = $iStart To $iDim_1_Src - 1
For $j = 0 To $iDim_2_Tgt - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart][$j] = $aArraySource[$i][$j]
Next
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
Return UBound($aArrayTarget, $UBOUND_ROWS)
EndFunc
Func _ArrayDelete(ByRef $aArray, $vRange)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber, $aSplit_1, $aSplit_2
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
Local $iCopyTo_Index = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
$aArray[$iCopyTo_Index] = $aArray[$iReadFrom_Index]
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1]
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]][0] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index][0] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
For $j = 0 To $iDim_2
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFrom_Index][$j]
Next
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1][$iDim_2 + 1]
Case Else
Return SetError(2, 0, False)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayExtract(Const ByRef $aArray, $iStart_Row = -1, $iEnd_Row = -1, $iStart_Col = -1, $iEnd_Col = -1)
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
For $i = 0 To $iEnd_Row - $iStart_Row
$aRetArray[$i] = $aArray[$i + $iStart_Row]
Next
Return $aRetArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col = -1 Then $iStart_Col = 0
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
If $iStart_Col = $iEnd_Col Then
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
Else
Local $aRetArray[$iEnd_Row - $iStart_Row + 1][$iEnd_Col - $iStart_Col + 1]
EndIf
For $i = 0 To $iEnd_Row - $iStart_Row
For $j = 0 To $iEnd_Col - $iStart_Col
If $iStart_Col = $iEnd_Col Then
$aRetArray[$i] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
Else
$aRetArray[$i][$j] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
EndIf
Next
Next
Return $aRetArray
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayFindAll(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iSubItem = 0, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iSubItem = Default Then $iSubItem = 0
If $bRow = Default Then $bRow = False
$iStart = _ArraySearch($aArray, $vValue, $iStart, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
If @error Then Return SetError(@error, 0, -1)
Local $iIndex = 0, $avResult[UBound($aArray,($bRow ? $UBOUND_COLUMNS : $UBOUND_ROWS))]
Do
$avResult[$iIndex] = $iStart
$iIndex += 1
$iStart = _ArraySearch($aArray, $vValue, $iStart + 1, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
Until @error
ReDim $avResult[$iIndex]
Return $avResult
EndFunc
Func _ArrayMax(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMaxIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_GreaterThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayMin(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMinIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMinIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_LessThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayReverse(ByRef $aArray, $iStart = 0, $iEnd = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
If Not UBound($aArray) Then Return SetError(4, 0, 0)
Local $vTmp, $iUBound = UBound($aArray) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
For $i = $iStart To Int(($iStart + $iEnd - 1) / 2)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iEnd]
$aArray[$iEnd] = $vTmp
$iEnd -= 1
Next
Return 1
EndFunc
Func _ArraySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iForward = 1, $iSubItem = -1, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iForward = Default Then $iForward = 1
If $iSubItem = Default Then $iSubItem = -1
If $bRow = Default Then $bRow = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray) - 1
If $iDim_1 = -1 Then Return SetError(3, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
Local $bCompType = False
If $iCompare = 2 Then
$iCompare = 0
$bCompType = True
EndIf
If $bRow Then
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then Return SetError(5, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_2 Then $iEnd = $iDim_2
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Else
If $iEnd < 1 Or $iEnd > $iDim_1 Then $iEnd = $iDim_1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
EndIf
Local $iStep = 1
If Not $iForward Then
Local $iTmp = $iStart
$iStart = $iEnd
$iEnd = $iTmp
$iStep = -1
EndIf
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] = $vValue Then Return $i
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] == $vValue Then Return $i
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If StringRegExp($aArray[$i], $vValue) Then Return $i
Else
If StringInStr($aArray[$i], $vValue, $iCase) > 0 Then Return $i
EndIf
Next
EndIf
Case 2
Local $iDim_Sub
If $bRow Then
$iDim_Sub = $iDim_1
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
Else
$iDim_Sub = $iDim_2
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
EndIf
For $j = $iSubItem To $iDim_Sub
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] = $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] = $vValue Then Return $i
EndIf
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] == $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] == $vValue Then Return $i
EndIf
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If $bRow Then
If StringRegExp($aArray[$j][$i], $vValue) Then Return $i
Else
If StringRegExp($aArray[$i][$j], $vValue) Then Return $i
EndIf
Else
If $bRow Then
If StringInStr($aArray[$j][$i], $vValue, $iCase) > 0 Then Return $i
Else
If StringInStr($aArray[$i][$j], $vValue, $iCase) > 0 Then Return $i
EndIf
EndIf
Next
EndIf
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return SetError(6, 0, -1)
EndFunc
Func _ArrayShuffle(ByRef $aArray, $iStart_Row = 0, $iEnd_Row = 0, $iCol = -1)
If $iStart_Row = Default Then $iStart_Row = 0
If $iEnd_Row = Default Then $iEnd_Row = 0
If $iCol = Default Then $iCol = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iEnd_Row = 0 Then $iEnd_Row = $iDim_1 - 1
If $iStart_Row < 0 Or $iStart_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iEnd_Row < 1 Or $iEnd_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $vTmp, $iRand
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iRand]
$aArray[$iRand] = $vTmp
Next
Return 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iCol < -1 Or $iCol > $iDim_2 - 1 Then Return SetError(5, 0, -1)
Local $iCol_Start, $iCol_End
If $iCol = -1 Then
$iCol_Start = 0
$iCol_End = $iDim_2 - 1
Else
$iCol_Start = $iCol
$iCol_End = $iCol
EndIf
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
For $j = $iCol_Start To $iCol_End
$vTmp = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$iRand][$j]
$aArray[$iRand][$j] = $vTmp
Next
Next
Return 1
Case Else
Return SetError(2, 0, -1)
EndSwitch
EndFunc
Func _ArraySort(ByRef $aArray, $iDescending = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0, $iPivot = 0)
If $iDescending = Default Then $iDescending = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If $iPivot = Default Then $iPivot = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(5, 0, 0)
If $iEnd = Default Then $iEnd = 0
If $iEnd < 1 Or $iEnd > $iUBound Or $iEnd = Default Then $iEnd = $iUBound
If $iStart < 0 Or $iStart = Default Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
If $iDescending = Default Then $iDescending = 0
If $iPivot = Default Then $iPivot = 0
If $iSubItem = Default Then $iSubItem = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iPivot Then
__ArrayDualPivotSort($aArray, $iStart, $iEnd)
Else
__ArrayQuickSort1D($aArray, $iStart, $iEnd)
EndIf
If $iDescending Then _ArrayReverse($aArray, $iStart, $iEnd)
Case 2
If $iPivot Then Return SetError(6, 0, 0)
Local $iSubMax = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem > $iSubMax Then Return SetError(3, 0, 0)
If $iDescending Then
$iDescending = -1
Else
$iDescending = 1
EndIf
__ArrayQuickSort2D($aArray, $iDescending, $iStart, $iEnd, $iSubItem, $iSubMax)
Case Else
Return SetError(4, 0, 0)
EndSwitch
Return 1
EndFunc
Func __ArrayQuickSort1D(ByRef $aArray, Const ByRef $iStart, Const ByRef $iEnd)
If $iEnd <= $iStart Then Return
Local $vTmp
If($iEnd - $iStart) < 15 Then
Local $vCur
For $i = $iStart + 1 To $iEnd
$vTmp = $aArray[$i]
If IsNumber($vTmp) Then
For $j = $i - 1 To $iStart Step -1
$vCur = $aArray[$j]
If($vTmp >= $vCur And IsNumber($vCur)) Or(Not IsNumber($vCur) And StringCompare($vTmp, $vCur) >= 0) Then ExitLoop
$aArray[$j + 1] = $vCur
Next
Else
For $j = $i - 1 To $iStart Step -1
If(StringCompare($vTmp, $aArray[$j]) >= 0) Then ExitLoop
$aArray[$j + 1] = $aArray[$j]
Next
EndIf
$aArray[$j + 1] = $vTmp
Next
Return
EndIf
Local $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While($aArray[$L] < $vPivot And IsNumber($aArray[$L])) Or(Not IsNumber($aArray[$L]) And StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While($aArray[$R] > $vPivot And IsNumber($aArray[$R])) Or(Not IsNumber($aArray[$R]) And StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
Else
While(StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While(StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
$vTmp = $aArray[$L]
$aArray[$L] = $aArray[$R]
$aArray[$R] = $vTmp
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort1D($aArray, $iStart, $R)
__ArrayQuickSort1D($aArray, $L, $iEnd)
EndFunc
Func __ArrayQuickSort2D(ByRef $aArray, Const ByRef $iStep, Const ByRef $iStart, Const ByRef $iEnd, Const ByRef $iSubItem, Const ByRef $iSubMax)
If $iEnd <= $iStart Then Return
Local $vTmp, $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)][$iSubItem], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While($iStep *($aArray[$L][$iSubItem] - $vPivot) < 0 And IsNumber($aArray[$L][$iSubItem])) Or(Not IsNumber($aArray[$L][$iSubItem]) And $iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While($iStep *($aArray[$R][$iSubItem] - $vPivot) > 0 And IsNumber($aArray[$R][$iSubItem])) Or(Not IsNumber($aArray[$R][$iSubItem]) And $iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
Else
While($iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While($iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
For $i = 0 To $iSubMax
$vTmp = $aArray[$L][$i]
$aArray[$L][$i] = $aArray[$R][$i]
$aArray[$R][$i] = $vTmp
Next
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort2D($aArray, $iStep, $iStart, $R, $iSubItem, $iSubMax)
__ArrayQuickSort2D($aArray, $iStep, $L, $iEnd, $iSubItem, $iSubMax)
EndFunc
Func __ArrayDualPivotSort(ByRef $aArray, $iPivot_Left, $iPivot_Right, $bLeftMost = True)
If $iPivot_Left > $iPivot_Right Then Return
Local $iLength = $iPivot_Right - $iPivot_Left + 1
Local $i, $j, $k, $iAi, $iAk, $iA1, $iA2, $iLast
If $iLength < 45 Then
If $bLeftMost Then
$i = $iPivot_Left
While $i < $iPivot_Right
$j = $i
$iAi = $aArray[$i + 1]
While $iAi < $aArray[$j]
$aArray[$j + 1] = $aArray[$j]
$j -= 1
If $j + 1 = $iPivot_Left Then ExitLoop
WEnd
$aArray[$j + 1] = $iAi
$i += 1
WEnd
Else
While 1
If $iPivot_Left >= $iPivot_Right Then Return 1
$iPivot_Left += 1
If $aArray[$iPivot_Left] < $aArray[$iPivot_Left - 1] Then ExitLoop
WEnd
While 1
$k = $iPivot_Left
$iPivot_Left += 1
If $iPivot_Left > $iPivot_Right Then ExitLoop
$iA1 = $aArray[$k]
$iA2 = $aArray[$iPivot_Left]
If $iA1 < $iA2 Then
$iA2 = $iA1
$iA1 = $aArray[$iPivot_Left]
EndIf
$k -= 1
While $iA1 < $aArray[$k]
$aArray[$k + 2] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 2] = $iA1
While $iA2 < $aArray[$k]
$aArray[$k + 1] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 1] = $iA2
$iPivot_Left += 1
WEnd
$iLast = $aArray[$iPivot_Right]
$iPivot_Right -= 1
While $iLast < $aArray[$iPivot_Right]
$aArray[$iPivot_Right + 1] = $aArray[$iPivot_Right]
$iPivot_Right -= 1
WEnd
$aArray[$iPivot_Right + 1] = $iLast
EndIf
Return 1
EndIf
Local $iSeventh = BitShift($iLength, 3) + BitShift($iLength, 6) + 1
Local $iE1, $iE2, $iE3, $iE4, $iE5, $t
$iE3 = Ceiling(($iPivot_Left + $iPivot_Right) / 2)
$iE2 = $iE3 - $iSeventh
$iE1 = $iE2 - $iSeventh
$iE4 = $iE3 + $iSeventh
$iE5 = $iE4 + $iSeventh
If $aArray[$iE2] < $aArray[$iE1] Then
$t = $aArray[$iE2]
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
If $aArray[$iE3] < $aArray[$iE2] Then
$t = $aArray[$iE3]
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
If $aArray[$iE4] < $aArray[$iE3] Then
$t = $aArray[$iE4]
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
If $aArray[$iE5] < $aArray[$iE4] Then
$t = $aArray[$iE5]
$aArray[$iE5] = $aArray[$iE4]
$aArray[$iE4] = $t
If $t < $aArray[$iE3] Then
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
EndIf
Local $iLess = $iPivot_Left
Local $iGreater = $iPivot_Right
If(($aArray[$iE1] <> $aArray[$iE2]) And($aArray[$iE2] <> $aArray[$iE3]) And($aArray[$iE3] <> $aArray[$iE4]) And($aArray[$iE4] <> $aArray[$iE5])) Then
Local $iPivot_1 = $aArray[$iE2]
Local $iPivot_2 = $aArray[$iE4]
$aArray[$iE2] = $aArray[$iPivot_Left]
$aArray[$iE4] = $aArray[$iPivot_Right]
Do
$iLess += 1
Until $aArray[$iLess] >= $iPivot_1
Do
$iGreater -= 1
Until $aArray[$iGreater] <= $iPivot_2
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk > $iPivot_2 Then
While $aArray[$iGreater] > $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
$aArray[$iPivot_Left] = $aArray[$iLess - 1]
$aArray[$iLess - 1] = $iPivot_1
$aArray[$iPivot_Right] = $aArray[$iGreater + 1]
$aArray[$iGreater + 1] = $iPivot_2
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 2, True)
__ArrayDualPivotSort($aArray, $iGreater + 2, $iPivot_Right, False)
If($iLess < $iE1) And($iE5 < $iGreater) Then
While $aArray[$iLess] = $iPivot_1
$iLess += 1
WEnd
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
WEnd
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk = $iPivot_2 Then
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iPivot_1
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
EndIf
__ArrayDualPivotSort($aArray, $iLess, $iGreater, False)
Else
Local $iPivot = $aArray[$iE3]
$k = $iLess
While $k <= $iGreater
If $aArray[$k] = $iPivot Then
$k += 1
ContinueLoop
EndIf
$iAk = $aArray[$k]
If $iAk < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
Else
While $aArray[$iGreater] > $iPivot
$iGreater -= 1
WEnd
If $aArray[$iGreater] < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $iPivot
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 1, True)
__ArrayDualPivotSort($aArray, $iGreater + 1, $iPivot_Right, False)
EndIf
EndFunc
Func _ArrayToString(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
If $sDelim_Col = Default Then $sDelim_Col = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, "")
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $sRet = ""
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iStart_Row To $iEnd_Row
$sRet &= $aArray[$i] & $sDelim_Col
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iStart_Col = -1 Then $iStart_Col = 0
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
For $i = $iStart_Row To $iEnd_Row
For $j = $iStart_Col To $iEnd_Col
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, StringLen($sDelim_Col)) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func __Array_MinMaxIndex(Const ByRef $aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, $fuComparison)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iCompNumeric <> 1 Then $iCompNumeric = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iDim_1 < 0 Then Return SetError(1, 0, -1)
If $iEnd = -1 Then $iEnd = $iDim_1
If $iStart = -1 Then $iStart = 0
If $iStart < -1 Or $iEnd < -1 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
If $iDim_1 < 0 Then Return SetError(5, 0, -1)
Local $iMaxMinIndex = $iStart
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i]), Number($aArray[$iMaxMinIndex])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i], $aArray[$iMaxMinIndex]) Then $iMaxMinIndex = $i
Next
EndIf
Case 2
If $iSubItem < 0 Or $iSubItem > UBound($aArray, $UBOUND_COLUMNS) - 1 Then Return SetError(6, 0, -1)
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i][$iSubItem]), Number($aArray[$iMaxMinIndex][$iSubItem])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i][$iSubItem], $aArray[$iMaxMinIndex][$iSubItem]) Then $iMaxMinIndex = $i
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return $iMaxMinIndex
EndFunc
Func __Array_GreaterThan($vValue1, $vValue2)
Return $vValue1 > $vValue2
EndFunc
Func __Array_LessThan($vValue1, $vValue2)
Return $vValue1 < $vValue2
EndFunc
Global Const $DMW_SHORTNAME = 1
Global Const $DMW_LOCALE_LONGNAME = 2
Func _WinAPI_GetDateFormat($iLCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetDateFormatW', 'dword', $iLCID, 'dword', $iFlags, 'struct*', $tSYSTEMTIME, $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetLocaleInfo($iLCID, $iType)
Local $aRet = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'dword', $iLCID, 'dword', $iType, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _DateAdd($sType, $iNumber, $sDate)
Local $asTimePart[4]
Local $asDatePart[4]
Local $iJulianDate
$sType = StringLeft($sType, 1)
If StringInStr("D,M,Y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not StringIsInt($iNumber) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sDate) Then
Return SetError(3, 0, 0)
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If $sType = "d" Or $sType = "w" Then
If $sType = "w" Then $iNumber = $iNumber * 7
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iNumber
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
EndIf
If $sType = "m" Then
$asDatePart[2] = $asDatePart[2] + $iNumber
While $asDatePart[2] > 12
$asDatePart[2] = $asDatePart[2] - 12
$asDatePart[1] = $asDatePart[1] + 1
WEnd
While $asDatePart[2] < 1
$asDatePart[2] = $asDatePart[2] + 12
$asDatePart[1] = $asDatePart[1] - 1
WEnd
EndIf
If $sType = "y" Then
$asDatePart[1] = $asDatePart[1] + $iNumber
EndIf
If $sType = "h" Or $sType = "n" Or $sType = "s" Then
Local $iTimeVal = _TimeToTicks($asTimePart[1], $asTimePart[2], $asTimePart[3]) / 1000
If $sType = "h" Then $iTimeVal = $iTimeVal + $iNumber * 3600
If $sType = "n" Then $iTimeVal = $iTimeVal + $iNumber * 60
If $sType = "s" Then $iTimeVal = $iTimeVal + $iNumber
Local $iDay2Add = Int($iTimeVal /(24 * 60 * 60))
$iTimeVal = $iTimeVal - $iDay2Add * 24 * 60 * 60
If $iTimeVal < 0 Then
$iDay2Add = $iDay2Add - 1
$iTimeVal = $iTimeVal + 24 * 60 * 60
EndIf
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iDay2Add
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
_TicksToTime($iTimeVal * 1000, $asTimePart[1], $asTimePart[2], $asTimePart[3])
EndIf
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $iNumDays[$asDatePart[2]] < $asDatePart[3] Then $asDatePart[3] = $iNumDays[$asDatePart[2]]
$sDate = $asDatePart[1] & '/' & StringRight("0" & $asDatePart[2], 2) & '/' & StringRight("0" & $asDatePart[3], 2)
If $asTimePart[0] > 0 Then
If $asTimePart[0] > 2 Then
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2) & ':' & StringRight("0" & $asTimePart[3], 2)
Else
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2)
EndIf
EndIf
Return $sDate
EndFunc
Func _DateDayOfWeek($iDayNum, $iFormat = Default)
Local Const $MONDAY_IS_NO1 = 128
If $iFormat = Default Then $iFormat = 0
$iDayNum = Int($iDayNum)
If $iDayNum < 1 Or $iDayNum > 7 Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", BitAND($iFormat, $MONDAY_IS_NO1) ? 2007 : 2006)
DllStructSetData($tSYSTEMTIME, "Month", 1)
DllStructSetData($tSYSTEMTIME, "Day", $iDayNum)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "ddd" : "dddd")
EndFunc
Func _DateDiff($sType, $sStartDate, $sEndDate)
$sType = StringLeft($sType, 1)
If StringInStr("d,m,y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not _DateIsValid($sStartDate) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sEndDate) Then
Return SetError(3, 0, 0)
EndIf
Local $asStartDatePart[4], $asStartTimePart[4], $asEndDatePart[4], $asEndTimePart[4]
_DateTimeSplit($sStartDate, $asStartDatePart, $asStartTimePart)
_DateTimeSplit($sEndDate, $asEndDatePart, $asEndTimePart)
Local $aDaysDiff = _DateToDayValue($asEndDatePart[1], $asEndDatePart[2], $asEndDatePart[3]) - _DateToDayValue($asStartDatePart[1], $asStartDatePart[2], $asStartDatePart[3])
Local $iTimeDiff, $iYearDiff, $iStartTimeInSecs, $iEndTimeInSecs
If $asStartTimePart[0] > 1 And $asEndTimePart[0] > 1 Then
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $iTimeDiff < 0 Then
$aDaysDiff = $aDaysDiff - 1
$iTimeDiff = $iTimeDiff + 24 * 60 * 60
EndIf
Else
$iTimeDiff = 0
EndIf
Select
Case $sType = "d"
Return $aDaysDiff
Case $sType = "m"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
Local $iMonthDiff = $asEndDatePart[2] - $asStartDatePart[2] + $iYearDiff * 12
If $asEndDatePart[3] < $asStartDatePart[3] Then $iMonthDiff = $iMonthDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iMonthDiff = $iMonthDiff - 1
Return $iMonthDiff
Case $sType = "y"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
If $asEndDatePart[2] < $asStartDatePart[2] Then $iYearDiff = $iYearDiff - 1
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] < $asStartDatePart[3] Then $iYearDiff = $iYearDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iYearDiff = $iYearDiff - 1
Return $iYearDiff
Case $sType = "w"
Return Int($aDaysDiff / 7)
Case $sType = "h"
Return $aDaysDiff * 24 + Int($iTimeDiff / 3600)
Case $sType = "n"
Return $aDaysDiff * 24 * 60 + Int($iTimeDiff / 60)
Case $sType = "s"
Return $aDaysDiff * 24 * 60 * 60 + $iTimeDiff
EndSelect
EndFunc
Func _DateIsLeapYear($iYear)
If StringIsInt($iYear) Then
Select
Case Mod($iYear, 4) = 0 And Mod($iYear, 100) <> 0
Return 1
Case Mod($iYear, 400) = 0
Return 1
Case Else
Return 0
EndSelect
EndIf
Return SetError(1, 0, 0)
EndFunc
Func __DateIsMonth($iNumber)
$iNumber = Int($iNumber)
Return $iNumber >= 1 And $iNumber <= 12
EndFunc
Func _DateIsValid($sDate)
Local $asDatePart[4], $asTimePart[4]
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If Not StringIsInt($asDatePart[1]) Then Return 0
If Not StringIsInt($asDatePart[2]) Then Return 0
If Not StringIsInt($asDatePart[3]) Then Return 0
$asDatePart[1] = Int($asDatePart[1])
$asDatePart[2] = Int($asDatePart[2])
$asDatePart[3] = Int($asDatePart[3])
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $asDatePart[1] < 1000 Or $asDatePart[1] > 2999 Then Return 0
If $asDatePart[2] < 1 Or $asDatePart[2] > 12 Then Return 0
If $asDatePart[3] < 1 Or $asDatePart[3] > $iNumDays[$asDatePart[2]] Then Return 0
If $asTimePart[0] < 1 Then Return 1
If $asTimePart[0] < 2 Then Return 0
If $asTimePart[0] = 2 Then $asTimePart[3] = "00"
If Not StringIsInt($asTimePart[1]) Then Return 0
If Not StringIsInt($asTimePart[2]) Then Return 0
If Not StringIsInt($asTimePart[3]) Then Return 0
$asTimePart[1] = Int($asTimePart[1])
$asTimePart[2] = Int($asTimePart[2])
$asTimePart[3] = Int($asTimePart[3])
If $asTimePart[1] < 0 Or $asTimePart[1] > 23 Then Return 0
If $asTimePart[2] < 0 Or $asTimePart[2] > 59 Then Return 0
If $asTimePart[3] < 0 Or $asTimePart[3] > 59 Then Return 0
Return 1
EndFunc
Func _DateTimeFormat($sDate, $sType)
Local $asDatePart[4], $asTimePart[4]
Local $sTempDate = "", $sTempTime = ""
Local $sAM, $sPM, $sTempString = ""
If Not _DateIsValid($sDate) Then
Return SetError(1, 0, "")
EndIf
If $sType < 0 Or $sType > 5 Or Not IsInt($sType) Then
Return SetError(2, 0, "")
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
Switch $sType
Case 0
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 1
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SLONGDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "dddd, MMMM dd, yyyy"
EndIf
Case 2
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
Case 3
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 4
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm"
EndIf
Case 5
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm:ss"
EndIf
EndSwitch
If $sTempDate <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = StringReplace($sTempDate, "/", $sTempString)
EndIf
Local $iWday = _DateToDayOfWeek($asDatePart[1], $asDatePart[2], $asDatePart[3])
$asDatePart[3] = StringRight("0" & $asDatePart[3], 2)
$asDatePart[2] = StringRight("0" & $asDatePart[2], 2)
$sTempDate = StringReplace($sTempDate, "d", "@")
$sTempDate = StringReplace($sTempDate, "m", "#")
$sTempDate = StringReplace($sTempDate, "y", "&")
$sTempDate = StringReplace($sTempDate, "@@@@", _DateDayOfWeek($iWday, 0))
$sTempDate = StringReplace($sTempDate, "@@@", _DateDayOfWeek($iWday, 1))
$sTempDate = StringReplace($sTempDate, "@@", $asDatePart[3])
$sTempDate = StringReplace($sTempDate, "@", StringReplace(StringLeft($asDatePart[3], 1), "0", "") & StringRight($asDatePart[3], 1))
$sTempDate = StringReplace($sTempDate, "####", _DateToMonth($asDatePart[2], 0))
$sTempDate = StringReplace($sTempDate, "###", _DateToMonth($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "##", $asDatePart[2])
$sTempDate = StringReplace($sTempDate, "#", StringReplace(StringLeft($asDatePart[2], 1), "0", "") & StringRight($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "&&&&", $asDatePart[1])
$sTempDate = StringReplace($sTempDate, "&&", StringRight($asDatePart[1], 2))
EndIf
If $sTempTime <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S1159)
If Not @error And Not($sTempString = '') Then
$sAM = $sTempString
Else
$sAM = "AM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S2359)
If Not @error And Not($sTempString = '') Then
$sPM = $sTempString
Else
$sPM = "PM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIME)
If Not @error And Not($sTempString = '') Then
$sTempTime = StringReplace($sTempTime, ":", $sTempString)
EndIf
If StringInStr($sTempTime, "tt") Then
If $asTimePart[1] < 12 Then
$sTempTime = StringReplace($sTempTime, "tt", $sAM)
If $asTimePart[1] = 0 Then $asTimePart[1] = 12
Else
$sTempTime = StringReplace($sTempTime, "tt", $sPM)
If $asTimePart[1] > 12 Then $asTimePart[1] = $asTimePart[1] - 12
EndIf
EndIf
$asTimePart[1] = StringRight("0" & $asTimePart[1], 2)
$asTimePart[2] = StringRight("0" & $asTimePart[2], 2)
$asTimePart[3] = StringRight("0" & $asTimePart[3], 2)
$sTempTime = StringReplace($sTempTime, "hh", StringFormat("%02d", $asTimePart[1]))
$sTempTime = StringReplace($sTempTime, "h", StringReplace(StringLeft($asTimePart[1], 1), "0", "") & StringRight($asTimePart[1], 1))
$sTempTime = StringReplace($sTempTime, "mm", StringFormat("%02d", $asTimePart[2]))
$sTempTime = StringReplace($sTempTime, "ss", StringFormat("%02d", $asTimePart[3]))
$sTempDate = StringStripWS($sTempDate & " " & $sTempTime, $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndIf
Return $sTempDate
EndFunc
Func _DateTimeSplit($sDate, ByRef $aDatePart, ByRef $iTimePart)
Local $sDateTime = StringSplit($sDate, " T")
If $sDateTime[0] > 0 Then $aDatePart = StringSplit($sDateTime[1], "/-.")
If $sDateTime[0] > 1 Then
$iTimePart = StringSplit($sDateTime[2], ":")
If UBound($iTimePart) < 4 Then ReDim $iTimePart[4]
Else
Dim $iTimePart[4]
EndIf
If UBound($aDatePart) < 4 Then ReDim $aDatePart[4]
For $x = 1 To 3
If StringIsInt($aDatePart[$x]) Then
$aDatePart[$x] = Int($aDatePart[$x])
Else
$aDatePart[$x] = -1
EndIf
If StringIsInt($iTimePart[$x]) Then
$iTimePart[$x] = Int($iTimePart[$x])
Else
$iTimePart[$x] = 0
EndIf
Next
Return 1
EndFunc
Func _DateToDayOfWeek($iYear, $iMonth, $iDay)
If Not _DateIsValid($iYear & "/" & $iMonth & "/" & $iDay) Then
Return SetError(1, 0, "")
EndIf
Local $i_FactorA = Int((14 - $iMonth) / 12)
Local $i_FactorY = $iYear - $i_FactorA
Local $i_FactorM = $iMonth +(12 * $i_FactorA) - 2
Local $i_FactorD = Mod($iDay + $i_FactorY + Int($i_FactorY / 4) - Int($i_FactorY / 100) + Int($i_FactorY / 400) + Int((31 * $i_FactorM) / 12), 7)
Return $i_FactorD + 1
EndFunc
Func _DateToDayValue($iYear, $iMonth, $iDay)
If Not _DateIsValid(StringFormat("%04d/%02d/%02d", $iYear, $iMonth, $iDay)) Then
Return SetError(1, 0, "")
EndIf
If $iMonth < 3 Then
$iMonth = $iMonth + 12
$iYear = $iYear - 1
EndIf
Local $i_FactorA = Int($iYear / 100)
Local $i_FactorB = Int($i_FactorA / 4)
Local $i_FactorC = 2 - $i_FactorA + $i_FactorB
Local $i_FactorE = Int(1461 *($iYear + 4716) / 4)
Local $i_FactorF = Int(153 *($iMonth + 1) / 5)
Local $iJulianDate = $i_FactorC + $iDay + $i_FactorE + $i_FactorF - 1524.5
Return $iJulianDate
EndFunc
Func _DateToMonth($iMonNum, $iFormat = Default)
If $iFormat = Default Then $iFormat = 0
$iMonNum = Int($iMonNum)
If Not __DateIsMonth($iMonNum) Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", @YEAR)
DllStructSetData($tSYSTEMTIME, "Month", $iMonNum)
DllStructSetData($tSYSTEMTIME, "Day", 1)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "MMM" : "MMMM")
EndFunc
Func _DayValueToDate($iJulianDate, ByRef $iYear, ByRef $iMonth, ByRef $iDay)
If $iJulianDate < 0 Or Not IsNumber($iJulianDate) Then
Return SetError(1, 0, 0)
EndIf
Local $i_FactorZ = Int($iJulianDate + 0.5)
Local $i_FactorW = Int(($i_FactorZ - 1867216.25) / 36524.25)
Local $i_FactorX = Int($i_FactorW / 4)
Local $i_FactorA = $i_FactorZ + 1 + $i_FactorW - $i_FactorX
Local $i_FactorB = $i_FactorA + 1524
Local $i_FactorC = Int(($i_FactorB - 122.1) / 365.25)
Local $i_FactorD = Int(365.25 * $i_FactorC)
Local $i_FactorE = Int(($i_FactorB - $i_FactorD) / 30.6001)
Local $i_FactorF = Int(30.6001 * $i_FactorE)
$iDay = $i_FactorB - $i_FactorD - $i_FactorF
If $i_FactorE - 1 < 13 Then
$iMonth = $i_FactorE - 1
Else
$iMonth = $i_FactorE - 13
EndIf
If $iMonth < 3 Then
$iYear = $i_FactorC - 4715
Else
$iYear = $i_FactorC - 4716
EndIf
$iYear = StringFormat("%04d", $iYear)
$iMonth = StringFormat("%02d", $iMonth)
$iDay = StringFormat("%02d", $iDay)
Return $iYear & "/" & $iMonth & "/" & $iDay
EndFunc
Func _Now()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, 0)
EndFunc
Func _NowCalc()
Return @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC
EndFunc
Func _NowCalcDate()
Return @YEAR & "/" & @MON & "/" & @MDAY
EndFunc
Func _NowDate()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY, 0)
EndFunc
Func _NowTime($sType = 3)
If $sType < 3 Or $sType > 5 Then $sType = 3
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, $sType)
EndFunc
Func _TicksToTime($iTicks, ByRef $iHours, ByRef $iMins, ByRef $iSecs)
If Number($iTicks) > 0 Then
$iTicks = Int($iTicks / 1000)
$iHours = Int($iTicks / 3600)
$iTicks = Mod($iTicks, 3600)
$iMins = Int($iTicks / 60)
$iSecs = Mod($iTicks, 60)
Return 1
ElseIf Number($iTicks) = 0 Then
$iHours = 0
$iTicks = 0
$iMins = 0
$iSecs = 0
Return 1
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _TimeToTicks($iHours = @HOUR, $iMins = @MIN, $iSecs = @SEC)
If StringIsInt($iHours) And StringIsInt($iMins) And StringIsInt($iSecs) Then
Local $iTicks = 1000 *((3600 * $iHours) +(60 * $iMins) + $iSecs)
Return $iTicks
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _DaysInMonth($iYear)
Local $aDays = [12, 31,(_DateIsLeapYear($iYear) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
Return $aDays
EndFunc
Func _Date_Time_EncodeFileTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour, $iMinute, $iSecond, $iMSeconds)
Return _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
EndFunc
Func _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Month", $iMonth)
DllStructSetData($tSYSTEMTIME, "Day", $iDay)
DllStructSetData($tSYSTEMTIME, "Year", $iYear)
DllStructSetData($tSYSTEMTIME, "Hour", $iHour)
DllStructSetData($tSYSTEMTIME, "Minute", $iMinute)
DllStructSetData($tSYSTEMTIME, "Second", $iSecond)
DllStructSetData($tSYSTEMTIME, "MSeconds", $iMSeconds)
Return $tSYSTEMTIME
EndFunc
Func _Date_Time_GetLocalTime()
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tSystTime
EndFunc
Func _Date_Time_GetTickCount()
Local $aResult = DllCall("kernel32.dll", "dword", "GetTickCount")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _Date_Time_LocalFileTimeToFileTime($tLocalTime)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "LocalFileTimeToFileTime", "struct*", $tLocalTime, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_SystemTimeToArray(ByRef $tSYSTEMTIME)
Local $aInfo[8]
$aInfo[0] = DllStructGetData($tSYSTEMTIME, "Month")
$aInfo[1] = DllStructGetData($tSYSTEMTIME, "Day")
$aInfo[2] = DllStructGetData($tSYSTEMTIME, "Year")
$aInfo[3] = DllStructGetData($tSYSTEMTIME, "Hour")
$aInfo[4] = DllStructGetData($tSYSTEMTIME, "Minute")
$aInfo[5] = DllStructGetData($tSYSTEMTIME, "Second")
$aInfo[6] = DllStructGetData($tSYSTEMTIME, "MSeconds")
$aInfo[7] = DllStructGetData($tSYSTEMTIME, "DOW")
Return $aInfo
EndFunc
Func _Date_Time_SystemTimeToDateTimeStr(ByRef $tSYSTEMTIME, $iFmt = 0)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $aInfo[2], $aInfo[0], $aInfo[1], $aInfo[3], $aInfo[4], $aInfo[5])
Else
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aInfo[0], $aInfo[1], $aInfo[2], $aInfo[3], $aInfo[4], $aInfo[5])
EndIf
EndFunc
Func _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SystemTimeToFileTime", "struct*", $tSYSTEMTIME, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Global Const $FW_MEDIUM = 500
Global Const $FW_BOLD = 700
Global Const $CLEARTYPE_QUALITY = 5
Func _IsPressed($sHexKey, $vDLL = 'user32.dll')
Local $a_R = DllCall($vDLL, "short", "GetAsyncKeyState", "int", '0x' & $sHexKey)
If @error Then Return SetError(@error, @extended, False)
Return BitAND($a_R[0], 0x8000) <> 0
EndFunc
Func _VersionCompare($sVersion1, $sVersion2)
If $sVersion1 = $sVersion2 Then Return 0
Local $sSubVersion1 = "", $sSubVersion2 = ""
If StringIsAlpha(StringRight($sVersion1, 1)) Then
$sSubVersion1 = StringRight($sVersion1, 1)
$sVersion1 = StringTrimRight($sVersion1, 1)
EndIf
If StringIsAlpha(StringRight($sVersion2, 1)) Then
$sSubVersion2 = StringRight($sVersion2, 1)
$sVersion2 = StringTrimRight($sVersion2, 1)
EndIf
Local $aVersion1 = StringSplit($sVersion1, ".,"), $aVersion2 = StringSplit($sVersion2, ".,")
Local $iPartDifference =($aVersion1[0] - $aVersion2[0])
If $iPartDifference < 0 Then
ReDim $aVersion1[UBound($aVersion2)]
$aVersion1[0] = UBound($aVersion1) - 1
For $i =(UBound($aVersion1) - Abs($iPartDifference)) To $aVersion1[0]
$aVersion1[$i] = "0"
Next
ElseIf $iPartDifference > 0 Then
ReDim $aVersion2[UBound($aVersion1)]
$aVersion2[0] = UBound($aVersion2) - 1
For $i =(UBound($aVersion2) - Abs($iPartDifference)) To $aVersion2[0]
$aVersion2[$i] = "0"
Next
EndIf
For $i = 1 To $aVersion1[0]
If StringIsDigit($aVersion1[$i]) And StringIsDigit($aVersion2[$i]) Then
If Number($aVersion1[$i]) > Number($aVersion2[$i]) Then
Return SetExtended(2, 1)
ElseIf Number($aVersion1[$i]) < Number($aVersion2[$i]) Then
Return SetExtended(2, -1)
ElseIf $i = $aVersion1[0] Then
If $sSubVersion1 > $sSubVersion2 Then
Return SetExtended(3, 1)
ElseIf $sSubVersion1 < $sSubVersion2 Then
Return SetExtended(3, -1)
EndIf
EndIf
Else
If $aVersion1[$i] > $aVersion2[$i] Then
Return SetExtended(1, 1)
ElseIf $aVersion1[$i] < $aVersion2[$i] Then
Return SetExtended(1, -1)
EndIf
EndIf
Next
Return SetExtended(Abs($iPartDifference), 0)
EndFunc
Func _FileCreate($sFilePath)
Local $hFileOpen = FileOpen($sFilePath, BitOR($FO_OVERWRITE, $FO_CREATEPATH))
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iFileWrite = FileWrite($hFileOpen, "")
FileClose($hFileOpen)
If Not $iFileWrite Then Return SetError(2, 0, 0)
Return 1
EndFunc
Func _FileListToArray($sFilePath, $sFilter = "*", $iFlag = $FLTA_FILESFOLDERS, $bReturnPath = False)
Local $sDelimiter = "|", $sFileList = "", $sFileName = "", $sFullPath = ""
$sFilePath = StringRegExpReplace($sFilePath, "[\\/]+$", "") & "\"
If $iFlag = Default Then $iFlag = $FLTA_FILESFOLDERS
If $bReturnPath Then $sFullPath = $sFilePath
If $sFilter = Default Then $sFilter = "*"
If Not FileExists($sFilePath) Then Return SetError(1, 0, 0)
If StringRegExp($sFilter, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(2, 0, 0)
If Not($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 0, 0)
Local $hSearch = FileFindFirstFile($sFilePath & $sFilter)
If @error Then Return SetError(4, 0, 0)
While 1
$sFileName = FileFindNextFile($hSearch)
If @error Then ExitLoop
If($iFlag + @extended = 2) Then ContinueLoop
$sFileList &= $sDelimiter & $sFullPath & $sFileName
WEnd
FileClose($hSearch)
If $sFileList = "" Then Return SetError(4, 0, 0)
Return StringSplit(StringTrimLeft($sFileList, 1), $sDelimiter)
EndFunc
Func _FileListToArrayRec($sFilePath, $sMask = "*", $iReturn = $FLTAR_FILESFOLDERS, $iRecur = $FLTAR_NORECUR, $iSort = $FLTAR_NOSORT, $iReturnPath = $FLTAR_RELPATH)
If Not FileExists($sFilePath) Then Return SetError(1, 1, "")
If $sMask = Default Then $sMask = "*"
If $iReturn = Default Then $iReturn = $FLTAR_FILESFOLDERS
If $iRecur = Default Then $iRecur = $FLTAR_NORECUR
If $iSort = Default Then $iSort = $FLTAR_NOSORT
If $iReturnPath = Default Then $iReturnPath = $FLTAR_RELPATH
If $iRecur > 1 Or Not IsInt($iRecur) Then Return SetError(1, 6, "")
Local $bLongPath = False
If StringLeft($sFilePath, 4) == "\\?\" Then
$bLongPath = True
EndIf
Local $sFolderSlash = ""
If StringRight($sFilePath, 1) = "\" Then
$sFolderSlash = "\"
Else
$sFilePath = $sFilePath & "\"
EndIf
Local $asFolderSearchList[100] = [1]
$asFolderSearchList[1] = $sFilePath
Local $iHide_HS = 0, $sHide_HS = ""
If BitAND($iReturn, 4) Then
$iHide_HS += 2
$sHide_HS &= "H"
$iReturn -= 4
EndIf
If BitAND($iReturn, 8) Then
$iHide_HS += 4
$sHide_HS &= "S"
$iReturn -= 8
EndIf
Local $iHide_Link = 0
If BitAND($iReturn, 16) Then
$iHide_Link = 0x400
$iReturn -= 16
EndIf
Local $iMaxLevel = 0
If $iRecur < 0 Then
StringReplace($sFilePath, "\", "", 0, $STR_NOCASESENSEBASIC)
$iMaxLevel = @extended - $iRecur
EndIf
Local $sExclude_List = "", $sExclude_List_Folder = "", $sInclude_List = "*"
Local $aMaskSplit = StringSplit($sMask, "|")
Switch $aMaskSplit[0]
Case 3
$sExclude_List_Folder = $aMaskSplit[3]
ContinueCase
Case 2
$sExclude_List = $aMaskSplit[2]
ContinueCase
Case 1
$sInclude_List = $aMaskSplit[1]
EndSwitch
Local $sInclude_File_Mask = ".+"
If $sInclude_List <> "*" Then
If Not __FLTAR_ListToMask($sInclude_File_Mask, $sInclude_List) Then Return SetError(1, 2, "")
EndIf
Local $sInclude_Folder_Mask = ".+"
Switch $iReturn
Case 0
Switch $iRecur
Case 0
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Case 2
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Local $sExclude_File_Mask = ":"
If $sExclude_List <> "" Then
If Not __FLTAR_ListToMask($sExclude_File_Mask, $sExclude_List) Then Return SetError(1, 3, "")
EndIf
Local $sExclude_Folder_Mask = ":"
If $iRecur Then
If $sExclude_List_Folder Then
If Not __FLTAR_ListToMask($sExclude_Folder_Mask, $sExclude_List_Folder) Then Return SetError(1, 4, "")
EndIf
If $iReturn = 2 Then
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
Else
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
If Not($iReturn = 0 Or $iReturn = 1 Or $iReturn = 2) Then Return SetError(1, 5, "")
If Not($iSort = 0 Or $iSort = 1 Or $iSort = 2) Then Return SetError(1, 7, "")
If Not($iReturnPath = 0 Or $iReturnPath = 1 Or $iReturnPath = 2) Then Return SetError(1, 8, "")
If $iHide_Link Then
Local $tFile_Data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
Local $hDLL = DllOpen('kernel32.dll'), $aDLL_Ret
EndIf
Local $asReturnList[100] = [0]
Local $asFileMatchList = $asReturnList, $asRootFileMatchList = $asReturnList, $asFolderMatchList = $asReturnList
Local $bFolder = False, $hSearch = 0, $sCurrentPath = "", $sName = "", $sRetPath = ""
Local $iAttribs = 0, $sAttribs = ''
Local $asFolderFileSectionList[100][2] = [[0, 0]]
While $asFolderSearchList[0] > 0
$sCurrentPath = $asFolderSearchList[$asFolderSearchList[0]]
$asFolderSearchList[0] -= 1
Switch $iReturnPath
Case 1
$sRetPath = StringReplace($sCurrentPath, $sFilePath, "")
Case 2
If $bLongPath Then
$sRetPath = StringTrimLeft($sCurrentPath, 4)
Else
$sRetPath = $sCurrentPath
EndIf
EndSwitch
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'handle', 'FindFirstFileW', 'wstr', $sCurrentPath & "*", 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ContinueLoop
EndIf
$hSearch = $aDLL_Ret[0]
Else
$hSearch = FileFindFirstFile($sCurrentPath & "*")
If $hSearch = -1 Then
ContinueLoop
EndIf
EndIf
If $iReturn = 0 And $iSort And $iReturnPath Then
__FLTAR_AddToList($asFolderFileSectionList, $sRetPath, $asFileMatchList[0] + 1)
EndIf
$sAttribs = ''
While 1
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'int', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ExitLoop
EndIf
$sName = DllStructGetData($tFile_Data, "FileName")
If $sName = ".." Then
ContinueLoop
EndIf
$iAttribs = DllStructGetData($tFile_Data, "FileAttributes")
If $iHide_HS And BitAND($iAttribs, $iHide_HS) Then
ContinueLoop
EndIf
If BitAND($iAttribs, $iHide_Link) Then
ContinueLoop
EndIf
$bFolder = False
If BitAND($iAttribs, 16) Then
$bFolder = True
EndIf
Else
$bFolder = False
$sName = FileFindNextFile($hSearch, 1)
If @error Then
ExitLoop
EndIf
$sAttribs = @extended
If StringInStr($sAttribs, "D") Then
$bFolder = True
EndIf
If StringRegExp($sAttribs, "[" & $sHide_HS & "]") Then
ContinueLoop
EndIf
EndIf
If $bFolder Then
Select
Case $iRecur < 0
StringReplace($sCurrentPath, "\", "", 0, $STR_NOCASESENSEBASIC)
If @extended < $iMaxLevel Then
ContinueCase
EndIf
Case $iRecur = 1
If Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderSearchList, $sCurrentPath & $sName & "\")
EndIf
EndSelect
EndIf
If $iSort Then
If $bFolder Then
If StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderMatchList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
If $sCurrentPath = $sFilePath Then
__FLTAR_AddToList($asRootFileMatchList, $sRetPath & $sName)
Else
__FLTAR_AddToList($asFileMatchList, $sRetPath & $sName)
EndIf
EndIf
EndIf
Else
If $bFolder Then
If $iReturn <> 1 And StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If $iReturn <> 2 And StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName)
EndIf
EndIf
EndIf
WEnd
If $iHide_Link Then
DllCall($hDLL, 'int', 'FindClose', 'ptr', $hSearch)
Else
FileClose($hSearch)
EndIf
WEnd
If $iHide_Link Then
DllClose($hDLL)
EndIf
If $iSort Then
Switch $iReturn
Case 2
If $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
$asReturnList = $asFolderMatchList
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Case 1
If $asRootFileMatchList[0] = 0 And $asFileMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList, 1)
EndIf
Case 0
If $asRootFileMatchList[0] = 0 And $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
$asReturnList[0] += $asFolderMatchList[0]
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
_ArrayConcatenate($asReturnList, $asFolderMatchList, 1)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
Local $asReturnList[$asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0] + 1]
$asReturnList[0] = $asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0]
__ArrayDualPivotSort($asRootFileMatchList, 1, $asRootFileMatchList[0])
For $i = 1 To $asRootFileMatchList[0]
$asReturnList[$i] = $asRootFileMatchList[$i]
Next
Local $iNextInsertionIndex = $asRootFileMatchList[0] + 1
__ArrayDualPivotSort($asFolderMatchList, 1, $asFolderMatchList[0])
Local $sFolderToFind = ""
For $i = 1 To $asFolderMatchList[0]
$asReturnList[$iNextInsertionIndex] = $asFolderMatchList[$i]
$iNextInsertionIndex += 1
If $sFolderSlash Then
$sFolderToFind = $asFolderMatchList[$i]
Else
$sFolderToFind = $asFolderMatchList[$i] & "\"
EndIf
Local $iFileSectionEndIndex = 0, $iFileSectionStartIndex = 0
For $j = 1 To $asFolderFileSectionList[0][0]
If $sFolderToFind = $asFolderFileSectionList[$j][0] Then
$iFileSectionStartIndex = $asFolderFileSectionList[$j][1]
If $j = $asFolderFileSectionList[0][0] Then
$iFileSectionEndIndex = $asFileMatchList[0]
Else
$iFileSectionEndIndex = $asFolderFileSectionList[$j + 1][1] - 1
EndIf
If $iSort = 1 Then
__ArrayDualPivotSort($asFileMatchList, $iFileSectionStartIndex, $iFileSectionEndIndex)
EndIf
For $k = $iFileSectionStartIndex To $iFileSectionEndIndex
$asReturnList[$iNextInsertionIndex] = $asFileMatchList[$k]
$iNextInsertionIndex += 1
Next
ExitLoop
EndIf
Next
Next
EndIf
EndSwitch
Else
If $asReturnList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asReturnList[$asReturnList[0] + 1]
EndIf
Return $asReturnList
EndFunc
Func __FLTAR_AddFileLists(ByRef $asTarget, $asSource_1, $asSource_2, $iSort = 0)
ReDim $asSource_1[$asSource_1[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_1, 1, $asSource_1[0])
$asTarget = $asSource_1
$asTarget[0] += $asSource_2[0]
ReDim $asSource_2[$asSource_2[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_2, 1, $asSource_2[0])
_ArrayConcatenate($asTarget, $asSource_2, 1)
EndFunc
Func __FLTAR_AddToList(ByRef $aList, $vValue_0, $vValue_1 = -1)
If $vValue_1 = -1 Then
$aList[0] += 1
If UBound($aList) <= $aList[0] Then ReDim $aList[UBound($aList) * 2]
$aList[$aList[0]] = $vValue_0
Else
$aList[0][0] += 1
If UBound($aList) <= $aList[0][0] Then ReDim $aList[UBound($aList) * 2][2]
$aList[$aList[0][0]][0] = $vValue_0
$aList[$aList[0][0]][1] = $vValue_1
EndIf
EndFunc
Func __FLTAR_ListToMask(ByRef $sMask, $sList)
If StringRegExp($sList, "\\|/|:|\<|\>|\|") Then Return 0
$sList = StringReplace(StringStripWS(StringRegExpReplace($sList, "\s*;\s*", ";"), $STR_STRIPLEADING + $STR_STRIPTRAILING), ";", "|")
$sList = StringReplace(StringReplace(StringRegExpReplace($sList, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
$sMask = "(?i)^(" & $sList & ")\z"
Return 1
EndFunc
Func _FileWriteLog($sLogPath, $sLogMsg, $iFlag = -1)
Local $iOpenMode = $FO_APPEND
Local $sDateNow = @YEAR & "-" & @MON & "-" & @MDAY
Local $sTimeNow = @HOUR & ":" & @MIN & ":" & @SEC
Local $sMsg = $sDateNow & " " & $sTimeNow & " : " & $sLogMsg
If $iFlag = Default Then $iFlag = -1
If $iFlag <> -1 Then
$iOpenMode = $FO_OVERWRITE
$sMsg &= @CRLF & FileRead($sLogPath)
EndIf
Local $hFileOpen = $sLogPath
If IsString($sLogPath) Then
$hFileOpen = FileOpen($sLogPath, $iOpenMode)
EndIf
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iReturn = FileWriteLine($hFileOpen, $sMsg)
If IsString($sLogPath) Then $iReturn = FileClose($hFileOpen)
If $iReturn <= 0 Then Return SetError(2, $iReturn, 0)
Return $iReturn
EndFunc
Global Const $TRAY_CHECKED = 1
Global Const $TRAY_UNCHECKED = 4
Global Const $TRAY_ENABLE = 64
Global Const $TRAY_DISABLE = 128
Global Const $TIP_ICONASTERISK = 1
Global Const $TIP_ICONEXCLAMATION = 2
Global Const $TIP_NOSOUND = 16
Global Const $MF_BYPOSITION = 0x00000400
Global Const $MIIM_DATAMASK = 0x0000003F
Global Const $SC_MINIMIZE = 0xF020
Global Const $SC_MAXIMIZE = 0xF030
Global Const $SC_CLOSE = 0xF060
Global Const $SC_RESTORE = 0xF120
Func _GUICtrlMenu_DrawMenuBar($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DrawMenuBar", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_FindParent($hMenu)
Local $hList = _WinAPI_EnumWindowsTop()
For $iI = 1 To $hList[0][0]
If _GUICtrlMenu_GetMenu($hList[$iI][0]) = $hMenu Then Return $hList[$iI][0]
Next
EndFunc
Func _GUICtrlMenu_GetItemCount($hMenu)
Local $aResult = DllCall("user32.dll", "int", "GetMenuItemCount", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetItemID($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "ID")
EndFunc
Func _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_DATAMASK)
Local $aResult = DllCall("user32.dll", "bool", "GetMenuItemInfo", "handle", $hMenu, "uint", $iItem, "bool", $bByPos, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tInfo)
EndFunc
Func _GUICtrlMenu_GetMenu($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetMenu", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetSystemMenu($hWnd, $bRevert = False)
Local $aResult = DllCall("user32.dll", "hwnd", "GetSystemMenu", "hwnd", $hWnd, "int", $bRevert)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_RemoveMenu($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aResult = DllCall("user32.dll", "bool", "RemoveMenu", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] = 0 Then Return SetError(10, 0, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _ClipBoard_RegisterFormat($sFormat)
Local $aResult = DllCall("user32.dll", "uint", "RegisterClipboardFormatW", "wstr", $sFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Global Const $__RICHEDITCONSTANT_WM_USER = 0x400
Global Const $EM_EXGETSEL = $__RICHEDITCONSTANT_WM_USER + 52
Global Const $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 94
Global Const $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 95
Global Const $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 63
Global Const $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 68
Global Const $EM_SETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 222
Global Const $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 97
Global Const $EM_STREAMIN = $__RICHEDITCONSTANT_WM_USER + 73
Global Const $ST_DEFAULT = 0
Global Const $ST_SELECTION = 2
Global Const $GT_USECRLF = 1
Global Const $GTL_CLOSE = 4
Global Const $GTL_DEFAULT = 0
Global Const $GTL_NUMBYTES = 16
Global Const $GTL_PRECISE = 2
Global Const $GTL_USECRLF = 1
Global Const $CP_ACP = 0
Global Const $CP_UNICODE = 1200
Global Const $CFE_SUBSCRIPT = 0x00010000
Global Const $CFE_SUPERSCRIPT = 0x00020000
Global Const $CFM_CHARSET = 0x8000000
Global Const $CFM_COLOR = 0x40000000
Global Const $CFM_FACE = 0x20000000
Global Const $CFM_LCID = 0x2000000
Global Const $CFM_SIZE = 0x80000000
Global Const $CFE_AUTOCOLOR = $CFM_COLOR
Global Const $SCF_SELECTION = 0x1
Global Const $LF_FACESIZE = 32
Global Const $SF_TEXT = 0x1
Global Const $SF_RTF = 0x2
Global Const $SFF_SELECTION = 0x8000
Global $__g_sRTFClassName, $__g_sRTFVersion, $__g_iRTFTwipsPeSpaceUnit = 1440
Global $__g_sGRE_CF_RTF, $__g_sGRE_CF_RETEXTOBJ
Global $__g_pGRC_StreamFromFileCallback = DllCallbackRegister("__GCR_StreamFromFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamFromVarCallback = DllCallbackRegister("__GCR_StreamFromVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToFileCallback = DllCallbackRegister("__GCR_StreamToFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToVarCallback = DllCallbackRegister("__GCR_StreamToVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_sStreamVar
Global $__g_hRELastWnd
Global $__g_tObj_RichComObject = DllStructCreate("ptr pIntf; dword  Refcount")
Global $__g_tCall_RichCom, $__g_pObj_RichCom
Global $__g_hLib_RichCom_OLE32 = DllOpen("OLE32.DLL")
Global $__g_pRichCom_Object_QueryInterface = DllCallbackRegister("__RichCom_Object_QueryInterface", "long", "ptr;dword;dword")
Global $__g_pRichCom_Object_AddRef = DllCallbackRegister("__RichCom_Object_AddRef", "long", "ptr")
Global $__g_pRichCom_Object_Release = DllCallbackRegister("__RichCom_Object_Release", "long", "ptr")
Global $__g_pRichCom_Object_GetNewStorage = DllCallbackRegister("__RichCom_Object_GetNewStorage", "long", "ptr;ptr")
Global $__g_pRichCom_Object_GetInPlaceContext = DllCallbackRegister("__RichCom_Object_GetInPlaceContext", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_ShowContainerUI = DllCallbackRegister("__RichCom_Object_ShowContainerUI", "long", "ptr;long")
Global $__g_pRichCom_Object_QueryInsertObject = DllCallbackRegister("__RichCom_Object_QueryInsertObject", "long", "ptr;dword;ptr;long")
Global $__g_pRichCom_Object_DeleteObject = DllCallbackRegister("__RichCom_Object_DeleteObject", "long", "ptr;ptr")
Global $__g_pRichCom_Object_QueryAcceptData = DllCallbackRegister("__RichCom_Object_QueryAcceptData", "long", "ptr;ptr;dword;dword;dword;ptr")
Global $__g_pRichCom_Object_ContextSensitiveHelp = DllCallbackRegister("__RichCom_Object_ContextSensitiveHelp", "long", "ptr;long")
Global $__g_pRichCom_Object_GetClipboardData = DllCallbackRegister("__RichCom_Object_GetClipboardData", "long", "ptr;ptr;dword;ptr")
Global $__g_pRichCom_Object_GetDragDropEffect = DllCallbackRegister("__RichCom_Object_GetDragDropEffect", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_GetContextMenu = DllCallbackRegister("__RichCom_Object_GetContextMenu", "long", "ptr;short;ptr;ptr;ptr")
Global Const $__RICHEDITCONSTANT_WM_SETFONT = 0x0030
Global Const $_GCR_S_OK = 0
Global Const $_GCR_E_NOTIMPL = 0x80004001
Global Const $tagEDITSTREAM = "align 4;dword_ptr dwCookie;dword dwError;ptr pfnCallback"
Global Const $tagCHARFORMAT = "struct;uint cbSize;dword dwMask;dword dwEffects;long yHeight;long yOffset;INT crCharColor;" & "byte bCharSet;byte bPitchAndFamily;wchar szFaceName[32];endstruct"
Global Const $tagCHARFORMAT2 = $tagCHARFORMAT & ";word wWeight;short sSpacing;INT crBackColor;dword lcid;dword dwReserved;" & "short sStyle;word wKerning;byte bUnderlineType;byte bAnimation;byte bRevAuthor;byte bReserved1"
Global Const $tagCHARRANGE = "struct;long cpMin;long cpMax;endstruct"
Global Const $tagGETTEXTEX = "align 4;dword cb;dword flags;uint codepage;ptr lpDefaultChar;ptr lpbUsedDefChar"
Global Const $tagGETTEXTLENGTHEX = "dword flags;uint codepage"
Global Const $tagSETTEXTEX = "dword flags;uint codepage"
Func _GUICtrlRichEdit_AppendText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iLength = _GUICtrlRichEdit_GetTextLength($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iLength, $iLength)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_Create($hWnd, $sText, $iLeft, $iTop, $iWidth = 150, $iHeight = 150, $iStyle = -1, $iExStyle = -1)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If Not __GCR_IsNumeric($iWidth, ">0,-1") Then Return SetError(105, 0, 0)
If Not __GCR_IsNumeric($iHeight, ">0,-1") Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iStyle, ">=0,-1") Then Return SetError(107, 0, 0)
If Not __GCR_IsNumeric($iExStyle, ">=0,-1") Then Return SetError(108, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = BitOR($ES_WANTRETURN, $ES_MULTILINE)
If BitAND($iStyle, $ES_MULTILINE) <> 0 Then $iStyle = BitOR($iStyle, $ES_WANTRETURN)
If $iExStyle = -1 Then $iExStyle = 0x200
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If BitAND($iStyle, $ES_READONLY) = 0 Then $iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_TABSTOP)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
__GCR_Init()
Local $hRichEdit = _WinAPI_CreateWindowEx($iExStyle, $__g_sRTFClassName, "", $iStyle, $iLeft, $iTop, $iWidth, $iHeight, $hWnd, $nCtrlID)
If $hRichEdit = 0 Then Return SetError(700, 0, False)
__GCR_SetOLECallback($hRichEdit)
_SendMessage($hRichEdit, $__RICHEDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($DEFAULT_GUI_FONT), True)
_GUICtrlRichEdit_AppendText($hRichEdit, $sText)
Return $hRichEdit
EndFunc
Func _GUICtrlRichEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hRELastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlRichEdit_GetText($hWnd, $bCrToCrLf = False, $iCodePage = 0, $sReplChar = "")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bCrToCrLf) Then Return SetError(102, 0, "")
If Not __GCR_IsNumeric($iCodePage) Then Return SetError(103, 0, "")
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd, False, True) + 1
Local $sUni = ''
If $iCodePage = $CP_UNICODE Or Not $iCodePage Then $sUni = "w"
Local $tText = DllStructCreate($sUni & "char[" & $iLen & "]")
Local $tGetTextEx = DllStructCreate($tagGETTEXTEX)
DllStructSetData($tGetTextEx, "cb", DllStructGetSize($tText))
Local $iFlags = 0
If $bCrToCrLf Then $iFlags = $GT_USECRLF
DllStructSetData($tGetTextEx, "flags", $iFlags)
If $iCodePage = 0 Then $iCodePage = $CP_UNICODE
DllStructSetData($tGetTextEx, "codepage", $iCodePage)
Local $pUsedDefChar = 0, $pDefaultChar = 0
If $sReplChar <> "" Then
Local $tDefaultChar = DllStructCreate("char")
$pDefaultChar = DllStructGetPtr($tDefaultChar, 1)
DllStructSetData($tDefaultChar, 1, $sReplChar)
Local $tUsedDefChar = DllStructCreate("bool")
$pUsedDefChar = DllStructGetPtr($tUsedDefChar, 1)
EndIf
DllStructSetData($tGetTextEx, "lpDefaultChar", $pDefaultChar)
DllStructSetData($tGetTextEx, "lpbUsedDefChar", $pUsedDefChar)
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTEX, $tGetTextEx, $tText, 0, "struct*", "struct*")
If $iRet = 0 Then Return SetError(700, 0, "")
If $sReplChar <> "" Then SetExtended(DllStructGetData($tUsedDefChar, 1) <> 0)
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetTextLength($hWnd, $bExact = True, $bChars = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not IsBool($bExact) Then Return SetError(102, 0, 0)
If Not IsBool($bChars) Then Return SetError(103, 0, 0)
Local $tGetTextLen = DllStructCreate($tagGETTEXTLENGTHEX)
Local $iFlags = BitOR($GTL_USECRLF,($bExact ? $GTL_PRECISE : $GTL_CLOSE))
$iFlags = BitOR($iFlags,($bChars ? $GTL_DEFAULT : $GTL_NUMBYTES))
DllStructSetData($tGetTextLen, 1, $iFlags)
DllStructSetData($tGetTextLen, 2,($bChars ? $CP_ACP : $CP_UNICODE))
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTLENGTHEX, $tGetTextLen, 0, 0, "struct*")
Return $iRet
EndFunc
Func _GUICtrlRichEdit_IsTextSelected($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharRange = DllStructCreate($tagCHARRANGE)
_SendMessage($hWnd, $EM_EXGETSEL, 0, $tCharRange, 0, "wparam", "struct*")
Return DllStructGetData($tCharRange, 2) <> DllStructGetData($tCharRange, 1)
EndFunc
Func _GUICtrlRichEdit_SetCharColor($hWnd, $iColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOCOLOR)
$iColor = 0
Else
If BitAND($iColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_COLOR)
DllStructSetData($tCharFormat, 6, $iColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetFont($hWnd, $iPoints = Default, $sName = Default, $iCharset = Default, $iLcid = Default)
Local $iDwMask = 0
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not($iPoints = Default Or __GCR_IsNumeric($iPoints, ">0")) Then Return SetError(102, 0, False)
If $sName <> Default Then
Local $aS = StringSplit($sName, " ")
For $i = 1 To UBound($aS) - 1
If Not StringIsAlpha($aS[$i]) Then Return SetError(103, 0, False)
Next
EndIf
If Not($iCharset = Default Or __GCR_IsNumeric($iCharset)) Then Return SetError(104, 0, False)
If Not($iLcid = Default Or __GCR_IsNumeric($iLcid)) Then Return SetError(105, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iPoints <> Default Then
$iDwMask = $CFM_SIZE
DllStructSetData($tCharFormat, 4, Int($iPoints * 20))
EndIf
If $sName <> Default Then
If StringLen($sName) > $LF_FACESIZE - 1 Then SetError(-1, 0, False)
$iDwMask = BitOR($iDwMask, $CFM_FACE)
DllStructSetData($tCharFormat, 9, $sName)
EndIf
If $iCharset <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_CHARSET)
DllStructSetData($tCharFormat, 7, $iCharset)
EndIf
If $iLcid <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_LCID)
DllStructSetData($tCharFormat, 13, $iLcid)
EndIf
DllStructSetData($tCharFormat, 2, $iDwMask)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(@error + 200, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetReadOnly($hWnd, $bState = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_SETREADONLY, $bState)
If $iRet = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetScrollPos($hWnd, $iX, $iY)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iX, ">=0") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iY, ">=0") Then Return SetError(103, 0, False)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, 1, $iX)
DllStructSetData($tPoint, 2, $iY)
Return _SendMessage($hWnd, $EM_SETSCROLLPOS, 0, $tPoint, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetSel($hWnd, $iAnchor, $iActive, $bHideSel = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iAnchor, ">=0,-1") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iActive, ">=0,-1") Then Return SetError(103, 0, False)
If Not IsBool($bHideSel) Then Return SetError(104, 0, False)
_SendMessage($hWnd, $EM_SETSEL, $iAnchor, $iActive)
If $bHideSel Then _SendMessage($hWnd, $EM_HIDESELECTION, $bHideSel)
_WinAPI_SetFocus($hWnd)
Return True
EndFunc
Func _GUICtrlRichEdit_SetText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_DEFAULT)
DllStructSetData($tSetText, 2, $CP_ACP)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_StreamFromFile($hWnd, $sFileSpec)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamFromFileCallback))
Local $hFile = FileOpen($sFileSpec, $FO_READ)
If $hFile = -1 Then Return SetError(1021, 0, False)
Local $sBuf = FileRead($hFile, 5)
FileClose($hFile)
$hFile = FileOpen($sFileSpec, $FO_READ)
DllStructSetData($tEditStream, "dwCookie", $hFile)
Local $wParam =($sBuf == "{\rtf" Or $sBuf == "{urtf") ? $SF_RTF : $SF_TEXT
$wParam = BitOR($wParam, $SFF_SELECTION)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
_GUICtrlRichEdit_SetText($hWnd, "")
EndIf
Local $iQchs = _SendMessage($hWnd, $EM_STREAMIN, $wParam, $tEditStream, 0, "wparam", "struct*")
FileClose($hFile)
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 1 Then SetError(700, $iError, False)
If $iQchs = 0 Then
If FileGetSize($sFileSpec) = 0 Then Return SetError(1022, 0, False)
Return SetError(700, $iError, False)
EndIf
Return True
EndFunc
Func __GCR_Init()
Local $ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "MSFTEDIT.DLL")
If $ah_GUICtrlRTF_lib[0] <> 0 Then
$__g_sRTFClassName = "RichEdit50W"
$__g_sRTFVersion = 4.1
Else
$ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "RICHED20.DLL")
$__g_sRTFVersion = FileGetVersion(@SystemDir & "\riched20.dll", "ProductVersion")
Switch $__g_sRTFVersion
Case 3.0
$__g_sRTFClassName = "RichEdit20W"
Case 5.0
$__g_sRTFClassName = "RichEdit50W"
Case 6.0
$__g_sRTFClassName = "RichEdit60W"
EndSwitch
EndIf
$__g_sGRE_CF_RTF = _ClipBoard_RegisterFormat("Rich Text Format")
$__g_sGRE_CF_RETEXTOBJ = _ClipBoard_RegisterFormat("Rich Text Format with Objects")
EndFunc
Func __GCR_StreamFromFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sBuf = FileRead($hFile, $iBuflen - 1)
If @error Then Return 1
DllStructSetData($tBuf, 1, $sBuf)
DllStructSetData($tQbytes, 1, StringLen($sBuf))
Return 0
EndFunc
Func __GCR_StreamFromVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tCtl = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sCtl = StringLeft($__g_pGRC_sStreamVar, $iBuflen - 1)
If $sCtl = "" Then Return 1
DllStructSetData($tCtl, 1, $sCtl)
Local $iLen = StringLen($sCtl)
DllStructSetData($tQbytes, 1, $iLen)
$__g_pGRC_sStreamVar = StringMid($__g_pGRC_sStreamVar, $iLen + 1)
Return 0
EndFunc
Func __GCR_StreamToFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
FileWrite($hFile, $s)
DllStructSetData($tQbytes, 1, StringLen($s))
Return 0
EndFunc
Func __GCR_StreamToVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
$__g_pGRC_sStreamVar &= $s
Return 0
EndFunc
Func __GCR_IsNumeric($vN, $sRange = "")
If Not(IsNumber($vN) Or StringIsInt($vN) Or StringIsFloat($vN)) Then Return False
Switch $sRange
Case ">0"
If $vN <= 0 Then Return False
Case ">=0"
If $vN < 0 Then Return False
Case ">0,-1"
If Not($vN > 0 Or $vN = -1) Then Return False
Case ">=0,-1"
If Not($vN >= 0 Or $vN = -1) Then Return False
EndSwitch
Return True
EndFunc
Func __GCR_SetOLECallback($hWnd)
If Not IsHWnd($hWnd) Then Return SetError(101, 0, False)
If Not $__g_pObj_RichCom Then
$__g_tCall_RichCom = DllStructCreate("ptr[20]")
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInterface), 1)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_AddRef), 2)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_Release), 3)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetNewStorage), 4)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetInPlaceContext), 5)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ShowContainerUI), 6)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInsertObject), 7)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_DeleteObject), 8)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryAcceptData), 9)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ContextSensitiveHelp), 10)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetClipboardData), 11)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetDragDropEffect), 12)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetContextMenu), 13)
DllStructSetData($__g_tObj_RichComObject, 1, DllStructGetPtr($__g_tCall_RichCom))
DllStructSetData($__g_tObj_RichComObject, 2, 1)
$__g_pObj_RichCom = DllStructGetPtr($__g_tObj_RichComObject)
EndIf
Local Const $EM_SETOLECALLBACK = 0x400 + 70
If _SendMessage($hWnd, $EM_SETOLECALLBACK, 0, $__g_pObj_RichCom) = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func __RichCom_Object_QueryInterface($pObject, $iREFIID, $pPvObj)
#forceref $pObject, $iREFIID, $pPvObj
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_AddRef($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
DllStructSetData($tData, 2, DllStructGetData($tData, 2) + 1)
Return DllStructGetData($tData, 2)
EndFunc
Func __RichCom_Object_Release($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
If DllStructGetData($tData, 2) > 0 Then
DllStructSetData($tData, 2, DllStructGetData($tData, 2) - 1)
Return DllStructGetData($tData, 2)
EndIf
EndFunc
Func __RichCom_Object_GetInPlaceContext($pObject, $pPFrame, $pPDoc, $pFrameInfo)
#forceref $pObject, $pPFrame, $pPDoc, $pFrameInfo
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_ShowContainerUI($pObject, $bShow)
#forceref $pObject, $bShow
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryInsertObject($pObject, $pClsid, $tStg, $vCp)
#forceref $pObject, $pClsid, $tStg, $vCp
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_DeleteObject($pObject, $pOleobj)
#forceref $pObject, $pOleobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryAcceptData($pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict)
#forceref $pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_ContextSensitiveHelp($pObject, $bEnterMode)
#forceref $pObject, $bEnterMode
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetClipboardData($pObject, $pChrg, $vReco, $pPdataobj)
#forceref $pObject, $pChrg, $vReco, $pPdataobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetDragDropEffect($pObject, $bDrag, $iGrfKeyState, $piEffect)
#forceref $pObject, $bDrag, $iGrfKeyState, $piEffect
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetContextMenu($pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu)
#forceref $pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetNewStorage($pObject, $pPstg)
#forceref $pObject
Local $aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "CreateILockBytesOnHGlobal", "hwnd", 0, "int", 1, "ptr*", 0)
Local $pLockBytes = $aSc[3]
$aSc = $aSc[0]
If $aSc Then Return $aSc
$aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "StgCreateDocfileOnILockBytes", "ptr", $pLockBytes, "dword", BitOR(0x10, 2, 0x1000), "dword", 0, "ptr*", 0)
Local $tStg = DllStructCreate("ptr", $pPstg)
DllStructSetData($tStg, 1, $aSc[4])
$aSc = $aSc[0]
If $aSc Then
Local $tObj = DllStructCreate("ptr", $pLockBytes)
Local $tUnknownFuncTable = DllStructCreate("ptr[3]", DllStructGetData($tObj, 1))
Local $pReleaseFunc = DllStructGetData($tUnknownFuncTable, 3)
DllCallAddress("long", $pReleaseFunc, "ptr", $pLockBytes)
EndIf
Return $aSc
EndFunc
Global Const $INET_FORCERELOAD = 1
Global Const $INET_DOWNLOADCOMPLETE = 2
Global $__g_hTabLastWnd
Func _GUICtrlTab_ClickTab($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iX, $iY
If Not $bMove Then
Local $hWinParent = _WinAPI_GetParent($hWnd)
Local $avTabPos = _GUICtrlTab_GetItemRect($hWnd, $iIndex)
$iX = $avTabPos[0] +(($avTabPos[2] - $avTabPos[0]) / 2)
$iY = $avTabPos[1] +(($avTabPos[3] - $avTabPos[1]) / 2)
ControlClick($hWinParent, "", $hWnd, $sButton, $iClicks, $iX, $iY)
Else
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
Opt("MouseCoordMode", $iMode)
EndIf
EndFunc
Func _GUICtrlTab_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $TCM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_SetCurFocus($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETCURFOCUS, $iIndex)
Else
GUICtrlSendMsg($hWnd, $TCM_SETCURFOCUS, $iIndex, 0)
EndIf
EndFunc
Func _StringBetween($sString, $sStart, $sEnd, $iMode = $STR_ENDISSTART, $bCase = False)
$sStart = $sStart ? "\Q" & $sStart & "\E" : "\A"
If $iMode <> $STR_ENDNOTSTART Then $iMode = $STR_ENDISSTART
If $iMode = $STR_ENDISSTART Then
$sEnd = $sEnd ? "(?=\Q" & $sEnd & "\E)" : "\z"
Else
$sEnd = $sEnd ? "\Q" & $sEnd & "\E" : "\z"
EndIf
If $bCase = Default Then
$bCase = False
EndIf
Local $aReturn = StringRegExp($sString, "(?s" &(Not $bCase ? "i" : "") & ")" & $sStart & "(.*?)" & $sEnd, $STR_REGEXPARRAYGLOBALMATCH)
If @error Then Return SetError(1, 0, 0)
Return $aReturn
EndFunc
Func _StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If $iRepeatCount = 0 Then Return ""
If StringLen($sString) < 1 Or $iRepeatCount < 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Global Const $HDM_FIRST = 0x1200
Global Const $HDM_LAYOUT = $HDM_FIRST + 5
Global $__g_hHDRLastWnd
Global Const $tagHDLAYOUT = "ptr Rect;ptr WindowPos"
Func _GUICtrlHeader_Layout($hWnd, ByRef $tRECT)
Local $tLayout = DllStructCreate($tagHDLAYOUT)
Local $tWindowPos = DllStructCreate($tagWINDOWPOS)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tLayout, "Rect", DllStructGetPtr($tRECT))
DllStructSetData($tLayout, "WindowPos", DllStructGetPtr($tWindowPos))
_SendMessage($hWnd, $HDM_LAYOUT, 0, $tLayout, 0, "wparam", "struct*")
Else
Local $iLayout = DllStructGetSize($tLayout)
Local $iRect = DllStructGetSize($tRECT)
Local $iWindowPos = DllStructGetSize($tWindowPos)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iLayout + $iRect + $iWindowPos, $tMemMap)
DllStructSetData($tLayout, "Rect", $pMemory + $iLayout)
DllStructSetData($tLayout, "WindowPos", $pMemory + $iLayout + $iRect)
_MemWrite($tMemMap, $tLayout, $pMemory, $iLayout)
_MemWrite($tMemMap, $tRECT, $pMemory + $iLayout, $iRect)
_SendMessage($hWnd, $HDM_LAYOUT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory + $iLayout + $iRect, $tWindowPos, $iWindowPos)
_MemFree($tMemMap)
EndIf
Return $tWindowPos
EndFunc
Global Const $LVM_FIRST = 0x1000
Global Const $LVM_GETHEADER =($LVM_FIRST + 31)
Global Const $LVM_GETITEMRECT =($LVM_FIRST + 14)
Global Const $LVN_FIRST = -100
Global $__g_hLVLastWnd
Func _GUICtrlListView_GetHeader($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETHEADER))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETHEADER, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetItemRect($hWnd, $iIndex, $iPart = 3)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart = 3)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iPart)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Global $__g_hTTLastWnd
Global Const $_TOOLTIPCONSTANTS_ClassName = "tooltips_class32"
Global Const $_TT_ghTTDefaultStyle = BitOR($TTS_ALWAYSTIP, $TTS_NOPREFIX)
Global Const $tagTOOLINFO = "uint Size;uint Flags;hwnd hWnd;uint_ptr ID;" & $tagRECT & ";handle hInst;ptr Text;lparam Param;ptr Reserved"
Func _GUIToolTip_AddTool($hTool, $hWnd, $sText, $iID = 0, $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $iFlags = Default, $iParam = 0)
Local $iBuffer, $tBuffer, $pBuffer
If $iFlags = Default Then $iFlags = BitOR($TTF_SUBCLASS, $TTF_IDISHWND)
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
$pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "Flags", $iFlags)
DllStructSetData($tToolInfo, "hWnd", $hWnd)
DllStructSetData($tToolInfo, "ID", $iID)
DllStructSetData($tToolInfo, "Left", $iLeft)
DllStructSetData($tToolInfo, "Top", $iTop)
DllStructSetData($tToolInfo, "Right", $iRight)
DllStructSetData($tToolInfo, "Bottom", $iBottom)
DllStructSetData($tToolInfo, "Param", $iParam)
Local $iRet
If _WinAPI_InProcess($hTool, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", $pBuffer)
$iRet = _SendMessage($hTool, $TTM_ADDTOOLW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hTool, $iToolInfo + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tToolInfo, "Text", -1)
EndIf
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
$iRet = _SendMessage($hTool, $TTM_ADDTOOLW, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUIToolTip_Create($hWnd, $iStyle = $_TT_ghTTDefaultStyle)
Return _WinAPI_CreateWindowEx(0, $_TOOLTIPCONSTANTS_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd)
EndFunc
Func _GUIToolTip_GetText($hWnd, $hTool, $iID)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hWnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $TTM_GETTEXTW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo + 4096, $tMemMap)
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
_SendMessage($hWnd, $TTM_GETTEXTW, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pText, $tBuffer, 81)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUIToolTip_SetMaxTipWidth($hWnd, $iWidth)
Return _SendMessage($hWnd, $TTM_SETMAXTIPWIDTH, 0, $iWidth)
EndFunc
Global Const $PROV_RSA_AES = 24
Global Const $CRYPT_VERIFYCONTEXT = 0xF0000000
Global Const $HP_HASHSIZE = 0x0004
Global Const $HP_HASHVAL = 0x0002
Global Const $CRYPT_USERDATA = 1
Global Const $CALG_SHA1 = 0x00008004
Global $__g_aCryptInternalData[3]
Func _Crypt_Startup()
If __Crypt_RefCount() = 0 Then
Local $hAdvapi32 = DllOpen("Advapi32.dll")
If $hAdvapi32 = -1 Then Return SetError(1, 0, False)
__Crypt_DllHandleSet($hAdvapi32)
Local $iProviderID = $PROV_RSA_AES
Local $aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptAcquireContext", "handle*", 0, "ptr", 0, "ptr", 0, "dword", $iProviderID, "dword", $CRYPT_VERIFYCONTEXT)
If @error Or Not $aRet[0] Then
Local $iError = @error + 10, $iExtended = @extended
DllClose(__Crypt_DllHandle())
Return SetError($iError, $iExtended, False)
Else
__Crypt_ContextSet($aRet[1])
EndIf
EndIf
__Crypt_RefCountInc()
Return True
EndFunc
Func _Crypt_Shutdown()
__Crypt_RefCountDec()
If __Crypt_RefCount() = 0 Then
DllCall(__Crypt_DllHandle(), "bool", "CryptReleaseContext", "handle", __Crypt_Context(), "dword", 0)
DllClose(__Crypt_DllHandle())
EndIf
EndFunc
Func _Crypt_HashData($vData, $iAlgID, $bFinal = True, $hCryptHash = 0)
Local $aRet = 0, $hBuff = 0, $iError = 0, $iExtended = 0, $iHashSize = 0, $vReturn = 0
_Crypt_Startup()
Do
If $hCryptHash = 0 Then
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptCreateHash", "handle", __Crypt_Context(), "uint", $iAlgID, "ptr", 0, "dword", 0, "handle*", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 10
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$hCryptHash = $aRet[5]
EndIf
$hBuff = DllStructCreate("byte[" & BinaryLen($vData) & "]")
DllStructSetData($hBuff, 1, $vData)
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptHashData", "handle", $hCryptHash, "struct*", $hBuff, "dword", DllStructGetSize($hBuff), "dword", $CRYPT_USERDATA)
If @error Or Not $aRet[0] Then
$iError = @error + 20
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
If $bFinal Then
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hCryptHash, "dword", $HP_HASHSIZE, "dword*", 0, "dword*", 4, "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$iHashSize = $aRet[3]
$hBuff = DllStructCreate("byte[" & $iHashSize & "]")
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hCryptHash, "dword", $HP_HASHVAL, "struct*", $hBuff, "dword*", DllStructGetSize($hBuff), "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 40
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$vReturn = DllStructGetData($hBuff, 1)
Else
$vReturn = $hCryptHash
EndIf
Until True
If $hCryptHash <> 0 And $bFinal Then DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyHash", "handle", $hCryptHash)
_Crypt_Shutdown()
Return SetError($iError, $iExtended, $vReturn)
EndFunc
Func __Crypt_RefCount()
Return $__g_aCryptInternalData[0]
EndFunc
Func __Crypt_RefCountInc()
$__g_aCryptInternalData[0] += 1
EndFunc
Func __Crypt_RefCountDec()
If $__g_aCryptInternalData[0] > 0 Then $__g_aCryptInternalData[0] -= 1
EndFunc
Func __Crypt_DllHandle()
Return $__g_aCryptInternalData[1]
EndFunc
Func __Crypt_DllHandleSet($hAdvapi32)
$__g_aCryptInternalData[1] = $hAdvapi32
EndFunc
Func __Crypt_Context()
Return $__g_aCryptInternalData[2]
EndFunc
Func __Crypt_ContextSet($hCryptContext)
$__g_aCryptInternalData[2] = $hCryptContext
EndFunc
Func _Timer_Diff($iTimeStamp)
Return 1000 *(__Timer_QueryPerformanceCounter() - $iTimeStamp) / __Timer_QueryPerformanceFrequency()
EndFunc
Func _Timer_Init()
Return __Timer_QueryPerformanceCounter()
EndFunc
Func __Timer_QueryPerformanceCounter()
Local $aResult = DllCall("kernel32.dll", "bool", "QueryPerformanceCounter", "int64*", 0)
If @error Then Return SetError(@error, @extended, -1)
Return SetExtended($aResult[0], $aResult[1])
EndFunc
Func __Timer_QueryPerformanceFrequency()
Local $aResult = DllCall("kernel32.dll", "bool", "QueryPerformanceFrequency", "int64*", 0)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $aResult[1])
EndFunc
Global Const $g_sLogoPath = @ScriptDir & "\Images\Logo.png"
Global Const $g_sLogoLoading = @ScriptDir & "\Images\LogoLoading.png"
Global Const $g_sLogoUrlPath = @ScriptDir & "\Images\LogoURL.png"
Global Const $g_sLogoUrlSmallPath = @ScriptDir & "\Images\LogoURLsmall.png"
Global Const $g_iGAME_WIDTH = 860
Global Const $g_iGAME_HEIGHT = 732
Global Const $g_iDEFAULT_HEIGHT = 780
Global Const $g_iDEFAULT_WIDTH = 860
Global Const $g_iMidOffsetY = Int(($g_iDEFAULT_HEIGHT - 720) / 2)
Global Const $g_iBottomOffsetY = $g_iDEFAULT_HEIGHT - 720
Global $g_hBotLaunchTime = __TimerInit()
Global $g_iBotLaunchTime = 0
Global $g_iVILLAGE_OFFSET[3] = [0, 0, 1]
Global $g_bDebugSetlog = False
Global $g_bDebugAndroid = False
Global $g_bDebugClick = False
Global $g_bDebugFuncTime = False
Global $g_bDebugFuncCall = False
Global $g_bDebugOcr = False
Global $g_bDebugImageSave = False
Global $g_bDebugBuildingPos = False
Global $g_bDebugSetlogTrain = False
Global $g_iDebugWindowMessages = 0
Global $g_bDebugAndroidEmbedded = False
Global $g_bDebugGetLocation = False
Global $g_bDebugRedArea = False
Global $g_hDebugAlwaysSaveFullScreenTimer = 0
Global $g_bDebugSmartZap = False
Global $g_bDebugAttackCSV = False
Global $g_bDebugMakeIMGCSV = False
Global $g_bDebugBetaVersion = StringInStr($g_sBotVersion, " b") > 0
Global $g_bDebugVillageSearchImages = False
Global $g_bDebugDeadBaseImage = False
Global $g_aiSearchEnableDebugDeadBaseImage = 200
Global $g_bDebugResourcesOffset = False
Global $g_bDebugMilkingIMGmake = False
Global $g_bDebugContinueSearchElixir = False
Global $g_bDebugOCRdonate = False
Global $g_bDebugDisableZoomout = False
Global $g_bVillageSearchAlwaysMeasure = False
Global $g_bDebugDisableVillageCentering = False
Global $g_iAndroidZoomoutMode = 0
Global $g_iDebugGDICount = 0
Global $g_aZombie = ["" , 0 , 0 , 0 , 0 , "" , "" , 30 , 300 , 600 , 150 ]
Global $g_iDebugGDICountMax = 0
Global $g_oDebugGDIHandles = ObjCreate("Scripting.Dictionary")
Global $g_oCOMErrorHandler = 0
Global Const $COLOR_ORANGE = 0xFF7700
Global Const $COLOR_ERROR = $COLOR_RED
Global Const $COLOR_WARNING = $COLOR_MAROON
Global Const $COLOR_INFO = $COLOR_BLUE
Global Const $COLOR_SUCCESS = 0x006600
Global Const $COLOR_SUCCESS1 = 0x009900
Global Const $COLOR_DEBUG = $COLOR_PURPLE
Global Const $COLOR_DEBUG1 = 0x7A00CC
Global Const $COLOR_DEBUG2 = 0xAA80FF
Global Const $COLOR_DEBUGS = $COLOR_MEDGRAY
Global Const $COLOR_ACTION = 0xFF8000
Global Const $COLOR_ACTION1 = 0xCC80FF
Global Const $g_bCapturePixel = True, $g_bNoCapturePixel = False
Global $g_bWinMove2_Compatible = True
Global $g_sControlGetHandle2_Classname = ""
Global $g_bCriticalMessageProcessing = False
Global $g_hHBitmapTest = 0
Global $g_hBitmap
Global $g_hHBitmap
Global $g_hHBitmap2
Global $g_bOcrForceCaptureRegion = True
Global $g_iGuiMode = 1
Global $g_bGuiControlsEnabled = True
Global $g_bGuiRemote = False
Global $g_iGuiPID = @AutoItPID
Global $g_iDpiAwarenessMode = 1
Global Const $g_b64Bit = StringInStr(@OSArch, "64") > 0
Global Const $g_sHKLM = "HKLM" &($g_b64Bit ? "64" : "")
Global Const $g_sWow6432Node =($g_b64Bit ? "\Wow6432Node" : "")
Global Const $g_sGoogle = "Google"
Global $g_sAndroidGameDistributor = "Google"
Global $g_sAndroidGamePackage = "com.supercell.clashofclans"
Global $g_sAndroidGameClass = ".GameApp"
Global $g_sUserGameDistributor = "Google"
Global $g_sUserGamePackage = "com.supercell.clashofclans"
Global $g_sUserGameClass = ".GameApp"
Global $g_hAndroidLaunchTime = 0
Global $g_iAndroidRebootHours = 24
Global Const $g_bAndroidShieldPreWin8 =(_WinAPI_GetVersion() < 6.2)
Global $g_avAndroidShieldDelay[4] = [0, 0, Default, Default]
Global $g_bAndroidShieldForceDown = False
Global $g_iAndroidShieldColor = $COLOR_WHITE
Global $g_iAndroidShieldTransparency = 48
Global $g_iAndroidActiveColor = $COLOR_BLACK
Global $g_iAndroidActiveTransparency = 1
Global $g_iAndroidInactiveColor = $COLOR_WHITE
Global $g_iAndroidInactiveTransparency = 24
Global $g_bAndroidShieldEnabled = True
Global $g_bAndroidEmbedEnabled = True
Global $g_bAndroidEmbedded = False
Global $g_bAndroidEmbeddedWindowZeroPosition = True
Global $g_aiAndroidEmbeddedCtrlTarget[10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_avAndroidShieldStatus[5] = [Default, 0, 0, Default, Default]
Global $g_bPoliteCloseCoC = False
Global Const $g_bAndroidBackgroundLaunchEnabled = False
Global $g_bAndroidCheckTimeLagEnabled = True
Global $g_iAndroidAdbAutoTerminate = 0
Global $g_bAndroidAdbScreencapEnabled = True
Global $g_bAndroidAdbScreencapPngEnabled = False
Global $g_bAndroidAdbZoomoutEnabled = True
Global $g_bAndroidAdbClickDragEnabled = True
Global $g_bAndroidAdbInputEnabled = True
Global $g_iAndroidAdbInputWordsCharLimit = 10
Global $g_bAndroidAdbClickEnabled = True
Global $g_bAndroidAdbClicksEnabled = False
Global $g_iAndroidAdbClicksTroopDeploySize = 0
Global $g_bAndroidAdbInstanceEnabled = True
Global $g_bAndroidSuspendedEnabled = True
Global $g_iAndroidSuspendModeFlags = 1
Global $g_bNoFocusTampering = False
Global $g_iAndroidRecoverStrategyDefault = 1
Global $g_iAndroidRecoverStrategy = $g_iAndroidRecoverStrategyDefault
Global $g_bTerminateAdbShellOnStop = False
Global $__BlueStacks2Version_2_5_or_later = False
Global $__MEmu_ToolBar_Width = 45
Global $__MEmu_SystemBar = 36
Global $__MEmu_PhoneLayout = "2"
Global $__MEmu_Window[4][5] = [ ["3.0.8", $g_iDEFAULT_WIDTH + 40, $g_iDEFAULT_HEIGHT - 14, 36, "-1"], ["2.6.2", $g_iDEFAULT_WIDTH + 48, $g_iDEFAULT_HEIGHT - 10, 40, "2"], ["2.5.0", $g_iDEFAULT_WIDTH + 51, $g_iDEFAULT_HEIGHT - 12, 45, "0"], ["2.2.1", $g_iDEFAULT_WIDTH + 51, $g_iDEFAULT_HEIGHT - 12, 45, "0"] ]
Global $__Droid4X_Window[3][3] = [ ["0.10.0", $g_iDEFAULT_WIDTH + 6, $g_iDEFAULT_HEIGHT + 53], ["0.8.6", $g_iDEFAULT_WIDTH + 10, $g_iDEFAULT_HEIGHT + 50] ]
Global $__Nox_Config[1][3] = [ ["3.3.0", "[CLASS:subWin; INSTANCE:1]|[CLASS:AnglePlayer_0; INSTANCE:1]", True] ]
Global $g_avAndroidAppConfig[8][16] = [ ["Nox", "nox", "No", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 4, $g_iDEFAULT_HEIGHT - 10,0, "127.0.0.1:62001", 1+2+4+8+16+32 +256+512, '# ', '(nox Virtual Input|Android Input|Android_Input)', 0, 2], ["MEmu", "MEmu", "MEmu ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 51,$g_iDEFAULT_HEIGHT - 12,0, "127.0.0.1:21503", 2+4+8+16+32 +512, '# ', '(Microvirt Virtual Input|User Input)', 0, 2], ["BlueStacks2","Android", "BlueStacks ", "[CLASS:BlueStacksApp; INSTANCE:1]","_ctl.Window", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,0, "127.0.0.1:5555", 1+2+4+8+16+32 +128, '$ ', 'BlueStacks Virtual Touch', 0, 1], ["BlueStacks", "Android", "BlueStacks App Player","[CLASS:BlueStacksApp; INSTANCE:1]","_ctl.Window", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,0, "127.0.0.1:5555", 1 +8+16+32 +128, '$ ', 'BlueStacks Virtual Touch', 0, 1], ["LeapDroid", "vm1", "Leapd", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,0, "emulator-5554", 1 +8+16+32 +512, '# ', 'qwerty2', 1, 1], ["iTools", "iToolsVM","iTools ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 2, $g_iDEFAULT_HEIGHT - 13,0, "127.0.0.1:54001", 1+2+4+8+16+32+64 +512, '# ', 'iTools Virtual PassThrough Input', 0, 1], ["KOPLAYER", "KOPLAYER","KOPLAYER", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 64,$g_iDEFAULT_HEIGHT - 8, 0, "127.0.0.1:6555", 1+2+4+8+16+32 +512, '# ', 'ttVM Virtual Input', 0, 2], ["Droid4X", "droid4x", "Droid4X ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 10,$g_iDEFAULT_HEIGHT + 50,0, "127.0.0.1:26944", 2+4+8+16+32 +512, '# ', 'droid4x Virtual Input', 0, 2] ]
Global $__Nox_Idx = _ArraySearch($g_avAndroidAppConfig, "Nox", 0, 0, 0, 0, 1, 0)
Global $__MEmu_Idx = _ArraySearch($g_avAndroidAppConfig, "MEmu", 0, 0, 0, 0, 1, 0)
Global $__BS2_Idx = _ArraySearch($g_avAndroidAppConfig, "BlueStacks2", 0, 0, 0, 0, 1, 0)
Global $__BS_Idx = _ArraySearch($g_avAndroidAppConfig, "BlueStacks", 0, 0, 0, 0, 1, 0)
Global $__LeapDroid_Idx = _ArraySearch($g_avAndroidAppConfig, "LeapDroid", 0, 0, 0, 0, 1, 0)
Global $__iTools_Idx = _ArraySearch($g_avAndroidAppConfig, "iTools", 0, 0, 0, 0, 1, 0)
Global $__KOPLAYER_Idx = _ArraySearch($g_avAndroidAppConfig, "KOPLAYER", 0, 0, 0, 0, 1, 0)
Global $__Droid4X_Idx = _ArraySearch($g_avAndroidAppConfig, "Droid4X", 0, 0, 0, 0, 1, 0)
Global $g_bOnlyInstance = True
Global $g_bFoundRunningAndroid = False
Global $g_bFoundInstalledAndroid = False
Global Const $g_iOpenAndroidActiveMaxTry = 5
Global Const $g_iAndroidBackgroundModeDirectX = 1
Global Const $g_iAndroidBackgroundModeOpenGL = 2
Global $g_iAndroidBackgroundMode = 0
Global $g_iAndroidBackgroundModeDefault = 1
Global $g_iAndroidConfig = 0
Global $g_sAndroidVersion
Global $g_sAndroidEmulator
Global $g_sAndroidInstance
Global $g_sAndroidTitle
Global $g_bUpdateAndroidWindowTitle = False
Global $g_sAppClassInstance
Global $g_sAppPaneName
Global $g_iAndroidClientWidth
Global $g_iAndroidClientHeight
Global $g_iAndroidWindowWidth
Global $g_iAndroidWindowHeight
Global $g_bAndroidAdbUseMyBot = True
Global $g_bAndroidAdbReplaceEmulatorVersion = True
Global $g_sAndroidAdbPath
Global $g_sAndroidAdbGlobalOptions
Global $g_sAndroidAdbDevice
Global $g_iAndroidSupportFeature
Global $g_sAndroidShellPrompt
Global $g_sAndroidMouseDevice
Global $g_iAndroidAdbSuCommand
Global $g_bAndroidAdbScreencap
Global $g_bAndroidAdbClick
Global $g_bAndroidAdbInput
Global $g_bAndroidAdbInstance
Global $g_bAndroidAdbClickDrag
Global $g_bAndroidAdbClickDragScript = True
Global $g_bAndroidEmbed
Global $g_iAndroidEmbedMode
Global $g_bAndroidBackgroundLaunch
Global $g_bAndroidBackgroundLaunched
Global $g_iAndroidControlClickDownDelay = 5
Global $g_iAndroidControlClickDelay = 10
Global $g_iAndroidAdbClickGroup = 50
Global $g_iAndroidAdbClickGroupDelay = 25
Global $g_iAndroidControlClickWindow = 0
Global $g_iAndroidControlClickMode = 0
Global $g_bAndroidCloseWithBot = False
Global $g_bAndroidInitialized = False
Global $g_bUpdateSharedPrefs = False
Global $g_iAndroidProcessAffinityMask = 0
Global Const $g_iAndroidJellyBean = 17
Global Const $g_iAndroidLollipop = 21
Global Const $g_iAndroidNougat = 24
Global $g_iAndroidVersionAPI = $g_iAndroidJellyBean
Global $g_bInitAndroidActive = False
Global $g_sAndroidPath = ""
Global $g_sAndroidProgramPath = ""
Global $b_sAndroidProgramWerFaultExcluded = True
Global $g_avAndroidProgramFileVersionInfo = 0
Global $g_bAndroidHasSystemBar = False
Global $g_iAndroidLaunchWaitSec = 600
Global $g_sAndroidPicturesPathAvailable = False
Global $g_sAndroidPicturesPath = ""
Global $g_sAndroidPicturesHostPath = ""
Global $g_bAndroidSharedFolderAvailable = True
Global $g_sAndroidSharedFolderName = ""
Global Const $g_iAndroidSecureFlags = 3
Global $g_sAndroidPicturesHostFolder = ""
Global $g_bAndroidPicturesPathAutoConfig = True
Global $g_iAndroidAdbAutoTerminateCount = 0
Global $g_aiAndroidAdbScreencapBuffer = DllStructCreate("byte[" &($g_iDEFAULT_WIDTH * $g_iDEFAULT_HEIGHT * 4) & "]")
Global $g_hAndroidAdbScreencapBufferPngHandle = 0
Global Const $g_iAndroidAdbScreencapWaitAdbTimeout = 10000
Global Const $g_iAndroidAdbScreencapWaitFileTimeout = 10000
Global $g_iAndroidAdbScreencapTimer = 0
Global $g_iAndroidAdbScreencapTimeoutMin = 200
Global $g_iAndroidAdbScreencapTimeoutMax = 1000
Global $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMax
Global $g_iAndroidAdbScreencapTimeoutDynamic = 3
Global $g_iAndroidAdbScreencapWidth = 0
Global $g_iAndroidAdbScreencapHeight = 0
Global $g_bAndroidAdbKeepClicksActive = False
Global $g_aiAndroidTimeLag[6] = [0, 0, 0, 0, 0, 0]
Global Const $g_iAndroidTimeLagThreshold = 5
Global Const $g_iAndroidTimeLagRebootThreshold = 2
Global Const $g_iAndroidTimeLagResetProblemCountMinutes = 5
Global Const $g_iAndroidRebootPageErrorCount = 5
Global Const $g_iAndroidRebootAdbCommandErrorCount = 10
Global Const $g_iAndroidRebootPageErrorPerMinutes = 10
Global $g_hProcShieldInput[5] = [0, 0, False, False, 0]
Global $g_bSkipFirstZoomout = False
Global $g_bForceCapture = False
Global $g_hAndroidWindow = 0
Global $g_hAndroidWindowDpiAware = 0
Global $g_hAndroidControl = 0
Global $g_bAndroidControlUseParentPos = False
Global $g_bInitAndroid = True
Global Const $g_iCoCReconnectingTimeout = 60000
Global $__BlueStacks_Version
Global $__BlueStacks_Path
Global $__Droid4X_Version
Global $__Droid4X_Path
Global $__MEmu_Path
Global $__LeapDroid_Path
Global $__Nox_Path
Global $__KOPLAYER_Path
Global $__iTools_Path
Global $__VBoxManage_Path
Global $__VBoxVMinfo
Global $__VBoxGuestProperties
Global $__VBoxExtraData
Global $g_iGlobalActiveBotsAllowed = EnvGet("NUMBER_OF_PROCESSORS")
If IsNumber($g_iGlobalActiveBotsAllowed) = 0 Or $g_iGlobalActiveBotsAllowed < 1 Then $g_iGlobalActiveBotsAllowed = 2
Global $g_hMutextOrSemaphoreGlobalActiveBots = 0
Global $g_iGlobalThreads = 0
Global $g_iThreads = 0
Global $g_sProfilePath = @ScriptDir & "\Profiles"
Global Const $g_sPrivateProfilePath = @AppDataDir & "\MyBot.run-Profiles"
Global Const $g_sPrivateAuthenticationFile = @AppDataDir & "\.mybot.run.authentication"
Global Const $g_sProfilePresetPath = @ScriptDir & "\Strategies"
Global $g_sProfileCurrentName = ""
Global $g_sProfileConfigPath = ""
Global $g_sProfileBuildingStatsPath = ""
Global $g_sProfileBuildingPath = ""
Global $g_sProfileLogsPath = "", $g_sProfileLootsPath = "", $g_sProfileTempPath = "", $g_sProfileTempDebugPath = ""
Global $g_sProfileDonateCapturePath = "", $g_sProfileDonateCaptureWhitelistPath = "", $g_sProfileDonateCaptureBlacklistPath = ""
Global $g_sProfileSecondaryInputFileName = ""
Global $g_sProfileSecondaryOutputFileName = ""
Global $g_asProfiles[0]
Global $g_bReadConfigIsActive = False
Global $g_bSaveConfigIsActive = False
Global $g_bApplyConfigIsActive = False
Global $g_hTxtLogTimer = __TimerInit()
Global Const $g_iTxtLogTimerTimeout = 500
Global $g_bMoveDivider = False
Global $g_bSilentSetLog = False
Global $g_sLogFileName = ""
Global $g_hLogFile = 0
Global $g_hAttackLogFile = 0
Global $g_hSwitchLogFile = 0
Global $g_bFlushGuiLogActive = False
Global $g_iLogCheckFreeSpaceMB = 100
Global $g_hStruct_SleepMicro = DllStructCreate("int64 time;")
Global $g_pStruct_SleepMicro = DllStructGetPtr($g_hStruct_SleepMicro)
Global Const $g_iEmptyWorkingSetAndroid = 0
Global Const $g_iEmptyWorkingSetBot = 300
Global Const $g_bMoveMouseOutBS = False
Global $g_bDevMode = False
Global $g_bBotLaunchOption_HideAndroid = False
Global $g_bBotLaunchOption_MinimizeBot = False
Global $g_bBotLaunchOption_Restart = False
Global $g_bBotLaunchOption_Autostart = False
Global $g_bBotLaunchOption_NoWatchdog = False
Global $g_bBotLaunchOption_ForceDpiAware = False
Global $g_iBotLaunchOption_Dock = 0
Global $g_bBotLaunchOption_NoBotSlot = False
Global $g_iBotLaunchOption_Console = False
Global $g_iBotLaunchOption_Help = False
Global $g_asCmdLine[1] = [0]
Global Const $g_sWorkingDir = @WorkingDir
Global $g_hMutex_BotTitle = 0
Global $g_ahMutex_Profile[0][2]
Global $g_ahMutex_SwitchAccountsGroup = [0, 0]
Global $g_hMutex_MyBot = 0
Global $g_hMutex_AdbDaemon = 0
Global $g_BotInstanceCount = 0
Global $g_aiWeakBaseStats
Global Const $g_sLibPath = @ScriptDir & "\lib"
Global Const $g_sMBRLib = "MyBot.run.dll"
Global $g_bLibMyBotActive = False
Global Const $g_sLibMyBotPath = $g_sLibPath & "\" & $g_sMBRLib
Global $g_hLibMyBot = -1
Global $g_hLibNTDLL = DllOpen("ntdll.dll")
Global $g_hLibUser32DLL = DllOpen("user32.dll")
Global Const $g_sLibIconPath = $g_sLibPath & "\MBRBOT.dll"
Global Const $g_sTHSnipeAttacksPath = @ScriptDir & "\CSV\THSnipe"
Global Const $g_sCSVAttacksPath = @ScriptDir & "\CSV\Attack"
Global Const $g_sIcnMBisland = @ScriptDir & "\Images\bbico.png"
Global Const $g_sIcnBldGold = @ScriptDir & "\Images\gold.png"
Global Const $g_sIcnBldElixir = @ScriptDir & "\Images\elixir.png"
Global Const $g_sIcnBldTrophy = @ScriptDir & "\Images\trophy.png"
Global $g_iRedrawBotWindowMode = 2
Global Enum $eIcnArcher = 1, $eIcnDonArcher, $eIcnBalloon, $eIcnDonBalloon, $eIcnBarbarian, $eIcnDonBarbarian, $eBtnTest, $eIcnBuilder, $eIcnCC, $eIcnGUI, $eIcnDark, $eIcnDragon, $eIcnDonDragon, $eIcnDrill, $eIcnElixir, $eIcnCollector, $eIcnFreezeSpell, $eIcnGem, $eIcnGiant, $eIcnDonGiant, $eIcnTrap, $eIcnGoblin, $eIcnDonGoblin, $eIcnGold, $eIcnGolem, $eIcnDonGolem, $eIcnHealer, $eIcnDonHealer, $eIcnHogRider, $eIcnDonHogRider, $eIcnHealSpell, $eIcnInferno, $eIcnJumpSpell, $eIcnLavaHound, $eIcnDonLavaHound, $eIcnLightSpell, $eIcnMinion, $eIcnDonMinion, $eIcnPekka, $eIcnDonPekka, $eIcnTreasury, $eIcnRageSpell, $eIcnTroops, $eIcnHourGlass, $eIcnTH1, $eIcnTH10, $eIcnTrophy, $eIcnValkyrie, $eIcnDonValkyrie, $eIcnWall, $eIcnWallBreaker, $eIcnDonWallBreaker, $eIcnWitch, $eIcnDonWitch, $eIcnWizard, $eIcnDonWizard, $eIcnXbow, $eIcnBarrackBoost, $eIcnMine, $eIcnCamp, $eIcnBarrack, $eIcnSpellFactory, $eIcnDonBlacklist, $eIcnSpellFactoryBoost, $eIcnMortar, $eIcnWizTower, $eIcnPayPal, $eIcnNotify, $eIcnGreenLight, $eIcnLaboratory, $eIcnRedLight, $eIcnBlank, $eIcnYellowLight, $eIcnDonCustom, $eIcnTombstone, $eIcnSilverStar, $eIcnGoldStar, $eIcnDarkBarrack, $eIcnCollectorLocate, $eIcnDrillLocate, $eIcnMineLocate, $eIcnBarrackLocate, $eIcnDarkBarrackLocate, $eIcnDarkSpellFactoryLocate, $eIcnDarkSpellFactory, $eIcnEarthQuakeSpell, $eIcnHasteSpell, $eIcnPoisonSpell, $eIcnBldgTarget, $eIcnBldgX, $eIcnRecycle, $eIcnHeroes, $eIcnBldgElixir, $eIcnBldgGold, $eIcnMagnifier, $eIcnWallElixir, $eIcnWallGold, $eIcnKing, $eIcnQueen, $eIcnDarkSpellBoost, $eIcnQueenBoostLocate, $eIcnKingBoostLocate, $eIcnKingUpgr, $eIcnQueenUpgr, $eIcnWardenUpgr, $eIcnWarden, $eIcnWardenBoostLocate, $eIcnKingBoost, $eIcnQueenBoost, $eIcnWardenBoost, $eEmpty3, $eIcnReload, $eIcnCopy, $eIcnAddcvs, $eIcnEdit, $eIcnTreeSnow, $eIcnSleepingQueen, $eIcnSleepingKing, $eIcnGoldElixir, $eIcnBowler, $eIcnDonBowler, $eIcnCCDonate, $eIcnEagleArt, $eIcnGembox, $eIcnInferno4, $eIcnInfo, $eIcnMain, $eIcnTree, $eIcnProfile, $eIcnCCRequest, $eIcnTelegram, $eIcnTiles, $eIcnXbow3, $eIcnBark, $eIcnDailyProgram, $eIcnLootCart, $eIcnSleepMode, $eIcnTH11, $eIcnTrainMode, $eIcnSleepingWarden, $eIcnCloneSpell, $eIcnSkeletonSpell, $eIcnBabyDragon, $eIcnDonBabyDragon, $eIcnMiner, $eIcnDonMiner, $eIcnNoShield, $eIcnDonCustomB, $eIcnAirdefense, $eIcnDarkBarrackBoost, $eIcnDarkElixirStorage, $eIcnSpellsCost, $eIcnTroopsCost, $eIcnResetButton, $eIcnNewSmartZap, $eIcnTrain, $eIcnAttack, $eIcnDelay, $eIcnReOrder, $eIcn2Arrow, $eIcnArrowLeft, $eIcnArrowRight, $eIcnAndroid, $eHdV04, $eHdV05, $eHdV06, $eHdV07, $eHdV08, $eHdV09, $eHdV10, $eHdV11, $eUnranked, $eBronze, $eSilver, $eGold, $eCrystal, $eMaster, $eChampion, $eTitan, $eLegend, $eWall04, $eWall05, $eWall06, $eWall07, $eWall08, $eWall09, $eWall10, $eWall11, $eIcnPBNotify, $eIcnCCTroops, $eIcnCCSpells, $eIcnSpellsGroup, $eBahasaIND, $eChinese_S, $eChinese_T, $eEnglish, $eFrench, $eGerman, $eItalian, $ePersian, $eRussian, $eSpanish, $eTurkish, $eMissingLangIcon, $eWall12, $ePortuguese, $eIcnDonPoisonSpell, $eIcnDonEarthQuakeSpell, $eIcnDonHasteSpell, $eIcnDonSkeletonSpell, $eVietnamese, $eKorean, $eAzerbaijani, $eArabic, $eIcnBuilderHall, $eIcnClockTower, $eIcnElixirCollectorL5, $eIcnGemMine, $eIcnGoldMineL5, $eIcnElectroDragon, $eIcnTH12, $eHdV12, $eWall13, $eIcnBattleB, $eIcnWallW, $eIcnSiegeCost, $eIcnTrainingPotion, $eIcnBatSpell, $eIcnStoneS, $eIcnIceGolem, $eIcnStarLaboratory, $eIcnRagedBarbarian, $eIcnSneakyArcher, $eIcnBoxerGiant, $eIcnBetaMinion, $eIcnBomber, $eIcnBBBabyDragon, $eIcnCannonCart, $eIcnNightWitch, $eIcnDropShip, $eIcnSuperPekka, $eIcnBBWall01, $eIcnBBWall02, $eIcnBBWall03, $eIcnBBWall04, $eIcnBBWall05, $eIcnBBWall06, $eIcnBBWall07, $eIcnBBWall08, $eIcnKingGrayShield, $eIcnKingBlueShield, $eIcnKingGreenShield, $eIcnKingRedShield, $eIcnQueenGrayShield, $eIcnQueenBlueShield, $eIcnQueenGreenShield, $eIcnQueenRedShield, $eIcnWardenGrayShield, $eIcnWardenBlueShield, $eIcnWardenGreenShield, $eIcnWardenRedShield, $eIcnLabGrayShield, $eIcnLabGreenShield, $eIcnLabRedShield, _
$eIcnClanHop, $eIcnChat, $eIcnRepeat, $eIcnClan, $eIcnTarget, $eIcnSettings, $eIcnClanGames, $eIcnDebug, $eIcnSwitchAcc, $eIcnSwitchProfiles, $eIcnFarmingSchedule, $eIcnAiOMOD, $eIcnMiscMod, $eIcnHumanization, $eIcnGoblinXP, $eIcnWarPreparation, $eIcnKingXP, $eIcnQueenXP, $eIcnWardenXP, $eIcnPrecise, $eIcnBattleBBoost, $eIcnWallWBoost, $eIcnPowerPotion, $eIcnResourcePotion
Global $eIcnDonBlank = $eIcnDonBlacklist
Global $eIcnOptions = $eIcnDonBlacklist
Global $eIcnAchievements = $eIcnMain
Global $eIcnStrategies = $eIcnBlank
Global Const $g_iCollectAtCount = 10
Global Enum $eBotNoAction, $eBotStart, $eBotStop, $eBotSearchMode, $eBotClose
Global $g_iBotAction = $eBotNoAction
Global $g_bBotMoveRequested = False
Global $g_bBotShrinkExpandToggleRequested = False
Global $g_bBotGuiModeToggleRequested = False
Global $g_bRestart = False
Global $g_bRunState = False
Global $g_bIdleState = False
Global $g_bBtnAttackNowPressed = False
Global $g_iCommandStop = -1
Global $g_bMeetCondStop = False
Global $g_bRestarted =($g_bBotLaunchOption_Autostart ? True : False)
Global $g_bFirstStart = True
Global $g_iFirstRun = 1
Global $g_iFirstAttack = 0
Global $g_hTimerSinceStarted = 0
Global $g_iTimePassed = 0
Global $g_bBotPaused = False
Global $g_bTogglePauseUpdateState = False
Global $g_bTogglePauseAllowed = True
Global $g_bWaitShield = False
Global $g_bGForcePBTUpdate = False
Global $g_bQuicklyFirstStart = True
Global $g_bQuickAttack = False
Global $g_sTimeBeforeTrain = ""
Global $g_hAttackTimer = 0
Global $g_iAttackTimerOffset = Default
Global Const $REDLINE_IMGLOC_RAW = 0
Global Const $REDLINE_IMGLOC = 1
Global Const $REDLINE_ORIGINAL = 2
Global Const $REDLINE_NONE = 3
Global Const $DROPLINE_EDGE_FIXED = 0
Global Const $DROPLINE_EDGE_FIRST = 1
Global Const $DROPLINE_FULL_EDGE_FIXED = 2
Global Const $DROPLINE_FULL_EDGE_FIRST = 3
Global Const $DROPLINE_DROPPOINTS_ONLY = 4
Global Enum $eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eEDrag, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eIceG, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell, $eWallW, $eBattleB, $eStoneS, $eArmyCount
Global Enum $DB, $LB, $TS, $MA, $TB, $DT
Global Const $g_iModeCount = 3
Global $g_iMatchMode = 0
Global Const $g_asModeText[6] = ["Dead Base", "Live Base", "TH Snipe", "Milking Attack", "TH Bully", "Drop Trophy"]
Global Enum $eTroopBarbarian, $eTroopArcher, $eTroopGiant, $eTroopGoblin, $eTroopWallBreaker, $eTroopBalloon, $eTroopWizard, $eTroopHealer, $eTroopDragon, $eTroopPekka, $eTroopBabyDragon, $eTroopMiner, $eTroopElectroDragon, $eTroopMinion, $eTroopHogRider, $eTroopValkyrie, $eTroopGolem, $eTroopWitch, $eTroopLavaHound, $eTroopBowler, $eTroopIceGolem, $eTroopCount
Global Const $g_asTroopNames[$eTroopCount] = [ "Barbarian", "Archer", "Giant", "Goblin", "Wall Breaker", "Balloon", "Wizard", "Healer", "Dragon", "Pekka", "Baby Dragon", "Miner", "Electro Dragon", "Minion", "Hog Rider", "Valkyrie", "Golem", "Witch", "Lava Hound", "Bowler", "Ice Golem"]
Global Const $g_asTroopNamesPlural[$eTroopCount] = [ "Barbarians", "Archers", "Giants", "Goblins", "Wall Breakers", "Balloons", "Wizards", "Healers", "Dragons", "Pekkas", "Baby Dragons", "Miners", "Electro Dragons", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers", "Ice Golems"]
Global Const $g_asTroopShortNames[$eTroopCount] = [ "Barb", "Arch", "Giant", "Gobl", "Wall", "Ball", "Wiza", "Heal", "Drag", "Pekk", "BabyD", "Mine", "EDrag", "Mini", "Hogs", "Valk", "Gole", "Witc", "Lava", "Bowl", "IceG"]
Global Const $g_aiTroopSpace[$eTroopCount] = [ 1, 1, 5, 1, 2, 5, 4, 14, 20, 25, 10, 6, 30, 2, 5, 8, 30, 12, 30, 6, 15]
Global Const $g_aiTroopTrainTime[$eTroopCount] = [ 20, 24, 120, 28, 60, 120, 120, 480, 720, 720, 360, 120, 1440, 36, 90, 180, 600, 360, 600, 120, 180]
Global Const $g_aiTroopCostPerLevel[$eTroopCount][10] = [ [8, 25, 40, 60, 100, 150, 200, 250, 300], [8, 50, 80, 120, 200, 300, 400, 500, 600], [9, 250, 750, 1250, 1750, 2250, 3000, 3500, 4000, 4500], [7, 25, 40, 60, 80, 100, 150, 200], [8, 1000, 1250, 1500, 1750, 2000, 2250, 2500, 2750], [8, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500], [9, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500], [5, 5000, 6000, 8000, 10000, 15000], [7, 18000, 20000, 22000, 24000, 26000, 28000, 30000], [8, 21000, 24000, 27000, 30000, 33000, 35000, 37000, 39000], [6, 10000, 11000, 12000, 13000, 14000, 15000], [6, 4200, 4800, 5200, 5600, 6000, 6400], [3, 36000, 40000, 44000], [8, 6, 7, 8, 9, 10, 11, 12, 13], [8, 40, 45, 52, 58, 65, 90, 115, 140], [7, 70, 100, 130, 160, 190, 220, 250], [8, 300, 375, 450, 525, 600, 675, 750, 825], [4, 175, 225, 275, 325], [5, 390, 450, 510, 570, 630], [4, 110, 130, 150, 170], [4, 220, 240, 260, 280]]
Global Const $g_aiTroopDonateXP[$eTroopCount] = [1, 1, 5, 1, 2, 5, 4, 14, 20, 25, 10, 6, 30, 2, 5, 8, 30, 12, 30, 6, 15]
Global Enum $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellClone, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton, $eSpellBat, $eSpellCount
Global Const $g_asSpellNames[$eSpellCount] = ["Lightning", "Heal", "Rage", "Jump", "Freeze", "Clone", "Poison", "Earthquake", "Haste", "Skeleton", "Bat"]
Global Const $g_asSpellShortNames[$eSpellCount] = ["LSpell", "HSpell", "RSpell", "JSpell", "FSpell", "CSpell", "PSpell", "ESpell", "HaSpell", "SkSpell", "BtSpell"]
Global Const $g_aiSpellSpace[$eSpellCount] = [2, 2, 2, 2, 1, 3, 1, 1, 1, 1, 1]
Global Const $g_aiSpellTrainTime[$eSpellCount] = [360, 360, 360, 360, 360, 720, 180, 180, 180, 180, 180]
Global Const $g_aiSpellCostPerLevel[$eSpellCount][8] = [ [7, 15000, 16500, 18000, 20000, 22000, 24000, 26000], [7, 15000, 16500, 18000, 19000, 21000, 23000, 25000], [5, 23000, 25000, 27000, 30000, 33000], [3, 23000, 27000, 31000], [7, 12000, 13000, 14000, 15000, 16000, 17000, 18000], [5, 38000, 39000, 41000, 43000, 45000], [5, 95, 110, 125, 140, 155], [4, 125, 140, 160, 180], [4, 80, 85, 90, 95], [5, 110, 120, 130, 140, 150], [5, 110, 120, 130, 140, 150]]
Global Const $g_aiSpellDonateXP[$eSpellCount] = [10, 10, 10, 10, 10, 0, 5, 5, 5, 5, 5]
Global Enum $eSiegeWallWrecker, $eSiegeBattleBlimp, $eSiegeStoneSlammer, $eSiegeMachineCount
Global Const $g_asSiegeMachineNames[$eSiegeMachineCount] = ["Wall Wrecker", "Battle Blimp", "Stone Slammer"]
Global Const $g_asSiegeMachineShortNames[$eSiegeMachineCount] = ["WallW", "BattleB", "StoneS"]
Global Const $g_aiSiegeMachineSpace[$eSiegeMachineCount] = [1, 1, 1]
Global Const $g_aiSiegeMachineTrainTimePerLevel[$eSiegeMachineCount][4] = [ [3, 1200, 1200, 1200], [3, 1200, 1200, 1200], [3, 1200, 1200, 1200]]
Global Const $g_aiSiegeMachineCostPerLevel[$eSiegeMachineCount][4] = [ [3, 100000, 100000, 100000], [3, 100000, 100000, 100000], [3, 100000, 100000, 100000]]
Global Const $g_aiSiegeMachineDonateXP[$eSiegeMachineCount] = [30, 30, 30]
Global Enum $eHeroNone = 0, $eHeroKing = 1, $eHeroQueen = 2, $eHeroWarden = 4
Global Enum $eHeroBarbarianKing, $eHeroArcherQueen, $eHeroGrandWarden, $eHeroCount
Global Const $g_asHeroNames[$eHeroCount] = ["Barbarian King", "Archer Queen", "Grand Warden"]
Global Const $g_asHeroShortNames[$eHeroCount] = ["King", "Queen", "Warden"]
Global $g_aiHeroBoost[$eHeroCount] = ["1970/01/01 00:00:00", "1970/01/01 00:00:00", "1970/01/01 00:00:00"]
Global Enum $eLeagueUnranked, $eLeagueBronze, $eLeagueSilver, $eLeagueGold, $eLeagueCrystal, $eLeagueMaster, $eLeagueChampion, $eLeagueTitan, $eLeagueLegend, $eLeagueCount
Global Const $g_asLeagueDetails[22][5] = [ ["700", "Bronze III", "0", "B3", "400"], ["1000", "Bronze II", "0", "B2", "500"], ["1300", "Bronze I", "0", "B1", "600"], ["2600", "Silver III", "0", "S3", "800"], ["3700", "Silver II", "0", "S2", "1000"], ["4800", "Silver I", "0", "S1", "1200"], ["10000", "Gold III", "0", "G3", "1400"], ["13500", "Gold II", "0", "G2", "1600"], ["17000", "Gold I", "0", "G1", "1800"], ["40000", "Crystal III", "120", "c3", "2000"], ["55000", "Crystal II", "220", "c2", "2200"], ["70000", "Crystal I", "320", "c1", "2400"], ["110000", "Master III", "560", "M3", "2600"], ["135000", "Master II", "740", "M2", "2800"], ["160000", "Master I", "920", "M1", "3000"], ["200000", "Champion III", "1220", "C3", "3200"], ["225000", "Champion II", "1400", "C2", "3500"], ["250000", "Champion I", "1580", "C1", "3800"], ["280000", "Titan III", "1880", "T3", "4100"], ["300000", "Titan II", "2060", "T2", "4400"], ["320000", "Titan I", "2240", "T1", "4700"], ["340000", "Legend", "2400", "LE", "5000"]]
Global Enum $eLootGold, $eLootElixir, $eLootDarkElixir, $eLootTrophy, $eLootCount
Global Enum $eLootGoldBB, $eLootElixirBB, $eLootTrophyBB, $eLootCountBB
Func TroopIndexLookup(Const $sName, Const $sSource = "")
For $i = 0 To UBound($g_asTroopShortNames) - 1
If $sName = $g_asTroopShortNames[$i] Then
Return $i
EndIf
Next
For $i = 0 To UBound($g_asSpellShortNames) - 1
If $sName = $g_asSpellShortNames[$i] Then
Return $i + $eLSpell
EndIf
Next
For $i = 0 To UBound($g_asHeroShortNames) - 1
If $sName = $g_asHeroShortNames[$i] Then
Return $i + $eKing
EndIf
Next
For $i = 0 To UBound($g_asSiegeMachineShortNames) - 1
If $sName = $g_asSiegeMachineShortNames[$i] Then
Return $i + $eWallW
EndIf
Next
If $sName = "castle" Then Return $eCastle
SetDebugLog("TroopIndexLookup() Error: Index for troop name '" & $sName & "' not found" &(($sSource) ?(" (" & $sSource & ").") :(".")))
Return -1
EndFunc
Func GetTroopName(Const $iIndex, $iQuantity = 1)
If $iIndex >= $eBarb And $iIndex <= $eIceG Then
Return $iQuantity > 1 ? $g_asTroopNamesPlural[$iIndex] : $g_asTroopNames[$iIndex]
ElseIf $iIndex >= $eLSpell And $iIndex <= $eBtSpell Then
Return $iQuantity > 1 ? $g_asSpellNames[$iIndex - $eLSpell] & " Spells" : $g_asSpellNames[$iIndex - $eLSpell] & " Spell"
ElseIf $iIndex >= $eKing And $iIndex <= $eWarden Then
Return $g_asHeroNames[$iIndex - $eKing]
ElseIf $iIndex >= $eWallW And $iIndex <= $eStoneS Then
Return $g_asSiegeMachineNames[$iIndex - $eWallW]
ElseIf $iIndex = $eCastle Then
Return "Clan Castle"
EndIf
EndFunc
Global $g_iLogDividerY = 385
Global Const $g_iLogDividerHeight = 4
Global $g_iCmbLogDividerOption = 0
Global $g_bChkBackgroundMode
Global $g_bMakeScreenshotNow = False
Global $g_bChkBotStop = False, $g_iCmbBotCommand = 0, $g_iCmbBotCond = 0, $g_iCmbHoursStop = 0
Global $g_iTxtRestartGold = 10000
Global $g_iTxtRestartElixir = 25000
Global $g_iTxtRestartDark = 500
Global $g_bChkCollect = True, $g_bChkTombstones = True, $g_bChkCleanYard = False, $g_bChkGemsBox = False
Global $g_bChkCollectCartFirst = False, $g_iTxtCollectGold = 0, $g_iTxtCollectElixir = 0, $g_iTxtCollectDark = 0
Global $g_bChkTreasuryCollect = False
Global $g_iTxtTreasuryGold = 0
Global $g_iTxtTreasuryElixir = 0
Global $g_iTxtTreasuryDark = 0
Global $g_bChkCollectBuilderBase = False, $g_bChkStartClockTowerBoost = False, $g_bChkCTBoostBlderBz = False, $g_bChkCleanBBYard = False
Global $g_bRequestTroopsEnable = False
Global $g_sRequestTroopsText = ""
Global $g_abRequestCCHours[24] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_abRequestType[3] = [True, True, False]
Global $g_iRequestCountCCTroop = 0, $g_iRequestCountCCSpell = 0
Global $g_aiCCTroopsExpected[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiCCSpellsExpected[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiCCSiegeExpected[$eSiegeMachineCount] = [0, 0, 0]
Global $g_aiClanCastleTroopWaitType[3], $g_aiClanCastleTroopWaitQty[3]
Global $g_aiClanCastleSpellWaitType[3]
Global $g_aiClanCastleSiegeWaitType[2]
Global Const $g_aiCCTroopsIcon = [ $eIcnBarbarian, $eIcnArcher, $eIcnGiant, $eIcnGoblin, $eIcnWallBreaker, $eIcnBalloon, $eIcnWizard, $eIcnHealer, $eIcnDragon, $eIcnPekka, $eIcnBabyDragon, $eIcnMiner, $eIcnElectroDragon, $eIcnMinion, $eIcnHogRider, $eIcnValkyrie, $eIcnGolem, $eIcnWitch, $eIcnLavaHound, $eIcnBowler, $eIcnIceGolem, $eIcnOptions]
Global Const $g_aiCCSpellsIcon = [ $eIcnLightSpell, $eIcnHealSpell, $eIcnRageSpell, $eIcnJumpSpell, $eIcnFreezeSpell, $eIcnCloneSpell, $eIcnPoisonSpell, $eIcnEarthQuakeSpell, $eIcnHasteSpell, $eIcnSkeletonSpell, $eIcnBatSpell, $eIcnOptions]
Global Const $g_aiCCSiegesIcon = [ $eIcnWallW, $eIcnBattleB, $eIcnStoneS, $eIcnOptions]
Global $g_bChkDonate = True
Global $g_abChkDonateQueueOnly[2]
Global Enum $eCustomA = $eTroopCount, $eCustomB = $eTroopCount + 1
Global Enum $eCustomC = $eTroopCount + 2, $eCustomD = $eTroopCount + 3
Global Const $g_iCustomDonateConfigs = 4
Global $g_abChkDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_abChkDonateAllTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_asTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
Global $g_asTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
Global $g_abChkDonateSpell[$eSpellCount] = [False, False, False, False, False, False, False, False, False, False, False]
Global $g_abChkDonateAllSpell[$eSpellCount] = [False, False, False, False, False, False, False, False, False, False, False]
Global $g_asTxtDonateSpell[$eSpellCount] = ["", "", "", "", "", "", "", "", "", "", ""]
Global $g_asTxtBlacklistSpell[$eSpellCount] = ["", "", "", "", "", "", "", "", "", "", ""]
Global $g_aiDonateCustomTrpNumA[3][2] = [[0, 0], [0, 0], [0, 0]], $g_aiDonateCustomTrpNumB[3][2] = [[0, 0], [0, 0], [0, 0]]
Global $g_aiDonateCustomTrpNumC[3][2] = [[0, 0], [0, 0], [0, 0]], $g_aiDonateCustomTrpNumD[3][2] = [[0, 0], [0, 0], [0, 0]]
Global $g_bChkExtraAlphabets = False
Global $g_bChkExtraChinese = False
Global $g_bChkExtraKorean = False
Global $g_bChkExtraPersian = False
Global $g_sTxtGeneralBlacklist = ""
Global $g_bDonateHoursEnable = False
Global $g_abDonateHours[24] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_iCmbDonateFilter = 0
Global $g_bDonateSkipNearFullEnable = False
Global $g_iDonateSkipNearFullPercent = 90
Global $g_bAutoLabUpgradeEnable = False, $g_iCmbLaboratory = 0, $g_bAutoStarLabUpgradeEnable = False, $g_iCmbStarLaboratory = 0
Global $g_bUpgradeKingEnable = False, $g_bUpgradeQueenEnable = False, $g_bUpgradeWardenEnable = False, $g_iHeroReservedBuilder = 0
Global Const $g_iUpgradeSlots = 14
Global $g_aiPicUpgradeStatus[$g_iUpgradeSlots] = [$eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops, $eIcnTroops]
Global $g_abBuildingUpgradeEnable[$g_iUpgradeSlots] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_avBuildingUpgrades[$g_iUpgradeSlots][8]
For $i = 0 To $g_iUpgradeSlots - 1
$g_avBuildingUpgrades[$i][0] = -1
$g_avBuildingUpgrades[$i][1] = -1
$g_avBuildingUpgrades[$i][2] = -1
$g_avBuildingUpgrades[$i][3] = ""
$g_avBuildingUpgrades[$i][4] = ""
$g_avBuildingUpgrades[$i][5] = ""
$g_avBuildingUpgrades[$i][6] = ""
$g_avBuildingUpgrades[$i][7] = ""
Next
Global $g_iUpgradeMinGold = 100000, $g_iUpgradeMinElixir = 100000, $g_iUpgradeMinDark = 3000
Global $g_abUpgradeRepeatEnable[$g_iUpgradeSlots] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_bAutoUpgradeWallsEnable = 0
Global $g_iUpgradeWallMinGold = 0, $g_iUpgradeWallMinElixir = 0
Global $g_iUpgradeWallLootType = 0, $g_bUpgradeWallSaveBuilder = False
Global $g_iCmbUpgradeWallsLevel = 6
Global $g_aiWallsCurrentCount[14] = [-1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiLastGoodWallPos[2] = [-1, -1]
Global $g_bAutoUpgradeEnabled = False
Global $g_iTxtSmartMinGold = 150000, $g_iTxtSmartMinElixir = 150000, $g_iTxtSmartMinDark = 1500
Global $g_iChkUpgradesToIgnore[14] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_iChkResourcesToIgnore[3] = [0, 0, 0]
Global $g_iCurrentLineOffset = 0, $g_iNextLineOffset = 0
Global $g_aUpgradeNameLevel
Global $g_aUpgradeResourceCostDuration[3] = ["", "", ""]
Global $g_iChkBBSuggestedUpgrades = 0, $g_iChkBBSuggestedUpgradesIgnoreGold = 0, $g_iChkBBSuggestedUpgradesIgnoreElixir = 0, $g_iChkBBSuggestedUpgradesIgnoreHall = 0
Global $g_iChkPlacingNewBuildings = 0
Global $g_iQuickMISX = 0, $g_iQuickMISY = 0
Global $g_iUnbrkMode = 0, $g_iUnbrkWait = 5
Global $g_iUnbrkMinGold = 50000, $g_iUnbrkMinElixir = 50000, $g_iUnbrkMaxGold = 600000, $g_iUnbrkMaxElixir = 600000, $g_iUnbrkMinDark = 5000, $g_iUnbrkMaxDark = 6000
Global Const $g_sCurlPath = $g_sLibPath & "\curl\curl.exe"
Global $g_bNotifyForced = False
Global $g_sTGChatID = ""
Global $g_bTGRequestScreenshot = False
Global $g_bTGRequestScreenshotHD = False
Global $g_bTGRequestBuilderInfo = False
Global $g_bTGRequestShieldInfo = False
Global $g_iTGLastRemote = 0
Global $g_sTGLast_UID = ""
Global $g_sTGLastMessage = ""
Global $g_sAttackFile = ""
Global $g_bNotifyTGEnable = False, $g_sNotifyTGToken = ""
Global $g_bNotifyRemoteEnable = False, $g_sNotifyOrigin = "", $g_bNotifyDeleteAllPushesOnStart = False, $g_bNotifyDeletePushesOlderThan = False, $g_iNotifyDeletePushesOlderThanHours = 4
Global $g_bNotifyAlertMatchFound = False, $g_bNotifyAlerLastRaidIMG = False, $g_bNotifyAlerLastRaidTXT = False, $g_bNotifyAlertCampFull = False, $g_bNotifyAlertUpgradeWalls = False, $g_bNotifyAlertOutOfSync = False, $g_bNotifyAlertTakeBreak = False, $g_bNotifyAlertBulderIdle = False, $g_bNotifyAlertVillageReport = False, $g_bNotifyAlertLastAttack = False, $g_bNotifyAlertAnotherDevice = False, $g_bNotifyAlertMaintenance = False, $g_bNotifyAlertBAN = False, $g_bNotifyAlertBOTUpdate = False, $g_bNotifyAlertSmartWaitTime = False, $g_bNotifyAlertLaboratoryIdle = False
Global $g_bNotifyScheduleHoursEnable = False, $g_bNotifyScheduleWeekDaysEnable = False
Global $g_abNotifyScheduleHours[24] = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
Global $g_abNotifyScheduleWeekDays[7] = [False, False, False, False, False, False, False]
Global $g_bQuickTrainEnable = False
Global $g_bQuickTrainArmy[3] = [True, False, False], $g_bChkMultiClick = False
Global $g_aiArmyCompTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiArmyCompSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiArmyCompSiegeMachine[$eSiegeMachineCount] = [0, 0, 0]
Global $g_aiTrainArmyTroopLevel[$eTroopCount] = [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiTrainArmySpellLevel[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiTrainArmySiegeMachineLevel[$eSiegeMachineCount] = [0, 0, 0]
Global $g_iTrainArmyFullTroopPct = 100
Global $g_bTotalCampForced = False, $g_iTotalCampForcedValue = 200
Global $g_bForceBrewSpells = False
Global $g_iTotalSpellValue = 0
Global $g_bDoubleTrain = False, $g_bChkPreciseArmy = False
Global $g_iCmbBoostBarracks = 0, $g_iCmbBoostSpellFactory = 0, $g_iCmbBoostWorkshop = 0, $g_iCmbBoostBarbarianKing = 0, $g_iCmbBoostArcherQueen = 0, $g_iCmbBoostWarden = 0
Global $g_iCmbBoostTrainingPotion = 0, $g_iCmbBoostResourcePotion = 0
Global $g_abBoostBarracksHours[24] = [True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
Global Const $g_aiTroopOrderIcon[23] = [ $eIcnOptions, $eIcnBarbarian, $eIcnArcher, $eIcnGiant, $eIcnGoblin, $eIcnWallBreaker, $eIcnBalloon, $eIcnWizard, $eIcnHealer, $eIcnDragon, $eIcnPekka, $eIcnBabyDragon, $eIcnMiner, $eIcnElectroDragon, $eIcnMinion, $eIcnHogRider, $eIcnValkyrie, $eIcnGolem, $eIcnWitch, $eIcnLavaHound, $eIcnBowler, $eIcnIceGolem]
Global $g_bCustomTrainOrderEnable = False, $g_aiCmbCustomTrainOrder[$eTroopCount] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
Global $g_aiTrainOrder[$eTroopCount] = [ $eTroopArcher, $eTroopGiant, $eTroopWallBreaker, $eTroopBarbarian, $eTroopGoblin, $eTroopHealer, $eTroopPekka, $eTroopBalloon, $eTroopWizard, $eTroopDragon, $eTroopBabyDragon, $eTroopMiner, $eTroopElectroDragon, $eTroopMinion, $eTroopHogRider, $eTroopValkyrie, $eTroopGolem, $eTroopWitch, $eTroopLavaHound, $eTroopBowler, $eTroopIceGolem]
Global Const $g_aiSpellsOrderIcon[13] = [ $eIcnOptions, $eIcnLightSpell, $eIcnHealSpell,$eIcnRageSpell, $eIcnJumpSpell, $eIcnFreezeSpell, $eIcnCloneSpell, $eIcnPoisonSpell, $eIcnEarthQuakeSpell, $eIcnHasteSpell, $eIcnSkeletonSpell, $eIcnBatSpell]
Global $g_bCustomBrewOrderEnable = False, $g_aiCmbCustomBrewOrder[$eSpellCount] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
Global $g_aiBrewOrder[$eSpellCount] = [ $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellClone, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton, $eSpellBat]
Global Enum $eTroopBarbarianS, $eTroopArcherS, $eTroopGiantS, $eTroopGoblinS, $eTroopWallBreakerS, $eTroopBalloonS, $eTroopWizardS, $eTroopHealerS, $eTroopDragonS, $eTroopPekkaS, $eTroopBabyDragonS, $eTroopMinerS, $eTroopElectroDragons, $eTroopMinionS, $eTroopHogRiderS, $eTroopValkyrieS, $eTroopGolemS, $eTroopWitchS, $eTroopLavaHoundS, $eTroopBowlerS, $eTroopIceGolemS, $eHeroeS, $eCCS, $eDropOrderCount
Global Const $g_asDropOrderNames[$eDropOrderCount] = [ "Barbarians", "Archers", "Giants", "Goblins", "Wall Breakers", "Balloons", "Wizards", "Healers", "Dragons", "Pekkas", "Baby Dragons", "Miners", "Electro Dragons", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers", "Ice Golems", "Clan Castle", "Heroes"]
Global Const $g_aiDropOrderIcon[25] = [ $eIcnOptions, $eIcnBarbarian, $eIcnArcher, $eIcnGiant, $eIcnGoblin, $eIcnWallBreaker, $eIcnBalloon, $eIcnWizard, $eIcnHealer, $eIcnDragon, $eIcnPekka, $eIcnBabyDragon, $eIcnMiner, $eIcnElectroDragon, $eIcnMinion, $eIcnHogRider, $eIcnValkyrie, $eIcnGolem, $eIcnWitch, $eIcnLavaHound, $eIcnBowler, $eIcnIceGolem, $eIcnCC, $eIcnHeroes]
Global $g_bCustomDropOrderEnable = False, $g_aiCmbCustomDropOrder[$eDropOrderCount] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
Global $g_aiDropOrder[$eDropOrderCount] = [ $eTroopBarbarianS, $eTroopArcherS, $eTroopGiantS, $eTroopGoblinS, $eTroopWallBreakerS, $eTroopBalloonS, $eTroopWizardS, $eTroopHealerS, $eTroopDragonS, $eTroopPekkaS, $eTroopBabyDragonS, $eTroopMinerS, $eTroopElectroDragonS, $eTroopMinionS, $eTroopHogRiderS, $eTroopValkyrieS, $eTroopGolemS, $eTroopWitchS, $eTroopLavaHoundS, $eTroopBowlerS, $eTroopIceGolem, $eHeroeS, $eCCS]
Global $g_bCloseWhileTrainingEnable = False, $g_bCloseWithoutShield = True, $g_bCloseEmulator = False, $g_bSuspendComputer = False, $g_bCloseRandom = False, $g_bCloseExactTime = True, $g_bCloseRandomTime = False, $g_iCloseRandomTimePercent = 10, $g_iCloseMinimumTime = 2
Global $g_iTrainClickDelay = 40
Global $g_bTrainAddRandomDelayEnable = False, $g_iTrainAddRandomDelayMin = 5, $g_iTrainAddRandomDelayMax = 60
Global $g_abAttackTypeEnable[$g_iModeCount + 3] = [True, False, False, -1, False, -1]
Global $g_abSearchSearchesEnable[$g_iModeCount] = [True, False, False], $g_aiSearchSearchesMin[$g_iModeCount] = [0, 0, 0], $g_aiSearchSearchesMax[$g_iModeCount] = [0, 0, 0]
Global $g_abSearchTropiesEnable[$g_iModeCount] = [False, False, False], $g_aiSearchTrophiesMin[$g_iModeCount] = [0, 0, 0], $g_aiSearchTrophiesMax[$g_iModeCount] = [0, 0, 0]
Global $g_abSearchCampsEnable[$g_iModeCount] = [False, False, False], $g_aiSearchCampsPct[$g_iModeCount] = [0, 0, 0]
Global $g_aiSearchHeroWaitEnable[$g_iModeCount] = [0, 0, 0]
Global $g_abSearchSpellsWaitEnable[$g_iModeCount] = [False, False, False]
Global $g_abSearchCastleWaitEnable[$g_iModeCount] = [False, False, False]
Global $g_aiSearchNotWaitHeroesEnable[$g_iModeCount] = [0, 0, 0]
Global $g_iSearchNotWaitHeroesEnable = -1
Global $g_abSearchSiegeWaitEnable[$g_iModeCount] = [False, False, False] , $g_aiSearchSiegeWait[$g_iModeCount] = [0, 0, 0]
Global $g_aiFilterMeetGE[$g_iModeCount] = [0, 0, 0], $g_aiFilterMinGold[$g_iModeCount] = [0, 0, 0], $g_aiFilterMinElixir[$g_iModeCount] = [0, 0, 0], $g_aiFilterMinGoldPlusElixir[$g_iModeCount] = [0, 0, 0]
Global $g_abFilterMeetDEEnable[$g_iModeCount] = [False, False, False], $g_aiFilterMeetDEMin[$g_iModeCount] = [0, 0, 0]
Global $g_abFilterMeetTrophyEnable[$g_iModeCount] = [False, False, False], $g_aiFilterMeetTrophyMin[$g_iModeCount] = [0, 0, 0], $g_aiFilterMeetTrophyMax[$g_iModeCount] = [99, 99, 99]
Global $g_abFilterMeetTH[$g_iModeCount] = [False, False, False], $g_aiFilterMeetTHMin[$g_iModeCount] = [0, 0, 0]
Global $g_abFilterMeetTHOutsideEnable[$g_iModeCount] = [False, False, False]
Global $g_abFilterMaxMortarEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxWizTowerEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxAirDefenseEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxXBowEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxInfernoEnable[$g_iModeCount] = [False, False, False], $g_abFilterMaxEagleEnable[$g_iModeCount] = [False, False, False]
Global $g_aiFilterMaxMortarLevel[$g_iModeCount] = [5, 5, 0], $g_aiFilterMaxWizTowerLevel[$g_iModeCount] = [4, 4, 0], $g_aiFilterMaxAirDefenseLevel[$g_iModeCount] = [0, 0, 0], $g_aiFilterMaxXBowLevel[$g_iModeCount] = [0, 0, 0], $g_aiFilterMaxInfernoLevel[$g_iModeCount] = [0, 0, 0], $g_aiFilterMaxEagleLevel[$g_iModeCount] = [0, 0, 0]
Global $g_abFilterMeetOneConditionEnable[$g_iModeCount] = [False, False, False]
Global $g_iSlotsGiants = 1
Global $g_aiAttackAlgorithm[$g_iModeCount] = [0, 0, 0], $g_aiAttackTroopSelection[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiAttackUseHeroes[$g_iModeCount] = [0, 0, 0], $g_abAttackDropCC[$g_iModeCount] = [0, 0, 0] , $g_aiAttackUseSiege[$g_iModeCount] = [0, 0, 0], $g_aiAttackUseWardenMode[$g_iModeCount] = [0, 0, 0]
Global $g_abAttackUseLightSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseHealSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseRageSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseJumpSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseFreezeSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseCloneSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUsePoisonSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseEarthquakeSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseHasteSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseSkeletonSpell[$g_iModeCount] = [0, 0, 0], $g_abAttackUseBatSpell[$g_iModeCount] = [0, 0, 0]
Global $g_bTHSnipeBeforeEnable[$g_iModeCount] = [False, False, False], $g_iTHSnipeBeforeTiles[$g_iModeCount] = [0, 0, 0], $g_iTHSnipeBeforeScript[$g_iModeCount] = [0, 0, 0]
Global $g_aiAttackStdDropOrder[$g_iModeCount + 1] = [0, 0, 0, 0], $g_aiAttackStdDropSides[$g_iModeCount + 1] = [3, 3, 0, 1], $g_aiAttackStdUnitDelay[$g_iModeCount + 1] = [4, 4, 0, 4], $g_aiAttackStdWaveDelay[$g_iModeCount + 1] = [4, 4, 0, 4], $g_abAttackStdRandomizeDelay[$g_iModeCount + 1] = [True, True, False, True], $g_abAttackStdSmartAttack[$g_iModeCount + 3] = [True, True, False, True, False, False], $g_aiAttackStdSmartDeploy[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0]
Global $g_abAttackStdSmartNearCollectors[$g_iModeCount + 3][3] = [[False, False, False], [False, False, False], [False, False, False], [False, False, False], [False, False, False], [False, False, False]]
Global $g_aiAttackScrRedlineRoutine[$g_iModeCount + 3] = [$REDLINE_IMGLOC_RAW, $REDLINE_IMGLOC_RAW, 0, 0, 0, 0]
Global $g_aiAttackScrDroplineEdge[$g_iModeCount + 3] = [$DROPLINE_EDGE_FIRST, $DROPLINE_EDGE_FIRST, 0, 0, 0, 0]
Global $g_sAttackScrScriptName[$g_iModeCount] = ["Barch four fingers", "Barch four fingers", ""]
Global $g_abStopAtkNoLoot1Enable[$g_iModeCount] = [True, True, False], $g_aiStopAtkNoLoot1Time[$g_iModeCount] = [0, 0, 0], $g_abStopAtkNoLoot2Enable[$g_iModeCount] = [False, False, False], $g_aiStopAtkNoLoot2Time[$g_iModeCount] = [0, 0, 0]
Global $g_aiStopAtkNoLoot2MinGold[$g_iModeCount] = [0, 0, 0], $g_aiStopAtkNoLoot2MinElixir[$g_iModeCount] = [0, 0, 0], $g_aiStopAtkNoLoot2MinDark[$g_iModeCount] = [0, 0, 0]
Global $g_abStopAtkNoResources[$g_iModeCount] = [False, False, False], $g_abStopAtkOneStar[$g_iModeCount] = [False, False, False], $g_abStopAtkTwoStars[$g_iModeCount] = [False, False, False]
Global $g_abStopAtkPctHigherEnable[$g_iModeCount] = [False, False, False], $g_aiStopAtkPctHigherAmt[$g_iModeCount] = [0, 0, 0]
Global $g_abStopAtkPctNoChangeEnable[$g_iModeCount] = [False, False, False], $g_aiStopAtkPctNoChangeTime[$g_iModeCount] = [0, 0, 0]
Global $g_iTxtInsidePercentage = 0 , $g_iTxtOutsidePercentage = 0 , $g_bDebugSmartFarm = False
Global $g_iSidesAttack = 0
Global $g_iPercentageDamage = 0
Global $g_abCollectorLevelEnabled[14] = [-1, -1, -1, -1, -1, -1, True, True, True, True, True, True, True, True]
Global $g_aiCollectorLevelFill[14] = [-1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1]
Global $g_bCollectorFilterDisable = False
Global $g_iCollectorMatchesMin = 3
Global $g_iCollectorToleranceOffset = 0
Global $g_bDESideEndEnable = False, $g_iDESideEndMin = 25, $g_bDESideDisableOther = False, $g_bDESideEndAQWeak = False, $g_bDESideEndBKWeak = False, $g_bDESideEndOneStar = False
Global $g_iAtkTSAddTilesWhileTrain = 1, $g_iAtkTSAddTilesFullTroops = 0
Global $g_sAtkTSType = "Bam"
Global $g_bEndTSCampsEnable = False, $g_iEndTSCampsPct = 0
Global $g_iAtkTBEnableCount = 150, $g_iAtkTBMaxTHLevel = 0, $g_iAtkTBMode = 0
Global $g_bSearchReductionEnable = False, $g_iSearchReductionCount = 20, $g_iSearchReductionGold = 2000, $g_iSearchReductionElixir = 2000, $g_iSearchReductionGoldPlusElixir = 4000, $g_iSearchReductionDark = 100, $g_iSearchReductionTrophy = 2
Global $g_iSearchDelayMin = 0, $g_iSearchDelayMax = 0
Global $g_bSearchAttackNowEnable = False, $g_iSearchAttackNowDelay = 0, $g_bSearchRestartEnable = False, $g_iSearchRestartLimit = 25, $g_bSearchAlertMe = True, $g_bSearchRestartPickupHero = False
Global $g_asHeroHealTime[3] = ["", "", ""]
Global $g_iActivateQueen = 0, $g_iActivateKing = 0, $g_iActivateWarden = 0
Global $g_iDelayActivateQueen = 9000, $g_iDelayActivateKing = 9000, $g_iDelayActivateWarden = 10000
Global $g_aHeroesTimerActivation[$eHeroCount] = [0, 0, 0]
Global $g_bAttackPlannerEnable = False, $g_bAttackPlannerCloseCoC = False, $g_bAttackPlannerCloseAll = False, $g_bAttackPlannerSuspendComputer = False, $g_bAttackPlannerRandomEnable = False, $g_iAttackPlannerRandomTime = 0, $g_iAttackPlannerRandomTime = 0, $g_bAttackPlannerDayLimit = False, $g_iAttackPlannerDayMin = 12, $g_iAttackPlannerDayMax = 15
Global $g_abPlannedAttackWeekDays[7] = [True, True, True, True, True, True, True]
Global $g_abPlannedattackHours[24] = [True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
Global $g_bPlannedDropCCHoursEnable = False, $g_bUseCCBalanced = False, $g_iCCDonated = 0, $g_iCCReceived = 0
Global $g_abPlannedDropCCHours[24] = [True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
Global $g_bSmartZapEnable = False, $g_bEarthQuakeZap = False, $g_bNoobZap = False, $g_bSmartZapDB = True, $g_bSmartZapSaveHeroes = True, $g_bSmartZapFTW = False, $g_iSmartZapMinDE = 350, $g_iSmartZapExpectedDE = 320, $g_bDebugSmartZap = False
Global $g_bShareAttackEnable = 0, $g_iShareMinGold = 300000, $g_iShareMinElixir = 300000, $g_iShareMinDark = 0, $g_sShareMessage = "Nice|Good|Thanks|Wowwww", $g_bTakeLootSnapShot = True, $g_bScreenshotLootInfo = False, $g_bShareAttackEnableNow = False
Global $g_bDropTrophyEnable = False, $g_iDropTrophyMax = 1200, $g_iDropTrophyMin = 800, $g_bDropTrophyUseHeroes = False, $g_iDropTrophyHeroesPriority = 0, $g_bDropTrophyAtkDead = 0, $g_iDropTrophyArmyMinPct = 70
Global $g_sLanguage = "English"
Global $g_bDisableSplash = False
Global $g_bMyBotDance = False
Global $g_bCheckVersion = True
Global $g_bDeleteLogs = True, $g_iDeleteLogsDays = 2, $g_bDeleteTemp = True, $g_iDeleteTempDays = 2, $g_bDeleteLoots = True, $g_iDeleteLootsDays = 2
Global $g_bAutoStart = False, $g_iAutoStartDelay = 10
Global $b_iAutoRestartDelay = 0
Global $g_bCheckGameLanguage = True
Global $g_bAutoUpdateGame = False
Global $g_bAutoAlignEnable = False, $g_iAutoAlignPosition = "EMBED", $g_iAutoAlignOffsetX = "", $g_iAutoAlignOffsetY = ""
Global $g_bUpdatingWhenMinimized = True
Global $g_bHideWhenMinimized = False
Global $g_bUseRandomClick = False
Global $g_bScreenshotPNGFormat = True, $g_bScreenshotHideName = True
Global $g_iAnotherDeviceWaitTime = 120
Global $g_bForceSinglePBLogoff = True, $g_iSinglePBForcedLogoffTime = 17, $g_iSinglePBForcedEarlyExitTime = 15
Global $g_bAutoResumeEnable = 0, $g_iAutoResumeTime = 5
Global $g_bDisableNotifications = False
Global $g_bForceClanCastleDetection = 0
Global $g_iCmbSwitchAcc = 0
Global $g_bChkSharedPrefs = True, $g_bChkGooglePlay = False, $g_bChkSuperCellID = False, $g_bChkSwitchAcc = False, $g_bChkSmartSwitch = False, $g_bDonateLikeCrazy = False, $g_iTotalAcc = -1, $g_iTrainTimeToSkip = 0
Global $g_bInitiateSwitchAcc = True, $g_bReMatchAcc = False, $g_bWaitForCCTroopSpell = False, $g_iNextAccount, $g_iCurAccount
Global $g_abAccountNo[8], $g_asProfileName[8], $g_abDonateOnly[8], $g_aiAttackedCountSwitch[8], $g_iActiveSwitchCounter = 0, $g_iDonateSwitchCounter = 0, $g_asTrainTimeFinish[8], $g_abPBActive[8], $g_aiRunTime[8], $g_ahTimerSinceSwitched[8]
Global $g_abChkSwitchMax[4] = [False, False, False, False], $g_abChkSwitchMin[4] = [False, False, False, False], $g_aiCmbSwitchMax[4] = [-1, -1, -1, -1], $g_aiCmbSwitchMin[4] = [-1, -1, -1, -1], $g_abChkBotTypeMax[4] = [False, False, False, False], $g_abChkBotTypeMin[4] = [False, False, False, False], $g_aiCmbBotTypeMax[4] = [1, 1, 1, 1], $g_aiCmbBotTypeMin[4] = [2, 2, 2, 2], $g_aiConditionMax[4] = ["12000000", "12000000", "240000", "5000"], $g_aiConditionMin[4] = ["1000000", "1000000", "20000", "3000"]
Global $g_abChkSetFarm[8], $g_aiCmbAction1[8], $g_aiCmbCriteria1[8], $g_aiTxtResource1[8], $g_aiCmbTime1[8], $g_aiCmbAction2[8], $g_aiCmbCriteria2[8], $g_aiTxtResource2[8], $g_aiCmbTime2[8]
Global Const $g_WIN_POS_DEFAULT = 0xFFFFFFF
Global $g_iFrmBotPosX = $g_WIN_POS_DEFAULT
Global $g_iFrmBotPosY = $g_WIN_POS_DEFAULT
Global $g_iAndroidPosX = $g_WIN_POS_DEFAULT
Global $g_iAndroidPosY = $g_WIN_POS_DEFAULT
Global $g_iFrmBotDockedPosX = $g_WIN_POS_DEFAULT
Global $g_iFrmBotDockedPosY = $g_WIN_POS_DEFAULT
Global $g_iFrmBotAddH = 0
Global $g_bIsHidden = False
Global $g_aiBSpos[2]
Global $g_aiBSrpos[2]
Global $g_bGUIControlDisabled = False
Global Const $g_sDirLanguages = @ScriptDir & "\Languages\"
Global Const $g_sDefaultLanguage = "English"
Global Const $g_sNotifyVersion = "v2.0"
Global Const $g_iPBRemoteControlInterval = 60000
Global $g_sLootFileName = ""
Global $g_iFreeBuilderCount = 0, $g_iTotalBuilderCount = 0, $g_iGemAmount = 0
Global $g_iFreeBuilderCountBB = 0, $g_iTotalBuilderCountBB = 0
Global $g_iTestFreeBuilderCount = -1
Global $g_iStatsStartedWith[$eLootCount] = [0, 0, 0, 0]
Global $g_iStatsTotalGain[$eLootCount] = [0, 0, 0, 0]
Global $g_iStatsLastAttack[$eLootCount] = [0, 0, 0, 0]
Global $g_iStatsBonusLast[$eLootCount] = [0, 0, 0, 0]
Global $g_iSkippedVillageCount = 0, $g_iDroppedTrophyCount = 0
Global $g_iCostGoldWall = 0, $g_iCostElixirWall = 0, $g_iCostGoldBuilding = 0, $g_iCostElixirBuilding = 0, $g_iCostDElixirHero = 0
Global $g_iNbrOfWallsUpped = 0, $g_iNbrOfWallsUppedGold = 0, $g_iNbrOfWallsUppedElixir = 0
Global $g_iNbrOfBuildingsUppedGold = 0, $g_iNbrOfBuildingsUppedElixir = 0, $g_iNbrOfHeroesUpped = 0
Global $g_iSearchCost = 0, $g_iTrainCostElixir = 0, $g_iTrainCostDElixir = 0, $g_iTrainCostGold = 0
Global $g_iNbrOfOoS = 0
Global $g_iNbrOfTHSnipeFails = 0, $g_iNbrOfTHSnipeSuccess = 0
Global $g_iGoldFromMines = 0, $g_iElixirFromCollectors = 0, $g_iDElixirFromDrills = 0
Global $g_aiAttackedVillageCount[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0]
Global $g_aiTotalGoldGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiTotalElixirGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiTotalDarkGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiTotalTrophyGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0]
Global $g_aiNbrOfDetectedMines[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiNbrOfDetectedCollectors[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_aiNbrOfDetectedDrills[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0]
Global $g_aiAttackedCount = 0
Global $g_iSearchCount = 0
Global Const $g_iMaxTrainSkip = 40
Global $g_iActualTrainSkip = 0
Global $g_iSmartZapGain = 0, $g_iNumEQSpellsUsed = 0, $g_iNumLSpellsUsed = 0
Global $g_bMainWindowOk = False
Global $g_aiCurrentLoot[$eLootCount] = [0, 0, 0, 0]
Global $g_iTownHallLevel = 0
Global $g_aiTownHallPos[2] = [-1, -1]
Global $g_aiKingAltarPos[2] = [-1, -1]
Global $g_aiQueenAltarPos[2] = [-1, -1]
Global $g_aiWardenAltarPos[2] = [-1, -1]
Global $g_aiLaboratoryPos[2] = [-1, -1]
Global $g_aiClanCastlePos[2] = [-1, -1]
Global $g_aiResourcesPos[2] = [-1, -1]
Global $g_iDetectedImageType = 0
Global $g_abNotNeedAllTime[2] = [True, True]
Global $g_aiCurrentLootBB[$eLootCountBB] = [0, 0, 0]
Global $g_aiStarLaboratoryPos[2] = [-1, -1]
Global $g_iArmyCapacity = 0
Global $g_iTotalTrainSpaceSpell = 0
Global $g_iTotalTrainSpaceSiege = 0
Global $g_iCurrentSpells
Global $g_iCurrentCCSpells = 0, $g_iTotalCCSpells = 0
Global $g_bFullArmySpells = False
Global $g_CurrentCampUtilization = 0, $g_iTotalCampSpace = 0
Global $g_iLaboratoryElixirCost = 0, $g_iLaboratoryDElixirCost = 0
Global $g_sLabUpgradeTime = ""
Global $g_sStarLabUpgradeTime = ""
Global $g_avLabTroops[36][5]
Global $g_avStarLabTroops[11][5]
Func TranslateTroopNames()
Dim $g_avLabTroops[36][5] = [ [-1, -1, -1, GetTranslatedFileIni("MBR Global GUI Design", "Any", "Any"), $eIcnBlank], [114, 337 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians"), $eIcnBarbarian], [114, 444 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers"), $eIcnArcher], [221, 337 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants"), $eIcnGiant], [221, 444 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins"), $eIcnGoblin], [327, 337 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers"), $eIcnWallBreaker], [327, 444 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons"), $eIcnBalloon], [434, 337 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards"), $eIcnWizard], [434, 444 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers"), $eIcnHealer], [541, 337 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons"), $eIcnDragon], [541, 444 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas"), $eIcnPekka], [647, 337 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons"), $eIcnBabyDragon], [647, 444 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners"), $eIcnMiner], [114, 337 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtElectroDragons", "Electro Dragons"), $eIcnElectroDragon], [114, 444 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtLightningSpells", "Lightning Spell"), $eIcnLightSpell], [221, 337 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHealingSpells", "Healing Spell"), $eIcnHealSpell], [221, 444 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtRageSpells", "Rage Spell"), $eIcnRageSpell], [327, 337 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtJumpSpells", "Jump Spell"), $eIcnJumpSpell], [327, 444 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtFreezeSpells", "Freeze Spell"), $eIcnFreezeSpell], [434, 337 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtCloneSpells", "Clone Spell"), $eIcnCloneSpell], [434, 444 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtPoisonSpells", "Poison Spell"), $eIcnPoisonSpell], [541, 337 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtEarthQuakeSpells", "EarthQuake Spell"), $eIcnEarthQuakeSpell], [541, 444 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHasteSpells", "Haste Spell"), $eIcnHasteSpell], [647, 337 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtSkeletonSpells", "Skeleton Spell"), $eIcnSkeletonSpell], [647, 444 + $g_iMidOffsetY, 1, GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtBatSpells", "Bat Spell"), $eIcnBatSpell], [114, 337 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions"), $eIcnMinion], [114, 444 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders"), $eIcnHogRider], [221, 337 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries"), $eIcnValkyrie], [221, 444 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems"), $eIcnGolem], _
[327, 337 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches"), $eIcnWitch], [327, 444 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds"), $eIcnLavaHound], [434, 337 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers"), $eIcnBowler], [434, 444 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtIceGolems", "Ice Golems"), $eIcnIceGolem], [541, 337 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallWreckers", "Wall Wreckers"), $eIcnWallW], [541, 444 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBattleBlimps", "Battle Blimps"), $eIcnBattleB], [647, 337 + $g_iMidOffsetY, 2, GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtStoneSlammers", "Stone Slammer"), $eIcnStoneS]]
Dim $g_avStarLabTroops[11][5] = [ [-1, -1, -1, GetTranslatedFileIni("MBR Global GUI Design", "Any", "Any"), $eIcnBlank], [160, 341 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtRagedBarbarian", "Raged Barbarian"), $eIcnRagedBarbarian], [160, 449 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtSneakyArcher", "SneakyArcher"), $eIcnSneakyArcher], [266, 341 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtBoxerGiant", "Boxer Giants"), $eIcnBoxerGiant], [266, 449 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtBetaMinion", "Beta Minion"), $eIcnBetaMinion], [372, 341 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtBomber", "Bomber"), $eIcnBomber], [372, 449 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtBabyDragon", "Baby Dragon"), $eIcnBBBabyDragon], [478, 341 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtCannonCart", "Cannon Cart"), $eIcnCannonCart], [478, 449 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtNightWitch", "Night Witch"), $eIcnNightWitch], [580, 341 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtDropShip", "Drop Ship"), $eIcnDropShip], [580, 449 + $g_iMidOffsetY, 0, GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtSuperPekka", "Super Pekka"), $eIcnSuperPekka]]
EndFunc
Global Const $g_aiWallCost[9] = [25000, 50000, 100000, 250000, 500000, 1000000, 2000000, 4000000, 5000000]
Global $g_iWallCost = 0
Global Const $g_iMaxKingLevel = 60
Global Const $g_iMaxQueenLevel = 60
Global Const $g_iMaxWardenLevel = 30
Global Const $g_afKingUpgCost[60] = [10, 12.5, 15, 17.5, 20, 22.5, 25, 27.5, 30, 32.5, 35, 39, 43, 47, 51, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 129, 133, 137, 141, 145, 149, 153, 157, 161, 165, 170, 173, 176, 179, 182, 185, 188, 191, 194, 197, 200, 203, 206, 209, 212, 215, 218, 221, 224, 227]
Global Const $g_afQueenUpgCost[60] = [40, 22.5, 25, 27.5, 30, 32.5, 35, 39, 43, 47, 51, 55, 59, 63, 67, 71, 75, 80, 85, 90, 95, 100, 105, 110, 115, 119, 123, 127, 131, 135, 139, 143, 147, 151, 155, 159, 163, 167, 171, 175, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236]
Global $g_iWardenLevel = -1
Global Const $g_afWardenUpgCost[30] = [6, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.4, 8.8, 9.1, 9.4, 9.6, 9.8, 10, 10, 10.2, 10.4, 10.6, 10.8, 11, 11.2, 11.4, 11.6, 11.8]
Global $g_bVillageSearchActive = False
Global $g_bCloudsActive = False
Global $g_bAttackActive = False
Global Const $g_iMaxTHLevel = 12
Global Const $g_asTHText[7] = ["4-6", "7", "8", "9", "10", "11", "12"]
Global Const $g_aiSearchCost[12] = [10, 50, 75, 110, 170, 250, 380, 580, 750, 900, 1000, 1100]
Global $g_bSearchMode = False
Global $g_bIsSearchLimit = False
Global $g_bIsClientSyncError = False
Global $g_iSearchGold = 0, $g_iSearchElixir = 0, $g_iSearchDark = 0, $g_iSearchTrophy = 0, $g_iSearchTH = 0
Global $g_aiMaxTH[$g_iModeCount] = [0, 0, 0]
Global $g_iAimGold[$g_iModeCount] = [0, 0, 0], $g_iAimElixir[$g_iModeCount] = [0, 0, 0], $g_iAimGoldPlusElixir[$g_iModeCount] = [0, 0, 0], $g_iAimDark[$g_iModeCount] = [0, 0, 0], $g_iAimTrophy[$g_iModeCount] = [0, 0, 0], $g_iAimTrophyMax[$g_iModeCount] = [99, 99, 99]
Global $g_iTHx = 0, $g_iTHy = 0
Global $g_bOutOfGold = False
Global $g_iTHside = 0, $g_iTHi = 0
Global $g_iSearchTHLResult = 0
Global $g_sTHLoc = "In"
Global $g_sImglocRedline
Global $g_iImglocTHLevel = 0
Global $g_aiTownHallDetails[4] = [-1, -1, -1, -1]
Global Const $g_aaiTopLeftDropPoints[5][2] = [[66, 299], [174, 210], [240, 169], [303, 127], [390, 55]]
Global Const $g_aaiTopRightDropPoints[5][2] = [[466, 60], [556, 120], [622, 170], [684, 220], [775, 285]]
Global Const $g_aaiBottomLeftDropPoints[5][2] = [[81, 390], [174, 475], [235, 521], [299, 570], [390, 610]]
Global Const $g_aaiBottomRightDropPoints[5][2] = [[466, 600], [554, 555], [615, 510], [678, 460], [765, 394]]
Global Const $g_aaiEdgeDropPoints[4] = [$g_aaiBottomRightDropPoints, $g_aaiTopLeftDropPoints, $g_aaiBottomLeftDropPoints, $g_aaiTopRightDropPoints]
Global Const $g_aiUseAllTroops[38] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eEDrag, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eIceG, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eBtSpell, $eWallW, $eBattleB, $eStoneS]
Global Const $g_aiUseBarracks[28] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eEDrag, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseBarbs[16] = [$eBarb, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseArchs[16] = [$eArch, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseBarcher[17] = [$eBarb, $eArch, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseBarbGob[17] = [$eBarb, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseArchGob[17] = [$eArch, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseBarcherGiant[18] = [$eBarb, $eArch, $eGiant, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseBarcherGobGiant[19] = [$eBarb, $eArch, $eGiant, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseBarcherHog[18] = [$eBarb, $eArch, $eHogs, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aiUseBarcherMinion[18] = [$eBarb, $eArch, $eMini, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Global Const $g_aaiTroopsToBeUsed[12] = [$g_aiUseAllTroops, $g_aiUseBarracks, $g_aiUseBarbs, $g_aiUseArchs, $g_aiUseBarcher, $g_aiUseBarbGob, $g_aiUseArchGob, $g_aiUseBarcherGiant, $g_aiUseBarcherGobGiant, $g_aiUseBarcherHog, $g_aiUseBarcherMinion]
Global $g_bTHSnipeUsedKing = False
Global $g_bTHSnipeUsedQueen = False
Global $g_bTHSnipeUsedWarden = False
Global $g_avAttackTroops[22][6]
Global $g_bFullArmy = False
Global $g_iKingSlot = -1, $g_iQueenSlot = -1, $g_iWardenSlot = -1, $g_iClanCastleSlot = -1
Global $g_iTotalAttackSlot = 10, $g_bDraggedAttackBar = False
Global $g_iSiegeLevel = 1
Global $g_iHeroWaitAttackNoBit[$g_iModeCount][3]
Global $g_iHeroAvailable = $eHeroNone
Global $g_iHeroUpgrading[3] = [0, 0, 0]
Global $g_iHeroUpgradingBit = $eHeroNone
Global $g_bCheckKingPower = False
Global $g_bCheckQueenPower = False
Global $g_bCheckWardenPower = False
Global $g_bDropQueen, $g_bDropKing, $g_bDropWarden
Global $g_aiSlotInArmy[$eTroopCount] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
Global $g_aiPixelTopLeft[0]
Global $g_aiPixelBottomLeft[0]
Global $g_aiPixelTopRight[0]
Global $g_aiPixelBottomRight[0]
Global $g_aiPixelTopLeftFurther[0]
Global $g_aiPixelBottomLeftFurther[0]
Global $g_aiPixelTopRightFurther[0]
Global $g_aiPixelBottomRightFurther[0]
Global $g_aiPixelMine[0]
Global $g_aiPixelElixir[0]
Global $g_aiPixelDarkElixir[0]
Global $g_aiPixelNearCollector[0]
Global $g_aiPixelRedArea[0]
Global $g_aiPixelRedAreaFurther[0]
Global Enum $eVectorLeftTop, $eVectorRightTop, $eVectorLeftBottom, $eVectorRightBottom
Global $g_bIsCCDropped = False
Global $g_bIsHeroesDropped = False
Global $g_aiDeployCCPosition[2] = [-1, -1]
Global $g_aiDeployHeroesPosition[2] = [-1, -1]
Global $g_aiCSVGoldStoragePos
Global $g_aiCSVElixirStoragePos
Global $g_aiCSVDarkElixirStoragePos
Global $g_aiCSVEagleArtilleryPos
Global $g_aiCSVInfernoPos
Global $g_aiCSVXBowPos
Global $g_aiCSVWizTowerPos
Global $g_aiCSVMortarPos
Global $g_aiCSVAirDefensePos
Global $g_bCSVLocateMine = False
Global $g_bCSVLocateElixir = False
Global $g_bCSVLocateDrill = False
Global $g_bCSVLocateStorageGold = False
Global $g_bCSVLocateStorageElixir = False
Global $g_bCSVLocateStorageDarkElixir = False
Global $g_bCSVLocateStorageTownHall = False
Global $g_bCSVLocateEagle = False
Global $g_bCSVLocateInferno = False
Global $g_bCSVLocateXBow = False
Global $g_bCSVLocateWizTower = False
Global $g_bCSVLocateMortar = False
Global $g_bCSVLocateAirDefense = False
Global $g_bCSVLocateWall = False
Global $g_iCSVLastTroopPositionDropTroopFromINI = -1
Global $ATTACKVECTOR_A, $ATTACKVECTOR_B, $ATTACKVECTOR_C, $ATTACKVECTOR_D, $ATTACKVECTOR_E, $ATTACKVECTOR_F
Global $ATTACKVECTOR_G, $ATTACKVECTOR_H, $ATTACKVECTOR_I, $ATTACKVECTOR_J, $ATTACKVECTOR_K, $ATTACKVECTOR_L
Global $ATTACKVECTOR_M, $ATTACKVECTOR_N, $ATTACKVECTOR_O, $ATTACKVECTOR_P, $ATTACKVECTOR_Q, $ATTACKVECTOR_R
Global $ATTACKVECTOR_S, $ATTACKVECTOR_T, $ATTACKVECTOR_U, $ATTACKVECTOR_V, $ATTACKVECTOR_W, $ATTACKVECTOR_X
Global $ATTACKVECTOR_Y, $ATTACKVECTOR_Z
Global $g_bDuringMilkingAttack = False
Global Const $g_asMilkFarmOffsetMine[9] = ["1-1", "1-1", "0-2", "0-4", "1-2", "1-1", "3-5", "3-6", "3-5"]
Global Const $g_asMilkFarmOffsetElixir[9] = ["1-11", "1-11", "1-9", "1-13", "0-11", "0-11", "0-13", "0-11", "0-14"]
Global Const $g_asMilkFarmOffsetDark[7] = ["0-0", "1-4", "1-3", "0-5", "4-8", "0-4", "0-3"]
Global $g_bTrainEnabled = True
Global $g_bIsFullArmywithHeroesAndSpells = False
Global $g_bOutOfElixir = False
Global $g_aiTimeTrain[4] = [0, 0, 0, 0]
Global Enum $ArmyTAB, $TrainTroopsTAB, $BrewSpellsTAB, $QuickTrainTAB
Global $g_bCheckSpells = False
Global Const $g_aiDonateTroopPriority[$eTroopCount] = [ $eTroopLavaHound, $eTroopElectroDragon, $eTroopGolem, $eTroopIceGolem, $eTroopPekka, $eTroopDragon, $eTroopWitch, $eTroopHealer, $eTroopBabyDragon, $eTroopValkyrie, $eTroopBowler, $eTroopMiner, $eTroopGiant, $eTroopBalloon, $eTroopHogRider, $eTroopWizard, $eTroopWallBreaker, $eTroopMinion, $eTroopArcher, $eTroopBarbarian, $eTroopGoblin]
Global Const $g_aiDonateSpellPriority[$eSpellCount] = [ $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellClone, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton, $eSpellBat]
Global $g_aiDonateStatsTroops[$eTroopCount][2] = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
Global $g_aiDonateStatsSpells[$eSpellCount][2] = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
Global $g_aiDonateStatsSieges[$eSiegeMachineCount][3] = [[0, 0], [0, 0], [0, 0]]
Global $g_iTotalDonateStatsTroops = 0, $g_iTotalDonateStatsTroopsXP = 0
Global $g_iTotalDonateStatsSpells = 0, $g_iTotalDonateStatsSpellsXP = 0
Global $g_iTotalDonateStatsSiegeMachines = 0, $g_iTotalDonateStatsSiegeMachinesXP = 0
Global $g_iActiveDonate = -1
Global $g_aiDonateTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_aiDonateSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_aiDonateSiegeMachines[$eSiegeMachineCount] = [0, 0, 0]
Global $g_aiCurrentTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_aiCurrentSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_aiCurrentSiegeMachines[$eSiegeMachineCount] = [0, 0, 0]
Global $g_aiCurrentCCTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_aiCurrentCCSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_aiCurrentCCSiegeMachines[$eSiegeMachineCount] = [0, 0, 0]
Global $g_bDonationEnabled = True
Global $g_iTroopsDonated = 0
Global $g_iTroopsReceived = 0
Global $g_iDonationWindowY = 0
Global $g_avDTtroopsToBeUsed[8][2] = [["Barb", 0], ["Arch", 0], ["Giant", 0], ["Wall", 0], ["Gobl", 0], ["Mini", 0], ["Ball", 0], ["Wiza", 0]]
Global $g_bMinorObstacle = False
Global $g_bGfxError = False
Global Const $g_iTaBChkAttack = 0x01
Global Const $g_iTaBChkIdle = 0x02
Global Const $g_iTaBChkTime = 0x04
Global $g_bDisableBreakCheck = False
Global $g_sPBStartTime = ""
Global $g_asShieldStatus = ["", "", ""]
Global Enum $eSideBuildingDES, $eSideBuildingTH
Global $g_iBuildingEdge = 0, $g_iBuildingToLoc = ""
Global $g_iDarkLow = 0
Global $g_iCCRemainTime = 0
Global $g_bCanRequestCC = True
Global $__TEST_ERROR_ADB_DEVICE_NOT_FOUND = False
Global $__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY = 0
Global $__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY = 0
Global $__TEST_ERROR_SLOW_ADB_CLICK_DELAY = 0
Global $g_iLSpellLevel = 1
Global $g_iESpellLevel = 1
Global Const $g_fDarkStealFactor = 0.75
Global Const $g_fDarkFillLevel = 0.70
Global Const $g_aDrillLevelHP[7] = [800, 860, 920, 980, 1060, 1160, 1280]
Global Const $g_aDrillLevelTotal[7] = [160, 300, 540, 840, 1280, 1800, 2400]
Global Const $g_aLSpellDmg[7] = [300, 360, 420, 480, 540, 600, 660]
Global Const $g_aEQSpellDmg[4] = [0.14, 0.17, 0.21, 0.25]
Global Enum $eWeakEagle = 1, $eWeakInferno, $eWeakXBow, $eWeakWizard, $eWeakMortar, $eWeakAirDefense
Global $g_aWeakDefenseNames = ["None", "Eagle Artillery", "Inferno Tower", "XBow", "Wizard Tower", "Mortar", "Air Defense"]
Global Enum $eBldgRedLine, $eBldgTownHall, $eBldgGoldM, $eBldgElixirC, $eBldgDrill, $eBldgGoldS, $eBldgElixirS, $eBldgDarkS, $eBldgEagle, $eBldgInferno, $eBldgXBow, $eBldgWizTower, $eBldgMortar, $eBldgAirDefense, $eExternalWall, $eInternalWall
Global $g_sBldgNames = ["Red Line", "Town Hall", "Gold Mine", "Elixir Collector", "Dark Elixir Drill", "Gold Storage", "Elixir Storage", "Dark Elixir Storage", "Eagle Artillery", "Inferno Tower", "XBow", "Wizard Tower", "Mortar", "Air Defense", "External Wall", "Internal Wall"]
Global Const $g_iMaxCapTroopTH[13] = [0, 20, 30, 70, 80, 135, 150, 200, 200, 220, 240, 260, 280]
Global Const $g_iMaxCapSpellTH[13] = [0, 0, 0, 0, 0, 2, 4, 6, 7, 9, 11, 11, 11]
Global $g_oBldgAttackInfo = ObjCreate("Scripting.Dictionary")
$g_oBldgAttackInfo.CompareMode = 1
Global $g_oBldgLevels = ObjCreate("Scripting.Dictionary")
Func _FilloBldgLevels()
Local Const $aBldgCollector[12] = [2, 4, 6, 8, 10, 10, 11, 12, 12, 12, 12, 12]
$g_oBldgLevels.add($eBldgGoldM, $aBldgCollector)
$g_oBldgLevels.add($eBldgElixirC, $aBldgCollector)
Local Const $aBldgDrill[12] = [0, 0, 0, 0, 0, 0, 3, 3, 6, 6, 6, 6]
$g_oBldgLevels.add($eBldgDrill, $aBldgDrill)
Local Const $aBldgStorage[12] = [1, 3, 6, 8, 9, 10, 11, 11, 11, 11, 12, 13]
$g_oBldgLevels.add($eBldgGoldS, $aBldgStorage)
$g_oBldgLevels.add($eBldgElixirS, $aBldgStorage)
Local Const $aBldgDarkStorage[12] = [0, 0, 0, 0, 0, 0, 2, 4, 6, 6, 6, 7]
$g_oBldgLevels.add($eBldgDarkS, $aBldgDarkStorage)
Local Const $aBldgEagle[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3]
$g_oBldgLevels.add($eBldgEagle, $aBldgEagle)
Local Const $aBldgInferno[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 6]
$g_oBldgLevels.add($eBldgInferno, $aBldgInferno)
Local Const $aBldgMortar[12] = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11]
$g_oBldgLevels.add($eBldgMortar, $aBldgMortar)
Local Const $aBldgWizTower[12] = [0, 0, 0, 0, 2, 3, 4, 6, 7, 9, 10, 11]
$g_oBldgLevels.add($eBldgWizTower, $aBldgWizTower)
Local Const $aBldgXBow[12] = [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6]
$g_oBldgLevels.add($eBldgXBow, $aBldgXBow)
Local Const $aBldgAirDefense[12] = [0, 0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10]
$g_oBldgLevels.add($eBldgAirDefense, $aBldgAirDefense)
EndFunc
_FilloBldgLevels()
Global $g_oBldgMaxQty = ObjCreate("Scripting.Dictionary")
Func _FilloBldgMaxQty()
Local Const $aBldgCollector[12] = [1, 2, 3, 4, 5, 6, 6, 6, 6, 7, 7, 7]
$g_oBldgMaxQty.add($eBldgGoldM, $aBldgCollector)
$g_oBldgMaxQty.add($eBldgElixirC, $aBldgCollector)
Local Const $aBldgDrill[12] = [0, 0, 0, 0, 0, 0, 1, 2, 2, 3, 3, 3]
$g_oBldgMaxQty.add($eBldgDrill, $aBldgDrill)
Local Const $aBldgStorage[12] = [1, 1, 2, 2, 2, 2, 2, 3, 4, 4, 4, 4]
$g_oBldgMaxQty.add($eBldgGoldS, $aBldgStorage)
$g_oBldgMaxQty.add($eBldgElixirS, $aBldgStorage)
Local Const $aBldgDarkStorage[12] = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
$g_oBldgMaxQty.add($eBldgDarkS, $aBldgDarkStorage)
Local Const $aBldgEagle[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]
$g_oBldgMaxQty.add($eBldgEagle, $aBldgEagle)
Local Const $aBldgInferno[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2]
$g_oBldgMaxQty.add($eBldgInferno, $aBldgInferno)
Local Const $aBldgMortar[12] = [0, 0, 1, 1, 1, 2, 3, 4, 4, 4, 4, 4]
$g_oBldgMaxQty.add($eBldgMortar, $aBldgMortar)
Local Const $aBldgWizTower[12] = [0, 0, 0, 0, 1, 2, 2, 3, 4, 4, 5, 5]
$g_oBldgMaxQty.add($eBldgWizTower, $aBldgWizTower)
Local Const $aBldgXBow[12] = [0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4]
$g_oBldgMaxQty.add($eBldgXBow, $aBldgXBow)
Local Const $aBldgAirDefense[12] = [0, 0, 0, 1, 1, 2, 3, 3, 4, 4, 4, 4]
$g_oBldgMaxQty.add($eBldgAirDefense, $aBldgAirDefense)
EndFunc
_FilloBldgMaxQty()
Global $g_oBldgImages = ObjCreate("Scripting.Dictionary")
$g_oBldgImages.add($eBldgTownHall & "_" & "0", "imglocth-bundle")
$g_oBldgImages.add($eBldgTownHall & "_" & "1", "snow-imglocth-bundle")
$g_oBldgImages.add($eBldgGoldM & "_" & "0", @ScriptDir & "\imgxml\Storages\Mines")
$g_oBldgImages.add($eBldgGoldM & "_" & "1", @ScriptDir & "\imgxml\Storages\Mines_Snow")
$g_oBldgImages.add($eBldgElixirC & "_" & "0", @ScriptDir & "\imgxml\Storages\Collectors")
$g_oBldgImages.add($eBldgElixirC & "_" & "1", @ScriptDir & "\imgxml\Storages\CollectorsSnow")
$g_oBldgImages.add($eBldgDrill & "_" & "0", @ScriptDir & "\imgxml\Storages\Drills")
$g_oBldgImages.add($eBldgGoldS & "_" & "0", @ScriptDir & "\imgxml\Storages\Gold")
$g_oBldgImages.add($eBldgElixirS & "_" & "0", @ScriptDir & "\imgxml\Storages\Elixir")
$g_oBldgImages.add($eBldgEagle & "_" & "0", @ScriptDir & "\imgxml\Buildings\Eagle")
$g_oBldgImages.add($eBldgInferno & "_" & "0", @ScriptDir & "\imgxml\Buildings\Infernos")
$g_oBldgImages.add($eBldgXBow & "_" & "0", @ScriptDir & "\imgxml\Buildings\Xbow")
$g_oBldgImages.add($eBldgWizTower & "_" & "0", @ScriptDir & "\imgxml\Buildings\WTower")
$g_oBldgImages.add($eBldgWizTower & "_" & "1", @ScriptDir & "\imgxml\Buildings\WTowerSnow")
$g_oBldgImages.add($eBldgMortar & "_" & "0", @ScriptDir & "\imgxml\Buildings\Mortars")
$g_oBldgImages.add($eBldgAirDefense & "_" & "0", @ScriptDir & "\imgxml\Buildings\ADefense")
Global $g_bChkClanGamesAir = 0, $g_bChkClanGamesGround = 0, $g_bChkClanGamesMisc = 0
Global $g_bChkClanGamesEnabled = 0
Global $g_bChkClanGames60 = 0
Global $g_bChkClanGamesLoot = 0
Global $g_bChkClanGamesBattle = 0
Global $g_bChkClanGamesDestruction = 0
Global $g_bChkClanGamesAirTroop = 0
Global $g_bChkClanGamesGroundTroop = 0
Global $g_bChkClanGamesMiscellaneous = 0
Global $g_bChkClanGamesPurge = 0
Global $g_bChkClanGamesStopBeforeReachAndPurge = 0
Global $g_bChkClanGamesDebug = 0
Global $g_iPurgeJobCount[8] = [0, 0, 0, 0, 0, 0, 0, 0]
Global $g_iPurgeMax = 5
Global $g_bChkCollectFreeMagicItems = True
Global $g_bOnlySCIDAccounts = False
Global $g_iWhatSCIDAccount2Use = 0
Global $g_bUseStatistics = False
Global $g_hSQLiteDB = Null
Global Const $g_sTabletName = "mybotrun"
Global $g_sDate = Null
Global $g_sProfilename = Null
Global $g_sSearchCount = Null
Global $g_sAttacksides = Null
Global $g_sResourcesIN = Null
Global $g_sResourcesOUT = Null
Global $g_sResBySide = Null
Global $g_sOppThlevel = Null
Global $g_sOppGold = Null
Global $g_sOppElixir = Null
Global $g_sOppDE = Null
Global $g_sOppTrophies = Null
Global $g_sTotalDamage = Null
Global $g_sLootGold = Null
Global $g_sLootElixir = Null
Global $g_sLootDE = Null
Global $g_sLeague = Null
Global $g_sBonusGold = Null
Global $g_sBonusElixir = Null
Global $g_sBonusDE = Null
Global $g_sPercentagesResources = Null
Global $g_sStarsEarned = Null
Func _ArrayIndexValid(Const ByRef $a, Const $idx)
Return $idx >= 0 And $idx < UBound($a)
EndFunc
Global $cmbCSVSpeed[2] = [$LB, $DB]
Global $icmbCSVSpeed[2] = [2, 2]
Global $g_CSVSpeedDivider[2] = [1, 1]
Global $g_bRequestCCDefense = False, $g_sRequestCCDefenseText = "", $g_bRequestCCDefenseWhenPB, $g_iRequestDefenseTime, $g_bSaveCCTroopForDefense = True
Global $g_aiCCTroopsExpectedForDefense[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_aiCCTroopDefenseType[3], $g_aiCCTroopDefenseQty[3]
Global $g_bEnableAuto = False, $g_bChkAutoDock = False, $g_bChkAutoHideEmulator = True, $g_bChkAutoMinimizeBot = False
Global $g_sNextBuilderReadyTime = ""
Global $g_bTrainLogoutMaxTime = False, $g_iTrainLogoutMaxTime = 4
Global $g_bIsSearchTimeout = False, $g_iSearchTimeout = 10, $g_iTotalSearchTime = 0
Global $g_bChkClanHop = False
Global Const $DELAYSLEEP = 100
Global Const $DELAYWAITFORPOPUP = 1500
Global Const $DELAYCLOUDSCLEARED = 1000
Global Const $DELAYRESPOND = 5
Global Const $DELAYRUNBOT1 = 1000
Global Const $DELAYRUNBOT2 = 800
Global Const $DELAYRUNBOT3 = 200
Global Const $DELAYRUNBOT5 = 500
Global Const $DELAYRUNBOT6 = 100
Global Const $DELAYIDLE1 = 200
Global Const $DELAYSMARTWAIT = 500
Global Const $DELAYATTACKMAIN1 = 1000
Global Const $DELAYATTACKMAIN2 = 1500
Global Const $DELAYATTCKTHGRID1 = 500
Global Const $DELAYCASTSPELL1 = 10
Global Const $DELAYALGORITHM_ALLTROOPS1 = 2000
Global Const $DELAYALGORITHM_ALLTROOPS2 = 1000
Global Const $DELAYALGORITHM_ALLTROOPS3 = $DELAYWAITFORPOPUP
Global Const $DELAYALGORITHM_ALLTROOPS4 = 100
Global Const $DELAYALGORITHM_ALLTROOPS5 = 250
Global Const $DELAYATTACKREPORT1 = 500
Global Const $DELAYATTACKREPORT2 = 150
Global Const $DELAYDROPCC1 = 500
Global Const $DELAYDROPHEROES1 = 300
Global Const $DELAYDROPHEROES2 = 500
Global Const $DELAYCHECKHEROESHEALTH = 4000
Global Const $DELAYGOLDELIXIRCHANGE1 = 500
Global Const $DELAYGOLDELIXIRCHANGE2 = 1000
Global Const $DELAYGOLDELIXIRCHANGEEBO1 = 500
Global Const $DELAYGOLDELIXIRCHANGEEBO2 = 1000
Global Const $DELAYPREPAREATTACK1 = 250
Global Const $DELAYDROPTROOP1 = 100
Global Const $DELAYDROPTROOP2 = 300
Global Const $DELAYRETURNHOME1 = 1000
Global Const $DELAYRETURNHOME2 = 1500
Global Const $DELAYRETURNHOME3 = 2500
Global Const $DELAYRETURNHOME4 = 2000
Global Const $DELAYRETURNHOME5 = 200
Global Const $DELAYDROPONEDGE1 = 100
Global Const $DELAYDROPONEDGE2 = 300
Global Const $DELAYDROPONEDGE3 = 50
Global Const $DELAYLAUNCHTROOP21 = 100
Global Const $DELAYLAUNCHTROOP22 = 1000
Global Const $DELAYLAUNCHTROOP23 = 300
Global Const $DELAYOLDDROPTROOP1 = 100
Global Const $DELAYOLDDROPTROOP2 = 50
Global Const $DELAYUNBREAKABLE1 = 1000
Global Const $DELAYUNBREAKABLE2 = 2000
Global Const $DELAYUNBREAKABLE3 = 3000
Global Const $DELAYUNBREAKABLE4 = 5000
Global Const $DELAYUNBREAKABLE6 = 30000
Global Const $DELAYUNBREAKABLE7 = 100
Global Const $DELAYUNBREAKABLE8 = 50
Global Const $DELAYCHECKTOMBS1 = 500
Global Const $DELAYCHECKTOMBS2 = 2000
Global Const $DELAYCHECKMAINSCREEN1 = 1000
Global Const $DELAYCHECKOBSTACLES1 = 1000
Global Const $DELAYCHECKOBSTACLES2 = 2000
Global Const $DELAYCHECKOBSTACLES3 = 5000
Global Const $DELAYCHECKOBSTACLES4 = 120000
Global Const $DELAYCHECKOBSTACLES6 = 300000
Global Const $DELAYCHECKOBSTACLES7 = 600000
Global Const $DELAYCHECKOBSTACLES8 = 900000
Global Const $DELAYCHECKOBSTACLES9 = 1200000
Global Const $DELAYCHECKOBSTACLES10 = 1800000
Global Const $DELAYISGEMOPEN1 = 350
Global Const $DELAYISBUILDERBASE = 300
Global Const $DELAYWAITMAINSCREEN1 = 2000
Global Const $DELAYZOOMOUT1 = 1500
Global Const $DELAYZOOMOUT2 = 200
Global Const $DELAYZOOMOUT3 = 1000
Global Const $DELAYDOWNLOADLICENSE = 250
Global Const $DELAYTOGGLEPAUSE1 = 100
Global Const $DELAYTOGGLEPAUSE2 = 250
Global Const $DELAYWINDOWSARRANGE1 = 500
Global Const $DELAYBUILDINGINFO1 = 1500
Global Const $DELAYGETRESOURCES1 = 250
Global Const $DELAYGETRESOURCES3 = 150
Global Const $DELAYPREPARESEARCH1 = 1000
Global Const $DELAYPREPARESEARCH2 = 2000
Global Const $DELAYVILLAGESEARCH1 = 1000
Global Const $DELAYVILLAGESEARCH2 = 100
Global Const $DELAYVILLAGESEARCH3 = 500
Global Const $DELAYBOOSTBARRACKS1 = 1000
Global Const $DELAYBOOSTBARRACKS2 = 600
Global Const $DELAYBOOSTBARRACKS3 = 200
Global Const $DELAYBOOSTHEROES1 = 1000
Global Const $DELAYBOOSTHEROES2 = 2000
Global Const $DELAYBOOSTHEROES3 = 500
Global Const $DELAYBOOSTHEROES4 = 600
Global Const $DELAYBOTCOMMAND1 = 500
Global Const $DELAYBOTDETECT1 = 1000
Global Const $DELAYBOTDETECT3 = 100
Global Const $DELAYCHECKARMYCAMP4 = 500
Global Const $DELAYCHECKARMYCAMP5 = 250
Global Const $DELAYCHECKARMYCAMP6 = 10
Global Const $DELAYCHECKFULLARMY1 = 100
Global Const $DELAYCHECKFULLARMY2 = 200
Global Const $DELAYCHECKFULLARMY3 = 500
Global Const $DELAYCOLLECT1 = 100
Global Const $DELAYCOLLECT2 = 250
Global Const $DELAYCOLLECT3 = 500
Global Const $DELAYDONATECC1 = 200
Global Const $DELAYDONATECC2 = 250
Global Const $DELAYDONATECC3 = 50
Global Const $DELAYDONATECC4 = 1250
Global Const $DELAYDONATEWINDOW1 = 1000
Global Const $DELAYDONATEWINDOW2 = 100
Global Const $DELAYDROPTROPHY1 = 1000
Global Const $DELAYDROPTROPHY4 = 250
Global Const $DELAYGETTHLEVEL1 = 1000
Global Const $DELAYGETTHLEVEL2 = 1500
Global Const $DELAYGETTHLEVEL3 = 200
Global Const $DELAYLABORATORY1 = 1000
Global Const $DELAYLABORATORY2 = 200
Global Const $DELAYLABORATORY3 = 1000
Global Const $DELAYLABORATORY4 = 200
Global Const $DELAYLABORATORY5 = 1500
Global Const $DELAYLABUPGRADE1 = 1000
Global Const $DELAYLABUPGRADE2 = 200
Global Const $DELAYLABUPGRADE3 = 200
Global Const $DELAYLOCATETH1 = 1000
Global Const $DELAYCHECKUPGRADES = 1000
Global Const $DELAYUPGRADEVALUE1 = 200
Global Const $DELAYUPGRADEVALUE2 = 800
Global Const $DELAYUPGRADEVALUE4 = 1000
Global Const $DELAYUPGRADEVALUE5 = 1250
Global Const $DELAYDEBUGIMAGESAVE1 = 200
Global Const $DELAYPROFILEREPORT1 = 500
Global Const $DELAYPROFILEREPORT2 = 1000
Global Const $DELAYPROFILEREPORT3 = 200
Global Const $DELAYNOTIFY1 = 500
Global Const $DELAYPUSHMSG1 = 500
Global Const $DELAYPUSHMSG2 = 1000
Global Const $DELAYTREASURY1 = 500
Global Const $DELAYTREASURY2 = 1500
Global Const $DELAYTREASURY4 = 200
Global Const $DELAYREPLAYSHARE1 = 250
Global Const $DELAYREPLAYSHARE2 = 500
Global Const $DELAYREQUESTCC1 = 1000
Global Const $DELAYMAKEREQUEST1 = 500
Global Const $DELAYMAKEREQUEST2 = 1500
Global Const $DELAYTRAIN1 = 1000
Global Const $DELAYTRAIN6 = 20
Global Const $DELAYTRAIN8 = 5000
Global Const $DELAYLVUP = 150
Global Const $DELAYISTRAINPAGE2 = 1000
Global Const $DELAYAUTOUPGRADEBUILDING1 = 1000
Global Const $DELAYUPGRADEBUILDING1 = 200
Global Const $DELAYUPGRADEBUILDING2 = 500
Global Const $DELAYUPGRADENORMAL1 = 700
Global Const $DELAYUPGRADENORMAL2 = 200
Global Const $DELAYUPGRADENORMAL3 = 750
Global Const $DELAYUPGRADEHERO1 = 800
Global Const $DELAYUPGRADEHERO2 = 500
Global Const $DELAYUPGRADEHERO3 = 1000
Global Const $DELAYUPGRADEWALL1 = 500
Global Const $DELAYUPGRADEWALLGOLD2 = 1000
Global Const $DELAYUPGRADEWALLGOLD3 = 500
Global Const $DELAYUPGRADEWALLELIXIR2 = 1000
Global Const $DELAYUPGRADEWALLELIXIR3 = 500
Global Const $DELAYVILLAGEREPORT1 = 500
Global Const $DELAYWAITNOPENCOC10000 = 10000
Global Const $DELAYSEARCHLIMIT = 200
Global Const $DELAYCHECKIMAGETYPE1 = 100
Global Const $DELAYSPECIALCLICK1 = 200
Global Const $DELAYSPECIALCLICK2 = 100
Global Const $DELAYPERSONALSHIELD1 = 1000
Global Const $DELAYPERSONALSHIELD2 = 500
Global Const $DELAYPERSONALSHIELD3 = 100
Global Const $DELAYSTARBONUS100 = 100
Global Const $DELAYSTARBONUS500 = 500
Global Const $DELAYATTACKDISABLE100 = 100
Global Const $DELAYATTACKDISABLE500 = 500
Global Const $DELAYWAITATTACK1 = 60000
Global Const $DELAYWAITATTACK2 = 300000
Global Const $DELAYCLOSEOPEN500 = 500
Global Const $DELAYCLOSEOPEN1000 = 1000
Global Const $DELAYCLOSEOPEN2000 = 2000
Global Const $DELAYCLOSEOPEN3000 = 3000
Global $DELAYSMARTZAP1 = 1000
Global $DELAYSMARTZAP4 = 4000
Global $DELAYSMARTZAP10 = 10000
Global $DELAYSWITCHBASES1 = 1000
Global $DELAYCLOCKTOWER1 = 1000
Global $DELAYCLOCKTOWER2 = 200
Global $g_hSplash = 0, $g_hSplashProgress, $g_lSplashStatus, $g_lSplashPic, $g_lSplashTitle
Global $g_iSplashTotalSteps = Default
Global $g_iSplashCurrentStep = 0
Global $g_hSplashTimer = 0
Global $g_hSplashMutex = 0
Func SplashStep($status, $bIncreaseStep = True)
If $bIncreaseStep = True Then $g_iSplashCurrentStep += 1
SetDebugLog("SplashStep " & $g_iSplashCurrentStep & " of " & $g_iSplashTotalSteps & ": " & $status & "(" & Round(__TimerDiff($g_hSplashTimer) / 1000, 2) & " sec)")
If $g_bDisableSplash Then Return
GUICtrlSetData($g_hSplashProgress,($g_iSplashCurrentStep / $g_iSplashTotalSteps) * 100)
GUICtrlSetData($g_lSplashStatus, $status)
If $g_bMyBotDance Then
Static $aSplashInfo, $iStartX, $iStartY, $iStep, $iStepIndex = 0
If $iStepIndex = 0 Then
$aSplashInfo = WinGetPos($g_hSplash)
If @error Then SetLog("SplashStep " & $g_iSplashCurrentStep & " Failed to find GUI Window!", $COLOR_ERROR)
$iStartY = Int(@DesktopHeight - 50 - $aSplashInfo[3])
$iStartX = Int((@DesktopWidth / 2) -($aSplashInfo[2] / 2))
$iStep = Int($iStartY /($g_iSplashTotalSteps - 1))
EndIf
Local $aSplashLoc[10][2] = [[-100, 0], [100, $iStep], [-100, $iStep * 2], [100, $iStep * 3], [-100, $iStep * 4], [100, $iStep * 5], [-100, $iStep * 6], [100, $iStep * 7], [-100, $iStep * 8], [0, $iStep * 9]]
WinMove($g_hSplash, "", $iStartX - $aSplashLoc[$iStepIndex][0], $iStartY - $aSplashLoc[$iStepIndex][1], Default, Default, 8)
$iStepIndex += 1
If $iStepIndex > 9 Then $iStepIndex = 0
EndIf
EndFunc
Func UpdateSplashTitle($title)
SetDebugLog("UpdateSplashTitle: " & $title)
If $g_bDisableSplash Then Return
GUICtrlSetData($g_lSplashTitle, $title)
EndFunc
Func DestroySplashScreen($bReleaseMutex = True)
If $g_hSplash And IsHWnd($g_hSplash) Then
GUIDelete($g_hSplash)
$g_hSplash = 0
EndIf
If $bReleaseMutex Then
ReleaseMutex($g_hSplashMutex)
$g_hSplashMutex = 0
EndIf
EndFunc
Func MoveSplashScreen()
_WinAPI_PostMessage($g_hSplash, $WM_SYSCOMMAND, 0xF012, 0)
EndFunc
Func CreateSplashScreen($iSteps = Default)
Local $iGuiState = @SW_SHOWNOACTIVATE
Local $bDisableSplash = $g_bDisableSplash
Local $bCustomWindow = IsString($iSteps)
If $iSteps = Default Then
$g_iSplashTotalSteps = 10
Else
$iGuiState = @SW_SHOW
$bDisableSplash = False
If Not $bCustomWindow Then
$g_iSplashTotalSteps = $iSteps
$g_iSplashCurrentStep = 0
$g_hSplashTimer = 0
EndIf
EndIf
Local $sSplashImg = $g_sLogoLoading
Local $hImage, $iX, $iY
Local $iT = 4
Local $iB = 0
If Not $bCustomWindow Then
Switch $g_iGuiMode
Case 0
$g_iSplashTotalSteps = 3
Case 2
$g_iSplashTotalSteps = 4
EndSwitch
$g_hSplashMutex = AcquireMutexTicket("Launching", 1, Default, False)
EndIf
If $bDisableSplash = False Or $bCustomWindow Then
Local $hSplashImg = _GDIPlus_BitmapCreateFromFile($sSplashImg)
$iX = _GDIPlus_ImageGetWidth($hSplashImg)
$iY = _GDIPlus_ImageGetHeight($hSplashImg)
Local $iHeight = $iY + $iT + $iB + 60
Local $iCenterX = @DesktopWidth / 2
Local $iCenterY = @DesktopHeight / 2
If $g_bMyBotDance Then
Local $iTop = @DesktopHeight - 50 - $iHeight
Else
Local $iTop = $iCenterY - $iHeight / 2
EndIf
Local $iLeft = $iCenterX - $iX / 2
$g_hSplash = GUICreate("", $iX, $iHeight, $iLeft, $iTop, BitOR($WS_POPUP, $WS_BORDER, $DS_MODALFRAME), BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE, $WS_EX_TOOLWINDOW))
GUISetBkColor($COLOR_WHITE, $g_hSplash)
$g_lSplashPic = _GUICtrlCreatePic($hSplashImg, 0, $iT)
GUICtrlSetOnEvent(-1, "MoveSplashScreen")
If Not $bCustomWindow Then
$g_lSplashTitle = GUICtrlCreateLabel($g_sBotTitle, 15, $iY + $iT + $iB + 3, $iX - 30, 15, $SS_CENTER)
GUICtrlSetOnEvent(-1, "MoveSplashScreen")
$g_hSplashProgress = GUICtrlCreateProgress(15, $iY + $iT + $iB + 20, $iX - 30, 10, $PBS_SMOOTH, BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE, $WS_EX_TOOLWINDOW))
$g_lSplashStatus = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_Loading", "Loading..."), 15, $iY + $iT + $iB + 38, $iX - 30, 15, $SS_CENTER)
GUICtrlSetOnEvent(-1, "MoveSplashScreen")
Else
$g_lSplashTitle = 0
$g_hSplashProgress = 0
$g_lSplashStatus = 0
EndIf
_GDIPlus_BitmapDispose($hSplashImg)
If $g_bDebugSetlog Then SetDebugLog("Splash created: $g_hSplash=" & $g_hSplash & ", $g_lSplashPic=" & $g_lSplashPic & ", $g_lSplashTitle=" & $g_lSplashTitle & ", $g_hSplashProgress=" & $g_hSplashProgress & ", $g_lSplashStatus=" & $g_lSplashStatus)
If Not $bCustomWindow Then
GUISetState($iGuiState, $g_hSplash)
$g_hSplashTimer = __TimerInit()
EndIf
Local $a = [$iX, $iHeight, $iY + $iT + $iB]
Return $a
EndIf
EndFunc
Global $aCenterEnemyVillageClickDrag = [65, 545]
Global $aCenterHomeVillageClickDrag = [430, 650]
Global $aIsReloadError[4] = [457, 301 + $g_iMidOffsetY, 0x33B5E5, 10]
Global $aIsMain[4] = [278, 9, 0x77BDE0, 20]
Global $aIsMainGrayed[4] = [278, 9, 0x3C5F70, 15]
Global $aIsOnBuilderBase[4] = [838, 18, 0xffff46, 10]
Global $aIsConnectLost[4] = [255, 271 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aIsCheckOOS[4] = [223, 272 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aIsMaintenance[4] = [350, 273 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aReloadButton[4] = [443, 408 + $g_iMidOffsetY, 0x282828, 10]
Global $aReloadButton51[4] = [205, 390 + $g_iMidOffsetY, 0x434545, 10]
Global $aAttackButton[2] = [60, 614 + $g_iBottomOffsetY]
Global $aFindMatchButton[4] = [195, 480 + $g_iBottomOffsetY, 0xFFBF43, 10]
Global $aFindMatchButton2[4] = [195, 480 + $g_iBottomOffsetY, 0xE75D0D, 10]
Global $aIsAttackShield[4] = [250, 415 + $g_iMidOffsetY, 0xE8E8E0, 10]
Global $aAway[2] = [175, 10]
Global $aNoShield[4] = [448, 20, 0x43484B, 15]
Global $aHaveShield[4] = [455, 19, 0xF0F8FB, 15]
Global $aHavePerGuard[4] = [455, 19, 0x10100D, 15]
Global $aShieldInfoButton[4] = [431, 10, 0x75BDE4, 15]
Global $aIsShieldInfo[4] = [645, 195, 0xED1115, 20]
Global $aSurrenderButton[4] = [70, 545 + $g_iBottomOffsetY, 0xC00000, 40]
Global $aConfirmSurrender[4] = [500, 415 + $g_iMidOffsetY, 0x60AC10, 20]
Global $aCancelFight[4] = [822, 48, 0xD80408, 20]
Global $aCancelFight2[4] = [830, 59, 0xD80408, 20]
Global $aEndFightSceneBtn[4] = [429, 519 + $g_iMidOffsetY, 0xB8E35F, 20]
Global $aEndFightSceneAvl[4] = [241, 196 + $g_iMidOffsetY, 0xFFF090, 20]
Global $aEndFightSceneReportGold = $aEndFightSceneAvl
Global $aReturnHomeButton[4] = [376, 567 + $g_iMidOffsetY, 0x60AC10, 20]
Global $aChatTab[4] = [331, 325 + $g_iMidOffsetY, 0xF0951D, 30]
Global $aChatTab2[4] = [331, 330 + $g_iMidOffsetY, 0xF0951D, 30]
Global $aChatTab3[4] = [331, 335 + $g_iMidOffsetY, 0xF0951D, 30]
Global $aOpenChat[2] = [19, 350 + $g_iMidOffsetY]
Global $aClanTab[2] = [189, 24]
Global $aArmyCampSize[2] = [110, 136 + $g_iMidOffsetY]
Global $aArmySpellSize[2] = [99, 284 + $g_iMidOffsetY]
Global $g_aArmyCCSpellSize[2] = [473, 438 + $g_iMidOffsetY]
Global $aArmyCCRemainTime[2] = [782, 552 + $g_iMidOffsetY]
Global $aIsCampFull[4] = [128, 151 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aBarrackFull[4] = [388, 154 + $g_iMidOffsetY, 0xE84D50, 20]
Global $aBuildersDigits[2] = [324, 21]
Global $aBuildersDigitsBuilderBase[2] = [414, 21]
Global $aTrophies[2] = [69, 84]
Global $aNoCloudsAttack[4] = [25, 606, 0xCD0D0D, 15]
Global $aMessageButton[2] = [38, 143]
Global $aArmyTrainButton[2] = [40, 525 + $g_iBottomOffsetY]
Global $aWonOneStar[4] = [714, 538 + $g_iBottomOffsetY, 0xC0C8C0, 20]
Global $aWonTwoStar[4] = [739, 538 + $g_iBottomOffsetY, 0xC0C8C0, 20]
Global $aCancRequestCCBtn[4] = [340, 250, 0xCC4010, 20]
Global $aSendRequestCCBtn[2] = [524, 250]
Global $atxtRequestCCBtn[2] = [430, 140]
Global $aIsAtkDarkElixirFull[4] = [743, 62 + $g_iMidOffsetY, 0x270D33, 10]
Global $aIsDarkElixirFull[4] = [708, 102 + $g_iMidOffsetY, 0x270D33, 10]
Global $aIsGoldFull[4] = [659, 2 + $g_iMidOffsetY, 0xE7C00D, 10]
Global $aIsElixirFull[4] = [659, 52 + $g_iMidOffsetY, 0xC027C0, 10]
Global $aPerkBtn[4] = [95, 243 + $g_iMidOffsetY, 0x7cd8e8, 10]
Global $aIsGemWindow1[4] = [573, 256 + $g_iMidOffsetY, 0xEB1316, 20]
Global $aIsGemWindow2[4] = [577, 266 + $g_iMidOffsetY, 0xCC2025, 20]
Global $aIsGemWindow3[4] = [586, 266 + $g_iMidOffsetY, 0xCC2025, 20]
Global $aIsGemWindow4[4] = [595, 266 + $g_iMidOffsetY, 0xCC2025, 20]
Global $aLootCartBtn[2] = [430, 575 + $g_iBottomOffsetY]
Global $aCleanYard[4] = [418, 587 + $g_iBottomOffsetY, 0xE1DEBE, 20]
Global $aIsTrainPgChk1[4] = [813, 80 + $g_iMidOffsetY, 0xFF8D95, 10]
Global $aRtnHomeCloud1[4] = [56, 592 + $g_iBottomOffsetY, 0x0A223F, 15]
Global $aRtnHomeCloud2[4] = [72, 592 + $g_iBottomOffsetY, 0x103F7E, 15]
Global $aDetectLang[2] = [16, 634 + $g_iBottomOffsetY]
Global $aGreenArrowTrainTroops[2] = [310, 127]
Global $aGreenArrowBrewSpells[2] = [467, 127]
Global $g_aShopWindowOpen[4] = [804, 54, 0xC00508, 15]
Global $aTreasuryWindow[4] = [689, 138 + $g_iMidOffsetY, 0xFF8D95, 20]
Global $aAttackForTreasury[4] = [88, 619 + $g_iMidOffsetY, 0xF0EBE8, 5]
Global $aAtkHasDarkElixir[4] = [ 31, 144, 0x282020, 10]
Global $aVillageHasDarkElixir[4] = [837, 134, 0x3D2D3D, 10]
Global $aReturnHomeOnSearchButton[4] = [50, 645 + $g_iMidOffsetY, 0x2C110D, 20]
Global $aCheckTopProfile[4] = [200, 166, 0x868CAC, 5]
Global $aCheckTopProfile2[4] = [220, 355, 0x4E4D79, 5]
Global $aIsTabOpen[4] = [0, 145, 0xEAEAE3, 25]
Global $aRecievedTroops[4] = [200 ,215 ,0xFFFFFF, 20]
Global $aKingHealth = [-1, 569 + $g_iBottomOffsetY, 0x00D500, 15, 13]
Global $aQueenHealth = [-1, 569 + $g_iBottomOffsetY, 0x00D500, 15, 8]
Global $aWardenHealth = [-1, 569 + $g_iBottomOffsetY, 0x00D500, 15, 3]
Global $aWonOneStarAtkRprt[4] = [325, 180 + $g_iMidOffsetY, 0xC8CaC4, 30]
Global $aWonTwoStarAtkRprt[4] = [398, 180 + $g_iMidOffsetY, 0xD0D6D0, 30]
Global $aWonThreeStarAtkRprt[4] = [534, 180 + $g_iMidOffsetY, 0xC8CAC7, 30]
Global $NextBtn[4] = [780, 546 + $g_iBottomOffsetY, 0xD34300, 20]
Global $a12OrMoreSlots[4] = [16, 648, 0x4583B9, 25]
Global $aDoubRowAttackBar[4] = [68, 486, 0xFC5D64, 20]
Global $aTroopIsDeployed[4] = [0, 0, 0x404040, 20]
Global Const $aIsAttackPage[4] = [56, 548 + $g_iBottomOffsetY, 0xcf0d0e, 20]
Global $aRequestTroopsAO[6] = [761, 592, 0x565656, 0x71BA2F, 0xFFFFFE, 25]
Global Const $aCloseChat[4] = [331, 330 + $g_iMidOffsetY, 0xF0951D, 20]
Global Const $aChatDonateBtnColors[4][4] = [[0x0d0d0d, 0, -4, 20], [0xdaf582, 10, 0, 20], [0xcdef75, 10, 5, 20], [0xFFFFFF, 24, 9, 10]]
Global Const $aAtkRprtDECheck[4] = [459, 372 + $g_iMidOffsetY, 0x433350, 20]
Global Const $aAtkRprtTrophyCheck[4] = [327, 189 + $g_iMidOffsetY, 0x3B321C, 30]
Global Const $aAtkRprtDECheck2[4] = [678, 418 + $g_iMidOffsetY, 0x030000, 30]
Global Const $aRtnHomeCheck1[4] = [363, 548 + $g_iMidOffsetY, 0x78C11C, 20]
Global Const $aRtnHomeCheck2[4] = [497, 548 + $g_iMidOffsetY, 0x79C326, 20]
Global Const $aAttackLogPage[4] = [775, 125, 0xEB1115, 40]
Global Const $aAttackLogAttackTab[4] = [437, 114, 0xF0F4F0, 30]
Global Const $aBlueShareReplayButton[4] = [500, 156 + $g_iMidOffsetY, 0x70D4E8, 30]
Global Const $aGrayShareReplayButton[4] = [500, 156 + $g_iMidOffsetY, 0xBBBBBB, 30]
Global Const $aProfileReport[4] = [619, 344, 0x4E4D79, 20]
Global $aArmyTrainButtonRND[4] = [20, 540 + $g_iMidOffsetY, 55, 570 + $g_iMidOffsetY]
Global $aAttackButtonRND[4] = [20, 610 + $g_iMidOffsetY, 100, 670 + $g_iMidOffsetY]
Global $aFindMatchButtonRND[4] = [200, 510 + $g_iMidOffsetY, 300, 530 + $g_iMidOffsetY]
Global $NextBtnRND[4] = [710, 530 + $g_iMidOffsetY, 830, 570 + $g_iMidOffsetY]
Global $aLoginWithSupercellID[4] = [280, 640 + $g_iMidOffsetY, 0xDCF684, 20]
Global $aLoginWithSupercellID2[4] = [266, 653 + $g_iMidOffsetY, 0xFFFFFF , 10]
Global $aButtonSetting[4] = [820, 550 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aIsSettingPage[4] = [753, 75 + $g_iMidOffsetY, 0xFF8F95, 10]
Global $aButtonConnected[4] = [602, 374 + $g_iMidOffsetY, 0xDAF481, 20]
Global $aButtonDisconnected[4] = [602, 374 + $g_iMidOffsetY, 0xFF7E82, 20]
Global $aListAccount[4] = [635, 210 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aButtonVillageLoad[4] = [515, 411 + $g_iMidOffsetY, 0x6EBD1F, 20]
Global $aTextBox[4] = [320, 160 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aButtonVillageOkay[4] = [500, 170 + $g_iMidOffsetY, 0x81CA2D, 20]
Global $aButtonConnectedSCID[4] = [453, 513 + $g_iMidOffsetY, 0x72BB2F, 20]
Global $aButtonLogOutSCID[4] = [690, 280 + $g_iMidOffsetY, 0x2584FA, 20]
Global $aButtonConfirmSCID[4] = [595, 405 + $g_iMidOffsetY, 0x2B87FA, 20]
Global $aCloseTabSCID[4] = [742, 142]
Global $aButtonEditArmy[4] = [800, 542, 0xDDF685, 25]
Global $aButtonRemoveTroopsOK1[4] = [747, 582, 0x76BF2F, 20]
Global $aButtonRemoveTroopsOK2[4] = [500, 447, 0x6DBC1F, 20]
Global $aTrainBarb[4] = [-1, -1, -1, -1]
Global $aTrainArch[4] = [-1, -1, -1, -1]
Global $aTrainGiant[4] = [-1, -1, -1, -1]
Global $aTrainGobl[4] = [-1, -1, -1, -1]
Global $aTrainWall[4] = [-1, -1, -1, -1]
Global $aTrainBall[4] = [-1, -1, -1, -1]
Global $aTrainWiza[4] = [-1, -1, -1, -1]
Global $aTrainHeal[4] = [-1, -1, -1, -1]
Global $aTrainDrag[4] = [-1, -1, -1, -1]
Global $aTrainPekk[4] = [-1, -1, -1, -1]
Global $aTrainBabyD[4] = [-1, -1, -1, -1]
Global $aTrainMine[4] = [-1, -1, -1, -1]
Global $aTrainEDrag[4] = [-1, -1, -1, -1]
Global $aTrainMini[4] = [-1, -1, -1, -1]
Global $aTrainHogs[4] = [-1, -1, -1, -1]
Global $aTrainValk[4] = [-1, -1, -1, -1]
Global $aTrainGole[4] = [-1, -1, -1, -1]
Global $aTrainWitc[4] = [-1, -1, -1, -1]
Global $aTrainLava[4] = [-1, -1, -1, -1]
Global $aTrainBowl[4] = [-1, -1, -1, -1]
Global $aTrainIceG[4] = [-1, -1, -1, -1]
Global $aTrainLSpell[4] = [-1, -1, -1, -1]
Global $aTrainHSpell[4] = [-1, -1, -1, -1]
Global $aTrainRSpell[4] = [-1, -1, -1, -1]
Global $aTrainJSpell[4] = [-1, -1, -1, -1]
Global $aTrainFSpell[4] = [-1, -1, -1, -1]
Global $aTrainCSpell[4] = [-1, -1, -1, -1]
Global $aTrainPSpell[4] = [-1, -1, -1, -1]
Global $aTrainESpell[4] = [-1, -1, -1, -1]
Global $aTrainHaSpell[4] = [-1, -1, -1, -1]
Global $aTrainSkSpell[4] = [-1, -1, -1, -1]
Global $aTrainBtSpell[4] = [-1, -1, -1, -1]
Global $aTrainArmy[$eArmyCount] = [$aTrainBarb, $aTrainArch, $aTrainGiant, $aTrainGobl, $aTrainWall, $aTrainBall, $aTrainWiza, $aTrainHeal, $aTrainDrag, $aTrainPekk, $aTrainBabyD, $aTrainMine, $aTrainEDrag, $aTrainMini, $aTrainHogs, $aTrainValk, $aTrainGole, $aTrainWitc, $aTrainLava, $aTrainBowl, $aTrainIceG, 0, 0, 0, 0, $aTrainLSpell, $aTrainHSpell, $aTrainRSpell, $aTrainJSpell, $aTrainFSpell, $aTrainCSpell, $aTrainPSpell, $aTrainESpell, $aTrainHaSpell, $aTrainSkSpell, $aTrainBtSpell]
Global $aButtonLanguage[4] = [210, 375 + $g_iMidOffsetY, 0xD0E978, 20]
Global $aListLanguage[4] = [110, 90 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aEnglishLanguage[4] = [420, 140 + $g_iMidOffsetY, 0xD7D5C7, 20]
Global $aLanguageOkay[4] = [510, 420 + $g_iMidOffsetY, 0x6FBD1F, 20]
Global $g_sImgImgLocButtons = @ScriptDir & "\imgxml\imglocbuttons"
Global Const $g_sImgAnyoneThere = @ScriptDir & "\imgxml\other\AnyoneThere[[Android]]*"
Global Const $g_sImgPersonalBreak = @ScriptDir & "\imgxml\other\break*"
Global Const $g_sImgAnotherDevice = @ScriptDir & "\imgxml\other\Device[[Android]]*"
Global Const $g_sImgCocStopped = @ScriptDir & "\imgxml\other\CocStopped*"
Global Const $g_sImgCocReconnecting = @ScriptDir & "\imgxml\other\CocReconnecting*"
Global Const $g_sImgAppRateNever = @ScriptDir & "\imgxml\other\RateNever[[Android]]*"
Global Const $g_sImgGfxError = @ScriptDir & "\imgxml\other\GfxError*"
Global Const $g_sImgError = @ScriptDir & "\imgxml\other\Error[[Android]]*"
Global Const $g_sImgOutOfSync = @ScriptDir & "\imgxml\other\Oos[[Android]]*"
Global $g_sImgCollectRessources = @ScriptDir & "\imgxml\Resources\Collect"
Global $g_sImgCollectLootCart = @ScriptDir & "\imgxml\Resources\LootCart\LootCart_0_85.xml"
Global $g_sImgBoat = @ScriptDir & "\imgxml\Boat\BoatNormalVillage_0_89.xml"
Global $g_sImgZoomOutDir = @ScriptDir & "\imgxml\village\NormalVillage\"
Global $g_sImgCheckWallDir = @ScriptDir & "\imgxml\Walls"
Global $g_sImgClearTombs = @ScriptDir & "\imgxml\Resources\Tombs"
Global $g_sImgCleanYard = @ScriptDir & "\imgxml\Resources\Obstacles"
Global $g_sImgCleanYardSnow = @ScriptDir & "\imgxml\Obstacles_Snow"
Global $g_sImgGemBox = @ScriptDir & "\imgxml\Resources\GemBox"
Global $g_sImgCollectReward = @ScriptDir & "\imgxml\Resources\ClaimReward"
Global $g_sImgTrader = @ScriptDir & "\imgxml\FreeMagicItems\TraderIcon"
Global $g_sImgDailyDiscountWindow = @ScriptDir & "\imgxml\FreeMagicItems\DailyDiscount"
Global $g_sImgCollectRessourcesBB = @ScriptDir & "\imgxml\Resources\BuildersBase\Collect"
Global $g_sImgBoatBB = @ScriptDir & "\imgxml\Boat\BoatBuilderBase_0_89.xml"
Global $g_sImgZoomOutDirBB = @ScriptDir & "\imgxml\village\BuilderBase\"
Global $g_sImgStartCTBoost = @ScriptDir & "\imgxml\Resources\BuildersBase\ClockTower\ClockTowerAvailable*.xml"
Global $g_sImgCleanBBYard = @ScriptDir & "\imgxml\Resources\ObstaclesBB"
Global $g_sImgIsOnBB = @ScriptDir & "\imgxml\village\Page\BuilderBase*"
Global $g_sImgStarLaboratory = @ScriptDir & "\imgxml\Resources\BuildersBase\StarLaboratory"
Global $g_sImgStarLabElex = @ScriptDir & "\imgxml\Resources\BuildersBase\StarLabElex\StarLabElex*"
Global $g_sImgDonateTroops = @ScriptDir & "\imgxml\DonateCC\Troops\"
Global $g_sImgDonateSpells = @ScriptDir & "\imgxml\DonateCC\Spells\"
Global $g_sImgDonateSiege = @ScriptDir & "\imgxml\DonateCC\SiegeMachines\"
Global $g_sImgChatDivider = @ScriptDir & "\imgxml\DonateCC\donateccwbl\chatdivider_0_98.xml"
Global $g_sImgChatDividerHidden = @ScriptDir & "\imgxml\DonateCC\donateccwbl\chatdividerhidden_0_98.xml"
Global $g_sImgChatIUnterstand = @ScriptDir & "\imgxml\DonateCC\donateccwbl\iunderstand_0_95.xml"
Global $g_sImgAUpgradeObst = @ScriptDir & "\imgxml\Resources\Auto Upgrade\Obstacles"
Global $g_sImgAUpgradeZero = @ScriptDir & "\imgxml\Resources\Auto Upgrade\Zero"
Global $g_sImgAUpgradeUpgradeBtn = @ScriptDir & "\imgxml\Resources\Auto Upgrade\UpgradeButton"
Global $g_sImgAUpgradeRes = @ScriptDir & "\imgxml\Resources\Auto Upgrade\Resources"
Global $g_sImgAutoUpgradeGold = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\Gold"
Global $g_sImgAutoUpgradeElixir = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\Elixir"
Global $g_sImgAutoUpgradeWindow = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\Window"
Global $g_sImgAutoUpgradeNew = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\New"
Global $g_sImgAutoUpgradeNoRes = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NoResources"
Global $g_sImgAutoUpgradeBtnElixir = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\ButtonUpg\Elixir"
Global $g_sImgAutoUpgradeBtnGold = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\ButtonUpg\Gold"
Global $g_sImgAutoUpgradeBtnDir = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\Upgrade"
Global $g_sImgAutoUpgradeZero = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\Shop"
Global $g_sImgAutoUpgradeClock = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\Clock"
Global $g_sImgAutoUpgradeInfo = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\Slot"
Global $g_sImgAutoUpgradeNewBldgYes = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\Yes"
Global $g_sImgAutoUpgradeNewBldgNo = @ScriptDir & "\imgxml\Resources\BuildersBase\AutoUpgrade\NewBuildings\No"
Global $g_sImgTrainTroops = @ScriptDir & "\imgxml\Train\Train_Train\"
Global $g_sImgTrainSpells = @ScriptDir & "\imgxml\Train\Spell_Train\"
Global $g_sImgRequestCCButton = @ScriptDir & "\imgxml\ArmyOverview\RequestCC"
Global $g_sImgAttackBarDir = @ScriptDir & "\imgxml\AttackBar"
Global $g_sImgSwitchSiegeMachine = @ScriptDir & "\imgxml\SwitchSiegeMachines\"
Global $g_sImgSwitchWardenMode = @ScriptDir & "\imgxml\SwitchWardenMode"
Global $g_sImgElixirStorage = @ScriptDir & "\imgxml\deadbase\elix\storage\"
Global $g_sImgWeakBaseBuildingsDir = @ScriptDir & "\imgxml\Buildings"
Global $g_sImgWeakBaseBuildingsEagleDir = @ScriptDir & "\imgxml\Buildings\Eagle"
Global $g_sImgWeakBaseBuildingsInfernoDir = @ScriptDir & "\imgxml\Buildings\Infernos"
Global $g_sImgWeakBaseBuildingsXbowDir = @ScriptDir & "\imgxml\Buildings\Xbow"
Global $g_sImgWeakBaseBuildingsWizTowerSnowDir = @ScriptDir & "\imgxml\Buildings\WTower_Snow"
Global $g_sImgWeakBaseBuildingsWizTowerDir = @ScriptDir & "\imgxml\Buildings\WTower"
Global $g_sImgWeakBaseBuildingsMortarsDir = @ScriptDir & "\imgxml\Buildings\Mortars"
Global $g_sImgWeakBaseBuildingsAirDefenseDir = @ScriptDir & "\imgxml\Buildings\ADefense"
Global $g_sImgSearchDrill = @ScriptDir & "\imgxml\Storages\Drills"
Global $g_sImgSearchDrillLevel = @ScriptDir & "\imgxml\Storages\Drills\Level"
Global $g_sImgEasyBuildings = @ScriptDir & "\imgxml\easybuildings"
Global $g_sImgRetrySearchButton = @ScriptDir & "\imgxml\Resources\Clouds\RetryButton*"
Global Const $g_sImgLoginWithSupercellID = @ScriptDir & "\imgxml\other\LoginWithSupercellID*"
Global Const $g_sImgGoogleSelectAccount = @ScriptDir & "\imgxml\other\GoogleSelectAccount*"
Global Const $g_sImgGoogleSelectEmail = @ScriptDir & "\imgxml\other\GoogleSelectEmail*"
Global Const $g_sImgGoogleAccounts = @ScriptDir & "\imgxml\SwitchAccounts\GooglePlay\GooglePlay*"
Global Const $g_sImgSupercellID = @ScriptDir & "\imgxml\SwitchAccounts\SuperCellID\SCID*"
Global Const $g_sImgListAccountsSCID = @ScriptDir & "\imgxml\SwitchAccounts\ListAccounts"
Global Const $g_sImgCaravan = @ScriptDir & "\imgxml\Resources\ClanGamesImages\MainLoop\Caravan"
Global Const $g_sImgStart = @ScriptDir & "\imgxml\Resources\ClanGamesImages\MainLoop\Start"
Global Const $g_sImgPurge = @ScriptDir & "\imgxml\Resources\ClanGamesImages\MainLoop\Purge"
Global Const $g_sImgCoolPurge = @ScriptDir & "\imgxml\Resources\ClanGamesImages\MainLoop\Gem"
Global Const $g_sImgTrashPurge = @ScriptDir & "\imgxml\Resources\ClanGamesImages\MainLoop\Trash"
Global Const $g_sImgOkayPurge = @ScriptDir & "\imgxml\Resources\ClanGamesImages\MainLoop\Okay"
Global Const $g_sImgReward = @ScriptDir & "\imgxml\Resources\ClanGamesImages\MainLoop\Reward"
Func _StringSize($sText, $iSize = 8.5, $iWeight = 400, $iAttrib = 0, $sName = "", $iMaxWidth = 0, $hWnd = 0)
If $iSize = Default Then $iSize = 8.5
If $iWeight = Default Then $iWeight = 400
If $iAttrib = Default Then $iAttrib = 0
If $sName = "" Or $sName = Default Then $sName = _StringSize_DefaultFontName()
If Not IsString($sText) Then Return SetError(1, 1, 0)
If Not IsNumber($iSize) Then Return SetError(1, 2, 0)
If Not IsInt($iWeight) Then Return SetError(1, 3, 0)
If Not IsInt($iAttrib) Then Return SetError(1, 4, 0)
If Not IsString($sName) Then Return SetError(1, 5, 0)
If Not IsNumber($iMaxWidth) Then Return SetError(1, 6, 0)
If Not IsHwnd($hWnd) And $hWnd <> 0 Then Return SetError(1, 7, 0)
Local $aRet, $hDC, $hFont, $hLabel = 0, $hLabel_Handle
Local $iExpTab = BitAnd($iAttrib, 1)
$iAttrib = BitAnd($iAttrib, BitNot(1))
If IsHWnd($hWnd) Then
$hLabel = GUICtrlCreateLabel("", -10, -10, 10, 10)
$hLabel_Handle = GUICtrlGetHandle(-1)
GUICtrlSetFont(-1, $iSize, $iWeight, $iAttrib, $sName)
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hLabel_Handle)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, 1, 0)
EndIf
$hDC = $aRet[0]
$aRet = DllCall("user32.dll", "lparam", "SendMessage", "hwnd", $hLabel_Handle, "int", 0x0031, "wparam", 0, "lparam", 0)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, _StringSize_Error_Close(2, $hDC), 0)
EndIf
$hFont = $aRet[0]
Else
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Or $aRet[0] = 0 Then Return SetError(2, 1, 0)
$hDC = $aRet[0]
$aRet = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(3, $hDC), 0)
Local $iInfo = $aRet[0]
$aRet = DllCall("gdi32.dll", "handle", "CreateFontW", "int", -$iInfo * $iSize / 72, "int", 0, "int", 0, "int", 0, "int", $iWeight, "dword", BitAND($iAttrib, 2), "dword", BitAND($iAttrib, 4), "dword", BitAND($iAttrib, 8), "dword", 0, "dword", 0, "dword", 0, "dword", 5, "dword", 0, "wstr", $sName)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(4, $hDC), 0)
$hFont = $aRet[0]
EndIf
$aRet = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hFont)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(5, $hDC, $hFont, $hLabel), 0)
Local $hPrevFont = $aRet[0]
Local $avSize_Info[4], $iLine_Length, $iLine_Height = 0, $iLine_Count = 0, $iLine_Width = 0, $iWrap_Count, $iLast_Word, $sTest_Line
Local $tSize = DllStructCreate("int X;int Y")
DllStructSetData($tSize, "X", 0)
DllStructSetData($tSize, "Y", 0)
$sText = StringRegExpReplace($sText, "((?<!\x0d)\x0a|\x0d(?!\x0a))", @CRLF)
Local $asLines = StringSplit($sText, @CRLF, 1)
For $i = 1 To $asLines[0]
If $iExpTab Then
$asLines[$i] = StringReplace($asLines[$i], @TAB, " XXXXXXXX")
EndIf
$iLine_Length = StringLen($asLines[$i])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$i], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") > $iLine_Width Then $iLine_Width = DllStructGetData($tSize, "X")
If DllStructGetData($tSize, "Y") > $iLine_Height Then $iLine_Height = DllStructGetData($tSize, "Y")
Next
If $iMaxWidth <> 0 And $iLine_Width > $iMaxWidth Then
For $j = 1 To $asLines[0]
$iLine_Length = StringLen($asLines[$j])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$j], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") < $iMaxWidth - 4 Then
$iLine_Count += 1
$avSize_Info[0] &= $asLines[$j] & @CRLF
Else
$iWrap_Count = 0
While 1
$iLine_Width = 0
$iLast_Word = 0
For $i = 1 To StringLen($asLines[$j])
If StringMid($asLines[$j], $i, 1) = " " Then $iLast_Word = $i - 1
$sTest_Line = StringMid($asLines[$j], 1, $i)
$iLine_Length = StringLen($sTest_Line)
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sTest_Line, "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
$iLine_Width = DllStructGetData($tSize, "X")
If $iLine_Width >= $iMaxWidth - 4 Then ExitLoop
Next
If $i > StringLen($asLines[$j]) Then
$iWrap_Count += 1
$avSize_Info[0] &= $sTest_Line & @CRLF
ExitLoop
Else
$iWrap_Count += 1
If $iLast_Word = 0 Then Return SetError(3, _StringSize_Error_Close(0, $hDC, $hFont, $hLabel), 0)
$avSize_Info[0] &= StringLeft($sTest_Line, $iLast_Word) & @CRLF
$asLines[$j] = StringTrimLeft($asLines[$j], $iLast_Word)
$asLines[$j] = StringStripWS($asLines[$j], 1)
EndIf
WEnd
$iLine_Count += $iWrap_Count
EndIf
Next
If $iExpTab Then
$avSize_Info[0] = StringRegExpReplace($avSize_Info[0], "\x20?XXXXXXXX", @TAB)
EndIf
$avSize_Info[1] = $iLine_Height
$avSize_Info[2] = $iMaxWidth
$avSize_Info[3] =($iLine_Count * $iLine_Height) + 4
Else
Local $avSize_Info[4] = [$sText, $iLine_Height, $iLine_Width,($asLines[0] * $iLine_Height) + 4]
EndIf
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hPrevFont)
DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
$tSize = 0
Return $avSize_Info
EndFunc
Func _StringSize_Error_Close($iExtCode, $hDC = 0, $hFont = 0, $hLabel = 0)
If $hFont <> 0 Then DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
If $hDC <> 0 Then DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
Return $iExtCode
EndFunc
Func _StringSize_DefaultFontName()
Local $tNONCLIENTMETRICS = DllStructCreate("uint;int;int;int;int;int;byte[60];int;int;byte[60];int;int;byte[60];byte[60];byte[60]")
DLLStructSetData($tNONCLIENTMETRICS, 1, DllStructGetSize($tNONCLIENTMETRICS))
DLLCall("user32.dll", "int", "SystemParametersInfo", "int", 41, "int", DllStructGetSize($tNONCLIENTMETRICS), "ptr", DllStructGetPtr($tNONCLIENTMETRICS), "int", 0)
Local $tLOGFONT = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;char[32]", DLLStructGetPtr($tNONCLIENTMETRICS, 13))
$tNONCLIENTMETRICS = 0
If IsString(DllStructGetData($tLOGFONT, 14)) Then
Local $iVal = DllStructGetData($tLOGFONT, 14)
$tLOGFONT = 0
Return $iVal
Else
$tLOGFONT = 0
Return "Tahoma"
EndIf
EndFunc
Global $g_aEMB_Settings[13]
Global $g_aEMB_TempArray = __EMB_GetDefaultFont()
$g_aEMB_Settings[10] = $g_aEMB_TempArray[0]
$g_aEMB_Settings[11] = $g_aEMB_TempArray[1]
$g_aEMB_TempArray = DllCall("User32.dll", "int", "GetSysColor", "int", 15)
$g_aEMB_Settings[8] = BitAND(BitShift(String(Binary($g_aEMB_TempArray[0])), 8), 0xFFFFFF)
$g_aEMB_TempArray = DllCall("User32.dll", "int", "GetSysColor", "int", 8)
$g_aEMB_Settings[9] = BitAND(BitShift(String(Binary($g_aEMB_TempArray[0])), 8), 0xFFFFFF)
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 11)
$g_aEMB_Settings[12] = $g_aEMB_TempArray[0]
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 30)
$g_aEMB_Settings[12] +=(($g_aEMB_TempArray[0] < 30) ?($g_aEMB_TempArray[0] * 3) :($g_aEMB_TempArray[0]) )
$g_aEMB_TempArray = 0
$g_aEMB_TempArray = DllCall("dwmapi.dll", "uint", "DwmIsCompositionEnabled", "int*", $g_aEMB_TempArray)
If Not @error And $g_aEMB_TempArray[1] = True Then
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 7)
$g_aEMB_Settings[12] +=($g_aEMB_TempArray[0] * 4)
EndIf
$g_aEMB_TempArray = 0
$g_aEMB_Settings[0] = 0
$g_aEMB_Settings[1] = 0
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
$g_aEMB_Settings[6] = 370
$g_aEMB_Settings[7] = 500
Func _ExtMsgBoxSet($iStyle = -1, $iJust = -1, $iBkCol = -1, $iCol = -1, $iFont_Size = -1, $sFont_Name = -1, $iWidth = -1, $iWidth_Abs = -1)
Switch $iStyle
Case Default
$g_aEMB_Settings[0] = 0
$g_aEMB_Settings[1] = 0
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
$g_aEMB_Settings[6] = 370
$g_aEMB_Settings[7] = 370
Return
Case -1
Case 0 To 127
$g_aEMB_Settings[0] = Int($iStyle)
Case Else
Return SetError(1, 1, 0)
EndSwitch
Switch $iJust
Case Default
$g_aEMB_Settings[1] = 0
Case -1
Case 0, 1, 2, 4, 5, 6
$g_aEMB_Settings[1] = $iJust
Case Else
Return SetError(1, 2, 0)
EndSwitch
Switch $iBkCol
Case Default
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
Case -1
Case 0 To 0xFFFFFF
$g_aEMB_Settings[2] = Int($iBkCol)
Case Else
Return SetError(1, 3, 0)
EndSwitch
Switch $iCol
Case Default
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
Case -1
Case 0 To 0xFFFFFF
$g_aEMB_Settings[3] = Int($iCol)
Case Else
Return SetError(1, 4, 0)
EndSwitch
Switch $iFont_Size
Case Default
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
Case -1
Case 8 To 72
$g_aEMB_Settings[4] = Int($iFont_Size)
Case Else
Return SetError(1, 5, 0)
EndSwitch
Switch $sFont_Name
Case Default
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
Case -1
Case Else
If IsString($sFont_Name) Then
$g_aEMB_Settings[5] = $sFont_Name
Else
Return SetError(1, 6, 0)
EndIf
EndSwitch
Switch $iWidth
Case Default
$g_aEMB_Settings[6] = 370
Case -1
Case 370 To @DesktopWidth - 20
$g_aEMB_Settings[6] = Int($iWidth)
Case Else
Return SetError(1, 7, 0)
EndSwitch
Switch $iWidth_Abs
Case Default
$g_aEMB_Settings[7] = 370
Case -1
Case 370 To @DesktopWidth - 20
$g_aEMB_Settings[7] = Int($iWidth_Abs)
Case Else
Return SetError(1, 8, 0)
EndSwitch
If $g_aEMB_Settings[7] < $g_aEMB_Settings[6] Then
$g_aEMB_Settings[7] = $g_aEMB_Settings[6]
EndIf
Return 1
EndFunc
Func _ExtMsgBox($vIcon, $vButton, $sTitle, $sText, $iTimeOut = 0, $hWin = $g_hFrmBot, $iVPos = 0, $bMain = True)
Local $iMsg_Width_Max = $g_aEMB_Settings[6], $iMsg_Width_Min = 150, $iMsg_Width_Abs = $g_aEMB_Settings[7]
Local $iMsg_Height_Min = 100
Local $iButton_Width_Def = 80, $iButton_Width_Min = 50
Local $iParent_Win = 0, $fCountdown = False, $cCheckbox, $aLabel_Size, $aRet, $iRet_Value, $iHpos
Local $sButton_Text, $iButton_Width, $iButton_Xpos
$iTimeOut = Int(Number($iTimeOut))
If $vButton == " " And $iTimeOut = 0 Then
$iTimeOut = 5
EndIf
Local $iIcon_Style = 0
Local $iIcon_Reduction = 50
Local $sDLL = "user32.dll"
If StringIsDigit($vIcon) Then
Switch $vIcon
Case 0
$iIcon_Reduction = 0
Case 8
$sDLL = "imageres.dll"
$iIcon_Style = 78
Case 16
$iIcon_Style = -4
Case 32
$iIcon_Style = -3
Case 48
$iIcon_Style = -2
Case 64
$iIcon_Style = -5
Case 128
If $iTimeOut > 0 Then
$fCountdown = True
Else
ContinueCase
EndIf
Case Else
Return SetError(1, 0, -1)
EndSwitch
Else
$sDLL = $vIcon
$iIcon_Style = 0
EndIf
StringRegExpReplace($vButton, "((?<!&)&)(?!&)", "*")
If @extended > 1 Then
Return SetError(2, 0, -1)
EndIf
If IsNumber($vButton) Then
Switch $vButton
Case 0
$vButton = "OK"
Case 1
$vButton = "&OK|Cancel"
Case 2
$vButton = "&Abort|Retry|Ignore"
Case 3
$vButton = "&Yes|No|Cancel"
Case 4
$vButton = "&Yes|No"
Case 5
$vButton = "&Retry|Cancel"
Case 6
$vButton = "&Cancel|Try Again|Continue"
Case Else
Return SetError(3, 0, -1)
EndSwitch
EndIf
Local $aButton_Text[1] = [0]
Local $iButton_Width_Req = 0
If $vButton <> " " Then
$aButton_Text = StringSplit($vButton, "|")
Local $iButton_Width_Abs = Floor((($iMsg_Width_Max - 10) / $aButton_Text[0]) - 10)
If $iButton_Width_Abs < $iButton_Width_Min Then
Return SetError(4, 0, -1)
EndIf
Local $iButton_Width_Text = 0
For $i = 1 To $aButton_Text[0]
$sButton_Text = StringRegExpReplace($aButton_Text[$i], "^&?(.*)$", "$1")
If BitAND($g_aEMB_Settings[0], 4) Then
$aRet = _StringSize($sButton_Text, $g_aEMB_Settings[10], Default, Default, $g_aEMB_Settings[11])
Else
$aRet = _StringSize($sButton_Text, $g_aEMB_Settings[4], Default, Default, $g_aEMB_Settings[5])
EndIf
If IsArray($aRet) And $aRet[2] + 10 > $iButton_Width_Text Then
$iButton_Width_Text = $aRet[2] + 10
EndIf
Next
If $iButton_Width_Text > $iButton_Width_Abs Then
Return SetError(5, 0, -1)
EndIf
$iButton_Width = $iButton_Width_Def
If $iButton_Width_Text > $iButton_Width_Def Then
$iButton_Width = $iButton_Width_Text
EndIf
If $iButton_Width_Abs < $iButton_Width_Def Then
If $iButton_Width_Text > $iButton_Width_Min Then
$iButton_Width = $iButton_Width_Text
Else
$iButton_Width = $iButton_Width_Min
EndIf
EndIf
$iButton_Width_Req =(($iButton_Width + 10) * $aButton_Text[0]) + 10
EndIf
Local $iExpTab = Default
If BitAND($g_aEMB_Settings[0], 8) Then
$iExpTab = 1
EndIf
While 1
Local $aLabel_Pos = _StringSize($sText, $g_aEMB_Settings[4], Default, $iExpTab, $g_aEMB_Settings[5], $iMsg_Width_Max - 20 - $iIcon_Reduction)
If @error Then
If $iMsg_Width_Max >= $iMsg_Width_Abs Then
Return SetError(6, 0, -1)
Else
$iMsg_Width_Max += 10
EndIf
Else
ExitLoop
EndIf
WEnd
$sText = $aLabel_Pos[0]
Local $iLabel_Width = $aLabel_Pos[2]
Local $iLabel_Height = $aLabel_Pos[3]
Local $iMsg_Width = $iLabel_Width + 20 + $iIcon_Reduction
If $iButton_Width_Req > $iMsg_Width Then $iMsg_Width = $iButton_Width_Req
If $iMsg_Width < $iMsg_Width_Min Then
$iMsg_Width = $iMsg_Width_Min
$iLabel_Width = $iMsg_Width_Min - 20
EndIf
Local $iDialog_Width = $iMsg_Width
Local $aTitleSize = _StringSize($sTitle, $g_aEMB_Settings[10], Default, Default, $g_aEMB_Settings[11])
If $aTitleSize[2] >($iMsg_Width - 70) Then
$iDialog_Width =(($aTitleSize[2] <($g_aEMB_Settings[7] - $g_aEMB_Settings[12])) ?($aTitleSize[2] + $g_aEMB_Settings[12]) :($g_aEMB_Settings[7]) )
EndIf
Local $iMsg_Height = $iLabel_Height + 35
If $vButton <> " " Then
$iMsg_Height += 30
EndIf
If BitAND($g_aEMB_Settings[0], 16) Then
$iMsg_Height += 40
EndIf
If $iMsg_Height < $iMsg_Height_Min Then $iMsg_Height = $iMsg_Height_Min
Local $iLabel_Vert = 20
If StringInStr($sText, @CRLF) = 0 Then $iLabel_Vert = 27
If Mod($g_aEMB_Settings[0], 2) = 1 Then
If IsHWnd($hWin) Then
$iParent_Win = $hWin
Else
$iParent_Win = WinGetHandle(AutoItWinGetTitle())
EndIf
EndIf
If $hWin = "" Then
$iHpos =(@DesktopWidth - $iDialog_Width) / 2
$iVPos =(@DesktopHeight - $iMsg_Height) / 2
Else
If IsHWnd($hWin) Then
If BitAND(WinGetState($hWin), 2) Then
Local $aPos = WinGetPos($hWin)
$iHpos =($aPos[2] - $iDialog_Width) / 2 + $aPos[0] - 3
$iVPos =($aPos[3] - $iMsg_Height) / 2 + $aPos[1] - 20
Else
$iHpos =(@DesktopWidth - $iDialog_Width) / 2
$iVPos =(@DesktopHeight - $iMsg_Height) / 2
EndIf
Else
$iHpos = $hWin
EndIf
EndIf
If $bMain Then
If $iHpos < 10 Then $iHpos = 10
If $iHpos + $iDialog_Width > @DesktopWidth - 20 Then $iHpos = @DesktopWidth - 20 - $iDialog_Width
If $iVPos < 10 Then $iVPos = 10
If $iVPos + $iMsg_Height > @DesktopHeight - 60 Then $iVPos = @DesktopHeight - 60 - $iMsg_Height
EndIf
Local $iExtStyle = 0x00000008
If BitAND($g_aEMB_Settings[0], 2) Then $iExtStyle = -1
Local $hMsgGUI = _GUICreate($sTitle, $iDialog_Width, $iMsg_Height, $iHpos, $iVPos, BitOR(0x80880000, 0x00C00000), $iExtStyle, $iParent_Win)
If @error Then
Return SetError(7, 0, -1)
EndIf
If BitAND($g_aEMB_Settings[0], 32) Then
If @Compiled Then
GUISetIcon(@ScriptName, -2, $hMsgGUI)
Else
GUISetIcon(@AutoItExe, -2, $hMsgGUI)
EndIf
EndIf
If $g_aEMB_Settings[2] <> Default Then GUISetBkColor($g_aEMB_Settings[2])
If BitAND($g_aEMB_Settings[0], 64) Then
$aRet = DllCall("User32.dll", "hwnd", "GetSystemMenu", "hwnd", $hMsgGUI, "int", 0)
Local $hSysMenu = $aRet[0]
DllCall("User32.dll", "int", "RemoveMenu", "hwnd", $hSysMenu, "int", 0xF060, "int", 0)
DllCall("User32.dll", "int", "DrawMenuBar", "hwnd", $hMsgGUI)
EndIf
Local $iLabel_Style = 0
If BitAND($g_aEMB_Settings[1], 1) = 1 Then
$iLabel_Style = 1
ElseIf BitAND($g_aEMB_Settings[1], 2) = 2 Then
$iLabel_Style = 2
EndIf
GUICtrlCreateLabel($sText, 10 + $iIcon_Reduction, $iLabel_Vert, $iLabel_Width, $iLabel_Height, $iLabel_Style)
GUICtrlSetFont(-1, $g_aEMB_Settings[4], Default, Default, $g_aEMB_Settings[5])
If $g_aEMB_Settings[3] <> Default Then GUICtrlSetColor(-1, $g_aEMB_Settings[3])
If BitAND($g_aEMB_Settings[0], 16) Then
Local $sAgain = " Do not show again"
Local $iY = $iLabel_Vert + $iLabel_Height + 10
$cCheckbox = GUICtrlCreateCheckbox("", 10 + $iIcon_Reduction, $iY, 20, 20)
Local $cCheckLabel = GUICtrlCreateLabel($sAgain, 20, 20, 20, 20)
GUICtrlSetColor($cCheckLabel, $g_aEMB_Settings[3])
GUICtrlSetBkColor($cCheckLabel, $g_aEMB_Settings[2])
If BitAND($g_aEMB_Settings[0], 4) Then
$aLabel_Size = _StringSize($sAgain)
Else
$aLabel_Size = _StringSize($sAgain, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
GUICtrlSetFont($cCheckLabel, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
EndIf
$iY =($iY + 10) -($aLabel_Size[3] - 4) / 2
ControlMove($hMsgGUI, "", $cCheckLabel, 30 + $iIcon_Reduction, $iY, $iMsg_Width -(30 + $iIcon_Reduction), $aLabel_Size[3])
EndIf
If $fCountdown = True Then
Local $cCountdown_Label = GUICtrlCreateLabel(StringFormat("%2s", $iTimeOut), 10, 20, 32, 32)
GUICtrlSetFont(-1, 18, Default, Default, $g_aEMB_Settings[5])
GUICtrlSetColor(-1, $g_aEMB_Settings[3])
Else
If $iIcon_Reduction Then _GUICtrlCreateIcon($sDLL, $iIcon_Style, 10, 20)
EndIf
Local $aButtonCID[$aButton_Text[0] + 1] = [9999]
If $vButton <> " " Then
$aButtonCID[0] = GUICtrlCreateDummy()
Local $aAccel_Key[1][2] = [["{SPACE}", $aButtonCID[0]]]
GUISetAccelerators($aAccel_Key)
If $aButton_Text[0] = 1 Then
If BitAND($g_aEMB_Settings[1], 4) = 4 Then
$iButton_Xpos =($iMsg_Width - $iButton_Width) / 2
Else
$iButton_Xpos = $iMsg_Width - $iButton_Width - 10
EndIf
Else
$iButton_Xpos =($iMsg_Width -($iButton_Width_Req - 20)) / 2
EndIf
Local $iDefButton_Code = 0
Local $iDef_Button_Style = 0
For $i = 0 To $aButton_Text[0] - 1
Local $iButton_Text = $aButton_Text[$i + 1]
If $aButton_Text[0] = 1 Then
$iDef_Button_Style = 0x0001
ElseIf StringLeft($iButton_Text, 1) = "&" Then
$iDef_Button_Style = 0x0001
$aButton_Text[$i + 1] = StringTrimLeft($iButton_Text, 1)
$iDefButton_Code = $i + 1
EndIf
$aButtonCID[$i + 1] = GUICtrlCreateButton($aButton_Text[$i + 1], $iButton_Xpos +($i *($iButton_Width + 10)), $iMsg_Height - 35, $iButton_Width, 25, $iDef_Button_Style)
If Not BitAND($g_aEMB_Settings[0], 4) Then GUICtrlSetFont(-1, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
$iDef_Button_Style = 0
Next
EndIf
GUISetState(@SW_SHOW, $hMsgGUI)
Local $iTimeout_Begin = __TimerInit()
Local $iCounter = 0
Local $aMsg
Local $iOrgMode = Opt('GUIOnEventMode', 0)
While 1
$aMsg = GUIGetMsg(1)
If $aMsg[1] = $hMsgGUI Then
Select
Case $aMsg[0] = -3
$iRet_Value = 0
ExitLoop
Case $aMsg[0] = $aButtonCID[0]
If $iDefButton_Code Then
$iRet_Value = $iDefButton_Code
ExitLoop
EndIf
Case Else
For $i = 1 To UBound($aButtonCID) - 1
If $aMsg[0] = $aButtonCID[$i] Then
$iRet_Value = $i
ExitLoop 2
EndIf
Next
EndSelect
EndIf
If __TimerDiff($iTimeout_Begin) / 1000 >= $iTimeOut And $iTimeOut > 0 Then
$iRet_Value = 9
ExitLoop
EndIf
If $fCountdown = True Then
Local $iTimeRun = Int(__TimerDiff($iTimeout_Begin) / 1000)
If $iTimeRun <> $iCounter Then
$iCounter = $iTimeRun
GUICtrlSetData($cCountdown_Label, StringFormat("%2s", $iTimeOut - $iCounter))
EndIf
EndIf
WEnd
Opt('GUIOnEventMode', $iOrgMode)
If GUICtrlRead($cCheckbox) = 1 Then
$iRet_Value *= -1
EndIf
GUIDelete($hMsgGUI)
Return $iRet_Value
EndFunc
Func __EMB_GetDefaultFont()
Local $aDefFontData[2] = [9, "Tahoma"]
Local $hWnd = WinGetHandle(AutoItWinGetTitle())
Local $hThemeDLL = DllOpen("uxtheme.dll")
Local $hTheme = DllCall($hThemeDLL, 'ptr', 'OpenThemeData', 'hwnd', $hWnd, 'wstr', "Static")
If @error Then Return $aDefFontData
$hTheme = $hTheme[0]
Local $tFont = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;wchar[32]")
Local $pFont = DllStructGetPtr($tFont)
DllCall($hThemeDLL, 'long', 'GetThemeSysFont', 'HANDLE', $hTheme, 'int', 805, 'ptr', $pFont)
If @error Then
$tFont = 0
Return $aDefFontData
EndIf
Local $hDC = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then
$tFont = 0
Return $aDefFontData
EndIf
$hDC = $hDC[0]
Local $iPixel_Y = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If Not @error Then
$iPixel_Y = $iPixel_Y[0]
$aDefFontData[0] = Int(2 *(.25 - DllStructGetData($tFont, 1) * 72 / $iPixel_Y)) / 2
EndIf
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
$aDefFontData[1] = DllStructGetData($tFont, 14)
$tFont = 0
Return $aDefFontData
EndFunc
Func MBRFunc($Start = True)
Switch $Start
Case True
RemoveZoneIdentifiers()
$g_hLibMyBot = DllOpen($g_sLibMyBotPath)
If $g_hLibMyBot = -1 Then
SetLog($g_sMBRLib & " not found.", $COLOR_ERROR)
Return False
EndIf
SetDebugLog($g_sMBRLib & " opened.")
setProcessingPoolSize($g_iGlobalThreads)
setMaxDegreeOfParallelism($g_iThreads)
Case False
DllClose($g_hLibMyBot)
SetDebugLog($g_sMBRLib & " closed.")
EndSwitch
EndFunc
Func _DllCallMyBot($sFunc, $sType1 = Default, $vParam1 = Default, $sType2 = Default, $vParam2 = Default, $sType3 = Default, $vParam3 = Default, $sType4 = Default, $vParam4 = Default, $sType5 = Default, $vParam5 = Default , $sType6 = Default, $vParam6 = Default, $sType7 = Default, $vParam7 = Default, $sType8 = Default, $vParam8 = Default, $sType9 = Default, $vParam9 = Default, $sType10 = Default, $vParam10 = Default)
If $sType1 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc)
If $sType2 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1)
If $sType3 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2)
If $sType4 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3)
If $sType5 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4)
If $sType6 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5)
If $sType7 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6)
If $sType8 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7)
If $sType9 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8)
If $sType10 = Default Then Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9)
Return DllCall($g_hLibMyBot, "str", $sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10)
EndFunc
Func DllCallMyBotIsActive()
Return $g_bLibMyBotActive
EndFunc
Func DllCallMyBot($sFunc, $sType1 = Default, $vParam1 = Default, $sType2 = Default, $vParam2 = Default, $sType3 = Default, $vParam3 = Default, $sType4 = Default, $vParam4 = Default, $sType5 = Default, $vParam5 = Default , $sType6 = Default, $vParam6 = Default, $sType7 = Default, $vParam7 = Default, $sType8 = Default, $vParam8 = Default, $sType9 = Default, $vParam9 = Default, $sType10 = Default, $vParam10 = Default)
$g_bLibMyBotActive = True
Local $aResult
Local $sFileOrFolder = Default
Switch $sFunc
Case "SearchMultipleTilesBetweenLevels", "FindTile", "SearchTile", "SearchMultipleTilesLevel", "SearchMultipleTiles", "RecheckTile", "DoOCR"
If StringLeft($vParam2, 1) <> "-" Then
$sFileOrFolder = $vParam2
$vParam2 = "-" & _Base64Encode(StringToBinary($vParam2, 4), 1024)
EndIf
EndSwitch
If $g_bDebugBetaVersion And $sFileOrFolder <> Default And StringInStr($sFileOrFolder, "\") And FileExists($sFileOrFolder) = 0 Then SetLog("Cannot access path: " & $sFileOrFolder, $COLOR_ERROR)
Local $bWasSuspended = SuspendAndroid()
$aResult = _DllCallMyBot($sFunc, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10)
Local $error = @error
Local $i = 1
While Not $error And $aResult[0] = "<GetAsyncResult>"
If Mod($i + 5, 10) = 0 Then
SetDebugLog("Waiting for DLL async function " & $sFunc & " ...")
ResumeAndroid()
EndIf
$i += 1
If _Sleep(100) Then
ResumeAndroid()
$aResult[0] = ""
$g_bLibMyBotActive = False
Return SetError(0, 0, $aResult)
EndIf
SuspendAndroid()
$aResult = _DllCallMyBot("GetAsyncResult")
$error = @error
WEnd
SuspendAndroid($bWasSuspended)
$g_bLibMyBotActive = False
Return SetError($error, @extended, $aResult)
EndFunc
Func debugMBRFunctions($iDebugSearchArea = 0, $iDebugRedArea = 0, $iDebugOcr = 0)
SetDebugLog("debugMBRFunctions: $iDebugSearchArea=" & $iDebugSearchArea & ", $iDebugRedArea=" & $iDebugRedArea & ", $giDebugOcr=" & $iDebugOcr)
Local $activeHWnD = WinGetHandle("")
Local $result = DllCall($g_hLibMyBot, "str", "setGlobalVar", "int", $iDebugSearchArea, "int", $iDebugRedArea, "int", $iDebugOcr)
If @error Then
_logErrorDLLCall($g_sLibMyBotPath & ", setGlobalVar:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $g_bDebugSetlog And $result[0] = -1 Then SetLog($g_sMBRLib & " error setting Global vars.", $COLOR_DEBUG)
Else
SetDebugLog($g_sMBRLib & " not found.", $COLOR_ERROR)
EndIf
WinActivate($activeHWnD)
EndFunc
Func setAndroidPID($pid = GetAndroidPid())
If $g_hLibMyBot = -1 Then Return
SetDebugLog("setAndroidPID: $pid=" & $pid)
Local $result = DllCall($g_hLibMyBot, "str", "setAndroidPID", "int", $pid, "str", $g_sBotVersion, "str", $g_sAndroidEmulator, "str", $g_sAndroidVersion, "str", $g_sAndroidInstance)
If @error Then
_logErrorDLLCall($g_sLibMyBotPath & ", setAndroidPID:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $result[0] = "" Then
SetDebugLog($g_sMBRLib & " error setting Android PID.")
Else
SetDebugLog("Android PID=" & $pid & " initialized: " & $result[0])
debugMBRFunctions(0, $g_bDebugRedArea ? 1 : 0, $g_bDebugOcr ? 1 : 0)
EndIf
Else
SetDebugLog($g_sMBRLib & " not found.", $COLOR_ERROR)
EndIf
EndFunc
Func SetBotGuiPID($pid = $g_iGuiPID)
If $g_hLibMyBot = -1 Then Return
SetDebugLog("SetBotGuiPID: $pid=" & $pid)
Local $result = DllCall($g_hLibMyBot, "str", "SetBotGuiPID", "int", $pid)
If @error Then
_logErrorDLLCall($g_sLibMyBotPath & ", SetBotGuiPID:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $result[0] = "" Then
SetDebugLog($g_sMBRLib & " error setting Android PID.")
Else
SetDebugLog("Bot GUI PID=" & $pid & " initialized: " & $result[0])
EndIf
Else
SetDebugLog($g_sMBRLib & " not found.", $COLOR_ERROR)
EndIf
EndFunc
Func CheckForumAuthentication()
If $g_hLibMyBot = -1 Then Return False
Local $result = DllCall($g_hLibMyBot, "boolean", "CheckForumAuthentication")
If @error Then
_logErrorDLLCall($g_sLibMyBotPath & ", CheckForumAuthentication:", @error)
Return SetError(@error)
EndIf
Local $bAuthenticated = False
If IsArray($result) Then
If $result[0] Then
SetLog(GetTranslatedFileIni("MBR Authentication", "BotIsAuthenticated", "MyBot.run is authenticated"), $COLOR_SUCCESS)
$bAuthenticated = True
Else
SetLog(GetTranslatedFileIni("MBR Authentication", "BotIsNotAuthenticated", "Error authenticating Mybot.run"), $COLOR_ERROR)
EndIf
Else
SetDebugLog($g_sMBRLib & " not found.", $COLOR_ERROR)
EndIf
Return $bAuthenticated
EndFunc
Func ForumLogin($sUsername, $sPassword)
If $g_hLibMyBot = -1 Then Return False
Local $result = DllCall($g_hLibMyBot, "str", "ForumLogin", "str", _Base64Encode(StringToBinary($sUsername, 4), 1024), "str", _Base64Encode(StringToBinary($sPassword, 4), 1024))
If @error Then
_logErrorDLLCall($g_sLibMyBotPath & ", ForumLogin:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If StringInStr($result[0], '"access_token"') > 0 Then
SetDebugLog("Forum login successful, message length: " & StringLen($result[0]))
Return $result[0]
Else
SetDebugLog("Forum login failed, message: " & $result[0])
Return $result[0]
EndIf
Else
SetDebugLog($g_sMBRLib & " not found.", $COLOR_ERROR)
EndIf
EndFunc
Func setVillageOffset($x, $y, $z)
DllCall($g_hLibMyBot, "str", "setVillageOffset", "int", $x, "int", $y, "float", $z)
$g_iVILLAGE_OFFSET[0] = $x
$g_iVILLAGE_OFFSET[1] = $y
$g_iVILLAGE_OFFSET[2] = $z
EndFunc
Func setMaxDegreeOfParallelism($iMaxDegreeOfParallelism = 0)
Local $i = Int($iMaxDegreeOfParallelism)
If $i < 1 Then $i = 0
SetDebugLog("Threading: Using " & $i & " threads for parallelism")
If $i < 1 Then $i = -1
DllCall($g_hLibMyBot, "none", "setMaxDegreeOfParallelism", "int", $i)
EndFunc
Func setProcessingPoolSize($iProcessingPoolSize = 0)
Local $i = Int($iProcessingPoolSize)
If $i < 1 Then $i = 0
SetDebugLog("Threading: Using " & $i & " threads shared across all bot instances")
If $i < 1 Then $i = -1
DllCall($g_hLibMyBot, "none", "setProcessingPoolSize", "int", $i)
EndFunc
Func ConvertVillagePos(ByRef $x, ByRef $y, $zoomfactor = 0)
If $g_hLibMyBot = -1 Then Return
Local $result = DllCall($g_hLibMyBot, "str", "ConvertVillagePos", "int", $x, "int", $y, "float", $zoomfactor)
If IsArray($result) = False Then
If $g_bDebugSetlog Then SetDebugLog("ConvertVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ConvertToVillagePos(ByRef $x, ByRef $y, $zoomfactor = 0)
If $g_hLibMyBot = -1 Then Return
Local $result = DllCall($g_hLibMyBot, "str", "ConvertToVillagePos", "int", $x, "int", $y, "float", $zoomfactor)
If IsArray($result) = False Then
If $g_bDebugSetlog Then SetDebugLog("ConvertToVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ConvertFromVillagePos(ByRef $x, ByRef $y)
If $g_hLibMyBot = -1 Then Return
Local $result = DllCall($g_hLibMyBot, "str", "ConvertFromVillagePos", "int", $x, "int", $y)
If IsArray($result) = False Then
If $g_bDebugSetlog Then SetDebugLog("ConvertVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ReduceBotMemory($bDisposeCaptures = True)
If $bDisposeCaptures = True Then _CaptureDispose()
If $g_iEmptyWorkingSetBot > 0 Then _WinAPI_EmptyWorkingSet(@AutoItPID)
EndFunc
Func RemoveZoneIdentifiers()
Local $aPaths = [@ScriptDir, $g_sLibPath, $g_sLibPath & "\adb", $g_sLibPath & "\curl"]
For $i = 0 To UBound($aPaths) - 1
Local $sPath = $aPaths[$i]
Local $aFiles = _FileListToArray($sPath, "*", $FLTA_FILES, True)
For $j = 1 To $aFiles[0]
If StringRegExp($aFiles[$j], ".+[.](exe|dll)$") Then
Local $sStream = $aFiles[$j] & ":Zone.Identifier:$DATA"
Local $h = _WinAPI_CreateFile($sStream, 2, 2)
If $h Then
_WinAPI_CloseHandle($h)
If _WinAPI_DeleteFile($sStream) Then
SetDebugLog("Removed Zone.Identifier from file: " & $sStream)
Else
SetDebugLog("Failed to remove Zone.Identifier from file: " & $sStream, $COLOR_ERROR)
EndIf
EndIf
EndIf
Next
Next
EndFunc
Global Const $g_sAdbScriptsPath = $g_sLibPath & "\adb.scripts"
Global $g_sAndroidAdbPrompt = "mybot.run:"
Global $g_bAndroidAdbPortPerInstance = True
Global $g_bAndroidAdbPort = 0
Global $g_iAndroidAdbMinitouchModeDefault = 1
Global $g_iAndroidAdbMinitouchMode = $g_iAndroidAdbMinitouchModeDefault
Global $g_bAndroidAdbMinitouchPort = 0
Global $g_bAndroidAdbMinitouchSocket = 0
Global $g_sAndroidAdbInstanceShellOptionsDefault = " -t -t"
Global $g_sAndroidAdbInstanceShellOptions = $g_sAndroidAdbInstanceShellOptionsDefault
Global $g_sAndroidAdbShellOptions = ""
Global $g_bAndroidAdbPromptUseGiven = False
Global $g_iAndroidCoCPid = 0
Global $g_iAndroidAdbProcess = [0, 0, 0, 0, 0]
Global $g_iAndroidAdbMinitouchProcess = [0, 0, 0, 0, 0]
Global $g_aiAndroidAdbClicks[1] = [-1]
Global $g_aiAndroidAdbStatsTotal[2][2] = [ [0, 0], [0, 0] ]
Global $g_aiAndroidAdbStatsLast[2][12]
$g_aiAndroidAdbStatsLast[0][0] = 0
$g_aiAndroidAdbStatsLast[0][1] = -1
$g_aiAndroidAdbStatsLast[1][0] = 0
$g_aiAndroidAdbStatsLast[1][1] = -1
Global $g_bWinGetAndroidHandleActive = False
Global $g_bAndroidSuspended = False
Global $g_bAndroidQueueReboot = False
Global $g_iAndroidSuspendedTimer = 0
Global $g_iSuspendAndroidTime = 0
Global $g_iSuspendAndroidTimeCount = 0
Global $g_hSuspendAndroidTimer = 0
Global $g_aiMouseOffset = [0, 0]
Global $g_aiMouseOffsetWindowOnly = [0, 0]
Global $g_bPullPushSharedPrefsAbdCommand = False
Global $g_PushedSharedPrefsProfile = ""
Global $g_PushedSharedPrefsProfile_Timer = 0
Global $g_bUpdateSharedPrefsLanguage = True
Global $g_bUpdateSharedPrefsSnow = True
Global $g_bUpdateSharedPrefsZoomLevel = True
Global $g_bUpdateSharedPrefsGoogleDisconnected = True
Global $g_bUpdateSharedPrefsRated = True
Func InitAndroidConfig($bRestart = False)
FuncEnter(InitAndroidConfig)
If $bRestart = False Then
$g_sAndroidEmulator = $g_avAndroidAppConfig[$g_iAndroidConfig][0]
$g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
$g_sAndroidTitle = $g_avAndroidAppConfig[$g_iAndroidConfig][2]
EndIf
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
$g_sAppPaneName = $g_avAndroidAppConfig[$g_iAndroidConfig][4]
$g_iAndroidClientWidth = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
$g_iAndroidClientHeight = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
$g_iAndroidWindowWidth = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
$g_iAndroidWindowHeight = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
$g_iAndroidAdbSuCommand = ""
$g_sAndroidAdbDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][10]
$g_iAndroidSupportFeature = $g_avAndroidAppConfig[$g_iAndroidConfig][11]
$g_sAndroidShellPrompt = $g_avAndroidAppConfig[$g_iAndroidConfig][12]
$g_sAndroidMouseDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][13]
$g_iAndroidEmbedMode = $g_avAndroidAppConfig[$g_iAndroidConfig][14]
$g_iAndroidBackgroundModeDefault = $g_avAndroidAppConfig[$g_iAndroidConfig][15]
$g_bAndroidAdbScreencap = $g_bAndroidAdbScreencapEnabled = True And BitAND($g_iAndroidSupportFeature, 2) = 2
$g_bAndroidAdbClick = $g_bAndroidAdbClickEnabled = True And AndroidAdbClickSupported()
$g_bAndroidAdbInput = $g_bAndroidAdbInputEnabled = True And BitAND($g_iAndroidSupportFeature, 8) = 8
$g_bAndroidAdbInstance = $g_bAndroidAdbInstanceEnabled = True And BitAND($g_iAndroidSupportFeature, 16) = 16
$g_bAndroidAdbClickDrag = $g_bAndroidAdbClickDragEnabled = True And BitAND($g_iAndroidSupportFeature, 32) = 32
$g_bAndroidPicturesPathAutoConfig = BitAND($g_iAndroidSupportFeature, 512) > 0
$g_bAndroidEmbed = $g_bAndroidEmbedEnabled = True And $g_iAndroidEmbedMode > -1
$g_bAndroidBackgroundLaunch = $g_bAndroidBackgroundLaunchEnabled = True
$g_bAndroidBackgroundLaunched = False
$g_bUpdateAndroidWindowTitle = False
$g_bAndroidControlUseParentPos = False
$g_sAndroidAdbInstanceShellOptions = $g_sAndroidAdbInstanceShellOptionsDefault
$g_sAndroidAdbShellOptions = ""
$g_bAndroidAdbPortPerInstance = True
$g_iAndroidRecoverStrategy = $g_iAndroidRecoverStrategyDefault
$g_iAndroidAdbMinitouchMode = $g_iAndroidAdbMinitouchModeDefault
$g_PushedSharedPrefsProfile = ""
$g_PushedSharedPrefsProfile_Timer = 0
If $g_bAndroidAdbScreencap Then
UpdateChkBackground()
EndIf
UpdateHWnD($g_hAndroidWindow, False)
FuncReturn()
EndFunc
Func AndroidSupportFeaturesSet($iValue, $iIdx = $g_iAndroidConfig)
$g_avAndroidAppConfig[$iIdx][11] = BitOR($g_avAndroidAppConfig[$iIdx][11], $iValue)
$g_iAndroidSupportFeature = BitOR($g_iAndroidSupportFeature, $iValue)
EndFunc
Func AndroidSupportFeaturesRemove($iValue, $iIdx = $g_iAndroidConfig)
$g_avAndroidAppConfig[$iIdx][11] = BitAND($g_avAndroidAppConfig[$iIdx][11], BitXOR(-1, $iValue))
$g_iAndroidSupportFeature = BitAND($g_iAndroidSupportFeature, BitXOR(-1, $iValue))
EndFunc
Func AndroidMakeDpiAware()
Return BitAND($g_iAndroidSupportFeature, 64) > 0 And $g_bAndroidAdbScreencap = False
EndFunc
Func CleanSecureFiles($iAgeInUTCSeconds = 600)
If $g_sAndroidPicturesHostPath = "" Then Return
Local $aFiles = _FileListToArray($g_sAndroidPicturesHostPath, "*", $FLTA_FILES)
If @error Then Return
For $i = 1 To $aFiles[0]
If StringRegExp($aFiles[$i], "[0-9A-F]{40}") = 1 Then
Local $aTime = FileGetTime($g_sAndroidPicturesHostPath & $aFiles[$i], $FT_CREATED)
If UBound($aTime) < 6 Then ContinueLoop
Local $tTime = _Date_Time_EncodeFileTime($aTime[1], $aTime[2], $aTime[0], $aTime[3], $aTime[4], $aTime[5])
Local $tLocal = _Date_Time_LocalFileTimeToFileTime($tTime)
Local $lo = DllStructGetData($tLocal, "Lo")
Local $hi = DllStructGetData($tLocal, "Hi")
Local $iCreated = $hi * 0x100000000 + $lo
$tTime = _Date_Time_EncodeFileTime(@MON, @MDAY, @YEAR, @HOUR, @MIN, @SEC)
$tLocal = _Date_Time_LocalFileTimeToFileTime($tTime)
$lo = DllStructGetData($tLocal, "Lo")
$hi = DllStructGetData($tLocal, "Hi")
Local $iNow = $hi * 0x100000000 + $lo
If $iCreated + $iAgeInUTCSeconds * 1000 < $iNow Then
FileDelete($g_sAndroidPicturesHostPath & $aFiles[$i])
EndIf
EndIf
Next
EndFunc
Func GetSecureFilename($Filename)
If BitAND($g_iAndroidSecureFlags, 1) = 0 Then
Return $Filename
EndIf
Return StringMid(_Crypt_HashData($Filename, $CALG_SHA1), 3)
EndFunc
Func UpdateAndroidConfig($instance = Default, $emulator = Default)
FuncEnter(UpdateAndroidConfig)
If $emulator <> Default Then
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
If $g_avAndroidAppConfig[$i][0] = $emulator Then
If $g_iAndroidConfig <> $i Then
$g_iAndroidConfig = $i
$g_sAndroidEmulator = $g_avAndroidAppConfig[$g_iAndroidConfig][0]
SetLog("Android Emulator " & $g_sAndroidEmulator)
EndIf
$emulator = Default
ExitLoop
EndIf
Next
EndIf
If $emulator <> Default Then SetLog("Unknown Android Emulator " & $emulator, $COLOR_RED)
If $instance = "" Then $instance = Default
If $instance = Default Then $instance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
SetDebugLog("UpdateAndroidConfig(""" & $instance & """)")
InitAndroidConfig(False)
$g_sAndroidInstance = $instance
If BitAND($g_iAndroidSecureFlags, 1) = 1 Then
$g_sAndroidPicturesHostFolder = ""
Else
$g_sAndroidPicturesHostFolder = "mybot.run\"
EndIf
Local $Result = InitAndroid(False, False)
SetDebugLog("UpdateAndroidConfig(""" & $instance & """) END")
Return FuncReturn($Result)
EndFunc
Func UpdateAndroidWindowState()
Local $bChanged = Execute("Update" & $g_sAndroidEmulator & "WindowState()")
If $bChanged = "" And @error <> 0 Then Return False
Return $bChanged
EndFunc
Func GetAndroidControlClass($bCheck = False, $bInit = False)
If $bInit = False And($bCheck = False Or IsString($g_sAppClassInstance) Or IsHWnd($g_sAppClassInstance)) Then Return SetError(0, 0, $g_sAppClassInstance)
$g_hAndroidControl = 0
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
Local $hAndroidWin = GetCurrentAndroidHWnD()
If IsHWnd($hAndroidWin) Then
Local $hCtrl = ControlGetHandle2($hAndroidWin, $g_sAppPaneName, $g_sAppClassInstance, 100, 100)
If $hCtrl = 0 Then
Return SetError(1, 0, $g_sAppClassInstance)
EndIf
Local $AppClass = $g_sControlGetHandle2_Classname
If BitAND($g_iAndroidSupportFeature, 256) > 0 Then $AppClass = $hCtrl
If $g_sAppClassInstance <> $AppClass Then
SetDebugLog("Update $g_sAppClassInstance to: " & $AppClass)
EndIf
$g_sAppClassInstance = $AppClass
Local $hWinParent = __WinAPI_GetParent($hCtrl)
If $hWinParent = 0 Then
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
Return SetError(1, 0, $g_sAppClassInstance)
EndIf
$g_hAndroidControl = $hWinParent
Return SetError(0, 0, $g_sAppClassInstance)
EndIf
Return SetError(0, 0, $g_sAppClassInstance)
EndFunc
Func UpdateHWnD($hWin, $bRestart = True)
FuncEnter(UpdateHWnD)
If $hWin = 0 Then
If $g_hAndroidWindow <> 0 And $bRestart Then
$g_bRestart = True
EndIf
$g_hAndroidWindow = 0
GetAndroidControlClass(True, True)
ResetAndroidProcess()
InitAndroidRebootCondition(False)
Return FuncReturn(False)
EndIf
If $g_hAndroidWindow <> 0 And $bRestart Then
$g_bRestart = True
EndIf
If $g_iAndroidProcessAffinityMask Then
Local $pid = WinGetProcess($hWin)
Local $ai_Handle = _WinAPI_OpenProcess($PROCESS_ALL_ACCESS, False, $pid)
If $ai_Handle Then
_WinAPI_SetProcessAffinityMask($ai_Handle, $g_iAndroidProcessAffinityMask)
EndIf
EndIf
$g_hAndroidWindow = $hWin
CheckDpiAwareness()
InitAndroidTimeLag()
ResetAndroidProcess()
GetAndroidControlClass(True, True)
If @error Then Return FuncReturn(SetError(1, 0, False))
Return FuncReturn(SetError(0, 0, True))
EndFunc
Func WinGetAndroidHandle($bInitAndroid = Default, $bTestPid = False)
FuncEnter(WinGetAndroidHandle)
If $bInitAndroid = Default Then $bInitAndroid = $g_bInitAndroidActive = False
If $g_bWinGetAndroidHandleActive = True Then
Return FuncReturn($g_hAndroidWindow)
EndIf
$g_bWinGetAndroidHandleActive = True
Local $currHWnD = $g_hAndroidWindow
If $g_hAndroidWindow = 0 Or $g_bAndroidBackgroundLaunched = False Then _WinGetAndroidHandle()
If IsHWnd($g_hAndroidWindow) = 1 Then
Local $aPos = WinGetPos($g_hAndroidWindow)
If IsArray($aPos) Then
If $g_bAndroidEmbedded = False And _CheckWindowVisibility($g_hAndroidWindow, $aPos) Then
SetDebugLog("Android Window '" & $g_sAndroidTitle & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1])
$aPos = WinGetPos($g_hAndroidWindow)
EndIf
EndIf
AndroidQueueReboot(False)
If($g_iAndroidPosX = $g_WIN_POS_DEFAULT Or $g_iAndroidPosY = $g_WIN_POS_DEFAULT) And UBound($aPos) > 1 Then
$g_iAndroidPosX = $aPos[0]
$g_iAndroidPosY = $aPos[1]
EndIf
If $currHWnD = 0 Or $currHWnD <> $g_hAndroidWindow Then
If $g_bAndroidEmbedded = False And IsArray($aPos) = 1 And($g_bIsHidden = False Or($aPos[0] > -30000 Or $aPos[1] > -30000)) Then
SetDebugLog("Move Android Window '" & $g_sAndroidTitle & "' to position: " & $g_iAndroidPosX & ", " & $g_iAndroidPosY)
HideAndroidWindow(False, Default, Default, "WinGetAndroidHandle:1", 0)
$aPos[0] = $g_iAndroidPosX
$aPos[1] = $g_iAndroidPosY
EndIf
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
SetLog($g_sAndroidEmulator & $instance & " running in window mode", $COLOR_ACTION)
If $currHWnD <> 0 And $currHWnD <> $g_hAndroidWindow Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
EndIf
If $g_bAndroidEmbedded = False And IsArray($aPos) = 1 Then
Local $posX = $g_iAndroidPosX
Local $posY = $g_iAndroidPosY
$g_iAndroidPosX =($aPos[0] > -30000 ? $aPos[0] : $g_iAndroidPosX)
$g_iAndroidPosY =($aPos[1] > -30000 ? $aPos[1] : $g_iAndroidPosY)
If $posX <> $g_iAndroidPosX Or $posY <> $g_iAndroidPosY Then
SetDebugLog("Updating Android Window '" & $g_sAndroidTitle & "' position: " & $g_iAndroidPosX & ", " & $g_iAndroidPosY)
EndIf
If $g_bIsHidden = True And($aPos[0] > -30000 Or $aPos[1] > -30000) Then
HideAndroidWindow(True, Default, Default, "WinGetAndroidHandle:2")
EndIf
EndIf
$g_bWinGetAndroidHandleActive = False
Return FuncReturn($g_hAndroidWindow)
EndIf
If $g_bAndroidBackgroundLaunch = False And $bTestPid = False Then
$g_bWinGetAndroidHandleActive = False
Return FuncReturn($g_hAndroidWindow)
EndIf
If $g_hAndroidWindow <> 0 Then
If $g_hAndroidWindow = ProcessExists2($g_hAndroidWindow) Then
Else
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
SetDebugLog($g_sAndroidEmulator & $instance & " process with PID = " & $g_hAndroidWindow & " not found")
UpdateHWnD(0)
EndIf
EndIf
If $g_hAndroidWindow = 0 Then
If $g_sAndroidProgramPath <> "" Then
Local $parameter = GetAndroidProgramParameter(False)
Local $parameter2 = GetAndroidProgramParameter(True)
Local $pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
If $pid = 0 And $parameter <> $parameter2 Then
$parameter = $parameter2
$pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
EndIf
Local $commandLine = $g_sAndroidProgramPath &($parameter = "" ? "" : " " & $parameter)
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
If $pid <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & $instance & " process " & $pid & " ('" & $commandLine & "')")
If $bTestPid = True Then
$g_bWinGetAndroidHandleActive = False
Return FuncReturn($pid)
EndIf
If $g_bAndroidAdbScreencap = True And $g_bAndroidAdbClick = False And AndroidAdbClickSupported() = True Then
SetLog("Enabled ADB Click to support background mode", $COLOR_ACTION)
$g_bAndroidAdbClick = True
EndIf
If $g_bAndroidAdbClick = False Or $g_bAndroidAdbScreencap = False Then
If $g_bAndroidQueueReboot = False Then
SetLog("Headless Android not supported because", $COLOR_ERROR)
Local $reason = ""
If $g_bAndroidAdbClick = False Then $reason &= "ADB Click " &($g_bAndroidAdbScreencap = False ? "and " : "")
If $g_bAndroidAdbScreencap = False Then $reason &= "ADB Screencap "
$reason &= "not available!"
SetLog($reason, $COLOR_ERROR)
AndroidQueueReboot(True)
EndIf
UpdateHWnD($pid)
If $currHWnD <> 0 And $currHWnD <> $g_hAndroidWindow Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
Else
SetLog($g_sAndroidEmulator & $instance & " running in headless mode", $COLOR_ACTION)
UpdateHWnD($pid)
If $currHWnD <> 0 And $currHWnD <> $g_hAndroidWindow Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
$g_bAndroidBackgroundLaunched = True
EndIf
setAndroidPID($pid)
Else
SetDebugLog($g_sAndroidEmulator & $instance & " process not found")
EndIf
EndIf
EndIf
If $g_hAndroidWindow = 0 Then
$g_bInitAndroid = True
$g_bAndroidBackgroundLaunched = False
EndIf
$g_bWinGetAndroidHandleActive = False
Return FuncReturn($g_hAndroidWindow)
EndFunc
Func GetAndroidPid()
Local $h = WinGetAndroidHandle(Default, True)
If IsHWnd($h) Then Return WinGetProcess($h)
Return $h
EndFunc
Func _WinGetAndroidHandle($bFindByTitle = False)
Local $hWin = WinGetHandle($g_hAndroidWindow)
If $hWin > 0 And $hWin = $g_hAndroidWindow Then Return $g_hAndroidWindow
If $g_sAppClassInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][3] Then
SetDebugLog("Restore $g_sAppClassInstance to: " & $g_avAndroidAppConfig[$g_iAndroidConfig][3])
EndIf
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
Local $i
Local $t
Local $ReInitAndroid = $g_hAndroidWindow <> 0
SetDebugLog("Searching " & $g_sAndroidEmulator & " Window: Title = '" & $g_sAndroidTitle & "', Class = '" & $g_sAppClassInstance & "', Text = '" & $g_sAppPaneName & "'")
Local $aWinList
If $bFindByTitle = True Then
$aWinList = WinList($g_sAndroidTitle)
If $aWinList[0][0] > 0 Then
For $i = 1 To $aWinList[0][0]
$hWin = $aWinList[$i][1]
$t = $aWinList[$i][0]
If $g_sAndroidTitle = $t Then
Local $hCtrl = ControlGetHandle2($hWin, $g_sAppPaneName, $g_sAppClassInstance)
If $hCtrl <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by matching title '" & $g_sAndroidTitle & "' (#1)")
UpdateHWnD($hWin)
$g_sAndroidTitle = UpdateAndroidWindowTitle($g_hAndroidWindow, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
EndIf
Next
EndIf
Local $iMode = Opt("WinTitleMatchMode", -1)
$hWin = WinGetHandle($g_sAndroidTitle)
Local $error = @error
Opt("WinTitleMatchMode", $iMode)
If $error = 0 Then
$t = WinGetTitle($hWin)
If $g_sAndroidTitle = $t And ControlGetHandle2($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 Then
If $g_hAndroidWindow <> $hWin Then SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by matching title '" & $g_sAndroidTitle & "' (#2)")
UpdateHWnD($hWin)
$g_sAndroidTitle = UpdateAndroidWindowTitle($g_hAndroidWindow, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
Else
SetDebugLog($g_sAndroidEmulator & " Window title '" & $t & "' not matching '" & $g_sAndroidTitle & "' or control")
EndIf
EndIf
$iMode = Opt("WinTitleMatchMode", -1)
$aWinList = WinList($g_sAndroidTitle)
Opt("WinTitleMatchMode", $iMode)
If $aWinList[0][0] = 0 Then
SetDebugLog($g_sAndroidEmulator & " Window not found")
If $ReInitAndroid = True Then $g_bInitAndroid = True
UpdateHWnD(0)
AndroidEmbed(False, False)
Return 0
EndIf
SetDebugLog("Found " & $aWinList[0][0] & " possible " & $g_sAndroidEmulator & " windows by title '" & $g_sAndroidTitle & "':")
For $i = 1 To $aWinList[0][0]
SetDebugLog($aWinList[$i][1] & ": " & $aWinList[$i][0])
Next
If $g_sAndroidInstance <> "" Then
For $i = 1 To $aWinList[0][0]
$t = $aWinList[$i][0]
$hWin = $aWinList[$i][1]
If StringRight($t, StringLen($g_sAndroidInstance)) = $g_sAndroidInstance And ControlGetHandle2($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") for instance " & $g_sAndroidInstance)
UpdateHWnD($hWin)
$g_sAndroidTitle = UpdateAndroidWindowTitle($g_hAndroidWindow, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
Next
EndIf
EndIf
If $g_sAndroidProgramPath <> "" Then
Local $parameter = GetAndroidProgramParameter(False)
Local $parameter2 = GetAndroidProgramParameter(True)
Local $pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
If $pid = 0 And $parameter <> $parameter2 Then
$parameter = $parameter2
$pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
EndIf
Local $commandLine = $g_sAndroidProgramPath &($parameter = "" ? "" : " " & $parameter)
If $pid <> 0 Then
If IsArray($aWinList) = 0 Then
Local $aWinList2 = _WinAPI_EnumProcessWindows($pid, True)
If IsArray($aWinList2) = 1 And $aWinList2[0][0] > 0 Then
Local $aWinList[$aWinList2[0][0] + 1][5]
$aWinList[0][0] = $aWinList2[0][0]
For $i = 1 To $aWinList2[0][0]
Local $aPos = WinGetPos($aWinList2[$i][0])
$aWinList[$i][0] = WinGetTitle($aWinList2[$i][0])
$aWinList[$i][1] = $aWinList2[$i][0]
$aWinList[$i][2] = $aWinList2[$i][1]
If UBound($aPos) > 3 Then
$aWinList[$i][3] = $aPos[2]
$aWinList[$i][4] = $aPos[3]
EndIf
SetDebugLog("Found Android window: " & $aWinList[$i][0] & ", " & $aWinList[$i][1] & ", " & $aWinList[$i][2] & ", " & $aWinList[$i][3] & ", " & $aWinList[$i][4])
Next
EndIf
EndIf
If IsArray($aWinList) = 1 Then
SetDebugLog("Found " & $aWinList[0][0] & " windows, searching for '" & $g_sAppPaneName & "' with class '" & $g_sAppClassInstance & "'")
For $i = 1 To $aWinList[0][0]
$t = $aWinList[$i][0]
$hWin = $aWinList[$i][1]
If $pid = WinGetProcess($hWin) And ControlGetHandle2($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 And $aWinList[$i][3] > 400 And $aWinList[$i][4] > 400 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by PID " & $pid & " ('" & $commandLine & "')")
UpdateHWnD($hWin)
$g_sAndroidTitle = UpdateAndroidWindowTitle($g_hAndroidWindow, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
Next
EndIf
SetDebugLog($g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")") & " Window not found for PID " & $pid)
EndIf
EndIf
SetDebugLog($g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")") & " Window not found in list")
If $ReInitAndroid = True Then $g_bInitAndroid = True
UpdateHWnD(0)
AndroidEmbed(False, False)
Return 0
EndFunc
Func UpdateAndroidWindowTitle($hWin, $t)
If $g_bUpdateAndroidWindowTitle = True And $g_sAndroidInstance <> "" And StringInStr($t, $g_sAndroidInstance) = 0 Then
$t = $g_sAndroidEmulator & " (" & $g_sAndroidInstance & ")"
_WinAPI_SetWindowText($hWin, $t)
EndIf
Return $t
EndFunc
Func AndroidControlAvailable()
If $g_bAndroidBackgroundLaunched = True Then
Return 0
EndIf
Return IsArray(GetAndroidPos(True))
EndFunc
Func GetAndroidSvcPid()
Static $iAndroidSvcPid = 0
If $iAndroidSvcPid <> 0 And $iAndroidSvcPid = ProcessExists2($iAndroidSvcPid) Then
Return $iAndroidSvcPid
EndIf
SetError(0, 0, 0)
Local $pid = Execute("Get" & $g_sAndroidEmulator & "SvcPid()")
If $pid = "" And @error <> 0 Then $pid = GetVBoxAndroidSvcPid()
If $pid <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Service PID = " & $pid)
Else
SetDebugLog("Cannot find " & $g_sAndroidEmulator & " Service PID", $COLOR_ERROR)
EndIf
$iAndroidSvcPid = $pid
Return $pid
EndFunc
Func GetVBoxAndroidSvcPid()
Local $aRegExResult = StringRegExp($__VBoxVMinfo, "UUID:\s+(.+)", $STR_REGEXPARRAYMATCH)
Local $uuid = ""
If Not @error Then $uuid = $aRegExResult[0]
If StringLen($uuid) < 32 Then
SetDebugLog("Cannot find VBox UUID", $COLOR_ERROR)
Return 0
EndIf
Local $pid = ProcessExists2("", $uuid, 1, 1)
Return $pid
EndFunc
Func GetAndroidRunningInstance($bStrictCheck = True)
FuncEnter(GetAndroidRunningInstance)
Local $runningInstance = Execute("Get" & $g_sAndroidEmulator & "RunningInstance(" & $bStrictCheck & ")")
Local $i
If $runningInstance = "" And @error <> 0 Then
Local $a[2] = [0, ""]
SetDebugLog("GetAndroidRunningInstance: Try to find """ & $g_sAndroidProgramPath & """")
Local $pids = ProcessesExist($g_sAndroidProgramPath, "", 1)
If UBound($pids) > 0 Then
Local $currentInstance = $g_sAndroidInstance
For $i = 0 To UBound($pids) - 1
Local $pid = $pids[$i]
Local $commandLine = ProcessGetCommandLine($pid)
SetDebugLog("GetAndroidRunningInstance: Found """ & $commandLine & """ by PID=" & $pid)
Local $lastSpace = StringInStr($commandLine, " ", 0, -1)
If $lastSpace > 0 Then
$g_sAndroidInstance = StringStripWS(StringMid($commandLine, $lastSpace + 1), 3)
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
EndIf
If WinGetAndroidHandle() <> 0 Then
SetDebugLog("Running " & $g_sAndroidEmulator & " instance found: """ & $g_sAndroidInstance & """")
If $a[0] = 0 Or $g_sAndroidInstance = $currentInstance Then
$a[0] = $g_hAndroidWindow
$a[1] = $g_sAndroidInstance
If $g_sAndroidInstance = $currentInstance Then ExitLoop
EndIf
Else
$g_sAndroidInstance = $currentInstance
EndIf
Next
EndIf
If $a[0] <> 0 Then SetDebugLog("Running " & $g_sAndroidEmulator & " instance is """ & $g_sAndroidInstance & """")
Return FuncReturn($a)
EndIf
Return FuncReturn($runningInstance)
EndFunc
Func DetectRunningAndroid()
FuncEnter(DetectRunningAndroid)
$g_bFoundRunningAndroid = False
Local $i, $iCurrentConfig = $g_iAndroidConfig
$g_bSilentSetLog = True
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$g_iAndroidConfig = $i
$g_bInitAndroid = True
If UpdateAndroidConfig() = True Then
Local $aRunning = GetAndroidRunningInstance(False)
If $aRunning[0] = 0 Then
Else
$g_bFoundRunningAndroid = True
$g_bSilentSetLog = False
$g_bInitAndroid = True
If InitAndroid() = True Then
SetDebugLog("Found running " & $g_sAndroidEmulator & " " & $g_sAndroidVersion)
EndIf
Return FuncReturn()
EndIf
EndIf
Next
$g_bInitAndroid = True
$g_iAndroidConfig = $iCurrentConfig
UpdateAndroidConfig()
$g_bSilentSetLog = False
SetDebugLog("Found no running Android Emulator")
FuncReturn()
EndFunc
Func DetectInstalledAndroid()
FuncEnter(DetectInstalledAndroid)
Local $i, $CurrentConfig = $g_iAndroidConfig
$g_bSilentSetLog = True
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$g_iAndroidConfig = $i
$g_bInitAndroid = True
If UpdateAndroidConfig() Then
$g_bFoundInstalledAndroid = True
$g_bSilentSetLog = False
SetDebugLog("Found installed " & $g_sAndroidEmulator & " " & $g_sAndroidVersion)
Return FuncReturn()
EndIf
Next
$g_iAndroidConfig = $CurrentConfig
$g_bInitAndroid = True
UpdateAndroidConfig()
$g_bSilentSetLog = False
SetDebugLog("Found no installed Android Emulator")
FuncReturn()
EndFunc
Func FindPreferredAdbPath()
Local $sAdb = @ScriptDir & "\lib\adb\adb.exe"
Local $aDll = ["AdbWinApi.dll", "AdbWinUsbApi.dll"]
Local $adbPath = Execute("Get" & $g_sAndroidEmulator & "AdbPath()")
Local $sAdbFolder = StringLeft($adbPath, StringInStr($adbPath, "\", 0, -1))
Local $sAdbFile = StringMid($adbPath, StringLen($sAdbFolder) + 1)
If $g_bAndroidAdbReplaceEmulatorVersion And $adbPath And FileExists($sAdb) And FileExists(@ScriptDir & "\lib\adb\" & $aDll[0]) And FileExists(@ScriptDir & "\lib\adb\" & $aDll[1]) And(FileGetSize($adbPath) <> FileGetSize($sAdb) Or FileGetSize($sAdbFolder & $aDll[0]) <> FileGetSize(@ScriptDir & "\lib\adb\" & $aDll[0]) Or FileGetSize($sAdbFolder & $aDll[1]) <> FileGetSize(@ScriptDir & "\lib\adb\" & $aDll[1])) Then
If FileCopy($sAdb, $adbPath, 1) And FileCopy(@ScriptDir & "\lib\adb\" & $aDll[0], $sAdbFolder & $aDll[0], 1) And FileCopy(@ScriptDir & "\lib\adb\" & $aDll[1], $sAdbFolder & $aDll[1], 1) Then
SetLog("Replaced " & $g_sAndroidEmulator & " ADB with MyBot.run version")
Else
SetLog("Cannot replace " & $g_sAndroidEmulator & " ADB with MyBot.run version", $COLOR_ERROR)
EndIf
EndIf
If $g_bAndroidAdbUseMyBot And FileExists($sAdb) Then
Return $sAdb
EndIf
If FileExists($g_sAndroidAdbPath) Then
Return $g_sAndroidAdbPath
EndIf
If $adbPath = "" Then
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$adbPath = Execute("Get" & $g_avAndroidAppConfig[$i][0] & "AdbPath()")
If $adbPath <> "" Then ExitLoop
Next
EndIf
If $adbPath <> "" Then
EndIf
Return $adbPath
EndFunc
Func CompareAndUpdate(ByRef $UpdateWhenDifferent, Const $New)
Local $bDifferent = $UpdateWhenDifferent <> $New
If $bDifferent Then $UpdateWhenDifferent = $New
Return $bDifferent
EndFunc
Func IncrUpdate(ByRef $i, $ReturnInitial = True)
Local $i2 = $i
$i += 1
If $ReturnInitial Then Return $i2
Return $i
EndFunc
Func InitAndroidAdbPorts($bForce = False)
Local $bUsePort = $g_bAndroidAdbPortPerInstance
If $bForce Then $g_bAndroidAdbPort = 0
If Not $g_bAndroidAdbPort Then
Local $iPortStart = 5038, $iPortRange = 255
Local $iPort = $iPortStart, $iTcpIdx = 1, $iTcpMtIdx = 0, $iMtPort
Local $hMutex = 0
$g_sAndroidAdbGlobalOptions = ""
Local $aTcpTable = _TcpTable(5, "LISTENING")
If $g_hMutex_AdbDaemon Then
ReleaseMutex($g_hMutex_AdbDaemon)
$g_hMutex_AdbDaemon = 0
EndIf
While Not $hMutex And $iPort < $iPortStart + $iPortRange
For $i = $iTcpIdx To UBound($aTcpTable) - 1
If $aTcpTable[$i][2] < $iPort Then
$iTcpIdx = $i + 1
ContinueLoop
ElseIf $aTcpTable[$i][0] = "adb.exe" Or $aTcpTable[$i][2] > $iPort Then
ExitLoop
Else
$iPort += 1
EndIf
Next
$iMtPort = 0
If $g_iAndroidAdbMinitouchMode = 0 Then
$iTcpMtIdx = _ArrayBinarySearch($aTcpTable, $iPort + 1000, 0, 0, 2)
If $iTcpMtIdx = -1 Or($iTcpMtIdx > 0 And $aTcpTable[$iTcpMtIdx][0] = "adb.exe") Then
$iMtPort = $iPort + 1000
EndIf
EndIf
If $iMtPort Or $g_iAndroidAdbMinitouchMode = 1 Then
$hMutex = CreateMutex("MyBot.run/Adb-Port-" & $iPort)
If $hMutex Then
$g_hMutex_AdbDaemon = $hMutex
$g_bAndroidAdbPort = $iPort
$g_bAndroidAdbMinitouchPort = $iMtPort
ExitLoop
EndIf
EndIf
$iPort += 1
WEnd
EndIf
If $bUsePort And $g_bAndroidAdbPort Then
SetDebugLog("Using ADB Daemon port " & $g_bAndroidAdbPort)
$g_sAndroidAdbGlobalOptions = "-P " & $g_bAndroidAdbPort
Else
If $g_bAndroidAdbPort Then
SetDebugLog("Using default ADB Daemon port, minitouch port is " &($g_bAndroidAdbPort + 1000), $COLOR_ERROR)
Else
SetDebugLog("Cannot aquire ADB Daemon port, using default", $COLOR_ERROR)
$g_bAndroidAdbMinitouchPort = 1111
EndIf
EndIf
EndFunc
Func InitAndroid($bCheckOnly = False, $bLogChangesOnly = True)
FuncEnter(InitAndroid)
If $bCheckOnly = False And $g_bInitAndroid = False Then
Return FuncReturn(True)
EndIf
$g_bAndroidInitialized = False
$g_bInitAndroidActive = True
Local $aPriorValues = [ $g_sAndroidEmulator , $g_iAndroidConfig , $g_sAndroidVersion , $g_sAndroidInstance , $g_sAndroidTitle , $g_sAndroidProgramPath , GetAndroidProgramParameter() ,((IsArray($g_avAndroidProgramFileVersionInfo) ? _ArrayToString($g_avAndroidProgramFileVersionInfo, ",", 1) : "not available")) , $g_iAndroidSecureFlags , $g_sAndroidAdbPath , $g_sAndroidAdbGlobalOptions , $__VBoxManage_Path , $g_sAndroidAdbDevice , $g_sAndroidPicturesPath , $g_sAndroidPicturesHostPath , $g_sAndroidPicturesHostFolder , $g_sAndroidMouseDevice , $g_bAndroidAdbScreencap , $g_bAndroidAdbInput , $g_bAndroidAdbClick , $g_bAndroidAdbClickDrag ,($g_bChkBackgroundMode = True ? "enabled" : "disabled") , $g_bNoFocusTampering ]
SetDebugLog("InitAndroid(" & $bCheckOnly & "): " & $g_sAndroidEmulator)
If Not $bCheckOnly Then
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
$__VBoxGuestProperties = ""
$__VBoxExtraData = ""
EndIf
Local $Result = Execute("Init" & $g_sAndroidEmulator & "(" & $bCheckOnly & ")")
If $Result = "" And @error <> 0 Then
SetLog("Android support for " & $g_sAndroidEmulator & " is not available", $COLOR_ERROR)
EndIf
Local $successful = @error = 0, $process_killed
If Not $bCheckOnly And $Result Then
InitAndroidAdbPorts()
If $b_sAndroidProgramWerFaultExcluded = True Then
Local $sFileOnly = StringMid($g_sAndroidProgramPath, StringInStr($g_sAndroidProgramPath, "\", 0, -1) + 1)
Local $aResult = DllCall("Wer.dll", "int", "WerAddExcludedApplication", "wstr", $sFileOnly, "bool", True)
If(UBound($aResult) > 0 And $aResult[0] = $S_OK) Or RegWrite($g_sHKLM & "\Software\Microsoft\Windows\Windows Error Reporting\ExcludedApplications", $sFileOnly, "REG_DWORD", "1") = 1 Then
SetDebugLog("Disabled WerFault for " & $sFileOnly)
Else
SetDebugLog("Cannot disable WerFault for " & $sFileOnly)
EndIf
Local $sPath = Execute("Get" & $g_sAndroidEmulator & "AdbPath()")
If $sPath Then
Local $sFileOnly = StringMid($sPath, StringInStr($sPath, "\", 0, -1) + 1)
Local $aResult = DllCall("Wer.dll", "int", "WerAddExcludedApplication", "wstr", $sFileOnly, "bool", True)
If(UBound($aResult) > 0 And $aResult[0] = $S_OK) Or RegWrite($g_sHKLM & "\Software\Microsoft\Windows\Windows Error Reporting\ExcludedApplications", $sFileOnly, "REG_DWORD", "1") = 1 Then
SetDebugLog("Disabled WerFault for " & $sFileOnly)
Else
SetDebugLog("Cannot disable WerFault for " & $sFileOnly)
EndIf
EndIf
EndIf
If FileExists($__VBoxManage_Path) Then
If $__VBoxGuestProperties = "" Then $__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
If $__VBoxExtraData = "" Then $__VBoxExtraData = LaunchConsole($__VBoxManage_Path, "getextradata " & $g_sAndroidInstance & " enumerate", $process_killed)
EndIf
UpdateAndroidBackgroundMode()
Local $pAndroidFileVersionInfo
If _WinAPI_GetFileVersionInfo($g_sAndroidProgramPath, $pAndroidFileVersionInfo) Then
$g_avAndroidProgramFileVersionInfo = _WinAPI_VerQueryValue($pAndroidFileVersionInfo)
Else
$g_avAndroidProgramFileVersionInfo = 0
EndIf
Local $i = 0
Local $sText = ""
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidEmulator) Or $bLogChangesOnly = False Then SetDebugLog("Android: " & $g_sAndroidEmulator)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_iAndroidConfig) Or $bLogChangesOnly = False Then SetDebugLog("Android Config: " & $g_iAndroidConfig)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidVersion) Or $bLogChangesOnly = False Then SetDebugLog("Android Version: " & $g_sAndroidVersion)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidInstance) Or $bLogChangesOnly = False Then SetDebugLog("Android Instance: " & $g_sAndroidInstance)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidTitle) Or $bLogChangesOnly = False Then SetDebugLog("Android Window Title: " & $g_sAndroidTitle)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidProgramPath) Or $bLogChangesOnly = False Then SetDebugLog("Android Program Path: " & $g_sAndroidProgramPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], GetAndroidProgramParameter()) Or $bLogChangesOnly = False Then SetDebugLog("Android Program Parameter: " & GetAndroidProgramParameter())
$sText =((IsArray($g_avAndroidProgramFileVersionInfo) ? _ArrayToString($g_avAndroidProgramFileVersionInfo, ",", 1) : "not available"))
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $sText) Or $bLogChangesOnly = False Then SetDebugLog("Android Program FileVersionInfo: " & $sText)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_iAndroidSecureFlags) Or $bLogChangesOnly = False Then SetDebugLog("Android SecureME setting: " & $g_iAndroidSecureFlags)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidAdbPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Path: " & $g_sAndroidAdbPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidAdbGlobalOptions) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Global Options: " & $g_sAndroidAdbGlobalOptions)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $__VBoxManage_Path) Or $bLogChangesOnly = False Then SetDebugLog("Android VBoxManage Path: " & $__VBoxManage_Path)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidAdbDevice) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Device: " & $g_sAndroidAdbDevice)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared Folder: " & $g_sAndroidPicturesPath)
If FileExists($g_sAndroidPicturesHostPath) Then
If($g_sAndroidPicturesHostFolder <> "" Or BitAND($g_iAndroidSecureFlags, 1) = 1) Then
DirCreate($g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder)
EndIf
ElseIf $g_sAndroidPicturesHostPath <> "" Then
EndIf
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesHostPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared Folder on Host: " & $g_sAndroidPicturesHostPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesHostFolder) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared SubFolder: " & $g_sAndroidPicturesHostFolder)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidMouseDevice) Or $bLogChangesOnly = False Then SetDebugLog("Android Mouse Device: " & $g_sAndroidMouseDevice)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbScreencap) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB screencap command enabled: " & $g_bAndroidAdbScreencap)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbInput) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB input command enabled: " & $g_bAndroidAdbInput)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbClick) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Mouse Click enabled: " & $g_bAndroidAdbClick)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbClickDrag) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Click Drag enabled: " & $g_bAndroidAdbClickDrag)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)],($g_bChkBackgroundMode = True ? "enabled" : "disabled")) Or $bLogChangesOnly = False Then SetDebugLog("Bot Background Mode for screen capture: " &($g_bChkBackgroundMode = True ? "enabled" : "disabled"))
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bNoFocusTampering) Or $bLogChangesOnly = False Then SetDebugLog("No Focus Tampering: " & $g_bNoFocusTampering)
WinGetAndroidHandle()
InitAndroidTimeLag()
InitAndroidPageError()
$g_bInitAndroid = Not $successful
$g_bAndroidInitialized = True
Else
If $bCheckOnly = False Then $g_bInitAndroid = True
EndIf
SetDebugLog("InitAndroid(" & $bCheckOnly & "): " & $g_sAndroidEmulator & " END, initialization successful = " & $successful & ", result = " & $Result)
$g_bInitAndroidActive = False
Return FuncReturn($Result)
EndFunc
Func GetAndroidProgramParameter($bAlternative = False)
Local $parameter = Execute("Get" & $g_sAndroidEmulator & "ProgramParameter(" & $bAlternative & ")")
If $parameter = "" And @error <> 0 Then $parameter = ""
Return $parameter
EndFunc
Func AndroidBotStartEvent()
reHide()
CheckAndroidRebootCondition(True, True)
Local $Result = Execute($g_sAndroidEmulator & "BotStartEvent()")
If $Result = "" And @error <> 0 Then $Result = ""
Return $Result
EndFunc
Func AndroidBotStopEvent()
Local $Result = Execute($g_sAndroidEmulator & "BotStopEvent()")
If $Result = "" And @error <> 0 Then $Result = ""
Return $Result
EndFunc
Func OpenAndroid($bRestart = False, $bStartOnlyAndroid = False, $wasRunState = $g_bRunState)
FuncEnter(OpenAndroid)
Static $OpenAndroidActive = 0
If $OpenAndroidActive >= $g_iOpenAndroidActiveMaxTry Then
SetLog("Cannot open " & $g_sAndroidEmulator & ", tried " & $OpenAndroidActive & " times...", $COLOR_ERROR)
btnStop()
Return FuncReturn(False)
EndIf
$OpenAndroidActive += 1
If $OpenAndroidActive > 1 Then
SetDebugLog("Opening " & $g_sAndroidEmulator & " recursively " & $OpenAndroidActive & ". time...")
EndIf
If $bStartOnlyAndroid = True And $wasRunState = False Then $g_bRunState = True
Local $Result = _OpenAndroid($bRestart, $bStartOnlyAndroid)
If $bStartOnlyAndroid = True And $wasRunState = False Then $g_bRunState = False
WinGetAndroidHandle()
$OpenAndroidActive -= 1
Return FuncReturn($Result)
EndFunc
Func _OpenAndroid($bRestart = False, $bStartOnlyAndroid = False)
ResumeAndroid()
Local $hMutex = AquireAdbDaemonMutex(), $process_killed
LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "devices", $process_killed)
ReleaseAdbDaemonMutex($hMutex)
If Not InitAndroid() Then
SetLog("Unable to open " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " instance '" & $g_sAndroidInstance & "'"), $COLOR_ERROR)
SetLog("Please check emulator/installation", $COLOR_ERROR)
SetLog("To switch to another emualtor, please use bot with command line parameter", $COLOR_BLUE)
SetLog("Unable to continue........", $COLOR_ERROR)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
AndroidAdbTerminateShellInstance()
If Not $g_bRunState Then Return False
WerFaultClose($g_sAndroidProgramPath)
If $g_bAndroidBackgroundLaunch = False And WinGetAndroidHandle(Default, True) <> 0 Or GetAndroidSvcPid() <> 0 Then
CloseAndroid("_OpenAndroid")
If _Sleep(1000) Then Return False
EndIf
InitAndroidRebootCondition(False)
If Not Execute("Open" & $g_sAndroidEmulator & "(" & $bRestart & ")") Then Return False
InitAndroidRebootCondition(True)
If $bStartOnlyAndroid Then
Return True
EndIf
If Not InitiateLayout() Then Return False
WinGetAndroidHandle(False)
If Not $g_bRunState Then Return False
AndroidBotStartEvent()
If Not $g_bRunState Then Return False
If Not StartAndroidCoC() Then Return False
If $bRestart = False Then
waitMainScreenMini()
If Not $g_bRunState Then Return False
Zoomout()
Else
WaitMainScreenMini()
If Not $g_bRunState Then Return False
If @error = 1 Then
$g_bRestart = True
$g_bIsClientSyncError = False
Return False
EndIf
Zoomout()
EndIf
If Not $g_bRunState Then Return False
Return True
EndFunc
Func StartAndroidCoC()
FuncEnter(StartAndroidCoC)
Return FuncReturn(RestartAndroidCoC(False, False, False))
EndFunc
Func RestartAndroidCoC($bInitAndroid = True, $bRestart = True, $bStopCoC = True)
FuncEnter(RestartAndroidCoC)
Return FuncReturn(_RestartAndroidCoC($bInitAndroid, $bRestart, $bStopCoC))
EndFunc
Func _RestartAndroidCoC($bInitAndroid = True, $bRestart = True, $bStopCoC = True)
ClearClicks()
$g_bSkipFirstZoomout = False
ResumeAndroid()
If Not $g_bRunState Then Return False
If $bInitAndroid Then
If Not InitAndroid() Then Return False
EndIf
Local $cmdOutput, $process_killed, $connected_to
ResetAndroidProcess()
Local $sRestart = ""
If $bRestart = True Then
If $bStopCoC Then
SetLog("Please wait for CoC restart.....", $COLOR_INFO)
$sRestart = "-S "
Else
SetLog("Please wait for CoC restart....", $COLOR_INFO)
EndIf
Else
SetLog("Launch Clash of Clans now...", $COLOR_SUCCESS)
EndIf
ConnectAndroidAdb()
If Not $g_bRunState Then Return False
If Not $g_bRunState Then Return False
If((ProfileSwitchAccountEnabled() And $g_bChkSharedPrefs) Or $g_bUpdateSharedPrefs) And HaveSharedPrefs() And($g_bUpdateSharedPrefs Or $g_PushedSharedPrefsProfile <> $g_sProfileCurrentName Or($g_PushedSharedPrefsProfile_Timer = 0 Or __TimerDiff($g_PushedSharedPrefsProfile_Timer) > 120000)) Then PushSharedPrefs()
$cmdOutput = AndroidAdbSendShellCommand("set export=$(am start " & $sRestart & "-n " & $g_sAndroidGamePackage & "/" & $g_sAndroidGameClass & " >&2)", 60000)
If StringInStr($cmdOutput, "Error:") > 0 And StringInStr($cmdOutput, $g_sAndroidGamePackage) > 0 Then
SetLog("Unable to load Clash of Clans, install/reinstall the game.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
If StringInStr($cmdOutput, "Exception") > 0 Then
If Not RebootAndroid() Then Return False
EndIf
If Not IsAdbConnected($cmdOutput) Then
If Not ConnectAndroidAdb() Then Return False
EndIf
If Not $g_bRunState Then Return False
AndroidAdbLaunchShellInstance()
InitAndroidTimeLag()
Return True
EndFunc
Func ResetAndroidProcess()
$g_iAndroidCoCPid = 0
$g_bMainWindowOk = False
EndFunc
Func CloseAndroid($sSource)
FuncEnter(CloseAndroid)
ResumeAndroid()
ResetAndroidProcess()
SetLog("Stopping " & $g_sAndroidEmulator & "....", $COLOR_INFO)
SetDebugLog("CloseAndroid, caller: " & $sSource)
AndroidEmbed(False)
AndroidAdbTerminateShellInstance()
If Not $g_bRunState Then Return FuncReturn(False)
SetLog("Please wait for full " & $g_sAndroidEmulator & " shutdown...", $COLOR_SUCCESS)
Local $pid = GetAndroidPid()
If ProcessExists2($pid) Then
KillProcess($pid, "CloseAndroid")
If _SleepStatus(1000) Then Return FuncReturn(False)
EndIf
Local $Result = Execute("Close" & $g_sAndroidEmulator & "()")
If Not $g_bRunState Then Return FuncReturn(False)
If ProcessExists($pid) Then
SetLog("Failed to stop " & $g_sAndroidEmulator, $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " stopped successfully", $COLOR_SUCCESS)
EndIf
If Not $g_bRunState Then Return FuncReturn(False)
RemoveGhostTrayIcons()
Return FuncReturn(True)
EndFunc
Func CloseVboxAndroidSvc()
Local $process_killed
If Not $g_bRunState Then Return
LaunchConsole($__VBoxManage_Path, "controlvm " & $g_sAndroidInstance & " poweroff", $process_killed, 30000)
If _SleepStatus(3000) Then Return
EndFunc
Func CheckAndroidRunning($bQuickCheck = True, $bStartIfRequired = True, $bStartOnlyAndroid = False)
FuncEnter(CheckAndroidRunning)
Local $hWin = $g_hAndroidWindow
If WinGetAndroidHandle() = 0 Or($bQuickCheck = False And $g_bAndroidBackgroundLaunched = False And AndroidControlAvailable() = 0) Then
SetDebugLog($g_sAndroidEmulator & " not running")
If $bStartIfRequired = True Then
If $hWin = 0 Then
OpenAndroid(True, $bStartOnlyAndroid)
Else
RebootAndroid()
EndIf
EndIf
Return FuncReturn(False)
EndIf
Return FuncReturn(True)
EndFunc
Func SetScreenAndroid()
ResumeAndroid()
If Not $g_bRunState Then Return False
SetLog("Set " & $g_sAndroidEmulator & " screen resolution to " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight, $COLOR_INFO)
Local $Result = Execute("SetScreen" & $g_sAndroidEmulator & "()")
If $Result Then
SetLog("A restart of your computer might be required", $COLOR_ACTION)
SetLog("for the applied changes to take effect.", $COLOR_ACTION)
EndIf
Return $Result
EndFunc
Func CloseUnsupportedAndroid()
ResumeAndroid()
If Not $g_bRunState Then Return False
SetError(0, 0, 0)
Local $Closed = Execute("CloseUnsupported" & $g_sAndroidEmulator & "()")
If $Closed = "" And @error <> 0 Then Return False
Return $Closed
EndFunc
Func RebootAndroidSetScreen()
ResumeAndroid()
If Not $g_bRunState Then Return False
Return Execute("Reboot" & $g_sAndroidEmulator & "SetScreen()")
EndFunc
Func IsAdbTCP()
Return StringInStr($g_sAndroidAdbDevice, ":") > 0
EndFunc
Func WaitForRunningVMS($WaitInSec = 120, $hTimer = 0)
ResumeAndroid()
If Not $g_bRunState Then Return True
Local $cmdOutput, $connected_to, $running, $process_killed, $hMyTimer
$hMyTimer =($hTimer = 0 ? __TimerInit() : $hTimer)
While True
If Not $g_bRunState Then Return True
$cmdOutput = LaunchConsole($__VBoxManage_Path, "list runningvms", $process_killed)
If Not $g_bRunState Then Return True
$running = StringInStr($cmdOutput, """" & $g_sAndroidInstance & """") > 0
If $running = True Then ExitLoop
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
_Sleep(3000)
If __TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for boot completed", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
WEnd
Return False
EndFunc
Func FindAvaiableInstances($sVboxManage = $__VBoxManage_Path)
Local $a = []
If FileExists($sVboxManage) = 0 Then
If $g_bDebugAndroid Then SetDebugLog("Cannot check for available " & $g_sAndroidEmulator & " instances: VBoxManager.exe not available", $COLOR_ERROR)
Return $a
EndIf
ResumeAndroid()
Local $cmdOutput, $connected_to, $running, $process_killed, $hMyTimer
$cmdOutput = LaunchConsole($sVboxManage, "list vms", $process_killed)
If $g_bDebugAndroid Then SetDebugLog("Available " & $g_sAndroidEmulator & " instances: " & $cmdOutput, $COLOR_ERROR)
$a = StringRegExp($cmdOutput, """(.*?)""", $STR_REGEXPARRAYGLOBALMATCH)
If @error Then Local $a = []
Return $a
EndFunc
Func GetAndroidVMinfo(ByRef $sVMinfo, $sVboxManage = $__VBoxManage_Path)
Local $process_killed
Local $as_Instances
$sVMinfo = LaunchConsole($sVboxManage, "showvminfo " & $g_sAndroidInstance, $process_killed)
If StringInStr($sVMinfo, "Could not find a registered machine named") > 0 Then
$as_Instances = FindAvaiableInstances($sVboxManage)
For $s In $as_Instances
If StringCompare($g_sAndroidInstance, $s, $STR_NOCASESENSE) = 0 Then
SetDebugLog("Using " & $g_sAndroidEmulator & " instance " & $s & " (" & $g_sAndroidInstance & " not found!)", $COLOR_ERROR)
$g_sAndroidInstance = $s
$sVMinfo = LaunchConsole($sVboxManage, "showvminfo " & $g_sAndroidInstance, $process_killed)
ExitLoop
EndIf
Next
EndIf
If StringInStr($sVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $g_sAndroidEmulator & " instance " & $g_sAndroidInstance, $COLOR_ERROR)
If UBound($as_Instances) = 0 Then
SetLog("No " & $g_sAndroidEmulator & " instance found, please check installation", $COLOR_ERROR)
Else
SetLog("Available " & $g_sAndroidEmulator & " instances are:", $COLOR_ERROR)
For $s In $as_Instances
SetLog($s, $COLOR_ERROR)
Next
EndIf
Return False
EndIf
Return True
EndFunc
Func WaitForAndroidBootCompleted($WaitInSec = 120, $hTimer = 0)
ResumeAndroid()
If Not $g_bRunState Then Return True
Local $cmdOutput, $connected_to, $booted, $process_killed, $hMyTimer
$hMyTimer =($hTimer = 0 ? __TimerInit() : $hTimer)
While True
If Not $g_bRunState Then Return True
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbShellOptions & " getprop sys.boot_completed", $process_killed)
If InvalidAdbShellOptions($cmdOutput, "WaitForAndroidBootCompleted") Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbShellOptions & " getprop sys.boot_completed", $process_killed)
EndIf
If Not $g_bRunState Then Return True
$connected_to = IsAdbConnected($cmdOutput)
If Not $g_bRunState Then Return True
If Not $connected_to Then ConnectAndroidAdb(False)
If Not $g_bRunState Then Return True
$booted = StringLeft($cmdOutput, 1) = "1"
If $booted = True Then ExitLoop
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
If _Sleep(5000) Then Return True
If __TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for boot completed", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
WEnd
Return False
EndFunc
Func IsAdbConnected($cmdOutput = Default)
ResumeAndroid()
If $__TEST_ERROR_ADB_DEVICE_NOT_FOUND Then Return False
Local $process_killed, $connected_to
If $cmdOutput = Default Then
If IsAdbTCP() Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "connect " & $g_sAndroidAdbDevice, $process_killed)
$connected_to = StringInStr($cmdOutput, "connected to") > 0
If $connected_to Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbShellOptions & " echo $USER:$USER_ID", $process_killed)
$connected_to = StringInStr($cmdOutput, " not ") = 0 And StringInStr($cmdOutput, "unable") = 0 And StringInStr($cmdOutput, "error: ") = 0 And StringInStr($cmdOutput, "device ") = 0 And $process_killed = False
EndIf
Else
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbShellOptions & " echo $USER:$USER_ID", $process_killed)
$connected_to = StringInStr($cmdOutput, " not ") = 0 And StringInStr($cmdOutput, "unable") = 0 And StringInStr($cmdOutput, "error: ") = 0 And $process_killed = False
EndIf
If Not $connected_to And InvalidAdbShellOptions($cmdOutput, "IsAdbConnected") Then
Return IsAdbConnected()
EndIf
Else
$connected_to = StringInStr($cmdOutput, " not ") = 0 And StringInStr($cmdOutput, "unable") = 0 And StringInStr($cmdOutput, "error: ") = 0
EndIf
Return $connected_to
EndFunc
Func AquireAdbDaemonMutex($timout = 30000)
Local $timer = __TimerInit()
Local $g_hMutex_MyBot = 0
While $g_hMutex_MyBot = 0 And __TimerDiff($timer) < $timout
$g_hMutex_MyBot = CreateMutex("MyBot.run/AdbDaemonLaunch" & $g_sAndroidAdbGlobalOptions)
If $g_hMutex_MyBot <> 0 Then ExitLoop
If _Sleep(250) Then ExitLoop
WEnd
Return $g_hMutex_MyBot
EndFunc
Func ReleaseAdbDaemonMutex($hMutex, $ReturnValue = Default)
Return ReleaseMutex($hMutex, $ReturnValue)
EndFunc
Func KillAdbDaemon($bMutexLock = True)
Local $hMutex = -1
If $bMutexLock Then $hMutex = AquireAdbDaemonMutex()
If $hMutex = 0 Then
SetDebugLog("Cannot acquire ADB mutex to kill daemon", $COLOR_ERROR)
Return False
EndIf
SetDebugLog("Stop ADB daemon!", $COLOR_ERROR)
Local $process_killed
LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "kill-server", $process_killed)
Local $sPort = ""
If $g_bAndroidAdbPort Then $sPort = String($g_bAndroidAdbPort)
Local $pids = ProcessesExist($g_sAndroidAdbPath, $sPort, 1, 1)
For $i = 0 To UBound($pids) - 1
KillProcess($pids[$i], $g_sAndroidAdbPath)
Next
Return ReleaseAdbDaemonMutex($hMutex, True)
EndFunc
Func ConnectAndroidAdb($rebootAndroidIfNeccessary = $g_bRunState, $bStartOnlyAndroid = False, $timeout = 15000)
FuncEnter(ConnectAndroidAdb)
Return FuncReturn(_ConnectAndroidAdb($rebootAndroidIfNeccessary, $bStartOnlyAndroid, $timeout))
EndFunc
Func _ConnectAndroidAdb($rebootAndroidIfNeccessary = $g_bRunState, $bStartOnlyAndroid = False, $timeout = 15000)
If $g_sAndroidAdbPath = "" Or FileExists($g_sAndroidAdbPath) = 0 Then
SetLog($g_sAndroidEmulator & " ADB Path not valid: " & $g_sAndroidAdbPath, $COLOR_ERROR)
Return 0
EndIf
ResumeAndroid()
Local $bRebooted = False
If $rebootAndroidIfNeccessary = True Then
WinGetAndroidHandle()
If AndroidInvalidState() Then
SetDebugLog("ConnectAndroidAdb: Reboot Android as it's not running")
$bRebooted = RebootAndroid(True, $bStartOnlyAndroid)
EndIf
EndIf
Local $hMutex = AquireAdbDaemonMutex()
Local $process_killed, $cmdOutput
Local $connected_to = False
Local $timer = __TimerInit()
Local $timerReInit = $timer
While __TimerDiff($timer) < $timeout
$connected_to = IsAdbConnected()
If $connected_to Then Return ReleaseAdbDaemonMutex($hMutex, 1)
Local $ms = $timeout - __TimerDiff($timer)
If $ms > 3000 Then $ms = 3000
If _Sleep($ms) Then Return ReleaseAdbDaemonMutex($hMutex, 0)
If __TimerDiff($timerReInit) >= 10000 Then
$timerReInit = __TimerInit()
$g_bInitAndroid = True
InitAndroid()
EndIf
WEnd
Switch $g_iAndroidRecoverStrategy
Case 0
KillAdbDaemon(False)
$connected_to = IsAdbConnected()
ReleaseAdbDaemonMutex($hMutex)
If Not $connected_to And $g_bRunState = True And $rebootAndroidIfNeccessary = True Then
SetLog("ADB cannot connect to " & $g_sAndroidEmulator & ", restart emulator now...", $COLOR_ERROR)
$bRebooted = RebootAndroid()
If Not $bRebooted Then Return 0
$connected_to = ConnectAndroidAdb(False, $bStartOnlyAndroid)
If Not $connected_to Then
If Not $g_bRunState Then Return 0
SetLog("ADB really cannot connect to " & $g_sAndroidEmulator & "!", $COLOR_ERROR)
SetLog("Please restart bot, emulator and/or PC...", $COLOR_ERROR)
EndIf
EndIf
Case 1
ReleaseAdbDaemonMutex($hMutex)
If $rebootAndroidIfNeccessary Then
SetDebugLog("ConnectAndroidAdb: Reboot Android due to ADB connection problems...", $COLOR_ERROR)
$bRebooted = RebootAndroid()
If Not $bRebooted Then Return 0
Else
SetDebugLog("ConnectAndroidAdb: Reboot Android nor ADB Daemon not allowed", $COLOR_ERROR)
Return 0
EndIf
$connected_to = IsAdbConnected()
If Not $connected_to Then
SetDebugLog("Stop ADB daemon!", $COLOR_ERROR)
LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "kill-server", $process_killed)
Local $sPort = ""
If $g_bAndroidAdbPort Then $sPort = String($g_bAndroidAdbPort)
Local $pids = ProcessesExist($g_sAndroidAdbPath, $sPort, 1, 1)
For $i = 0 To UBound($pids) - 1
KillProcess($pids[$i], $g_sAndroidAdbPath)
Next
$connected_to = ConnectAndroidAdb(False, $bStartOnlyAndroid)
If Not $connected_to Then
If Not $g_bRunState Then Return 0
SetLog("ADB really cannot connect to " & $g_sAndroidEmulator & "!", $COLOR_ERROR)
SetLog("Please restart bot, emulator and/or PC...", $COLOR_ERROR)
EndIf
EndIf
EndSwitch
Return(($connected_to) ?(($bRebooted) ?(2) :(1)) :(0))
EndFunc
Func RebootAndroid($bRestart = True, $bStartOnlyAndroid = False)
FuncEnter(RebootAndroid)
ResumeAndroid()
If Not $g_bRunState Then Return FuncReturn(False)
If CloseUnsupportedAndroid() Then
Else
CloseAndroid("RebootAndroid")
EndIf
If _Sleep(1000) Then Return FuncReturn(False)
Return FuncReturn(OpenAndroid($bRestart, $bStartOnlyAndroid))
EndFunc
Func RebootAndroidSetScreenDefault()
ResumeAndroid()
If Not $g_bRunState Then Return False
AndroidSetFontSizeNormal()
If Not $g_bRunState Then Return False
CloseAndroid("RebootAndroidSetScreenDefault")
If _Sleep(1000) Then Return False
SetScreenAndroid()
If Not $g_bRunState Then Return False
Return OpenAndroid(True)
EndFunc
Func CheckScreenAndroid($ClientWidth, $ClientHeight, $bSetLog = True)
ResumeAndroid()
If Not $g_bRunState Then Return True
Local $AndroidWinPos = WinGetPos($g_hAndroidWindow)
If IsArray($AndroidWinPos) = 1 Then
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
If $WinWidth <> $g_iAndroidWindowWidth Or $WinHeight <> $g_iAndroidWindowHeight Then
SetDebugLog("CheckScreenAndroid: Window size " & $WinWidth & " x " & $WinHeight & " <> " & $g_iAndroidWindowWidth & " x " & $g_iAndroidWindowHeight, $COLOR_ERROR)
Else
SetDebugLog("CheckScreenAndroid: Window size " & $WinWidth & " x " & $WinHeight)
EndIf
EndIf
Local $ok =($ClientWidth = $g_iAndroidClientWidth) And($ClientHeight = $g_iAndroidClientHeight)
If Not $ok Then
If $bSetLog Then SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen resolution of " & $ClientWidth & " x " & $ClientHeight & "!", $COLOR_ERROR)
SetDebugLog("CheckScreenAndroid: " & $ClientWidth & " x " & $ClientHeight & " <> " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight)
Return False
EndIf
SetError(0, 0, 0)
$ok = Execute("CheckScreen" & $g_sAndroidEmulator & "(" & $bSetLog & ")")
If $ok = "" And @error <> 0 Then
$ok = True
EndIf
If Not $ok Then
If $bSetLog Then SetLog($g_sAndroidEmulator & " misses required configuration!", $COLOR_ERROR)
Return False
EndIf
AndroidAdbLaunchShellInstance()
If Not $g_bRunState Then Return True
Local $s_font_scale = AndroidAdbSendShellCommand("settings get system font_scale")
Local $font_scale = Number($s_font_scale)
If $font_scale > 0 Then
SetDebugLog($g_sAndroidEmulator & " font_scale = " & $font_scale)
If $font_scale <> 1 Then
SetLog("MyBot doesn't work with Display Font Scale of " & $font_scale, $COLOR_ERROR)
Return False
EndIf
Else
Switch $g_sAndroidEmulator
Case "BlueStacks", "BlueStacks2"
Case Else
SetDebugLog($g_sAndroidEmulator & " Display Font Scale cannot be verified", $COLOR_ERROR)
EndSwitch
EndIf
Return $ok
EndFunc
Func AndroidSetFontSizeNormal()
ResumeAndroid()
AndroidAdbLaunchShellInstance($g_bRunState, False)
SetLog("Set " & $g_sAndroidEmulator & " Display Font Scale to normal", $COLOR_INFO)
AndroidAdbSendShellCommand("settings put system font_scale 1.0", Default, Default, False)
EndFunc
Func AndroidInitPrompt()
If Not $g_bAndroidAdbInstance Then Return
Local $bIdentified = False
Local $s
Sleep(250)
AndroidAdbSendShellCommand("", -250, Default, False, False)
AndroidAdbSendShellCommand("", -250, Default, False, False)
If $g_bAndroidAdbPromptUseGiven Then
$s = AndroidAdbSendShellCommand("", -500, Default, False, False)
If $s Then
$g_sAndroidAdbPrompt = StringStripWS($s, $STR_STRIPLEADING)
SetDebugLog("Initialize shell prompt with '" & $g_sAndroidAdbPrompt & "'")
$bIdentified = True
Else
SetDebugLog("ADB Prompt not identified!", $COLOR_ERROR)
SetDebugLog("ADB Result: " & $s, $COLOR_ERROR)
EndIf
EndIf
If Not $bIdentified Then
SetDebugLog("Initialize shell prompt with '" & $g_sAndroidAdbPrompt & "'")
$s = AndroidAdbSendShellCommand("export PS1=" & $g_sAndroidAdbPrompt, -500, Default, False)
EndIf
Return $s
EndFunc
Func AndroidAdbLaunchShellInstance($wasRunState = Default, $rebootAndroidIfNeccessary = $g_bRunState)
Static $bAndroidAdbLaunchShellInstanceActive = False
Local $bWasActive = $bAndroidAdbLaunchShellInstanceActive
FuncEnter(AndroidAdbLaunchShellInstance)
$bAndroidAdbLaunchShellInstanceActive = True
Local $Result = _AndroidAdbLaunchShellInstance($wasRunState,(($bWasActive) ?(False) :($rebootAndroidIfNeccessary)))
$bAndroidAdbLaunchShellInstanceActive = $bWasActive
Return FuncReturn($Result)
EndFunc
Func _AndroidAdbLaunchShellInstance($wasRunState = Default, $rebootAndroidIfNeccessary = $g_bRunState)
If $wasRunState = Default Then $wasRunState = $g_bRunState
Local $iConnected
If Not $g_bAndroidInitialized Or $g_iAndroidAdbProcess[0] = 0 Or ProcessExists2($g_iAndroidAdbProcess[0]) <> $g_iAndroidAdbProcess[0] Then
Local $SuspendMode = ResumeAndroid()
InitAndroid()
Local $s
If(Not $g_sAndroidPicturesHostPath Or Not $g_bAndroidSharedFolderAvailable) And $g_bAndroidPicturesPathAutoConfig And $rebootAndroidIfNeccessary Then
RebootAndroidSetScreenDefault()
EndIf
Local $hostFolder = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
If FileExists($hostFolder) = 1 Then
SetDebugLog($hostFolder & " exists")
Local $aTools = ["toybox", "minitouch"]
Local $tool
For $tool In $aTools
Local $srcFile = $g_sAdbScriptsPath & "\" & $tool
Local $dstFile = $hostFolder & $tool
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
Next
EndIf
If $g_bAndroidAdbInstance = True Then
$iConnected = ConnectAndroidAdb($rebootAndroidIfNeccessary)
If $iConnected = 0 Or($iConnected = 2 And $g_iAndroidAdbProcess[0] = 0) Then
Return SetError(3, 0)
ElseIf $iConnected = 2 And $g_iAndroidAdbProcess[0] Then
Return SetError(0, 0)
EndIf
AndroidAdbTerminateShellInstance()
Local $cmd = '"' & $g_sAndroidAdbPath & '"' & AddSpace($g_sAndroidAdbGlobalOptions, 1) & " -s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbInstanceShellOptions & $g_sAndroidAdbShellOptions
SetDebugLog("Run pipe ADB shell: " & $cmd)
$g_iAndroidAdbProcess[0] = RunPipe($cmd, "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED), $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4])
Sleep(500)
If $g_sAndroidAdbInstanceShellOptions And $g_iAndroidAdbProcess[0] <> 0 And ProcessExists2($g_iAndroidAdbProcess[0]) <> $g_iAndroidAdbProcess[0] Then
Local $aReadPipe = $g_iAndroidAdbProcess[2]
Local $output = ReadPipe($aReadPipe[0])
If InvalidAdbInstanceShellOptions($output, "_AndroidAdbLaunchShellInstance") Then
ClosePipe($g_iAndroidAdbProcess[0], $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4])
$cmd = '"' & $g_sAndroidAdbPath & '"' & AddSpace($g_sAndroidAdbGlobalOptions, 1) & " -s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbInstanceShellOptions & $g_sAndroidAdbShellOptions
SetDebugLog("Run pipe ADB shell: " & $cmd)
$g_iAndroidAdbProcess[0] = RunPipe('"' & $g_sAndroidAdbPath & '"' & AddSpace($g_sAndroidAdbGlobalOptions, 1) & " -s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbInstanceShellOptions & $g_sAndroidAdbShellOptions, "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED), $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4])
Sleep(500)
EndIf
EndIf
If $g_sAndroidAdbShellOptions And $g_iAndroidAdbProcess[0] <> 0 And ProcessExists2($g_iAndroidAdbProcess[0]) <> $g_iAndroidAdbProcess[0] Then
Local $aReadPipe = $g_iAndroidAdbProcess[2]
Local $output = ReadPipe($aReadPipe[0])
If InvalidAdbShellOptions($output, "_AndroidAdbLaunchShellInstance") Then
ClosePipe($g_iAndroidAdbProcess[0], $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4])
$cmd = '"' & $g_sAndroidAdbPath & '"' & AddSpace($g_sAndroidAdbGlobalOptions, 1) & " -s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbInstanceShellOptions & $g_sAndroidAdbShellOptions
SetDebugLog("Run pipe ADB shell: " & $cmd)
$g_iAndroidAdbProcess[0] = RunPipe('"' & $g_sAndroidAdbPath & '"' & AddSpace($g_sAndroidAdbGlobalOptions, 1) & " -s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbInstanceShellOptions & $g_sAndroidAdbShellOptions, "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED), $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4])
Sleep(500)
EndIf
EndIf
If $g_iAndroidAdbProcess[0] = 0 Or ProcessExists2($g_iAndroidAdbProcess[0]) <> $g_iAndroidAdbProcess[0] Then
SetLog($g_sAndroidEmulator & " error launching ADB for background mode, zoom-out, mouse click and input", $COLOR_ERROR)
$g_iAndroidAdbProcess[0] = 0
$g_bAndroidAdbScreencap = False
$g_bAndroidAdbClick = False
$g_bAndroidAdbInput = False
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
Return SetError(1, 0)
Else
AndroidInitPrompt()
EndIf
EndIf
If $g_bAndroidAdbInstance = True Then
$s = ""
Local $scriptFile = ""
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\shell.init." & $g_sAndroidEmulator & ".script") = 1 Then $scriptFile = "shell.init." & $g_sAndroidEmulator & ".script"
If $scriptFile = "" Then $scriptFile = "shell.init.script"
$s &= AndroidAdbSendShellCommandScript($scriptFile, Default, True, 3000, $wasRunState, False)
$s &= AndroidInitPrompt()
Local $error = @error
SetDebugLog("ADB shell launched, PID = " & $g_iAndroidAdbProcess[0] & ": " & $s)
If $error <> 0 Then
Return SetError(1, 0)
EndIf
EndIf
If True Then
$iConnected = ConnectAndroidAdb($rebootAndroidIfNeccessary)
If $iConnected = 0 Or($iConnected = 2 And $g_iAndroidAdbProcess[0] = 0) Then
Return SetError(3, 0)
ElseIf $iConnected = 2 And $g_iAndroidAdbProcess[0] Then
Return SetError(0, 0)
EndIf
Local $pathFound = False
Local $iMount
For $iMount = 0 To 29
$s = AndroidAdbSendShellCommand("mount", Default, $wasRunState, False)
Local $path = $g_sAndroidPicturesPath
If StringRight($path, 1) = "/" Then $path = StringLeft($path, StringLen($path) - 1)
Local $aRegExResult = StringRegExp($s, "[^ ]+(?: on)* ([^ ]+).+", $STR_REGEXPARRAYGLOBALMATCH)
SetError(0)
Local $aMounts[0]
If $path Then _ArrayConcatenate($aMounts, StringSplit(((StringLeft($path, 1) = "(" And StringRight($path, 1) = ")") ? StringMid($path, 2, StringLen($path) - 2) : $path), "|", $STR_NOCOUNT))
If UBound($aRegExResult) > 0 Then _ArrayConcatenate($aMounts, $aRegExResult)
Local $dummyFile = StringMid(_Crypt_HashData($g_sBotTitle & _Now(), $CALG_SHA1), 3)
If FileWriteLine($g_sAndroidPicturesHostPath & $dummyFile, _Now()) Then
SetDebugLog("Created dummy file: " & $g_sAndroidPicturesHostPath & $dummyFile)
Else
SetLog("Cannot create dummy file: " & $g_sAndroidPicturesHostPath & $dummyFile, $COLOR_ERROR)
Return SetError(4, 0)
EndIf
For $i = 0 To UBound($aMounts) - 1
$path = $aMounts[$i]
If $path = "" Then ContinueLoop
If StringRight($path, 1) <> "/" Then $path &= "/"
$s = AndroidAdbSendShellCommand("set result=$(ls '" & $path & $dummyFile & "' >&2)", 10000, $wasRunState, False)
If StringInStr($s, $dummyFile) > 0 And StringInStr($s, $dummyFile & ":") = 0 And StringInStr($s, "No such file or directory") = 0 And StringInStr($s, "syntax error") = 0 And StringInStr($s, "Permission denied") = 0 Then
$pathFound = True
$g_sAndroidPicturesPath = $path
SetDebugLog("Using " & $g_sAndroidPicturesPath & " for Android shared folder")
ExitLoop
EndIf
Next
FileDelete($g_sAndroidPicturesHostPath & $dummyFile)
If $pathFound = True Then ExitLoop
If $iMount = 0 Then
SetLog("Waiting for shared folder to get mounted...", $COLOR_GREEN)
Else
SetDebugLog("Still waiting for shared folder to get mounted...")
EndIf
If _Sleep(6000) Then Return
Next
$g_sAndroidPicturesPathAvailable = $pathFound
If $pathFound = False Then
SetLog($g_sAndroidEmulator & " cannot use ADB on shared folder, """ & $g_sAndroidPicturesPath & """ not found", $COLOR_ERROR)
EndIf
AndroidAdbSendShellCommand("", Default, $wasRunState, False)
$g_iAndroidVersionAPI = Int(AndroidAdbSendShellCommand("getprop ro.build.version.sdk", Default, $wasRunState, False))
SetDebugLog("Android Version API = " & $g_iAndroidVersionAPI)
EndIf
If StringLen($g_sAndroidMouseDevice) > 0 And $g_sAndroidMouseDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][13] Then
$iConnected = ConnectAndroidAdb($rebootAndroidIfNeccessary)
If $iConnected = 0 Or($iConnected = 2 And $g_iAndroidAdbProcess[0] = 0) Then
Return SetError(3, 0)
ElseIf $iConnected = 2 And $g_iAndroidAdbProcess[0] Then
Return SetError(0, 0)
EndIf
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then
$s = AndroidAdbSendShellCommand("getevent -p", Default, $wasRunState, False)
SetDebugLog($g_sAndroidEmulator & " getevent -p: " & $s)
Local $aRegExResult = StringRegExp($s, "(\/dev\/input\/event\d+)[\r\n]+.+""" & $g_sAndroidMouseDevice & """((?!\/dev\/input\/event)[\s\S])+ABS", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$g_sAndroidMouseDevice = $aRegExResult[0]
SetDebugLog("Using " & $g_sAndroidMouseDevice & " for mouse events")
Else
$aRegExResult = StringRegExp($s, "(\/dev\/input\/event\d+)[\r\n]+.+"".+""((?!\/dev\/input\/event)[\s\S])+ABS \(\d+\): 0035.+max " & $g_iGAME_WIDTH & ".+\n.+0036.+max " & $g_iGAME_HEIGHT, $STR_REGEXPARRAYMATCH)
If @error = 0 Then
SetDebugLog("Using " & $aRegExResult[0] & " for mouse events (" & $g_sAndroidMouseDevice & " not found)")
$g_sAndroidMouseDevice = $aRegExResult[0]
Else
$g_bAndroidAdbClick = False
SetLog($g_sAndroidEmulator & " cannot use ADB for mouse events, """ & $g_sAndroidMouseDevice & """ not found", $COLOR_ERROR)
Return SetError(2, 1)
EndIf
EndIf
EndIf
Else
SetDebugLog($g_sAndroidEmulator & " ADB use " & $g_sAndroidMouseDevice & " for mouse events")
EndIf
If $g_bAndroidAdbMinitouchSocket Then
TCPCloseSocket($g_bAndroidAdbMinitouchSocket)
$g_bAndroidAdbMinitouchSocket = 0
EndIf
If $g_iAndroidAdbMinitouchMode = 0 Then
If $g_bAndroidAdbMinitouchPort Then
SetDebugLog($g_sAndroidEmulator & " initialize minitouch on port " & $g_bAndroidAdbMinitouchPort)
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
Local $output = AndroidAdbSendShellCommand($androidPath & "minitouch -d " & $g_sAndroidMouseDevice & " >/dev/null 2>&1 &", -1000, $wasRunState, False)
AndroidAdbSendShellCommand("", Default, $wasRunState, False)
Local $process_killed
Local $output = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " forward tcp:" & $g_bAndroidAdbMinitouchPort & " localabstract:minitouch", $process_killed)
If StringInStr($output, "cannot bind") > 0 Then
SetLog("Initialize Android ADB ports...")
AndroidAdbTerminateShellInstance()
InitAndroidAdbPorts(True)
_AndroidAdbLaunchShellInstance($wasRunState, $rebootAndroidIfNeccessary)
Return
EndIf
$g_bAndroidAdbMinitouchSocket = TCPConnect("127.0.0.1", $g_bAndroidAdbMinitouchPort)
EndIf
If $g_bAndroidAdbMinitouchSocket < 1 Then
SetDebugLog($g_sAndroidEmulator & " minitouch not available, switch to STDIN", $COLOR_ERROR)
$g_bAndroidAdbMinitouchSocket = 0
$g_iAndroidAdbMinitouchMode = 1
EndIf
EndIf
If $g_iAndroidAdbMinitouchMode = 1 Then
AndroidAdbLaunchMinitouchShellInstance($wasRunState, $rebootAndroidIfNeccessary)
EndIf
SuspendAndroid($SuspendMode)
EndIf
SetError(0, 0)
EndFunc
Func AndroidAdbTerminateShellInstance()
ClearClicks()
Local $SuspendMode = ResumeAndroid()
If $g_iAndroidAdbProcess[0] <> 0 Then
If _AndroidAdbSendShellCommand("exit", 500, Default, False, False, True) Then _AndroidAdbSendShellCommand("exit", 0, Default, False, False, True)
If ClosePipe($g_iAndroidAdbProcess[0], $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4]) = 1 Then
SetDebugLog("ADB shell terminated, PID = " & $g_iAndroidAdbProcess[0])
Else
SetDebugLog("ADB shell already terminated, PID = " & $g_iAndroidAdbProcess[0])
EndIf
$g_iAndroidAdbProcess[0] = 0
EndIf
If $g_bAndroidAdbMinitouchSocket Then
TCPCloseSocket($g_bAndroidAdbMinitouchSocket)
$g_bAndroidAdbMinitouchSocket = 0
EndIf
AndroidAdbTerminateMinitouchShellInstance()
EndFunc
Func AndroidAdbSendShellCommand($cmd = Default, $timeout = Default, $wasRunState = Default, $EnsureShellInstance = True, $bStripPrompt = True, $bNoShellTerminate = False)
FuncEnter(AndroidAdbSendShellCommand)
If Not $g_bAndroidInitialized Then Return FuncReturn()
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $Result = _AndroidAdbSendShellCommand($cmd, $timeout, $wasRunState, $EnsureShellInstance, $bStripPrompt, $bNoShellTerminate)
$g_bTogglePauseAllowed = $wasAllowed
Return FuncReturn(SetError(@error, @extended, $Result))
EndFunc
Func _AndroidAdbSendShellCommand($cmd = Default, $timeout = Default, $wasRunState = Default, $EnsureShellInstance = True, $bStripPrompt = True, $bNoShellTerminate = False)
Static $iCommandErrors = 0
If $timeout = Default Then $timeout = 3000
If $wasRunState = Default Then $wasRunState = $g_bRunState
Local $sentBytes = 0
Local $SuspendMode = ResumeAndroid()
SetError(0, 0, 0)
If $EnsureShellInstance = True Then
AndroidAdbLaunchShellInstance($wasRunState)
EndIf
If @error <> 0 Then Return SetError(@error, 0, "")
Local $hTimer = __TimerInit()
Local $s = ""
Local $loopCount = 0
Local $cleanOutput = True
If $g_bAndroidAdbInstance = True Then
Local $aReadPipe = $g_iAndroidAdbProcess[2]
Local $aWritePipe = $g_iAndroidAdbProcess[1]
If UBound($aReadPipe) < 2 Or UBound($aWritePipe) < 2 Then
SetDebugLog("ADB Shell instance not initialized, cannot execute: " & $cmd, $COLOR_ERROR)
Return SetError(1, 0, "")
EndIf
ReadPipe($aReadPipe[0])
If $cmd = Default Then
Else
If $g_bDebugAndroid Then
SetDebugLog("Send ADB shell command: " & $cmd)
EndIf
$sentBytes = WritePipe($aWritePipe[1], $cmd & @LF)
EndIf
If $timeout <> 0 Then
While @error = 0 And($timeout < 0 Or StringCompare(StringRight($s, StringLen($g_sAndroidAdbPrompt) + 1), @LF & $g_sAndroidAdbPrompt, $STR_CASESENSE) <> 0) And __TimerDiff($hTimer) < Abs($timeout)
Sleep(10)
$s &= ReadPipe($aReadPipe[0])
$loopCount += 1
If $wasRunState And Not $g_bRunState Then ExitLoop
WEnd
Else
$s &= ReadPipe($aReadPipe[0])
EndIf
Else
$cleanOutput = False
If $cmd = Default Then
Else
Local $process_killed
If $g_bDebugAndroid Then
SetDebugLog("Execute ADB shell command: " & $cmd)
EndIf
$s = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " shell " & $cmd, $process_killed, Abs($timeout))
EndIf
EndIf
If $cleanOutput Then
Local $i = StringInStr($s, @LF)
If $i > 0 Then $s = StringMid($s, $i)
If $bStripPrompt And StringCompare(StringRight($s, StringLen($g_sAndroidAdbPrompt) + 1), @LF & $g_sAndroidAdbPrompt, $STR_CASESENSE) = 0 Then $s = StringLeft($s, StringLen($s) - StringLen($g_sAndroidAdbPrompt) - 1)
CleanLaunchOutput($s)
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
Else
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
If StringRight($s, 1) = @LF Then $s = StringLeft($s, StringLen($s) - 1)
If StringRight($s, 1) = @CR Then $s = StringLeft($s, StringLen($s) - 1)
EndIf
Local $sRemove = "WARNING: linker: libdvm.so has text relocations. This is wasting memory and is a security risk. Please fix."
If StringLen($s) >= StringLen($sRemove) And StringLeft($s, StringLen($sRemove)) = $sRemove Then
$s = StringMid($s, StringLen($sRemove) + 1)
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
EndIf
If $g_bAndroidAdbInstance = True And $g_bDebugAndroid And StringLen($s) > 0 Then SetDebugLog("ADB shell command output: " & $s)
SuspendAndroid($SuspendMode)
Local $error =(($g_bRunState = False Or __TimerDiff($hTimer) < $timeout Or $timeout < 1) ? 0 : 1)
If $error <> 0 Then
SetDebugLog("(" & $iCommandErrors & "): ADB shell command error " & $error & " (" & $g_sAndroidAdbPrompt & "): " & $s, $COLOR_ERROR)
$iCommandErrors += 1
EndIf
If $__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY)
$g_iAndroidAdbAutoTerminateCount += 1
If $iCommandErrors > $g_iAndroidRebootAdbCommandErrorCount Or(Mod($g_iAndroidAdbAutoTerminateCount, $g_iAndroidAdbAutoTerminate) = 0 And $EnsureShellInstance = True) Then
If $iCommandErrors > $g_iAndroidRebootAdbCommandErrorCount Then
$iCommandErrors = 0
RebootAndroid()
Else
$iCommandErrors = 0
If $bNoShellTerminate = False Then AndroidAdbTerminateShellInstance()
EndIf
EndIf
Return SetError($error, Int(__TimerDiff($hTimer)), $s)
EndFunc
Func AndroidAdbLaunchMinitouchShellInstance($wasRunState = Default, $rebootAndroidIfNeccessary = $g_bRunState)
If Not $g_bAndroidInitialized Then Return SetError(2, 0)
If $wasRunState = Default Then $wasRunState = $g_bRunState
Local $iConnected
If Not $g_bAndroidInitialized Or $g_iAndroidAdbMinitouchProcess[0] = 0 Or ProcessExists2($g_iAndroidAdbMinitouchProcess[0]) <> $g_iAndroidAdbMinitouchProcess[0] Then
Local $SuspendMode = ResumeAndroid()
$iConnected = ConnectAndroidAdb($rebootAndroidIfNeccessary)
If $iConnected = 0 Or($iConnected = 2 And $g_iAndroidAdbMinitouchProcess[0] = 0) Then
Return SetError(3, 0)
ElseIf $iConnected = 2 And $g_iAndroidAdbMinitouchProcess[0] Then
Return SetError(0, 0)
EndIf
AndroidAdbTerminateMinitouchShellInstance()
Local $cmdMinitouch = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/") & "minitouch -d " & $g_sAndroidMouseDevice & " -i"
Local $cmd = '"' & $g_sAndroidAdbPath & '"' & AddSpace($g_sAndroidAdbGlobalOptions, 1) & " -s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbInstanceShellOptions & $g_sAndroidAdbShellOptions & " " & $cmdMinitouch
SetDebugLog("Run pipe ADB shell for minituch: " & $cmd)
$g_iAndroidAdbMinitouchProcess[0] = RunPipe($cmd, "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED), $g_iAndroidAdbMinitouchProcess[1], $g_iAndroidAdbMinitouchProcess[2], $g_iAndroidAdbMinitouchProcess[3], $g_iAndroidAdbMinitouchProcess[4])
Sleep(500)
If $g_sAndroidAdbInstanceShellOptions And $g_iAndroidAdbMinitouchProcess[0] <> 0 And ProcessExists2($g_iAndroidAdbMinitouchProcess[0]) <> $g_iAndroidAdbMinitouchProcess[0] Then
Local $aReadPipe = $g_iAndroidAdbMinitouchProcess[2]
Local $output = ReadPipe($aReadPipe[0])
If InvalidAdbInstanceShellOptions($output, "AndroidAdbLaunchMinitouchShellInstance") Then
ClosePipe($g_iAndroidAdbMinitouchProcess[0], $g_iAndroidAdbMinitouchProcess[1], $g_iAndroidAdbMinitouchProcess[2], $g_iAndroidAdbMinitouchProcess[3], $g_iAndroidAdbMinitouchProcess[4])
$cmd = '"' & $g_sAndroidAdbPath & '"' & AddSpace($g_sAndroidAdbGlobalOptions, 1) & " -s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbInstanceShellOptions & $g_sAndroidAdbShellOptions & " " & $cmdMinitouch
SetDebugLog("Run pipe ADB shell for minituch: " & $cmd)
$g_iAndroidAdbMinitouchProcess[0] = RunPipe($cmd, "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED), $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4])
Sleep(500)
EndIf
EndIf
If $g_sAndroidAdbShellOptions And $g_iAndroidAdbMinitouchProcess[0] <> 0 And ProcessExists2($g_iAndroidAdbMinitouchProcess[0]) <> $g_iAndroidAdbMinitouchProcess[0] Then
Local $aReadPipe = $g_iAndroidAdbMinitouchProcess[2]
Local $output = ReadPipe($aReadPipe[0])
If InvalidAdbShellOptions($output, "AndroidAdbLaunchMinitouchShellInstance") Then
ClosePipe($g_iAndroidAdbMinitouchProcess[0], $g_iAndroidAdbMinitouchProcess[1], $g_iAndroidAdbMinitouchProcess[2], $g_iAndroidAdbMinitouchProcess[3], $g_iAndroidAdbMinitouchProcess[4])
$cmd = '"' & $g_sAndroidAdbPath & '"' & AddSpace($g_sAndroidAdbGlobalOptions, 1) & " -s " & $g_sAndroidAdbDevice & " shell" & $g_sAndroidAdbInstanceShellOptions & $g_sAndroidAdbShellOptions & " " & $cmdMinitouch
SetDebugLog("Run pipe ADB shell for minituch: " & $cmd)
$g_iAndroidAdbMinitouchProcess[0] = RunPipe($cmd, "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED), $g_iAndroidAdbProcess[1], $g_iAndroidAdbProcess[2], $g_iAndroidAdbProcess[3], $g_iAndroidAdbProcess[4])
Sleep(500)
EndIf
EndIf
If $g_iAndroidAdbMinitouchProcess[0] And ProcessExists2($g_iAndroidAdbMinitouchProcess[0]) = $g_iAndroidAdbMinitouchProcess[0] Then
Else
SetLog($g_sAndroidEmulator & " error launching ADB shell for minitouch", $COLOR_ERROR)
$g_iAndroidAdbMinitouchProcess[0] = 0
Return SetError(1, 0)
EndIf
EndIf
SetError(0, 0)
EndFunc
Func AndroidAdbTerminateMinitouchShellInstance()
Local $SuspendMode = ResumeAndroid()
If $g_iAndroidAdbMinitouchProcess[0] <> 0 Then
If ClosePipe($g_iAndroidAdbMinitouchProcess[0], $g_iAndroidAdbMinitouchProcess[1], $g_iAndroidAdbMinitouchProcess[2], $g_iAndroidAdbMinitouchProcess[3], $g_iAndroidAdbMinitouchProcess[4]) = 1 Then
SetDebugLog("ADB minitouch shell terminated, PID = " & $g_iAndroidAdbMinitouchProcess[0])
Else
SetDebugLog("ADB minitouch shell already terminated, PID = " & $g_iAndroidAdbMinitouchProcess[0])
EndIf
$g_iAndroidAdbMinitouchProcess[0] = 0
EndIf
EndFunc
Func AndroidAdbSendMinitouchShellCommand($cmd = Default, $iDelay = 0, $wasRunState = Default, $EnsureShellInstance = True, $bStripPrompt = True, $bNoShellTerminate = False)
Static $iCommandErrors = 0
If $wasRunState = Default Then $wasRunState = $g_bRunState
Local $sentBytes = 0
Local $SuspendMode = ResumeAndroid()
SetError(0, 0, 0)
If $EnsureShellInstance = True Then
AndroidAdbLaunchMinitouchShellInstance($wasRunState)
EndIf
If @error <> 0 Then Return SetError(@error, 0, "")
Local $aReadPipe = $g_iAndroidAdbMinitouchProcess[2]
Local $aWritePipe = $g_iAndroidAdbMinitouchProcess[1]
If UBound($aReadPipe) < 2 Or UBound($aWritePipe) < 2 Then
SetDebugLog("ADB Minitiuch Shell instance not initialized, cannot execute: " & $cmd, $COLOR_ERROR)
Return SetError(1, 0, "")
EndIf
ReadPipe($aReadPipe[0])
If $cmd = Default Then
Else
If $g_bDebugAndroid Then
SetDebugLog("Send ADB minitouch shell command: " & StringReplace($cmd, @LF, ";"))
EndIf
$sentBytes = WritePipe($aWritePipe[1], $cmd)
EndIf
If $iDelay Then Sleep($iDelay)
Local $s = ReadPipe($aReadPipe[0])
SuspendAndroid($SuspendMode)
Return $s
EndFunc
Func GetBinaryEvent($type, $code, $value)
Local $h, $hType, $hCode, $hValue
If IsInt($type) Then
$hType = StringLeft(Hex(Binary($type)), 4)
ElseIf IsString($type) Then
$hType = $type
EndIf
If IsInt($code) Then
$hCode = StringLeft(Hex(Binary($code)), 4)
ElseIf IsString($code) Then
$hCode = $code
EndIf
If IsInt($value) Then
$hValue = StringLeft(Hex(Binary($value)), 8)
ElseIf IsString($value) Then
$hValue = $value
EndIf
$h = "0x0000000000000000" & $hType & $hCode & $hValue
Return Binary($h)
EndFunc
Func AndroidAdbSendShellCommandScript($scriptFile, $variablesArray = Default, $combine = Default, $timeout = Default, $wasRunState = $g_bRunState, $EnsureShellInstance = True)
If $combine = Default Then $combine = False
If $timeout = Default Then $timeout = 20000
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
AndroidAdbLaunchShellInstance()
If @error <> 0 Then Return SetError(3, 0)
Local $hTimer = __TimerInit()
Local $hFileOpen = FileOpen($g_sAdbScriptsPath & "\" & $scriptFile)
If $hFileOpen = -1 Then
SetLog("ADB script file not found: " & $scriptFile, $COLOR_ERROR)
Return SetError(5, 0)
EndIf
Local $script = FileRead($hFileOpen)
FileClose($hFileOpen)
Local $scriptModifiedTime = FileGetTime($g_sAdbScriptsPath & "\" & $scriptFile, $FT_MODIFIED, $FT_STRING)
Local $scriptFileSh = $scriptFile
Local $bIsMinitouch = StringRight($scriptFile, 10) = ".minitouch"
Local $i, $j, $k, $iAdditional
If $bIsMinitouch Then
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then
$g_bAndroidAdbClick = False
SetLog($g_sAndroidEmulator & " mouse device not configured", $COLOR_ERROR)
Return SetError(4, 0, 0)
EndIf
Else
$script = StringReplace($script, "{$AndroidMouseDevice}", $g_sAndroidMouseDevice)
If @extended > 0 Then
$scriptFileSh &= $g_sAndroidMouseDevice
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then
$g_bAndroidAdbClick = False
SetLog($g_sAndroidEmulator & " mouse device not configured", $COLOR_ERROR)
Return SetError(4, 0, 0)
EndIf
EndIf
Local $additionalFilenames[0]
$i = 1
While FileExists($g_sAdbScriptsPath & "\" & $scriptFile & "." & $i) = 1
Local $srcFile = $g_sAdbScriptsPath & "\" & $scriptFile & "." & $i
Local $secFile = GetSecureFilename($scriptFile & "." & $i)
Local $dstFile = $hostPath & $secFile
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
$iAdditional = $i
ReDim $additionalFilenames[$iAdditional]
$additionalFilenames[$iAdditional - 1] = $secFile
$script = StringReplace($script, $scriptFile & "." & $i, $secFile)
$i += 1
WEnd
If UBound($variablesArray, 2) = 2 Then
For $i = 0 To UBound($variablesArray, 1) - 1
$script = StringReplace($script, $variablesArray[$i][0], $variablesArray[$i][1])
If @extended > 0 Then
$scriptFileSh &= "." & $variablesArray[$i][1]
EndIf
Next
EndIf
EndIf
$scriptFileSh = StringRegExpReplace($scriptFileSh, '[/\:*?"<>|]', '.')
$scriptFileSh &= ".sh"
$scriptFileSh = GetSecureFilename($scriptFileSh)
$script = StringReplace($script, @CRLF, @LF)
Local $aCmds = StringSplit($script, @LF)
Local $hTimer = __TimerInit()
Local $s = ""
If FileExists($hostPath) = 0 Then
SetLog($g_sAndroidEmulator & " ADB script file folder doesn't exist:", $COLOR_ERROR)
SetLog($hostPath, $COLOR_ERROR)
Return SetError(6, 0)
EndIf
SetError(0, 0)
If Not $bIsMinitouch Then
Local $sDev
Local $cmds = ""
Local $dd[1]
Local $ddFile, $ddHandle
For $i = 1 To $aCmds[0]
Local $cmd = $aCmds[$i]
If StringInStr($cmd, "/dev/input/") = 1 Then
Local $aElem = StringSplit($cmd, " ")
$sDev = StringReplace($aElem[1], ":", "")
If $aElem[0] < 4 Then
SetDebugLog("ADB script " & $scriptFile & ": ignore line " & $i & ": " & $cmd, $COLOR_ACTION)
Else
If IsString($combine) = 1 And $combine = "dd" Then
$j = UBound($dd)
ReDim $dd[$j + 1]
$dd[0] = $sDev
$dd[$j] = GetBinaryEvent(Dec($aElem[2]), Dec($aElem[3]), Dec($aElem[4]))
$cmd = ""
Else
$cmd = "sendevent " & $sDev & " " & Dec($aElem[2]) & " " & Dec($aElem[3]) & " " & Dec($aElem[4])
EndIf
EndIf
EndIf
$cmd = StringStripWS($cmd, 3)
If $cmd = "#dd send" Then
$j = UBound($dd) - 1
If $j > 0 Then
$iAdditional += 1
$ddFile = GetSecureFilename($scriptFile & "." & $iAdditional)
ReDim $additionalFilenames[$iAdditional]
$additionalFilenames[$iAdditional - 1] = $ddFile
$ddHandle = FileOpen($hostPath & $ddFile, BitOR($FO_OVERWRITE, $FO_BINARY))
$cmd = "dd obs=" & 16 *($j - 1) & " if=" & $androidPath & $ddFile & " of=" & $dd[0]
For $k = 1 To $j
FileWrite($ddHandle, $dd[$k])
Next
FileClose($ddHandle)
EndIf
EndIf
$aCmds[$i] = $cmd
If $combine = True And IsString($combine) = 0 And StringLen($cmd) > 0 Then
$cmds &= $cmd
If $i < $aCmds[0] Then $cmds &= ";"
EndIf
Next
EndIf
$script = ""
Local $loopCount = 0
If Not $bIsMinitouch And $combine = True And IsString($combine) = 0 And StringLen($cmds) <= 1024 Then
$s = AndroidAdbSendShellCommand($cmds, $timeout, $wasRunState, $EnsureShellInstance)
If @error <> 0 Then Return SetError(1, 0, $s)
Local $a = StringSplit(@extended, "#")
If $a[0] > 1 Then $loopCount += Number($a[2])
Else
If $scriptModifiedTime <> FileGetTime($hostPath & $scriptFileSh, $FT_MODIFIED, $FT_STRING) Then
FileDelete($hostPath & $scriptFileSh)
EndIf
If FileExists($hostPath & $scriptFileSh) = 0 Then
If Not $bIsMinitouch Then $script = "#!/bin/sh"
For $i = 1 To $aCmds[0]
If($i = 1 And StringLeft($aCmds[$i], 2) = "#!") Or $aCmds[$i] = "" Then
ContinueLoop
EndIf
If $script <> "" Then $script &= @LF
$script &= $aCmds[$i]
Next
If FileWrite($hostPath & $scriptFileSh, $script) = 1 Then
If BitAND($g_iAndroidSecureFlags, 3) = 0 Then SetLog("ADB script file created: " & $hostPath & $scriptFileSh)
Else
SetLog("ADB cannot create script file: " & $hostPath & $scriptFileSh, $COLOR_ERROR)
Return SetError(7, 0)
EndIf
FileSetTime($hostPath & $scriptFileSh, $scriptModifiedTime, $FT_MODIFIED)
EndIf
If $bIsMinitouch Then
$s = AndroidAdbSendShellCommand("""" & $androidPath & "minitouch"" -v -d " & $g_sAndroidMouseDevice & " -f """ & $androidPath & $scriptFileSh & """", $timeout, $wasRunState, $EnsureShellInstance)
Else
$s = AndroidAdbSendShellCommand("sh """ & $androidPath & $scriptFileSh & """", $timeout, $wasRunState, $EnsureShellInstance)
EndIf
If BitAND($g_iAndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $scriptFileSh)
For $i = 0 To $iAdditional - 1
FileDelete($hostPath & $additionalFilenames[$i])
Next
EndIf
If @error <> 0 Then
SetDebugLog("Error executing " & $scriptFileSh & ": " & $s)
Return SetError(1, 0, $s)
EndIf
Local $a = StringSplit(@extended, "#")
If $a[0] > 1 Then $loopCount += Number($a[2])
EndIf
Return SetError(0, Int(__TimerDiff($hTimer)) & "ms,#" & $loopCount, $s)
EndFunc
Func AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount = 0)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $Result = _AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount)
$g_bTogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount = 0)
If $iWidth > $g_iGAME_WIDTH Then $iWidth = $g_iGAME_WIDTH
If $iHeight > $g_iGAME_HEIGHT Then $iHeight = $g_iGAME_HEIGHT
If $iWidth < 1 Then $iWidth = 1
If $iHeight < 1 Then $iHeight = 1
If $iLeft > $g_iGAME_WIDTH - 1 Then $iLeft = $g_iGAME_WIDTH - 1
If $iTop > $g_iGAME_HEIGHT - 1 Then $iTop = $g_iGAME_HEIGHT - 1
If $iLeft < 0 Then $iLeft = 0
If $iTop < 0 Then $iTop = 0
If $iLeft + $iWidth > $g_iGAME_WIDTH Then $iWidth = $g_iGAME_WIDTH - $iLeft
If $iTop + $iHeight > $g_iGAME_HEIGHT Then $iHeight = $g_iGAME_HEIGHT - $iTop
Local $startTimer = __TimerInit()
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
If $hostPath = "" Or $androidPath = "" Then
If $hostPath = "" Then
SetLog($g_sAndroidEmulator & " shared folder not configured for host", $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
EndIf
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
$g_bAndroidAdbScreencap = False
EndIf
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then Return SetError(2, 0)
Local $sBotTitleEx = StringRegExpReplace($g_sBotTitle, '[/:*?"<>|]', '_')
Local $Filename = $sBotTitleEx & ".rgba"
If $g_bAndroidAdbScreencapPngEnabled = True Then $Filename = $sBotTitleEx & ".png"
$Filename = GetSecureFilename($Filename)
Local $s
Local $tBIV5HDR = 0
If $g_bAndroidAdbScreencapPngEnabled = False Then
$tBIV5HDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIV5HDR, 'bV5Size', DllStructGetSize($tBIV5HDR))
DllStructSetData($tBIV5HDR, 'bV5Width', $iWidth)
DllStructSetData($tBIV5HDR, 'bV5Height', -$iHeight)
DllStructSetData($tBIV5HDR, 'bV5Planes', 1)
DllStructSetData($tBIV5HDR, 'bV5BitCount', 32)
DllStructSetData($tBIV5HDR, 'biCompression', $BI_RGB)
EndIf
Local $pBits = 0
Local $hHBitmap = 0
If $g_iAndroidAdbScreencapTimer <> 0 And $g_bForceCapture = False And __TimerDiff($g_iAndroidAdbScreencapTimer) < $g_iAndroidAdbScreencapTimeout And $g_bRunState = True And $iRetryCount = 0 Then
If $g_bAndroidAdbScreencapPngEnabled = False Then
$hHBitmap = _WinAPI_CreateDIBSection(0, $tBIV5HDR, $DIB_RGB_COLORS, $pBits)
$tBIV5HDR = 0
DllCall($g_sLibPath & "\helper_functions.dll", "none:cdecl", "RGBA2BGRA", "ptr", DllStructGetPtr($g_aiAndroidAdbScreencapBuffer), "ptr", $pBits, "int", $iLeft, "int", $iTop, "int", $iWidth, "int", $iHeight, "int", $g_iAndroidAdbScreencapWidth, "int", $g_iAndroidAdbScreencapHeight)
Return $hHBitmap
ElseIf $g_hAndroidAdbScreencapBufferPngHandle <> 0 Then
If $iWidth > $g_iAndroidAdbScreencapWidth - $iLeft Then $iWidth = $g_iAndroidAdbScreencapWidth - $iLeft
If $iHeight > $g_iAndroidAdbScreencapHeight - $iTop Then $iHeight = $g_iAndroidAdbScreencapHeight - $iTop
Local $hClone = _GDIPlus_BitmapCloneArea($g_hAndroidAdbScreencapBufferPngHandle, $iLeft, $iTop, $iWidth, $iHeight, $GDIP_PXF32ARGB)
Return _GDIPlus_BitmapCreateDIBFromBitmap($hClone)
EndIf
EndIf
FileDelete($hostPath & $Filename)
$s = AndroidAdbSendShellCommand("screencap """ & $androidPath & $Filename & """", $g_iAndroidAdbScreencapWaitAdbTimeout, $wasRunState)
If $__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY)
Local $shellLogInfo = @extended
Local $hTimer = __TimerInit()
Local $hFile = 0
Local $iSize = 0
Local $iLoopCountFile = 0
Local $AdbStatsType = 0
Local $iF = 0
Local $ExpectedFileSize = 1500
Local $iReadData = 0
If $g_bAndroidAdbScreencapPngEnabled = False Then
Local $tHeader = DllStructCreate("int w;int h;int f")
Local $iHeaderSize = DllStructGetSize($tHeader)
Local $iDataSize = DllStructGetSize($g_aiAndroidAdbScreencapBuffer)
$ExpectedFileSize = $g_iAndroidClientWidth * $g_iAndroidClientHeight * 4 + $iHeaderSize
While $iSize < $ExpectedFileSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If $hFile = 0 Then $hFile = _WinAPI_CreateFile($hostPath & $Filename, 2, 2, 7)
If $hFile <> 0 Then $iSize = _WinAPI_GetFileSizeEx($hFile)
If $iSize >= $ExpectedFileSize Then ExitLoop
Sleep(10)
If $wasRunState = True And $g_bRunState = False Then
If $hFile <> 0 Then _WinAPI_CloseHandle($hFile)
Return SetError(1, 0)
EndIf
$iLoopCountFile += 1
WEnd
Local $iReadHeader = 0
$g_iAndroidAdbScreencapWidth = 0
$g_iAndroidAdbScreencapHeight = 0
If $hFile <> 0 Then
If $iSize >= $ExpectedFileSize Then
$hTimer = __TimerInit()
While $iReadHeader < $iHeaderSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $tHeader, $iHeaderSize, $iReadHeader) = True And $iReadHeader = $iHeaderSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadHeader & " header bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadHeader > 0 Then _WinAPI_SetFilePointer($hFile, 0)
Sleep(10)
EndIf
WEnd
$g_iAndroidAdbScreencapWidth = DllStructGetData($tHeader, "w")
If $g_iAndroidAdbScreencapWidth > $g_iGAME_WIDTH Then $g_iAndroidAdbScreencapWidth = $g_iGAME_WIDTH
$g_iAndroidAdbScreencapHeight = DllStructGetData($tHeader, "h")
If $g_iAndroidAdbScreencapHeight > $g_iGAME_HEIGHT Then $g_iAndroidAdbScreencapHeight = $g_iGAME_HEIGHT
$iF = DllStructGetData($tHeader, "f")
$hTimer = __TimerInit()
If $iSize - $iHeaderSize < $iDataSize Then $iDataSize = $iSize - $iHeaderSize
While $iReadData < $iDataSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $g_aiAndroidAdbScreencapBuffer, $iDataSize, $iReadData) = True And $iReadData = $iDataSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadData & " data bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadData > 0 Then _WinAPI_SetFilePointer($hFile, $iHeaderSize)
Sleep(10)
EndIf
WEnd
_WinAPI_CloseHandle($hFile)
$hHBitmap = _WinAPI_CreateDIBSection(0, $tBIV5HDR, $DIB_RGB_COLORS, $pBits)
DllCall($g_sLibPath & "\helper_functions.dll", "none:cdecl", "RGBA2BGRA", "ptr", DllStructGetPtr($g_aiAndroidAdbScreencapBuffer), "ptr", $pBits, "int", $iLeft, "int", $iTop, "int", $iWidth, "int", $iHeight, "int", $g_iAndroidAdbScreencapWidth, "int", $g_iAndroidAdbScreencapHeight)
Else
_WinAPI_CloseHandle($hFile)
SetDebugLog("File too small (" & $iSize & " < " & $ExpectedFileSize & "): " & $hostPath & $Filename, $COLOR_ERROR)
EndIf
EndIf
If $hFile = 0 Or $iSize < $ExpectedFileSize Or $iReadHeader < $iHeaderSize Or $iReadData < $iDataSize Then
If $hFile = 0 Then
SetLog("File not found: " & $hostPath & $Filename, $COLOR_ERROR)
Else
If $iSize <> $ExpectedFileSize Then SetDebugLog("File size " & $iSize & " is not " & $ExpectedFileSize & " for " & $hostPath & $Filename, $COLOR_ERROR)
SetDebugLog("Captured screen size " & $g_iAndroidAdbScreencapWidth & " x " & $g_iAndroidAdbScreencapHeight, $COLOR_ERROR)
SetDebugLog("Captured screen bytes read (header/datata): " & $iReadHeader & " / " & $iReadData, $COLOR_ERROR)
EndIf
If $iRetryCount < 10 Then
SetDebugLog("ADB retry screencap in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount + 1)
EndIf
SetLog($g_sAndroidEmulator & " screen not captured using ADB", $COLOR_ERROR)
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] < 50 And AndroidControlAvailable() Then
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
$g_bAndroidAdbScreencap = False
Else
SetLog("Rebooting " & $g_sAndroidEmulator & " due to problems capturing screen", $COLOR_ERROR)
Local $_NoFocusTampering = $g_bNoFocusTampering
$g_bNoFocusTampering = True
RebootAndroid()
$g_bNoFocusTampering = $_NoFocusTampering
EndIf
Return SetError(3, 0)
EndIf
Else
If $g_hAndroidAdbScreencapBufferPngHandle <> 0 Then
_GDIPlus_ImageDispose($g_hAndroidAdbScreencapBufferPngHandle)
_GDIPlus_BitmapDispose($g_hAndroidAdbScreencapBufferPngHandle)
_WinAPI_DeleteObject($g_hAndroidAdbScreencapBufferPngHandle)
$g_hAndroidAdbScreencapBufferPngHandle = 0
EndIf
Local $hBitmap = 0
While $iSize < $ExpectedFileSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If $hFile = 0 Then $hFile = _WinAPI_CreateFile($hostPath & $Filename, 2, 2, 7)
If $hFile <> 0 Then $iSize = _WinAPI_GetFileSizeEx($hFile)
If $iSize >= $ExpectedFileSize Then ExitLoop
Sleep(10)
If $wasRunState = True And $g_bRunState = False Then Return SetError(1, 0)
$iLoopCountFile += 1
WEnd
Local $hData = _MemGlobalAlloc($iSize, $GMEM_MOVEABLE)
Local $pData = _MemGlobalLock($hData)
Local $tData = DllStructCreate('byte[' & $iSize & ']', $pData)
While $iSize > 0 And $iReadData < $iSize And __TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $tData, $iSize, $iReadData) = True And $iReadData = $iSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadData & " data bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadData > 0 Then _WinAPI_SetFilePointer($hFile, 0)
Sleep(10)
EndIf
WEnd
_WinAPI_CloseHandle($hFile)
SetDebugLog($iSize, $COLOR_ERROR)
Local $testTimer = __TimerInit()
Local $msg = ""
_MemGlobalUnlock($hData)
Local $pStream = _WinAPI_CreateStreamOnHGlobal($hData)
$hBitmap = _GDIPlus_BitmapCreateFromStream($pStream)
_WinAPI_ReleaseStream($pStream)
$msg &= ", " & Round(__TimerDiff($testTimer), 2)
If $hBitmap = 0 Then
If $iRetryCount < 10 Then
SetDebugLog("ADB retry screencap in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount + 1)
EndIf
SetLog($g_sAndroidEmulator & " screen not captured using ADB", $COLOR_ERROR)
If FileExists($hostPath & $Filename) = 0 Then SetLog("File not found: " & $hostPath & $Filename, $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
$g_bAndroidAdbScreencap = False
Return SetError(5, 0)
Else
$g_iAndroidAdbScreencapWidth = _GDIPlus_ImageGetWidth($hBitmap)
$g_iAndroidAdbScreencapHeight = _GDIPlus_ImageGetHeight($hBitmap)
$msg &= ", " & Round(__TimerDiff($testTimer), 2)
If $iWidth > $g_iAndroidAdbScreencapWidth - $iLeft Then $iWidth = $g_iAndroidAdbScreencapWidth - $iLeft
If $iHeight > $g_iAndroidAdbScreencapHeight - $iTop Then $iHeight = $g_iAndroidAdbScreencapHeight - $iTop
Local $hClone = _GDIPlus_BitmapCloneArea($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $GDIP_PXF32ARGB)
$msg &= ", " & Round(__TimerDiff($testTimer), 2)
If $hClone = 0 Then
SetDebugLog($g_sAndroidEmulator & " error using " & $g_iAndroidAdbScreencapWidth & "x" & $g_iAndroidAdbScreencapHeight & " on _GDIPlus_BitmapCloneArea(" & $hBitmap & "," & $iLeft & "," & $iTop & "," & $iWidth & "," & $iHeight, $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " screenshot not available", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
$g_bAndroidAdbScreencap = False
Return SetError(6, 0)
EndIf
$g_hAndroidAdbScreencapBufferPngHandle = $hBitmap
$msg &= ", " & Round(__TimerDiff($testTimer), 2)
$hHBitmap = _GDIPlus_BitmapCreateDIBFromBitmap($hClone)
EndIf
EndIf
If BitAND($g_iAndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $Filename)
EndIf
Local $duration = Int(__TimerDiff($startTimer))
$g_iAndroidAdbScreencapTimeout =($g_iAndroidAdbScreencapTimeoutDynamic = 0 ? $g_iAndroidAdbScreencapTimeoutMax : $duration * $g_iAndroidAdbScreencapTimeoutDynamic)
If $g_iAndroidAdbScreencapTimeout < $g_iAndroidAdbScreencapTimeoutMin Then $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMin
If $g_iAndroidAdbScreencapTimeout > $g_iAndroidAdbScreencapTimeoutMax Then $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMax
$g_iAndroidAdbScreencapTimer = __TimerInit()
$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] += 1
$g_aiAndroidAdbStatsTotal[$AdbStatsType][1] += $duration
Local $iLastCount = UBound($g_aiAndroidAdbStatsLast, 2) - 2
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] <= $iLastCount Then
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] + 1] = $duration
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] = $iLastCount Then $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0
Else
Local $iLastIdx = $g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 2
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] -= $g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx]
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx] = $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][1] = Mod($g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 1, $iLastCount)
EndIf
If $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0 Then
Local $totalAvg = Round($g_aiAndroidAdbStatsTotal[$AdbStatsType][1] / $g_aiAndroidAdbStatsTotal[$AdbStatsType][0])
Local $lastAvg = Round($g_aiAndroidAdbStatsLast[$AdbStatsType][0] / $iLastCount)
If $g_bDebugAndroid Or Mod($g_aiAndroidAdbStatsTotal[$AdbStatsType][0], 100) = 0 Then
SetDebugLog("AdbScreencap: " & $totalAvg & "/" & $lastAvg & "/" & $duration & " ms (all/" & $iLastCount & "/1)," & $shellLogInfo & "," & $iLoopCountFile & ",l=" & $iLeft & ",t=" & $iTop & ",w=" & $iWidth & ",h=" & $iHeight & ", " & $Filename & ": w=" & $g_iAndroidAdbScreencapWidth & ",h=" & $g_iAndroidAdbScreencapHeight & ",f=" & $iF)
EndIf
EndIf
$tBIV5HDR = 0
Return $hHBitmap
EndFunc
Func AndroidZoomOut($loopCount = 0, $timeout = Default, $bMinitouch = Default, $wasRunState = Default)
Return AndroidAdbScript("ZoomOut", Default, $timeout, $bMinitouch, $wasRunState)
EndFunc
Func AndroidAdbScript($scriptTag, $variablesArray = Default, $timeout = Default, $bMinitouch = Default, $wasRunState = Default)
If $bMinitouch = Default Then $bMinitouch = True
If $wasRunState = Default Then $wasRunState = $g_bRunState
ResumeAndroid()
If $g_bAndroidAdbZoomoutEnabled = False Then Return SetError(4, 0)
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then Return SetError(2, 0, 0)
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then Return SetError(2, 0, 0)
Local $scriptFile = ""
If $bMinitouch And $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & "." & $g_sAndroidEmulator & ".minitouch") = 1 Then $scriptFile = $scriptTag & "." & $g_sAndroidEmulator & ".minitouch"
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & "." & $g_sAndroidEmulator & ".script") = 1 Then $scriptFile = $scriptTag & "." & $g_sAndroidEmulator & ".script"
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & "." & $g_sAndroidEmulator & ".getevent") = 1 Then $scriptFile = $scriptTag & "." & $g_sAndroidEmulator & ".getevent"
If Not $bMinitouch And $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & "." & $g_sAndroidEmulator & ".minitouch") = 1 Then $scriptFile = $scriptTag & "." & $g_sAndroidEmulator & ".minitouch"
If $bMinitouch And $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & ".minitouch") = 1 Then $scriptFile = $scriptTag & ".minitouch"
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & ".script") = 1 Then $scriptFile = $scriptTag & ".script"
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & ".getevent") = 1 Then $scriptFile = $scriptTag & ".getevent"
If Not $bMinitouch And $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & ".minitouch") = 1 Then $scriptFile = $scriptTag & ".minitouch"
AndroidAdbSendShellCommandScript($scriptFile, $variablesArray, Default, $timeout, $wasRunState)
Return SetError(@error, @extended,(@error = 0 ? 1 : 0))
EndFunc
Func AndroidClickDrag($x1, $y1, $x2, $y2, $wasRunState = Default)
$x1 = Int($x1) + $g_aiMouseOffset[0]
$y1 = Int($y1) + $g_aiMouseOffset[1]
$x2 = Int($x2) + $g_aiMouseOffset[0]
$y2 = Int($y2) + $g_aiMouseOffset[1]
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x1,$y1)")
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x2,$y2)")
Return AndroidMinitouchClickDrag($x1, $y1, $x2, $y2, $wasRunState)
EndFunc
Func AndroidMinitouchClickDrag($x1, $y1, $x2, $y2, $wasRunState = Default)
AndroidAdbLaunchShellInstance($wasRunState)
If $g_iAndroidAdbMinitouchMode = 0 Then
If $g_bAndroidAdbMinitouchSocket < 1 Then
SetLog("Minitouch not available", $COLOR_ERROR)
Return SetError(1, 0, 0)
EndIf
TCPRecv($g_bAndroidAdbMinitouchSocket, 256, 1)
Local $recv_state = [@error, @extended]
Local $bytes = TCPSend($g_bAndroidAdbMinitouchSocket, @LF)
Local $send_state = [@error, $bytes]
If($recv_state[0] Or $send_state[0] Or $send_state[1] <> 1) Then
If $wasRunState Then
SetLog("Cannot send minitouch data to " & $g_sAndroidEmulator & ", received " & $recv_state[1] & ", send " & $send_state[1], $COLOR_ERROR)
AndroidAdbTerminateShellInstance()
Return AndroidMinitouchClickDrag($x1, $y1, $x2, $y2, False)
EndIf
Return SetError(1, 0, 0)
EndIf
EndIf
Local $sleepStart = 250
Local $sleepMove = 10
Local $sleepEnd = 1000
Local $sleep = $sleepStart
Local $botSleep = 0
Local $send = ""
Local $screen_w = $g_iGAME_WIDTH
Local $screen_h = $g_iGAME_HEIGHT
If $screen_h Then Execute($g_sAndroidEmulator & "AdjustClickCoordinates($screen_w,$screen_h)")
Local $steps = Int(($screen_w * 10) / $g_iGAME_WIDTH)
Local $loops = Int(_Max(Abs($x2 - $x1), Abs($y2 - $y1)) / $steps) + 1
Local $x_steps =($x2 - $x1) / $loops
Local $y_steps =($y2 - $y1) / $loops
Local $x = $x1, $y = $y1
$send = "d 0 " & $x & " " & $y & " 50" & @LF & "c" & @LF & "w " & $sleep & @LF
$botSleep += $sleep
If $g_bDebugAndroid Then SetDebugLog("minitouch: " & StringReplace($send, @LF, ";"))
If $g_iAndroidAdbMinitouchMode = 0 Then
TCPSend($g_bAndroidAdbMinitouchSocket, $send)
Else
AndroidAdbSendMinitouchShellCommand($send)
EndIf
$sleep = $sleepMove
For $i = 1 To $loops
$x += $x_steps
$y += $y_steps
If($x2 >= $x1 And $x >= $x2) Or($x2 < $x1 And $x <= $x2) Then
$x = $x2
EndIf
If($y2 >= $y1 And $y >= $y2) Or($y2 < $y1 And $y <= $y2) Then
$y = $y2
EndIf
If Int($x) = $x2 And Int($y) = $y2 Then
$i = $loops
$sleep = $sleepEnd
EndIf
$send = "m 0 " & Int($x) & " " & Int($y) & " 50" & @LF & "c" & @LF & "w " & $sleep & @LF
$botSleep += $sleep
If $g_bDebugAndroid Then SetDebugLog("minitouch: " & StringReplace($send, @LF, ";"))
If $g_iAndroidAdbMinitouchMode = 0 Then
TCPSend($g_bAndroidAdbMinitouchSocket, $send)
Else
AndroidAdbSendMinitouchShellCommand($send)
EndIf
Next
$sleep = $sleepMove
$send = "u 0" & @LF & "c" & @LF & "w " & $sleep & @LF
$botSleep += $sleep
If $g_bDebugAndroid Then SetDebugLog("minitouch: " & StringReplace($send, @LF, ";"))
If $g_iAndroidAdbMinitouchMode = 0 Then
TCPSend($g_bAndroidAdbMinitouchSocket, $send)
Else
AndroidAdbSendMinitouchShellCommand($send)
EndIf
_Sleep($botSleep)
Return SetError(0, 0, 1)
EndFunc
Func IsKeepClicksActive($Really = True)
If $Really = True Then
Return $g_bAndroidAdbClick = True And $g_bAndroidAdbClicksEnabled = True And $g_aiAndroidAdbClicks[0] > -1
EndIf
Return $g_bAndroidAdbKeepClicksActive
EndFunc
Func KeepClicks()
$g_bAndroidAdbKeepClicksActive = True
If $g_bAndroidAdbClick = False Or $g_bAndroidAdbClicksEnabled = False Then Return False
If $g_aiAndroidAdbClicks[0] = -1 Then $g_aiAndroidAdbClicks[0] = 0
EndFunc
Func ReleaseClicks($minClicksToRelease = 0, $ReleaseClicksEnabled = $g_bAndroidAdbClicksEnabled)
If $g_bAndroidAdbClick = False Or $ReleaseClicksEnabled = False Then
$g_bAndroidAdbKeepClicksActive = False
Return False
EndIf
If $g_aiAndroidAdbClicks[0] > 0 And $g_bRunState = True Then
If $g_aiAndroidAdbClicks[0] >= $minClicksToRelease Then
AndroidClick(Default, Default, $g_aiAndroidAdbClicks[0], 0)
Else
Return False
EndIf
EndIf
ClearClicks()
EndFunc
Func ClearClicks()
$g_bAndroidAdbKeepClicksActive = False
ReDim $g_aiAndroidAdbClicks[1]
$g_aiAndroidAdbClicks[0] = -1
EndFunc
Func AndroidAdbClickSupported()
Return BitAND($g_iAndroidSupportFeature, 4) = 4
EndFunc
Func AndroidClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True)
If Not($x = Default) Then $x = Int($x) + $g_aiMouseOffset[0]
If Not($x = Default) Then $y = Int($y) + $g_aiMouseOffset[1]
ForceCaptureRegion()
AndroidMinitouchClick($x, $y, $times, $speed, $checkProblemAffect)
EndFunc
Func Minitouch($x, $y, $iAction = 0, $iDelay = 1)
If $g_iAndroidAdbMinitouchMode = 0 Then
If $g_bAndroidAdbMinitouchSocket < 1 Then Return -1
EndIf
Static $x_dn, $y_dn
$x = Int($x)
$y = Int($y)
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
Local $iBytes = 0
Local $s
Local $t = ""
Local $sWait = ""
Switch $iAction
Case 0, 2
If $iAction = 0 Or $x_dn <> $x Or $y_dn <> $y Then
$s = "m 0 " & $x & " " & $y & " 50" & @LF & "c" & @LF & $sWait
$t &= $s
If $g_iAndroidAdbMinitouchMode = 0 Then
$iBytes += TCPSend($g_bAndroidAdbMinitouchSocket, $s)
Else
AndroidAdbSendMinitouchShellCommand($s)
If @error Then
Return SetError(@error, 0, 0)
Else
$iBytes += StringLen($s)
EndIf
EndIf
EndIf
If $iAction = 2 Then
$s = "u 0 " & @LF & "c" & @LF & $sWait
$t &= $s
If $g_iAndroidAdbMinitouchMode = 0 Then
$iBytes += TCPSend($g_bAndroidAdbMinitouchSocket, $s)
Else
AndroidAdbSendMinitouchShellCommand($s)
If @error Then
Return SetError(@error, 0, 0)
Else
$iBytes += StringLen($s)
EndIf
EndIf
EndIf
Case 1
$s = "d 0 " & $x & " " & $y & " 50" & @LF & "c" & @LF & $sWait
$t &= $s
If $g_iAndroidAdbMinitouchMode = 0 Then
$iBytes += TCPSend($g_bAndroidAdbMinitouchSocket, $s)
Else
AndroidAdbSendMinitouchShellCommand($s)
If @error Then
Return SetError(@error, 0, 0)
Else
$iBytes += StringLen($s)
EndIf
EndIf
$x_dn = $x
$y_dn = $y
EndSwitch
If $g_bDebugAndroid Then
SetDebugLog("Minitouch: " & StringReplace($t, @LF, ";"), $COLOR_INFO, True)
EndIf
Return $iBytes
EndFunc
Func AndroidMinitouchClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True, $iRetryCount = 0)
Local $minSleep = $g_iAndroidControlClickDownDelay
Local $iDelay = $g_iAndroidControlClickDelay
Local $_SilentSetLog = $g_bSilentSetLog
Local $hDuration = __TimerInit()
If $times < 1 Then Return SetError(0, 0)
Local $i = 0, $j = 0
Local $Click = [$x, $y, "down-up"]
Local $aiAndroidAdbClicks
Local $ReleaseClicks =($x = Default And $y = Default And $g_aiAndroidAdbClicks[0] > 0)
If $ReleaseClicks = False And $g_aiAndroidAdbClicks[0] > -1 Then
Local $pos = $g_aiAndroidAdbClicks[0]
$g_aiAndroidAdbClicks[0] = $pos + $times
ReDim $g_aiAndroidAdbClicks[$g_aiAndroidAdbClicks[0] + 1]
For $i = 1 To $times
$g_aiAndroidAdbClicks[$pos + $i] = $Click
Next
If $g_bDebugAndroid Or $g_bDebugClick Then
$g_bSilentSetLog = True
SetDebugLog("Hold back click (" & $x & "/" & $y & " * " & $times & "): queue size = " & $g_aiAndroidAdbClicks[0], $COLOR_ERROR)
$g_bSilentSetLog = $_SilentSetLog
EndIf
Return
EndIf
Local $bytes = 0
Local $bytesSent = 0
Local $wasRunState = $g_bRunState
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
If $hostPath = "" Or $androidPath = "" Then
If $hostPath = "" Then
SetLog($g_sAndroidEmulator & " shared folder not configured for host", $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
EndIf
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
$g_bAndroidAdbClick = False
SetLog("Disabled " & $g_sAndroidEmulator & " ADB fast mouse click", $COLOR_ERROR)
Return SetError(1, 0)
EndIf
AndroidAdbLaunchShellInstance($wasRunState)
If $g_iAndroidAdbMinitouchMode = 0 Then
If $g_bAndroidAdbMinitouchSocket < 1 Then
$g_bAndroidAdbClick = False
SetLog("Disabled " & $g_sAndroidEmulator & " ADB fast mouse click", $COLOR_ERROR)
Return SetError(1, 0)
EndIf
TCPRecv($g_bAndroidAdbMinitouchSocket, 256, 1)
Local $recv_state = [@error, @extended]
$bytes = TCPSend($g_bAndroidAdbMinitouchSocket, @LF)
Local $send_state = [@error, $bytes]
If($recv_state[0] Or $send_state[0] Or $send_state[1] <> 1) Then
SetLog("Cannot send minitouch data to " & $g_sAndroidEmulator & ", received " & $recv_state[1] & ", send " & $send_state[1], $COLOR_ERROR)
If $iRetryCount < 1 Then
AndroidAdbTerminateShellInstance()
Return AndroidMinitouchClick($x, $y, $times, $speed, $checkProblemAffect, $iRetryCount + 1)
EndIf
Return SetError(1, 0)
EndIf
EndIf
Local $ReleaseClicksCheck =($x = Default And $y = Default And $g_aiAndroidAdbClicks[0] > 0)
If $ReleaseClicks <> $ReleaseClicksCheck Then
SetDebugLog("AndroidMinitouchClick: Release clicks condition changed from " & $ReleaseClicks & " to " & $ReleaseClicksCheck)
Return AndroidMinitouchClick($x, $y, $times, $speed, $checkProblemAffect, $iRetryCount)
EndIf
$x = Int($x)
$y = Int($y)
Local $loops = 1
Local $remaining = 0
Local $adjustSpeed = 0
Local $timer = __TimerInit()
If $times > $g_iAndroidAdbClickGroup Then
$speed = $g_iAndroidAdbClickGroupDelay
$remaining = Mod($times, $g_iAndroidAdbClickGroup)
$loops = Int($times / $g_iAndroidAdbClickGroup) +($remaining > 0 ? 1 : 0)
$times = $g_iAndroidAdbClickGroup
Else
If $ReleaseClicks = False Then $adjustSpeed = $speed
$speed = 0
EndIf
Local $recordsClicks =($times < $g_iAndroidAdbClickGroup ? $times : $g_iAndroidAdbClickGroup)
If $ReleaseClicks = True Then
If $g_bDebugAndroid Or $g_bDebugClick Then SetDebugLog("Release clicks: queue size = " & $g_aiAndroidAdbClicks[0])
Local $aiAndroidAdbClicks = $g_aiAndroidAdbClicks
Else
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
EndIf
Local $AdbStatsType = 1
Local $timeSlept = 0
For $i = 1 To $loops
If IsKeepClicksActive(False) = False Then
If $checkProblemAffect = True Then
If isProblemAffect(True) Then
SetDebugLog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
Return
EndIf
EndIf
EndIf
If $i = $loops And $remaining > 0 Then
$recordsClicks = $remaining
ElseIf $ReleaseClicks = True Then
EndIf
Local $sleepTimer = __TimerInit()
If True Then
For $j = 0 To $recordsClicks - 1
Local $BTN_TOUCH_DOWN = True
Local $BTN_TOUCH_UP = True
If $ReleaseClicks = True Then
$Click = $aiAndroidAdbClicks[($i - 1) * $recordsClicks + $j + 1]
$x = $Click[0]
$y = $Click[1]
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
Local $up_down = $Click[2]
$BTN_TOUCH_DOWN = StringInStr($up_down, "down") > 0
$BTN_TOUCH_UP = StringInStr($up_down, "up") > 0
EndIf
Local $send = ""
$bytes = 0
$bytesSent = 0
If $BTN_TOUCH_DOWN Then
$send &= "d 0 " & $x & " " & $y & " 50" & @LF
$send &= "c" & @LF
If $g_iAndroidAdbMinitouchMode = 0 Then
$bytes += TCPSend($g_bAndroidAdbMinitouchSocket, $send)
$bytesSent += StringLen($send)
Else
AndroidAdbSendMinitouchShellCommand($send)
EndIf
EndIf
If $BTN_TOUCH_UP Then
$send = ""
Local $sleep = $minSleep
If $speed > $minSleep And $times = 1 Then
$sleep = $speed
EndIf
$send &= "w " & $sleep & @LF
If $g_iAndroidAdbMinitouchMode = 0 Then
$bytes += TCPSend($g_bAndroidAdbMinitouchSocket, $send)
$bytesSent += StringLen($send)
Else
AndroidAdbSendMinitouchShellCommand($send)
EndIf
$send = ""
$send &= "u 0" & @LF
$send &= "c" & @LF
$send &= "w " & $iDelay & @LF
If $g_iAndroidAdbMinitouchMode = 0 Then
$bytes += TCPSend($g_bAndroidAdbMinitouchSocket, $send)
$bytesSent += StringLen($send)
Else
AndroidAdbSendMinitouchShellCommand($send)
EndIf
_SleepMicro(($iDelay + $sleep) * 1000)
If $g_bDebugClick Then SetDebugLog("minitouch: d 0 " & $x & " " & $y & " 50, speed=" & $sleep & ", delay=" & $iDelay)
EndIf
If $g_iAndroidAdbMinitouchMode = 0 Then
If $bytes < $bytesSent Then SetDebugLog("minitouch: Faild to send " &($bytesSent - $bytes) & " bytes!", $COLOR_ERROR)
EndIf
Next
EndIf
$g_bSilentSetLog = True
$g_bSilentSetLog = $_SilentSetLog
If False Then
If $speed > 0 Then
If $g_bDebugClick Then SetDebugLog("minitouch: wait between group clicks: " & $speed & " ms.")
$send = "w " & $speed & @LF
If $g_iAndroidAdbMinitouchMode = 0 Then
$bytes += TCPSend($g_bAndroidAdbMinitouchSocket, $send)
Else
AndroidAdbSendMinitouchShellCommand($send)
EndIf
_SleepMicro($speed * 1000)
EndIf
If $adjustSpeed > 0 Then
Local $wait = Round($adjustSpeed - __TimerDiff($timer))
If $wait > 0 Then
If $g_bDebugAndroid Or $g_bDebugClick Then
$g_bSilentSetLog = True
SetDebugLog("AndroidMinitouchClick: Sleep " & $wait & " ms.")
$g_bSilentSetLog = $_SilentSetLog
EndIf
_Sleep($wait, False)
EndIf
EndIf
EndIf
$timeSlept += __TimerDiff($sleepTimer)
If $g_bRunState = False Then ExitLoop
If $__TEST_ERROR_SLOW_ADB_CLICK_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_CLICK_DELAY)
Next
If IsKeepClicksActive(False) = False Then
$g_iAndroidAdbScreencapTimer = 0
EndIf
Local $duration = Round((__TimerDiff($hDuration) - $timeSlept) / $loops)
$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] += 1
$g_aiAndroidAdbStatsTotal[$AdbStatsType][1] += $duration
Local $iLastCount = UBound($g_aiAndroidAdbStatsLast, 2) - 2
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] <= $iLastCount Then
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] + 1] = $duration
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] = $iLastCount Then $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0
Else
Local $iLastIdx = $g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 2
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] -= $g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx]
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx] = $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][1] = Mod($g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 1, $iLastCount)
EndIf
If $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0 Then
Local $totalAvg = Round($g_aiAndroidAdbStatsTotal[$AdbStatsType][1] / $g_aiAndroidAdbStatsTotal[$AdbStatsType][0])
Local $lastAvg = Round($g_aiAndroidAdbStatsLast[$AdbStatsType][0] / $iLastCount)
If $g_bDebugAndroid Or $g_bDebugClick Or Mod($g_aiAndroidAdbStatsTotal[$AdbStatsType][0], 100) = 0 Then
SetDebugLog("AndroidMinitouchClick: " & $totalAvg & "/" & $lastAvg & "/" & $duration & " ms (all/" & $iLastCount & "/1), $x=" & $x & ", $y=" & $y & ", $times=" & $times & ", $speed = " & $speed & ", $checkProblemAffect=" & $checkProblemAffect)
EndIf
EndIf
EndFunc
Func AndroidSendText($sText, $SymbolFix = False, $wasRunState = $g_bRunState)
AndroidAdbLaunchShellInstance($wasRunState)
Local $error = @error
If $error = 0 Then
Local $newText = $sText
StringRegExpReplace($newText, "[^A-Za-z0-9\.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]'~ ]", ".")
If @extended <> 0 Then
If $SymbolFix = False Then SetDebugLog("Cannot use ADB to send input text, use Windows method", $COLOR_ERROR)
Return SetError(10, 0)
EndIf
If $SymbolFix = False Then
If $g_iAndroidAdbInputWordsCharLimit = 0 Then
$newText = StringRegExpReplace($newText, "([\\\?""\$\^&\*\(\)\+<>\|'~;])", "\\$1")
$newText = StringReplace($newText, " ", "%s")
AndroidAdbSendShellCommand("input text " & $newText, 6000, $wasRunState)
Else
Local $words = StringSplit($newText, " ")
Local $i, $word, $newWord
For $i = 1 To $words[0]
$word = $words[$i]
While StringLen($word) > 0
$newWord = StringRegExpReplace(StringLeft($word, $g_iAndroidAdbInputWordsCharLimit), "([\\\?""\$\^&\*\(\)\+<>\|'~;])", "\\$1")
AndroidAdbSendShellCommand("input text " & $newWord, 6000, $wasRunState)
$word = StringMid($word, $g_iAndroidAdbInputWordsCharLimit + 1)
WEnd
If $i < $words[0] Then AndroidAdbSendShellCommand("input text %s", Default, $wasRunState)
Next
EndIf
Else
AndroidAdbSendShellCommand("input text %s", Default, $wasRunState)
EndIf
SetError(0, 0)
Else
If $SymbolFix = False Then
SetDebugLog("Disabled " & $g_sAndroidEmulator & " ADB input due to error", $COLOR_ERROR)
$g_bAndroidAdbInput = False
EndIf
Return SetError($error, 0)
EndIf
EndFunc
Func AndroidInputSwipe($x1, $y1, $x2, $y2, $wasRunState = $g_bRunState)
AndroidAdbLaunchShellInstance($wasRunState)
If @error = 0 Then
AndroidAdbSendShellCommand("input swipe " & $x1 & " " & $y1 & " " & $x2 & " " & $y2 & ";input tap " & $x2 & " " & $y2, 6000, $wasRunState)
SetError(0, 0)
Else
Local $error = @error
SetDebugLog("Disabled " & $g_sAndroidEmulator & " ADB input due to error", $COLOR_ERROR)
$g_bAndroidAdbInput = False
Return SetError($error, 0)
EndIf
EndFunc
Func SuspendAndroidTime($Action = False)
If IsBool($Action) And $Action = True Then
Local $iTime = $g_iSuspendAndroidTime
$g_iSuspendAndroidTime = 0
$g_iSuspendAndroidTimeCount = 0
$g_hSuspendAndroidTimer = 0
Return $iTime
ElseIf $Action = False Then
Return $g_iSuspendAndroidTime
EndIf
If $g_hSuspendAndroidTimer = 0 Then
ElseIf $Action = "Stats" Then
SetDebugLog("SuspendAndroidTime: Time = " & $g_iSuspendAndroidTime & ", Count = " & $g_iSuspendAndroidTimeCount)
Else
Local $iSuspendTime =(_HPTimerDiff($g_hSuspendAndroidTimer) - 50)
If $iSuspendTime > 0 Then
$g_iSuspendAndroidTime += $iSuspendTime
$g_iSuspendAndroidTimeCount += 1
EndIf
$g_hSuspendAndroidTimer = 0
EndIf
If $Action = "Start" Then $g_hSuspendAndroidTimer = _HPTimerInit()
Return $g_iSuspendAndroidTime
EndFunc
Func SuspendAndroid($SuspendMode = True, $bDebugLog = Default, $bForceSuspendAndroid = False)
If $bDebugLog = Default Then $bDebugLog = $g_bDebugAndroid
If($g_bAndroidSuspendedEnabled = False Or $g_iAndroidSuspendModeFlags = 0) And $bForceSuspendAndroid = False Then Return False
Local $bSuspendAllowed = Not $g_bCloudsActive And $g_bMainWindowOk And(($g_iAndroidSuspendModeFlags = 1 And($g_bAttackActive Or $g_bVillageSearchActive)) Or $g_iAndroidSuspendModeFlags >= 2)
If Not $bSuspendAllowed And $bForceSuspendAndroid = False Then
If $g_bAndroidSuspended Then
Return ResumeAndroid($bDebugLog, $bForceSuspendAndroid)
EndIf
Return False
EndIf
If $SuspendMode = False Then Return ResumeAndroid($bDebugLog, $bForceSuspendAndroid)
If $g_bAndroidSuspended = True Then Return True
Local $bSuspendProcess = BitAND($g_iAndroidSuspendModeFlags, 4) = 0
If $bSuspendProcess = True Then
If $g_iAndroidCoCPid = 0 Then $g_iAndroidCoCPid = GetAndroidProcessPID(Default, False)
If $g_iAndroidCoCPid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
Local $s = AndroidAdbSendShellCommand("kill -STOP " & $g_iAndroidCoCPid, 0)
If StringInStr($s, "No such process") > 0 Then
$g_iAndroidCoCPid = GetAndroidProcessPID(Default, False)
If $g_iAndroidCoCPid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
$s = AndroidAdbSendShellCommand("kill -STOP " & $g_iAndroidCoCPid, 0)
EndIf
$g_bAndroidSuspended = True
Else
Local $pid = GetAndroidSvcPid()
If $pid = -1 Or $pid = 0 Then $pid = GetAndroidPid()
If $pid = -1 Or $pid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
$g_bAndroidSuspended = True
_ProcessSuspendResume($pid, True)
$g_iAndroidSuspendedTimer = __TimerInit()
EndIf
SuspendAndroidTime("Start")
If $bDebugLog = True Then SetDebugLog("Android Suspended")
Return False
EndFunc
Func ResumeAndroid($bDebugLog = Default, $bForceSuspendAndroid = False)
If $bDebugLog = Default Then $bDebugLog = $g_bDebugAndroid
If($g_bAndroidSuspendedEnabled = False Or $g_iAndroidSuspendModeFlags = 0) And $bForceSuspendAndroid = False Then Return False
If $g_bAndroidSuspended = False Then Return False
Local $bSuspendProcess = BitAND($g_iAndroidSuspendModeFlags, 4) = 0
SuspendAndroidTime("Stop")
If $bSuspendProcess = True Then
$g_bAndroidSuspended = False
If $g_iAndroidCoCPid = 0 Then $g_iAndroidCoCPid = GetAndroidProcessPID(Default, False)
If $g_iAndroidCoCPid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
Local $s = AndroidAdbSendShellCommand("kill -CONT " & $g_iAndroidCoCPid)
If StringInStr($s, "No such process") > 0 Then
$g_iAndroidCoCPid = GetAndroidProcessPID(Default, False)
If $g_iAndroidCoCPid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
$s = AndroidAdbSendShellCommand("kill -CONT " & $g_iAndroidCoCPid)
EndIf
If $bDebugLog = True Then SetDebugLog("Android Resumed")
Else
Local $pid = GetAndroidSvcPid()
If $pid = -1 Or $pid = 0 Then $pid = GetAndroidPid()
If $pid = -1 Or $pid = 0 Then
SuspendAndroidTime(True)
Return False
EndIf
$g_bAndroidSuspended = False
_ProcessSuspendResume($pid, False)
$g_aiAndroidTimeLag[3] += __TimerDiff($g_iAndroidSuspendedTimer)
If $bDebugLog = True Then SetDebugLog("Android Resumed (total time " & Round($g_aiAndroidTimeLag[3]) & " ms)")
EndIf
Return True
EndFunc
Func AndroidCloseSystemBar()
If AndroidInvalidState() Then Return False
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then
SetLog("Cannot close " & $g_sAndroidEmulator & " System Bar", $COLOR_ERROR)
Return False
EndIf
Local $cmdOutput = AndroidAdbSendShellCommand("service call activity 42 s16 com.android.systemui", Default, $wasRunState, False)
Local $Result = StringLeft($cmdOutput, 6) = "Result"
SetDebugLog("Closed " & $g_sAndroidEmulator & " System Bar: " & $Result)
Return $Result
EndFunc
Func AndroidOpenSystemBar($bZygote = False)
If AndroidInvalidState() Then Return False
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then
SetLog("Cannot open " & $g_sAndroidEmulator & " System Bar", $COLOR_ERROR)
Return False
EndIf
Local $cmdOutput
Local $Result
If $bZygote = True Then
$cmdOutput = AndroidAdbSendShellCommand("setprop ctl.restart zygote", Default, $wasRunState, False)
$Result = $cmdOutput = ""
Else
$cmdOutput = AndroidAdbSendShellCommand("am startservice -n com.android.systemui/.SystemUIService", Default, $wasRunState, False)
$Result = StringLeft($cmdOutput, 16) = "Starting service"
SetDebugLog("Opened " & $g_sAndroidEmulator & " System Bar: " & $Result)
EndIf
Return $Result
EndFunc
Func RedrawAndroidWindow()
Local $Result = Execute("Redraw" & $g_sAndroidEmulator & "Window()")
If $Result = "" And @error <> 0 Then
_WinAPI_RedrawWindow($g_hAndroidWindow, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN)
_WinAPI_SetWindowPos($g_hAndroidWindow, 0, 0, 0, 0, 0, BitOR($SWP_NOMOVE, $SWP_NOSIZE, $SWP_FRAMECHANGED))
_WinAPI_UpdateWindow($g_hAndroidWindow)
EndIf
Return $Result
EndFunc
Func AndroidQueueReboot($bQueueReboot = True)
$g_bAndroidQueueReboot = $bQueueReboot
EndFunc
Func AndroidInvalidState()
If $g_hAndroidWindow = 0 Then
SetDebugLog("AndroidInvalidState: No Window Handle", $COLOR_ERROR)
Return True
EndIf
If IsHWnd($g_hAndroidWindow) And WinGetHandle($g_hAndroidWindow, "") = 0 Then
SetDebugLog("AndroidInvalidState: Window Handle " & $g_hAndroidWindow & " doesn't exist", $COLOR_ERROR)
Return True
EndIf
If IsHWnd($g_hAndroidWindow) = False And IsNumber($g_hAndroidWindow) And $g_bAndroidBackgroundLaunched = False Then
SetDebugLog("AndroidInvalidState: PID " & $g_hAndroidWindow & " not supported for Headless Mode", $COLOR_ERROR)
Return True
EndIf
If $g_bAndroidBackgroundLaunched = True And ProcessExists2($g_hAndroidWindow) = 0 Then
SetDebugLog("AndroidInvalidState: PID " & $g_hAndroidWindow & " doesn't exist", $COLOR_ERROR)
Return True
EndIf
Return False
EndFunc
Func CheckAndroidReboot($bRebootAndroid = True)
If CheckAndroidTimeLag($bRebootAndroid) = True Or CheckAndroidPageError($bRebootAndroid) = True Or CheckAndroidRebootCondition($bRebootAndroid) = True Then
Local $_NoFocusTampering = $g_bNoFocusTampering
$g_bNoFocusTampering = True
RebootAndroid()
$g_bNoFocusTampering = $_NoFocusTampering
Return True
EndIf
Return False
EndFunc
Func GetAndroidProcessPID($sPackage = Default, $bForeground = True, $iRetryCount = 0)
If $sPackage = Default Then $sPackage = $g_sAndroidGamePackage
If AndroidInvalidState() Then Return 0
Local $cmd = "set result=$(ps -p|grep """ & $g_sAndroidGamePackage & """ >&2)"
Local $output = AndroidAdbSendShellCommand($cmd)
SetDebugLog("$g_sAndroidGamePackage: " & $g_sAndroidGamePackage)
SetDebugLog("GetAndroidProcessPID StdOut :" & $output)
$output = StringStripWS($output, 7)
Local $aPkgList[0][26]
Local $iCols
_ArrayAdd($aPkgList, $output, 0, " ", @LF, $ARRAYFILL_FORCE_STRING)
Local $CorrectSCHED = "0"
Switch $g_sAndroidGamePackage
Case $g_sAndroidGamePackage = "com.tencent.tmgp.supercell.clashofclans"
$CorrectSCHED = "3"
Case Else
$CorrectSCHED = "0"
EndSwitch
For $i = 1 To UBound($aPkgList)
$iCols = _ArraySearch($aPkgList, "", 0, 0, 0, 0, 1, $i, True)
If $iCols > 9 And $aPkgList[$i - 1][$iCols - 1] = $g_sAndroidGamePackage Then
If $bForeground = True And $aPkgList[$i - 1][8] <> $CorrectSCHED Then
If $iRetryCount < 2 Then
Sleep(100)
Return GetAndroidProcessPID($sPackage, $bForeground, $iRetryCount + 1)
EndIf
SetDebugLog("Android process " & $sPackage & " not running in foreground")
Return 0
EndIf
Return Int($aPkgList[$i - 1][1])
EndIf
Next
If $iRetryCount < 2 Then
Sleep(100)
Return GetAndroidProcessPID($sPackage, $bForeground, $iRetryCount + 1)
EndIf
SetDebugLog("Android process " & $sPackage & " not running")
Return 0
EndFunc
Func AndroidToFront($hHWndAfter = Default, $sSource = "Unknown")
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
SetDebugLog("AndroidToFront: Source " & $sSource)
WinMove2(GetAndroidDisplayHWnD(), "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $g_bChkBackgroundMode And($hHWndAfter = $HWND_TOPMOST Or $hHWndAfter = $HWND_TOP) Then WinMove2(GetAndroidDisplayHWnD(), "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndFunc
Func ShowAndroidWindow($hHWndAfter = Default, $bRestorePosAndActivateWindow = Default, $bFastCheck = Default, $sSource = "Unknown")
Return HideAndroidWindow(False, $bRestorePosAndActivateWindow, $bFastCheck, $sSource & "->ShowAndroidWindow", $hHWndAfter)
EndFunc
Func HideAndroidWindow($bHide = True, $bRestorePosAndActivateWhenShow = Default, $bFastCheck = Default, $sSource = "Unknown", $hHWndAfter = Default)
If $bFastCheck = Default Then $bFastCheck = True
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
SetDebugLog("HideAndroidWindow: " & $bHide & ", " & $bRestorePosAndActivateWhenShow & ", " & $bFastCheck & ", " & $sSource)
ResumeAndroid()
SetError(0)
If $bFastCheck Then
If Not IsHWnd($g_hAndroidWindow) Then SetError(1)
Else
WinGetAndroidHandle()
WinGetPos($g_hAndroidWindow)
EndIf
If @error <> 0 Or AndroidEmbedded() Then Return SetError(0, 0, 0)
If $bHide = True Then
WinMove($g_hAndroidWindow, "", -32000, -32000)
ElseIf $bHide = False Then
Switch $bRestorePosAndActivateWhenShow
Case True
WinMove($g_hAndroidWindow, "", $g_iAndroidPosX, $g_iAndroidPosY)
WinActivate($g_hAndroidWindow)
Case False
Local $a = WinGetPos($g_hAndroidWindow)
If UBound($a) > 1 And($a[0] < -30000 Or $a[1] < -30000) Then WinMove($g_hAndroidWindow, "", $g_iAndroidPosX, $g_iAndroidPosY)
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_SHOWNOACTIVATE)
Case Default
Local $a = WinGetPos($g_hAndroidWindow)
If UBound($a) > 1 And($a[0] <> $g_iAndroidPosX Or $a[1] <> $g_iAndroidPosY) Then WinMove($g_hAndroidWindow, "", $g_iAndroidPosX, $g_iAndroidPosY)
EndSwitch
If $hHWndAfter <> $g_hAndroidWindow Then AndroidToFront($hHWndAfter, $sSource & "->HideAndroidWindow")
EndIf
Execute("Hide" & $g_sAndroidEmulator & "Window($bHide, $hHWndAfter)")
SetError(0)
EndFunc
Func AndroidPicturePathAutoConfig($myPictures = Default, $subDir = Default, $bSetLog = Default)
If $subDir = Default Then $subDir = $g_sAndroidEmulator & " Photo"
If $bSetLog = Default Then $bSetLog = True
Local $Result = False
Local $path
If $g_bAndroidPicturesPathAutoConfig = True Then
If $g_sAndroidPicturesHostPath = "" Then
If $myPictures = Default Then $myPictures = RegRead("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\", "My Pictures")
If @error = 0 And FileExists($myPictures) = 1 Then
If $subDir <> "" Then $subDir = "\" & $subDir
$path = $myPictures & $subDir
If StringRight($path, 1) <> "\" Then $path &= "\"
If FileExists($path) = 1 Then
$g_sAndroidPicturesHostPath = $path
SetGuiLog("Shared folder: '" & $g_sAndroidPicturesHostPath & "' will be added to " & $g_sAndroidEmulator, $COLOR_SUCCESS, $bSetLog)
$Result = True
ElseIf DirCreate($path) = 1 Then
$g_sAndroidPicturesHostPath = $path
SetGuiLog("Configure " & $g_sAndroidEmulator & " to support shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Folder created: " & $path, $COLOR_SUCCESS, $bSetLog)
SetGuiLog("This shared folder will be added to " & $g_sAndroidEmulator, $COLOR_SUCCESS, $bSetLog)
$Result = True
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot create folder: " & $path, $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot find current user 'My Pictures' folder", $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
Else
$path = $g_sAndroidPicturesHostPath
If FileExists($path) = 1 Then
ElseIf DirCreate($path) = 1 Then
SetGuiLog("Shared folder created: " & $path, $COLOR_SUCCESS, $bSetLog)
$Result = True
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot create folder: " & $path, $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
EndIf
EndIf
Return $Result
EndFunc
Func ConfigureSharedFolder($iMode = 0, $bSetLog = Default)
If $bSetLog = Default Then $bSetLog = True
Local $Result = Execute("ConfigureSharedFolder" & $g_sAndroidEmulator & "(" & $iMode & "," & $bSetLog & ")")
If Not($Result = "" And @error <> 0) Then
Return $Result
EndIf
Local $bResult = False
Switch $iMode
Case 0
Local $aRegexResult = StringRegExp($__VBoxVMinfo, "Name: '" & $g_sAndroidSharedFolderName & "', Host path: '(.*)'.*", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$bResult = True
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = $aRegexResult[UBound($aRegexResult) - 1] & "\"
Else
SetLog($g_sAndroidEmulator & " shared folder is not available", $COLOR_ERROR)
$g_sAndroidPicturesHostPath = ""
$g_bAndroidAdbScreencap = False
$g_bAndroidSharedFolderAvailable = False
EndIf
Case 1
$bResult = AndroidPicturePathAutoConfig(Default, Default, $bSetLog)
Case 2
If $g_bAndroidSharedFolderAvailable = False And $g_bAndroidPicturesPathAutoConfig = True And FileExists($g_sAndroidPicturesHostPath) = 1 Then
Local $cmdOutput, $process_killed
Local $path = $g_sAndroidPicturesHostPath
If StringRight($path, 1) = "\" Then $path = StringLeft($path, StringLen($path) - 1)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder remove " & $g_sAndroidInstance & " --name " & $g_sAndroidSharedFolderName, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $g_sAndroidInstance & " --name " & $g_sAndroidSharedFolderName & " --hostpath """ & $path & """  --automount", $process_killed)
$bResult = True
EndIf
EndSwitch
Return SetError(0,0, $bResult)
EndFunc
Func OpenAdbShell()
Local $bWasRunState = $g_bRunState
$g_bRunState = True
Local $Result = _OpenAdbShell()
$g_bRunState = $bWasRunState
Return $Result
EndFunc
Func _OpenAdbShell($bRunInitScript = True, $bAdbInstanceShellOptions = True, $bAdbShellOptions = True)
CheckAndroidRunning(True, True, True)
If ConnectAndroidAdb(True, True) = False Then
SetLog("Cannot open ADB Shell, ADB connection not available", $COLOR_ERROR)
Return 0
EndIf
Local $param = AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " shell"
If $bAdbInstanceShellOptions Then $param &= $g_sAndroidAdbInstanceShellOptions
If $bAdbShellOptions Then $param &= $g_sAndroidAdbShellOptions
Local $iPid = ShellExecute($g_sAndroidAdbPath, $param)
SetLog("Launched ADB Shell, PID=" & $iPid & ": """ & $g_sAndroidAdbPath & """ " & $param)
Local $hWnd = 0
Local $hTimer = __TimerInit()
Do
If $hWnd = 0 Then _Sleep(100, True, False)
Local $winlist = WinList()
For $i = 1 To $winlist[0][0]
If $winlist[$i][0] <> "" Then
If WinGetProcess($winlist[$i][1]) = $iPid Then
$hWnd = $winlist[$i][1]
SetDebugLog("Launched ADB Shell, found Window Handle " & $hWnd)
ExitLoop
EndIf
EndIf
Next
Until $hWnd <> 0 Or __TimerDiff($hTimer) > 3000
If $hWnd <> 0 Then
_WinAPI_SetWindowText($hWnd, "ADB Shell: " & $g_sAndroidEmulator & " (" & $g_sAndroidInstance & "), Device = " & $g_sAndroidAdbDevice)
_WinAPI_SetConsoleIcon($g_sLibIconPath, $eIcnGUI, $hWnd)
Else
SetLog("Cannot find ADB Shell Window, try again...")
If $bAdbInstanceShellOptions And $g_sAndroidAdbInstanceShellOptions Then Return _OpenAdbShell($bRunInitScript, False, $bAdbShellOptions)
If $bAdbShellOptions And $g_sAndroidAdbShellOptions Then Return _OpenAdbShell($bRunInitScript, $bAdbInstanceShellOptions, False)
EndIf
If $hWnd <> 0 And $g_iAndroidAdbSuCommand <> "" Then
ControlSend($hWnd, "", "", "{ENTER}")
SetLog("Send Shell command: " & $g_iAndroidAdbSuCommand)
ControlSend($hWnd, "", "", $g_iAndroidAdbSuCommand & "{ENTER}")
ControlSend($hWnd, "", "", "{ENTER}")
ControlSend($hWnd, "", "", "{ENTER}")
EndIf
Return $iPid
EndFunc
Func OpenPlayStore($sPackage)
CheckAndroidRunning(True, True, True)
If ConnectAndroidAdb(True, True) = False Then
SetLog("Cannot open Play Store, ADB connection not available", $COLOR_ERROR)
Return 0
EndIf
SetLog("Open Play Store App '" & $sPackage & "'", $COLOR_INFO)
AndroidAdbSendShellCommand("am start -a android.intent.action.VIEW -d 'market://details?id=" & $sPackage & "'")
EndFunc
Func OpenPlayStoreGame()
Return OpenPlayStore($g_sUserGamePackage)
EndFunc
Func OpenPlayStoreGooglePlayServices()
Return OpenPlayStore("com.google.android.gms")
EndFunc
Func OpenPlayStoreNovaLauncher()
Return OpenPlayStore("com.teslacoilsw.launcher")
EndFunc
Func LaunchAndroid($sProgramPath, $sCmdParam, $sPath, $iWaitInSecAfterLaunch = Default, $bStopIfLaunchFails = True)
If $iWaitInSecAfterLaunch = Default Then $iWaitInSecAfterLaunch = 10
If $sCmdParam And StringLeft($sCmdParam, 1) <> " " Then
$sCmdParam = " " & $sCmdParam
EndIf
If Not $g_sAndroidPicturesHostPath Then
SetScreenAndroid()
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
Local $pid = 0
For $i = 1 To 3
SetDebugLog("LaunchAndroid: " & $sProgramPath & $sCmdParam)
$pid = Run($sProgramPath & $sCmdParam, $sPath)
If _Sleep(3000) Then Return False
If $pid <> 0 Then $pid = ProcessExists($pid)
If $pid <> 0 Then ExitLoop
Next
SetDebugLog("$PID= " & $pid)
If $pid = 0 And $bStopIfLaunchFails = True Then
SetLog("Unable to load " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : "(" & $g_sAndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return 0
EndIf
If $iWaitInSecAfterLaunch > 0 Then
_SleepStatus($iWaitInSecAfterLaunch * 1000)
EndIf
Return $pid
EndFunc
Func UpdateAndroidBackgroundMode()
Local $iMode =(($g_iAndroidBackgroundMode = 0) ?($g_iAndroidBackgroundModeDefault) :($g_iAndroidBackgroundMode))
Local $iBackgroundMode = Execute("Get" & $g_sAndroidEmulator & "BackgroundMode()")
If $iBackgroundMode = "" And @error <> 0 Then
Local $sMode = "Unknown"
Switch $iMode
Case $g_iAndroidBackgroundModeDirectX
$sMode = "DirectX/WinAPI"
Case $g_iAndroidBackgroundModeOpenGL
$sMode = "OpenGL/ADB screencap"
EndSwitch
SetLog($g_sAndroidEmulator & " DirectX/OpenGL cannot be detected")
SetLog("Using " & $sMode & " for Background Mode")
Else
Local $sGraphicsEngine = "Unknown"
Switch $iBackgroundMode
Case $g_iAndroidBackgroundModeDirectX
$sGraphicsEngine = "DirectX"
SetDebugLog($g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") is using DirectX, enable WinAPI for Background Mode")
AndroidSupportFeaturesSet(1)
Case $g_iAndroidBackgroundModeOpenGL
$sGraphicsEngine = "OpenGL"
SetDebugLog($g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") is using OpenGL, disable WinAPI for Background Mode")
AndroidSupportFeaturesRemove(1)
Case Else
$iMode = $g_iAndroidBackgroundModeDefault
Local $sMode = "Unknown"
Switch $iMode
Case $g_iAndroidBackgroundModeDirectX
$sMode = "DirectX/WinAPI"
Case $g_iAndroidBackgroundModeOpenGL
$sMode = "OpenGL/ADB screencap"
EndSwitch
SetLog($g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") unsupported Graphics Engine / Render Mode, using " & $sMode, $COLOR_WARNING)
EndSwitch
EndIf
Switch $iMode
Case 1
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then
If BitAND($g_iAndroidSupportFeature, 2) > 0 Then
SetLog("Android DirectX not available, using ADB screencap for background capture", $COLOR_WARNING)
Else
SetLog("Android DirectX and ADB screencap not available, Background Mode not supported", $COLOR_ERROR)
EndIf
Else
SetDebugLog("Disable ADB screencap, using WinAPI DirectX for Background Mode")
$g_bAndroidAdbScreencap = False
EndIf
Case 2
If $g_bAndroidAdbScreencapEnabled <> True Or $g_bAndroidSharedFolderAvailable <> True Then
SetLog("Android ADB screencap disabled, please check Android Options", $COLOR_ERROR)
Else
If BitAND($g_iAndroidSupportFeature, 2) = 0 Then
If BitAND($g_iAndroidSupportFeature, 1) > 0 Then
SetLog("Android ADB screencap not available, using WinAPI for background capture", $COLOR_WARNING)
Else
SetLog("Android ADB screencap and DirectX not available, Background Mode not supported", $COLOR_ERROR)
EndIf
Else
SetDebugLog("Enable ADB screencap for Background Mode")
$g_bAndroidAdbScreencap = $g_bAndroidAdbScreencapEnabled = True And BitAND($g_iAndroidSupportFeature, 2) = 2
EndIf
EndIf
Case Else
SetLog("Unsupported Android Background Mode " & $iMode, $COLOR_ERROR)
EndSwitch
UpdateChkBackground()
EndFunc
Func GetAndroidCodeName($iAPI = $g_iAndroidVersionAPI)
If $iAPI >= $g_iAndroidNougat Then Return "Nougat"
If $iAPI >= $g_iAndroidLollipop Then Return "Lollipop"
If $iAPI >= $g_iAndroidJellyBean Then Return "JellyBean"
SetDebugLog("Unsupport Android API Version: " & $iAPI, $COLOR_ERROR)
Return ""
EndFunc
Func HaveSharedPrefs($sProfile = $g_sProfileCurrentName, $BothNewOrOld = Default, $bReturnArray = False)
If $sProfile = Default Then $sProfile = $g_sProfileCurrentName
If Not $bReturnArray Then
Return(($BothNewOrOld = Default Or $BothNewOrOld = True) And UBound(_FileListToArray($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES)) > 1) Or(($BothNewOrOld = Default Or $BothNewOrOld = False) And UBound(_FileListToArray($g_sProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES)) > 1)
EndIf
Local $aFiles
If $BothNewOrOld = Default Or $BothNewOrOld = True Then
$aFiles = _FileListToArray($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES, True)
EndIf
If($BothNewOrOld = Default And UBound($aFiles) < 2) Or $BothNewOrOld = False Then
$aFiles = _FileListToArray($g_sProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES, True)
EndIf
If UBound($aFiles) < 1 Then Local $aFiles = [0]
Return SetError(0, 0, $aFiles)
EndFunc
Func PullSharedPrefs($sProfile = $g_sProfileCurrentName)
Local $process_killed
DirCreate($g_sPrivateProfilePath & "\" & $sProfile)
Local $cmdOutput
Local $Result = False
Local $iFiles = 5
Local $iFilesPulled = 0
If Not $g_sAndroidPicturesPathAvailable Then
SetLog("Shard folder in Android not availble, cannot pull shared_prefs", $COLOR_RED)
Return SetError(0, 0, $Result)
EndIf
SetDebugLog("Pulling shared_pref of profile " & $sProfile)
DirRemove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs_tmp", 1)
DirMove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs_tmp")
If FileExists($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs") Then
SetLog("Cannot rename " & $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", $COLOR_ERROR)
SetLog("Error pulling shared_prefs of profile " & $sProfile, $COLOR_ERROR)
Return SetError(0, 0, $Result)
EndIf
If $g_bPullPushSharedPrefsAbdCommand Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " pull /data/data/" & $g_sAndroidGamePackage & "/shared_prefs """ & $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs""", $process_killed)
Else
$cmdOutput = ""
EndIf
If StringInStr($cmdOutput, "files pulled") > 0 And StringInStr($cmdOutput, @LF & "0 files pulled") = 0 And StringInStr($cmdOutput, "failed to ") = 0 And StringInStr($cmdOutput, "Permission denied") = 0 Then
Local $aRegExResult = StringRegExp($cmdOutput, "(\d+) files pulled", $STR_REGEXPARRAYMATCH)
If Not @error Then
$iFilesPulled = Number($aRegExResult[0])
EndIf
$Result = $iFilesPulled >= $iFiles
If Not $Result Then SetLog("Pulled " & $iFilesPulled & " files of " & $iFiles & " total", $COLOR_ERROR)
Else
If $g_bPullPushSharedPrefsAbdCommand Then SetDebugLog("ADB pull failed, try to use host shared folder")
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls -l /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/ >&2)")
$iFiles = UBound(Ls_l_FilesOnly(StringSplit($cmdOutput, @LF, $STR_NOCOUNT)))
If $iFiles >= 5 And StringInStr($cmdOutput, "Permission denied") = 0 And StringInStr($cmdOutput, "No such file or directory") = 0 Then
Local $androidFolder = StringReplace($g_sAndroidPicturesPath & $g_sAndroidPicturesHostFolder & $sProfile, " ", "\ ")
AndroidAdbSendShellCommand("set result=$(rm -r " & $androidFolder & " >&2)")
AndroidAdbSendShellCommand("set result=$(mkdir -p " & $androidFolder & "/shared_prefs >&2)")
AndroidAdbSendShellCommand("set result=$(cp /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/* " & $androidFolder & "/shared_prefs >&2)")
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls -l " & $androidFolder & "/shared_prefs/ >&2)")
$iFilesPulled = UBound(Ls_l_FilesOnly(StringSplit($cmdOutput, @LF, $STR_NOCOUNT)))
If $iFilesPulled >= $iFiles And StringInStr($cmdOutput, "Permission denied") = 0 And StringInStr($cmdOutput, "No such file or directory") = 0 Then
Local $hostFolder = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder & $sProfile
$iFilesPulled = UBound(_FileListToArray($hostFolder & "\shared_prefs", "*", $FLTA_FILES)) - 1
If $iFilesPulled >= $iFiles Then
FileDelete($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs")
DirRemove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", 1)
DirCreate($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs")
If FileCopy($hostFolder & "\shared_prefs\*", $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", $FC_OVERWRITE) And UBound(_FileListToArray($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES)) - 1 >= $iFiles Then
AndroidAdbSendShellCommand("set result=$(rm -r " & $androidFolder & " >&2)")
$Result = True
Else
SetLog("Cannot copy shared_prefs to " & $g_sPrivateProfilePath & "\" & $sProfile, $COLOR_ERROR)
EndIf
Else
SetLog("Cannot copy shared_prefs to " & $hostFolder, $COLOR_ERROR)
EndIf
Else
SetLog("Cannot copy shared_prefs to " & $androidFolder, $COLOR_ERROR)
EndIf
Else
SetLog($g_sAndroidGamePackage & " has no valid shared_prefs folder or it cannot be accessed", $COLOR_ERROR)
EndIf
EndIf
Local $aFiles = _FileListToArray($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", "*", $FLTA_FILES, True)
$iFilesPulled = UBound($aFiles) - 1
If $Result Then $Result = $iFilesPulled >= $iFiles
If $Result Then
DirRemove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs_tmp", 1)
Local $a[$iFilesPulled][2]
For $i = 1 To $aFiles[0]
Local $aFileTime = FileGetTime($aFiles[$i], 0)
$a[$i - 1][0] = $aFiles[$i]
$a[$i - 1][1] = _ArrayToString($aFileTime, "-", -1, 2) & " " & _ArrayToString($aFileTime, ":", 3, -1)
Next
SetDebugLog(_ArrayToString($a, ","))
SetLog("Pulled shared_prefs of profile " & $sProfile & " (" & $iFilesPulled & " files)")
Else
DirRemove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs", 1)
DirMove($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs_tmp", $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs")
SetLog("Error pulling shared_prefs of profile " & $sProfile, $COLOR_ERROR)
EndIf
Return SetError(0, 0, $Result)
EndFunc
Func PushSharedPrefs($sProfile = $g_sProfileCurrentName, $bCloseGameIfRunning = True)
Local $Result = False
Local $bWasRunState = $g_bRunState
Local $process_killed
Local $cmdOutput
If Not $g_sAndroidPicturesPathAvailable Then
SetLog("Shard folder in Android not availble, cannot push shared_prefs", $COLOR_RED)
Return SetError(0, 0, $Result)
EndIf
Local $aNewFiles = HaveSharedPrefs($sProfile, True, True)
Local $bHaveNew = UBound($aNewFiles) > 1
Local $bHaveOld = HaveSharedPrefs($sProfile, False, True)
If Not $bHaveNew And Not $bHaveOld Then
SetLog("Profile " & $sProfile & " doesn't have shared_prefs folder to push", $COLOR_RED)
Return SetError(0, 0, $Result)
EndIf
SetDebugLog("Pushing shared_pref of profile " & $sProfile)
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/ >&2)")
If StringInStr($cmdOutput, "No such file or directory") Then
SetLog("Please launch game one time before pushing shared_prefs", $COLOR_ERROR)
Return SetError(0, 0, $Result)
EndIf
If $bCloseGameIfRunning And GetAndroidProcessPID(Default, $bWasRunState) Then
CloseCoC(False, False)
EndIf
If Not $bHaveNew And $bHaveOld Then
SetLog("Migrate shared_prefs to " & $g_sPrivateProfilePath & "\" & $sProfile)
If DirMove($g_sProfilePath & "\" & $sProfile & "\shared_prefs", $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs") Then
DirRemove($g_sProfilePath & "\" & $sProfile & "\shared_prefs", 1)
$aNewFiles = HaveSharedPrefs($sProfile, True, True)
Else
SetLog("Migration of shared_prefs failed", $COLOR_ERROR)
EndIf
EndIf
Local $iFiles = UBound($aNewFiles) - 1
Local $iFilesPushed = 0
_Sleep(1000)
If $g_bPullPushSharedPrefsAbdCommand Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "-s " & $g_sAndroidAdbDevice & " push """ & $g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs"" /data/data/" & $g_sAndroidGamePackage & "/shared_prefs", $process_killed)
Else
$cmdOutput = ""
EndIf
If StringInStr($cmdOutput, "files pushed") > 0 And StringInStr($cmdOutput, @LF & "0 files pushed") = 0 And StringInStr($cmdOutput, "failed to ") = 0 And StringInStr($cmdOutput, "Permission denied") = 0 Then
Local $aRegExResult = StringRegExp($cmdOutput, "(\d+) files pushed", $STR_REGEXPARRAYMATCH)
If Not @error Then
$iFilesPushed = Number($aRegExResult[0])
EndIf
$Result = $iFilesPushed >= $iFiles
If Not $Result Then SetLog("Pushed " & $iFilesPushed & " files of " & $iFiles & " total", $COLOR_ERROR)
Else
If $g_bPullPushSharedPrefsAbdCommand Then SetDebugLog("ADB push failed, try to use host shared folder")
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls -l /data/data/" & $g_sAndroidGamePackage & "/ >&2)")
Local $aLs = Ls_l_ToArray($cmdOutput)
SetDebugLog("Game folder: " & _ArrayToString($aLs))
Local $iSharedPrefs = _ArraySearch($aLs, "shared_prefs")
If StringInStr($cmdOutput, "Permission denied") = 0 And StringInStr($cmdOutput, "No such file or directory") = 0 And $iSharedPrefs > -1 Then
Local $androidFolder = StringReplace($g_sAndroidPicturesPath & $g_sAndroidPicturesHostFolder & $sProfile, " ", "\ ")
AndroidAdbSendShellCommand("set result=$(rm -r " & $androidFolder & " >&2)")
AndroidAdbSendShellCommand("set result=$(mkdir -p " & $androidFolder & "/shared_prefs >&2)")
Local $hostFolder = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder & $sProfile
Local $iFilesInShared = UBound(_FileListToArray($hostFolder & "\shared_prefs", "*", $FLTA_FILES)) - 1
If FileExists($hostFolder & "\shared_prefs") And $iFilesInShared < 1 Then
If FileCopy($g_sPrivateProfilePath & "\" & $sProfile & "\shared_prefs\*", $hostFolder & "\shared_prefs", $FC_OVERWRITE) And UBound(_FileListToArray($hostFolder & "\shared_prefs", "*", $FLTA_FILES)) - 1 >= $iFiles Then
If $g_bUpdateSharedPrefs And($g_bUpdateSharedPrefsLanguage OR $g_bUpdateSharedPrefsSnow Or $g_bUpdateSharedPrefsZoomLevel Or $g_bUpdateSharedPrefsGoogleDisconnected Or $g_bUpdateSharedPrefsRated) Then
Local $hFile = FileOpen($hostFolder & "\shared_prefs\storage_new.xml", $FO_READ + $FO_UTF8_NOBOM)
Local $sStorage = FileRead($hFile)
FileClose($hFile)
If $sStorage Then
Local $sStorageUpdated = $sStorage
If $g_bUpdateSharedPrefsLanguage Then $sStorageUpdated = StringRegExpReplace($sStorageUpdated, '<string name="d0h6phQUOxO\/uSfvat949w==">.+<\/string>', '<string name="d0h6phQUOxO/uSfvat949w==">FWCNTu39RUlYoSt0Y6mCwg==</string>', 1)
If $g_bUpdateSharedPrefsSnow Then $sStorageUpdated = StringRegExpReplace($sStorageUpdated, '<string name="WnITdUFs6FnH4NScnkEtyg==">.+<\/string>', '<string name="WnITdUFs6FnH4NScnkEtyg==">jS26iozgAh+i/424eyY5cA==</string>', 1)
If $g_bUpdateSharedPrefsZoomLevel Then $sStorageUpdated = StringRegExpReplace($sStorageUpdated, '<string name="MjhxqoFNUV\+begGvsz3gkg==">.+<\/string>', '<string name="MjhxqoFNUV+begGvsz3gkg==">oiMa1oDch9dThLoIKokZqQ==</string>', 1)
If $g_bUpdateSharedPrefsGoogleDisconnected Then $sStorageUpdated = StringRegExpReplace($sStorageUpdated, '<string name="AQ\+\/D2n+JXPIPpMLdPZcqHpYSGJ5PpF3sOnowks5I5s=">.+<\/string>', '<string name="AQ+/D2n+JXPIPpMLdPZcqHpYSGJ5PpF3sOnowks5I5s=">pmvEzdQuRQuKZob4KB0IeA==</string>', 1)
If $g_bUpdateSharedPrefsRated Then $sStorageUpdated = StringRegExpReplace($sStorageUpdated, '<string name="7lJCTt3TmNyzikZuHh9wZQ==">.+<\/string>', '<string name="7lJCTt3TmNyzikZuHh9wZQ==">pmvEzdQuRQuKZob4KB0IeA==</string>', 1)
If $sStorageUpdated <> $sStorage Then
Local $hFile = FileOpen($hostFolder & "\shared_prefs\storage_new.xml", $FO_OVERWRITE + $FO_UTF8_NOBOM)
If FileWrite($hFile, $sStorageUpdated) Then
SetLog("Updated shared_prefs", $COLOR_SUCCESS)
Else
SetLog("Failed to update shared_prefs", $COLOR_ERROR)
EndIf
FileClose($hFile)
Else
SetDebugLog("No need to update shared_prefs", $COLOR_ERROR)
EndIf
Else
SetLog("Failed to read shared_prefs", $COLOR_ERROR)
EndIf
EndIf
AndroidAdbSendShellCommand("set result=$(rm /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/* >&2)")
AndroidAdbSendShellCommand("set result=$(cp " & $androidFolder & "/shared_prefs/* /data/data/" & $g_sAndroidGamePackage & "/shared_prefs >&2)")
$cmdOutput = AndroidAdbSendShellCommand("set result=$(ls -l /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/ >&2)")
$iFilesPushed = UBound(Ls_l_FilesOnly(StringSplit($cmdOutput, @LF, $STR_NOCOUNT)))
$cmdOutput += AndroidAdbSendShellCommand("set result=$(ls -l " & $androidFolder & "/shared_prefs/ >&2)")
If $iFilesPushed >= $iFiles And StringInStr($cmdOutput, "Permission denied") = 0 And StringInStr($cmdOutput, "No such file or directory") = 0 Then
AndroidAdbSendShellCommand("set result=$(rm -r " & $androidFolder & " >&2)")
Local $sPerm = Ls_l_PermissionsToNumber($aLs[$iSharedPrefs][0])
Local $sOwn = $aLs[$iSharedPrefs][1] & ":" & $aLs[$iSharedPrefs][2]
If $g_iAndroidVersionAPI >= $g_iAndroidNougat Then $sOwn = $aLs[$iSharedPrefs][2] & ":" & $aLs[$iSharedPrefs][3]
AndroidAdbSendShellCommand("set result=$(chmod " & $sPerm & " /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/* >&2)")
AndroidAdbSendShellCommand("set result=$(chown " & $sOwn & " /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/* >&2)")
$Result = True
Else
SetLog("Cannot copy sharef_prefs to /data/data/" & $g_sAndroidGamePackage, $COLOR_ERROR)
EndIf
Else
SetLog("Cannot copy shared_prefs to " & $hostFolder, $COLOR_ERROR)
EndIf
Else
SetLog("Cannot create empty folder " & $androidFolder & "/shared_prefs", $COLOR_ERROR)
EndIf
Else
SetDebugLog("ADB command: ls -l /data/data/" & $g_sAndroidGamePackage & "/" & @LF & $cmdOutput)
SetLog($g_sAndroidGamePackage & " has no shared_prefs or cannot be accessed, please launch game first", $COLOR_ERROR)
EndIf
EndIf
If $Result Then
AndroidAdbSendShellCommand("set result=$(ls -l /data/data/" & $g_sAndroidGamePackage & "/shared_prefs/ >&2)")
SetLog("Pushed shared_prefs of profile " & $sProfile & " (" & $iFilesPushed & " files)")
$g_PushedSharedPrefsProfile = $sProfile
$g_PushedSharedPrefsProfile_Timer = __TimerInit()
_Sleep(3000)
Else
SetLog("Error pushing shared_prefs of profile " & $sProfile, $COLOR_ERROR)
EndIf
Return SetError(0, 0, $Result)
EndFunc
Func Ls_l_FilesOnly($aFiles)
If UBound($aFiles) < 1 Then Return $aFiles
Local $i = 0
While $i < UBound($aFiles)
If IsString($aFiles[$i]) And StringLeft($aFiles[$i], 1) <> "-" Then
_ArrayDelete($aFiles, $i)
Else
$i += 1
EndIf
WEnd
Return $aFiles
EndFunc
Func Ls_l_PermissionsToNumber($sPerm)
If StringLen($sPerm) <> 10 Then Return 770
Local $n = ""
For $u = 0 To 2
Local $p = 0
If StringMid($sPerm, $u * 3 + 2, 1) = "r" Then $p += 4
If StringMid($sPerm, $u * 3 + 3, 1) = "w" Then $p += 2
If StringMid($sPerm, $u * 3 + 4, 1) = "x" Then $p += 1
$n &= $p
Next
Return $n
EndFunc
Func Ls_l_ToArray($sOutput)
$sOutput = StringStripWS($sOutput, $STR_STRIPSPACES)
Local $aFiles = StringSplit($sOutput, @LF, $STR_NOCOUNT)
Local $aResult[UBound($aFiles)][0]
For $i = 0 To UBound($aFiles) - 1
Local $aFile = StringSplit($aFiles[$i], " ", $STR_NOCOUNT)
If UBound($aFile) > UBound($aResult, 2) Then ReDim $aResult[UBound($aFiles)][UBound($aFile)]
For $j = 0 To UBound($aFile) - 1
$aResult[$i][$j] = $aFile[$j]
Next
Next
Return $aResult
EndFunc
Func CheckEmuNewVersions()
Local $Version = GetVersionNormalized($g_sAndroidVersion)
Local $NewVersion = ""
Local $HelpLink = "Please visit MyBot Forum!"
Switch $g_sAndroidEmulator
Case "BlueStacks2"
$NewVersion = GetVersionNormalized("4.61.0.0")
Case "MEmu"
$NewVersion = GetVersionNormalized("6.2.0.0")
Case "Nox"
$NewVersion = GetVersionNormalized("6.3.0.0")
Case Else
$NewVersion = GetVersionNormalized("99.0.0.0")
EndSwitch
If $Version > $NewVersion Then
SetLog("You are using an unsupported " & $g_sAndroidEmulator & " version (" & $g_sAndroidVersion & ")!", $COLOR_ERROR)
SetLog($HelpLink, $COLOR_INFO)
EndIf
EndFunc
Func InvalidAdbShellOptions($cmdOutput, $source)
If $g_sAndroidAdbShellOptions And StringInStr($cmdOutput, ": not found") > 0 Then
SetDebugLog($source & ": Shell option '" & $g_sAndroidAdbShellOptions & "' not supported and now disabled")
$g_sAndroidAdbShellOptions = ""
Return True
EndIf
Return False
EndFunc
Func InvalidAdbInstanceShellOptions($cmdOutput, $source)
If $g_sAndroidAdbInstanceShellOptions And StringInStr($cmdOutput, "error: target doesn't support PTY") > 0 Or StringInStr($cmdOutput, ": unknown option") Then
SetDebugLog($source & ": Shell instance option '" & $g_sAndroidAdbInstanceShellOptions & "' not supported and now disabled")
$g_sAndroidAdbInstanceShellOptions = ""
Return True
EndIf
Return False
EndFunc
Func AddSpace($s, $Option = Default)
If Not $s Then Return ""
If $Option == Default Then $Option = 0
Switch $Option
Case 0
Return $s & " "
Case 1
Return " " & $s
EndSwitch
Return $s
EndFunc
Global $g_sNO_COC, $g_sUNKNOWN_COC
Global $_g_asDISTRIBUTORS[24][4]
Func InitializeCOCDistributors()
$g_sNO_COC = "<" & GetTranslatedFileIni("MBR Distributors", "NO_COC", "No COC") & ">"
$g_sUNKNOWN_COC = "<" & GetTranslatedFileIni("MBR Distributors", "Unknown_COC", "Unknown COC") & ">"
Dim $_g_asDISTRIBUTORS[24][4] = [ ["Google", "com.supercell.clashofclans", "com.supercell.clashofclans.GameApp", "Google"], ["Kunlun", "com.supercell.clashofclans.kunlun", "com.supercell.clashofclans.GameAppKunlun", "Kunlun"], ["Qihoo", "com.supercell.clashofclans.qihoo", "com.supercell.clashofclans.GameAppKunlun","Qihoo"], ["Baidu", "com.supercell.clashofclans.baidu", "com.supercell.clashofclans.GameAppKunlun", "Baidu"], ["9game", "com.supercell.clashofclans.uc", "com.supercell.clashofclans.uc.GameApp", "9game"], ["Wandoujia/Downjoy", "com.supercell.clashofclans.wdj", "com.supercell.clashofclans.GameAppKunlun", "Wandoujia/Downjoy"], ["Huawei", "com.supercell.clashofclans.huawei", "com.supercell.clashofclans.GameAppKunlun", "Huawei"], ["OPPO", "com.supercell.clashofclans.nearme.gamecenter", "com.supercell.clashofclans.GameAppKunlun", "OPPO"], ["VIVO", "com.supercell.clashofclans.vivo", "com.supercell.clashofclans.GameAppKunlun", "VIVO"], ["Anzhi", "com.supercell.clashofclans.anzhi", "com.supercell.clashofclans.GameAppKunlun", "Anzhi"], ["Kaopu", "com.supercell.clashofclans.ewan.kaopu", "com.supercell.clashofclans.GameAppKunlun", "Kaopu"], ["Lenovo", "com.supercell.clashofclans.lenovo", "com.supercell.clashofclans.GameAppKunlun", "Lenovo"], ["Guopan", "com.supercell.clashofclans.guopan", "com.flamingo.sdk.view.GPSplashActivity", "Guopan"], ["Xiaomi", "com.supercell.clashofclans.mi", "com.supercell.clashofclans.mi.GameAppXiaomi","Xiaomi"], ["Haimawan", "com.supercell.clashofclans.ewan.hm", "cn.ewan.supersdk.activity.SplashActivity", "Haimawan"], ["Leshi", "com.supercell.clashofclans.ewan.leshi", "cn.ewan.supersdk.activity.SplashActivity", "Leshi"], ["Microvirt", "com.supercell.clashofclans.ewan.xyaz", "cn.ewan.supersdk.activity.SplashActivity", "Microvirt"], ["Yeshen", "com.supercell.clashofclans.ewan.yeshen", "cn.ewan.supersdk.activity.SplashActivity","Yeshen"], ["Aiyouxi", "com.supercell.clashofclans.ewan.egame", "cn.ewan.supersdk.activity.SplashActivity","Aiyouxi"], ["Tencent", "com.tencent.tmgp.supercell.clashofclans", "com.tencent.tmgp.supercell.clashofclans.GameAppTencent","Tencent"], ["Clash Of Magic, The Black Magic: S1", "net.clashofmagic.s1", "com.supercell.clashofclans.GameApp", "Clash Of Magic, The Black Magic: S1"], ["Clash Of Magic, The Power Of Magic: S2", "net.clashofmagic.s2", "com.supercell.clashofclans.GameApp","Clash Of Magic, The Power Of Magic: S2"], ["Clash Of Magic, The Hall Of Magic: S3", "net.clashofmagic.s3", "com.supercell.clashofclans.GameApp", "Clash Of Magic, The Hall Of Magic: S3"], ["Clash Of Magic, The Hall Of Magic 2: S4", "net.clashofmagic.s4", "com.supercell.clashofclans.GameApp", "Clash Of Magic, The Hall Of Magic 2: S4"] ]
EndFunc
Func GetCOCDistributors()
FuncEnter(GetCOCDistributors)
Static $s_asDistributorsLoaded = -1
If $s_asDistributorsLoaded <> -1 And Not IsBotLaunched() Then Return FuncReturn($s_asDistributorsLoaded)
SetDebugLog("Retrieving CoC distributors")
Local $sPkgList = StringReplace(AndroidAdbSendShellCommand("pm list packages clashofclans;pm list packages clashofmagic"), "package:", "")
If @error <> 0 Or $sPkgList = "" Then Return FuncReturn(SetError(1, 0, ""))
Local $aPkgList = StringSplit($sPkgList, @LF, $STR_ENTIRESPLIT)
Local $aDList[0]
Local $bFirstTimeWDJ = True
Local $iIndex, $wasSilentSetLog
For $i = 1 To $aPkgList[0]
$iIndex = _ArraySearch($_g_asDISTRIBUTORS, $aPkgList[$i], 0, 0, 0, 0, 1, 1)
If @error = 6 Then
$wasSilentSetLog = $g_bSilentSetLog
$g_bSilentSetLog = True
SetLog("Unrecognized COC Package: " & $aPkgList[$i])
$g_bSilentSetLog = $wasSilentSetLog
If $aPkgList[$i] = $g_sUserGamePackage Then _ArrayAdd($aDList, $g_sUserGameDistributor, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
Else
If $iIndex <> 5 Then
_ArrayAdd($aDList, $_g_asDISTRIBUTORS[$iIndex][3], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
Else
If $bFirstTimeWDJ Then
_ArrayAdd($aDList, $_g_asDISTRIBUTORS[5][3], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
_ArrayAdd($aDList, $_g_asDISTRIBUTORS[12][3], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
$bFirstTimeWDJ = False
EndIf
EndIf
EndIf
Next
If Not IsBotLaunched() Then $s_asDistributorsLoaded = $aDList
If UBound($aDList) = 0 Then Return FuncReturn(SetError(2, 0, ""))
Return FuncReturn(SetError(0, 0, $aDList))
EndFunc
Func GetCOCPackage($sDistributor)
Local $iIndex = _ArraySearch($_g_asDISTRIBUTORS, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, "")
Else
Return SetError(0, 0, $_g_asDISTRIBUTORS[$iIndex][1])
EndIf
EndFunc
Func GetCOCClass($sDistributor)
Local $iIndex = _ArraySearch($_g_asDISTRIBUTORS, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, "")
Else
Return SetError(0, 0, $_g_asDISTRIBUTORS[$iIndex][2])
EndIf
EndFunc
Func GetCOCUnTranslated($sDistributor)
Local $iIndex = _ArraySearch($_g_asDISTRIBUTORS, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, $sDistributor)
Else
Return SetError(0, 0, $_g_asDISTRIBUTORS[$iIndex][0])
EndIf
EndFunc
Func GetCOCTranslated($sDistributor)
Local $iIndex = _ArraySearch($_g_asDISTRIBUTORS, $sDistributor, 0, 0, 0, 0, 1, 0)
If @error = 6 Then
Return SetError(1, 0, $sDistributor)
Else
Return SetError(0, 0, $_g_asDISTRIBUTORS[$iIndex][3])
EndIf
EndFunc
Global Const $CLSID_ShellLink = "{00021401-0000-0000-C000-000000000046}"
Global Const $sIID_IShellLinkW = "{000214F9-0000-0000-C000-000000000046}"
Global Const $tag_IShellLinkW = "GetPath hresult(long;long;long;long);" & "GetIDList hresult(long);" & "SetIDList hresult(long);" & "GetDescription hresult(long;long);" & "SetDescription hresult(wstr);" & "GetWorkingDirectory hresult(long;long);" & "SetWorkingDirectory hresult(long;long);" & "GetArguments hresult(long;long);" & "SetArguments hresult(ptr);" & "GetHotkey hresult(long);" & "SetHotkey hresult(word);" & "GetShowCmd hresult(long);" & "SetShowCmd hresult(int);" & "GetIconLocation hresult(long;long;long);" & "SetIconLocation hresult(wstr;int);" & "SetRelativePath hresult(long;long);" & "Resolve hresult(long;long);" & "SetPath hresult(wstr);"
Global Const $tag_IPersist = "GetClassID hresult(long);"
Global Const $sIID_IPersistFile = "{0000010b-0000-0000-C000-000000000046}"
Global Const $tag_IPersistFile = $tag_IPersist & "IsDirty hresult();" & "Load hresult(wstr;dword);" & "Save hresult(wstr;bool);" & "SaveCompleted hresult(long);" & "GetCurFile hresult(long);"
Global Const $STGM_READ = 0x00000000
Global Const $STGM_READWRITE = 0x00000002
Global Const $STGM_SHARE_DENY_NONE = 0x00000040
Global Const $tagPROPERTYKEY = 'struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];DWORD pid;endstruct'
Global $tagPROPVARIANT = 'USHORT vt;' & 'WORD wReserved1;' & 'WORD wReserved2;' & 'WORD wReserved3;' & 'LONG;PTR'
Global Const $sIID_IPropertyStore = '{886D8EEB-8CF2-4446-8D02-CDBA1DBDCF99}'
Global Const $VT_EMPTY = 0, $VT_LPWSTR = 31
Func _WindowAppId($hWnd, $appid = Default)
Local $tpIPropertyStore = DllStructCreate('ptr')
_WinAPI_SHGetPropertyStoreForWindow($hWnd, $sIID_IPropertyStore, $tpIPropertyStore)
Local $pPropertyStore = DllStructGetData($tpIPropertyStore, 1)
$tpIPropertyStore = 0
Local $oPropertyStore = ObjCreateInterface($pPropertyStore, $sIID_IPropertyStore, 'GetCount HRESULT(PTR);GetAt HRESULT(DWORD; PTR);GetValue HRESULT(PTR;PTR);' & 'SetValue HRESULT(PTR;PTR);Commit HRESULT()')
If Not IsObj($oPropertyStore) Then Return SetError(1, 0, '')
Local $tPKEY = _PKEY_AppUserModel_ID()
Local $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Local $sAppId
If $appid = Default Then
$oPropertyStore.GetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
If DllStructGetData($tPROPVARIANT, 'vt') <> $VT_EMPTY Then
Local $buf = DllStructCreate('wchar[128]')
DllCall('Propsys.dll', 'long', 'PropVariantToString', 'ptr', DllStructGetPtr($tPROPVARIANT), 'ptr', DllStructGetPtr($buf), 'uint', DllStructGetSize($buf))
If Not @error Then
$sAppId = DllStructGetData($buf, 1)
EndIf
$buf = 0
EndIf
Else
_WinAPI_InitPropVariantFromString($appid, $tPROPVARIANT)
$oPropertyStore.SetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
$oPropertyStore.Commit()
$sAppId = $appid
EndIf
$tPROPVARIANT = 0
$tPKEY = 0
Return SetError(($sAppId == '') * 2, 0, $sAppId)
EndFunc
Func _ShortcutAppId($lnkfile, $appid = Default)
Local $oIShellLinkW = ObjCreateInterface($CLSID_ShellLink, $sIID_IShellLinkW, $tag_IShellLinkW)
If Not IsObj($oIShellLinkW) Then Return SetError(1, 0, '')
Local $pIPersistFile, $oIPersistFile, $ret, $sAppId
Local $tRIID_IPersistFile = _WinAPI_GUIDFromString($sIID_IPersistFile)
$oIShellLinkW.QueryInterface($tRIID_IPersistFile, $pIPersistFile)
$oIPersistFile = ObjCreateInterface($pIPersistFile, $sIID_IPersistFile, $tag_IPersistFile)
If IsObj($oIPersistFile) Then
If $appid == Default Then
$ret = $oIPersistFile.Load($lnkfile, BitOR($STGM_READ, $STGM_SHARE_DENY_NONE))
Else
$ret = $oIPersistFile.Load($lnkfile, $STGM_READWRITE)
EndIf
If $ret = 0 Then
Local $tPKEY = _PKEY_AppUserModel_ID()
Local $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Local $tRIID_IPropertyStore = _WinAPI_GUIDFromString($sIID_IPropertyStore)
Local $pPropertyStore
$oIShellLinkW.QueryInterface($tRIID_IPropertyStore, $pPropertyStore)
Local $oPropertyStore = ObjCreateInterface($pPropertyStore, $sIID_IPropertyStore, 'GetCount HRESULT(PTR);GetAt HRESULT(DWORD;PTR);GetValue HRESULT(PTR;PTR);' & 'SetValue HRESULT(PTR;PTR);Commit HRESULT()')
If IsObj($oPropertyStore) Then
If $appid == Default Then
$oPropertyStore.GetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
If DllStructGetData($tPROPVARIANT, 'vt') <> $VT_EMPTY Then
Local $buf = DllStructCreate('wchar[128]')
DllCall('Propsys.dll', 'long', 'PropVariantToString', 'ptr', DllStructGetPtr($tPROPVARIANT), 'ptr', DllStructGetPtr($buf), 'uint', DllStructGetSize($buf))
$sAppId = DllStructGetData($buf, 1)
$buf = 0
EndIf
Else
_WinAPI_InitPropVariantFromString($appid, $tPROPVARIANT)
$oPropertyStore.SetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
$oPropertyStore.Commit()
$oIPersistFile.Save($lnkfile, True)
$sAppId = $appid
EndIf
EndIf
$tPROPVARIANT = 0
$tPKEY = 0
EndIf
EndIf
If IsObj($oPropertyStore) Then $oPropertyStore.Release()
If IsObj($oIPersistFile) Then $oIPersistFile.Release()
If IsObj($oIShellLinkW) Then $oIShellLinkW.Release()
Return SetError(($sAppId == '') * 2, 0, $sAppId)
EndFunc
Func _WinAPI_InitPropVariantFromString($sUnicodeString, ByRef $tPROPVARIANT)
DllStructSetData($tPROPVARIANT, 'vt', $VT_LPWSTR)
Local $aRet = DllCall('Shlwapi.dll', 'LONG', 'SHStrDupW', 'WSTR', $sUnicodeString, 'PTR', DllStructGetPtr($tPROPVARIANT) + 8)
If @error Then Return SetError(@error, @extended, False)
Local $bSuccess = $aRet[0] == 0
If(Not $bSuccess) Then $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Return SetExtended($aRet[0], $bSuccess)
EndFunc
Func _PKEY_AppUserModel_ID()
Local $tPKEY = DllStructCreate($tagPROPERTYKEY)
_WinAPI_GUIDFromStringEx('{9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}', DllStructGetPtr($tPKEY))
DllStructSetData($tPKEY, 'pid', 5)
Return $tPKEY
EndFunc
Func _WinAPI_SHGetPropertyStoreForWindow($hWnd, $sIID, ByRef $tPointer)
Local $tIID = _WinAPI_GUIDFromString($sIID)
Local $pp = IsPtr($tPointer) ? $tPointer : DllStructGetPtr($tPointer)
Local $aRet = DllCall('Shell32.dll', 'LONG', 'SHGetPropertyStoreForWindow', 'HWND', $hWnd, 'STRUCT*', $tIID, 'PTR', $pp)
If @error Then Return SetError(@error, @extended, False)
Return SetExtended($aRet[0],($aRet[0] = 0))
EndFunc
Global $g_hToolTip = 0
Func _GUICtrlSetTip($controlID, $tiptext, $title = Default, $icon = Default, $options = Default, $useControlID = True)
If $g_hToolTip = 0 Then
SetDebugLog("_GUICtrlSetTip: Missing $hToolTip! $controlID=" & $controlID, $COLOR_ERROR)
Return False
EndIf
Local $hCtrl =($useControlID = True ? GUICtrlGetHandle($controlID) : $controlID)
Return _GUIToolTip_AddTool($g_hToolTip, 0, $tiptext, $hCtrl)
EndFunc
Func _GUICtrlGetControlID($hCtrl = -1)
Local $aRet = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd",($hCtrl = -1 ? GUICtrlGetHandle(-1) : $hCtrl))
Return(IsArray($aRet) ? $aRet[0] : -1)
EndFunc
Func _GUICtrlCreatePic($sFilename_or_hBitmap, $iLeft, $iTop, $iWidth = -1, $iHeight = -1, $iStyle = -1, $iExStyle = -1)
Local $idPic = GUICtrlCreatePic("", $iLeft, $iTop, $iWidth, $iHeight, $iStyle, $iExStyle)
Local $hBMP
If IsPtr($sFilename_or_hBitmap) Then
$hBMP = $sFilename_or_hBitmap
Else
$hBMP = _GDIPlus_BitmapCreateFromFile($sFilename_or_hBitmap)
EndIf
Local $iBmpWidth = _GDIPlus_ImageGetWidth($hBMP)
Local $iBmpHeight = _GDIPlus_ImageGetHeight($hBMP)
Local $g_hBitmap_Resized = 0
Local $hBMP_Ctxt = 0
If $iWidth = -1 Then $iWidth = $iBmpWidth
If $iHeight = -1 Then $iHeight = $iBmpHeight
If $iWidth <> $iBmpWidth Or $iHeight <> $iBmpHeight Then
$g_hBitmap_Resized = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
$hBMP_Ctxt = _GDIPlus_ImageGetGraphicsContext($g_hBitmap_Resized)
_GDIPlus_GraphicsSetInterpolationMode($hBMP_Ctxt, $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
_GDIPlus_GraphicsDrawImageRect($hBMP_Ctxt, $hBMP, 0, 0, $iWidth, $iHeight)
EndIf
Local $hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap(($g_hBitmap_Resized ? $g_hBitmap_Resized : $hBMP))
Local $hPrevImage = GUICtrlSendMsg($idPic, $STM_SETIMAGE, 0, $hHBMP)
_WinAPI_DeleteObject($hPrevImage)
If IsPtr($sFilename_or_hBitmap) = 0 Then _GDIPlus_BitmapDispose($hBMP)
If $g_hBitmap_Resized Then _GDIPlus_BitmapDispose($g_hBitmap_Resized)
If $hBMP_Ctxt Then _GDIPlus_GraphicsDispose($hBMP_Ctxt)
_WinAPI_DeleteObject($hHBMP)
Return $idPic
EndFunc
Func _GUI_Value_STATE($action_groupe, $group_de_controle)
Local $liste_controle = StringSplit($group_de_controle, "#")
If IsArray($liste_controle) Then
For $i = 1 To $liste_controle[0]
Switch StringUpper($action_groupe)
Case "HIDE"
GUICtrlSetState($liste_controle[$i], $GUI_HIDE)
Case "SHOW"
GUICtrlSetState($liste_controle[$i], $GUI_SHOW)
Case "ENABLE"
GUICtrlSetState($liste_controle[$i], $GUI_ENABLE)
Case "DISABLE"
GUICtrlSetState($liste_controle[$i], $GUI_DISABLE)
Case "UNCHECKED"
GUICtrlSetState($liste_controle[$i], $GUI_UNCHECKED)
Case "CHECKED"
GUICtrlSetState($liste_controle[$i], $GUI_CHECKED)
EndSwitch
Next
EndIf
EndFunc
Global Const $TCM_SETITEM = 0x1306
Global $_GUI_MAIN_WIDTH = 472
Global $_GUI_MAIN_HEIGHT = 692
Global Const $_NORMALGUI_MAIN_WIDTH = $_GUI_MAIN_WIDTH
Global Const $_NORMALGUI_MAIN_HEIGHT = $_GUI_MAIN_HEIGHT
Global Const $_MINIGUI_MAIN_WIDTH = $_GUI_MAIN_WIDTH
Global Const $_MINIGUI_MAIN_HEIGHT = 220
Global $_GUI_MAIN_TOP = 23
Global $_GUI_MAIN_BUTTON_SIZE = [25, 17]
Global $_GUI_MAIN_BUTTON_COUNT = 4
Global $_GUI_CHILD_TOP = 110 + $_GUI_MAIN_TOP
Global Const $_GUI_BOTTOM_HEIGHT = 135
Global Const $_GUI_CHILD_LEFT = 10
Global Const $g_bBtnColor = False
Global Const $g_iSizeWGrpTab1 = $_GUI_MAIN_WIDTH - 20
Global Const $g_iSizeHGrpTab1 = $_GUI_MAIN_HEIGHT - 255
Global Const $g_iSizeWGrpTab2 = $_GUI_MAIN_WIDTH - 30
Global Const $g_iSizeHGrpTab2 = $_GUI_MAIN_HEIGHT - 285
Global Const $g_iSizeWGrpTab3 = $_GUI_MAIN_WIDTH - 40
Global Const $g_iSizeHGrpTab3 = $_GUI_MAIN_HEIGHT - 315
Global Const $g_iSizeWGrpTab4 = $_GUI_MAIN_WIDTH - 50
Global Const $g_iSizeHGrpTab4 = $_GUI_MAIN_HEIGHT - 345
Global $g_iBotDesignFlags = 3
Global $g_bCustomTitleBarActive = Default
Global $g_bBotDockedShrinked = False
Global $g_hFrmBotButtons, $g_hFrmBotLogoUrlSmall, $g_hFrmBotEx = 0, $g_hLblBotTitle, $g_hLblBotShrink = 0, $g_hLblBotExpand = 0, $g_hLblBotMiniGUI = 0, $g_hLblBotNormalGUI = 0 , $g_hLblBotMinimize = 0, $g_hLblBotClose = 0, $g_hFrmBotBottom = 0, $g_hFrmBotEmbeddedShield = 0, $g_hFrmBotEmbeddedShieldInput = 0, $g_hFrmBotEmbeddedGraphics = 0
Global $g_hFrmBot_MAIN_PIC = 0, $g_hFrmBot_URL_PIC = 0, $g_hFrmBot_URL_PIC2 = 0
Global $g_hTabMain = 0, $g_hTabLog = 0, $g_hTabVillage = 0, $g_hTabAttack = 0, $g_hTabMOD = 0, $g_hTabBot = 0, $g_hTabAbout = 0
Global $g_hStatusBar = 0
Global $g_hTiShow = 0, $g_hTiHide = 0, $g_hTiDonate = 0, $g_hTiAbout = 0, $g_hTiStartStop = 0, $g_hTiPause = 0, $g_hTiExit = 0
Global $g_aFrmBotPosInit[8] = [0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hFirstControlToHide = 0, $g_hLastControlToHide = 0, $g_aiControlPrevState[1]
Global $g_bFrmBotMinimized = False
Global $g_hLblAndroidInfo = 0
Global $g_oCtrlIconData = ObjCreate("Scripting.Dictionary")
Global $g_oGuiNotInMini = ObjCreate("Scripting.Dictionary")
Global $g_hBtnStart = 0, $g_hBtnStop = 0, $g_hBtnPause = 0, $g_hBtnResume = 0, $g_hBtnSearchMode = 0, $g_hBtnMakeScreenshot = 0, $g_hBtnHide = 0, $g_hBtnEmbed = 0, $g_hChkBackgroundMode = 0, $g_hLblDonate = 0, $g_hBtnAttackNowDB = 0, $g_hBtnAttackNowLB = 0, $g_hBtnAttackNowTS = 0
Global $g_hPicTwoArrowShield = 0, $g_hLblVersion = 0, $g_hLblMod = 0, $g_hPicArrowLeft = 0, $g_hPicArrowRight = 0
Global $g_hGrpVillage = 0
Global $g_hLblResultGoldNow = 0, $g_hLblResultGoldHourNow = 0, $g_hPicResultGoldNow = 0, $g_hPicResultGoldTemp = 0
Global $g_hLblResultElixirNow = 0, $g_hLblResultElixirHourNow = 0, $g_hPicResultElixirNow = 0, $g_hPicResultElixirTemp = 0
Global $g_hLblResultDENow = 0, $g_hLblResultDEHourNow = 0, $g_hPicResultDENow = 0, $g_hPicResultDETemp = 0
Global $g_hLblResultTrophyNow = 0, $g_hPicResultTrophyNow = 0, $g_hLblResultRuntimeNow = 0, $g_hPicResultRuntimeNow = 0, $g_hLblResultBuilderNow = 0, $g_hPicResultBuilderNow = 0
Global $g_hLblResultAttackedHourNow = 0, $g_hPicResultAttackedHourNow = 0, $g_hLblResultGemNow = 0, $g_hPicResultGemNow = 0, $g_hLblResultSkippedHourNow = 0, $g_hPicResultSkippedHourNow = 0
Global $g_hLblVillageReportTemp = 0
Global $g_hPicHeroGray[3] = [0, 0, 0], $g_hPicHeroBlue[3] = [0, 0, 0], $g_hPicHeroRed[3] = [0, 0, 0], $g_hPicHeroGreen[3] = [0, 0, 0], $g_hPicLabGray = 0, $g_hPicLabRed = 0, $g_hPicLabGreen = 0, $g_hLblLabTime = 0
Global $g_hBtnEnableGUI = 0, $g_hBtnDisableGUI = 0
Func CreateBottomPanel()
Local $sTxtTip = ""
Local $y_bottom = 0
Local $x = 10, $y = $y_bottom + 10
GUICtrlCreateGroup("https://mybot.run " & GetTranslatedFileIni("MBR GUI Design Bottom", "Group_01", "- freeware bot -"), $x - 5, $y - 10, 190, 108)
$g_hBtnStart = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnStart", "Start Bot"), $x, $y + 2 +5, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnStart_Info_01", "Use this to START the bot."))
GUICtrlSetOnEvent(-1, "btnStart")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnStop = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnStop", "Stop Bot"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnStop_Info_01", "Use this to STOP the bot (or ESC key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xDB4D4D)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnPause = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnPause", "Pause"), $x + 90, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnPause_Info_01", "Use this to PAUSE all actions of the bot until you Resume (or Pause/Break key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnResume = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnResume", "Resume"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnResume_Info_01", "Use this to RESUME a paused Bot (or Pause/Break key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnSearchMode = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnSearchMode", "Search Mode"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnSearchMode_Info_01", "Does not attack. Searches for a Village that meets conditions."))
GUICtrlSetOnEvent(-1, "btnSearchMode")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnMakeScreenshot = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnMakeScreenshot", "Photo"), $x , $y + 45, 40, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnMakeScreenshot_Info_01", "Click here to take a snaphot of your village and save it to a file."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
$g_hBtnHide = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnHide", "Hide"), $x + 40, $y + 45, 50, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnHide_Info_01", "Use this to move the Android Window out of sight.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "BtnHide_Info_02", "(Not minimized, but hidden)"))
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnEmbed = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEmbed", "Dock"), $x + 90, $y + 45, 90, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEmbed_Info_01", "Use this to embed the Android Window into Bot."))
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "btnEmbed")
$g_hChkBackgroundMode = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Bottom", "ChkBackgroundMode", "Background Mode"), $x + 1, $y + 72, 90, 24)
GUICtrlSetFont(-1, 7)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "ChkBackgroundMode_Info_01", "Check this to ENABLE the Background Mode of the Bot.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "ChkBackgroundMode_Info_02", "With this you can also hide the Android Emulator window out of sight."))
If $g_bGuiRemote Then GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkBackground")
GUICtrlSetState(-1,(($g_bAndroidAdbScreencap = True) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
$g_hBtnEnableGUI = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEnableGUI", "Enable GUI"), $x + 100, $y + 72, 80, 22)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEnableGUI_Info_01", "Enable GUI control while botting") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEnableGUI_Info_02", "Warning: USE THIS WITH CAUTION!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEnableGUI_Info_03", "This function may create errors that require bot/PC restart") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "BtnEnableGUI_Info_04", "Better to stop the Bot completely if you need to change the setting"))
GUICtrlSetOnEvent(-1, "btnEnableGUI")
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnDisableGUI = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnDisableGUI", "Disable GUI"), $x + 100, $y + 72, 80, 22)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "BtnDisableGUI_Info_01", "Disable GUI control to continue botting"))
GUICtrlSetOnEvent(-1, "btnDisableGUI")
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnAttackNowDB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnAttackNowDB", "DB Attack!"), $x + 195, $y - 4, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnAttackNowLB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnAttackNowLB", "LB Attack!"), $x + 195, $y + 23, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnAttackNowTS = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Bottom", "BtnAttackNowTS", "TH Snipe!"), $x + 195, $y + 50, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblDonate = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Bottom", "LblDonate", "Support the Development"), $x + 293, $y + 85, 142, 18, $SS_RIGHT)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Bottom", "LblDonate_Info_01", "Paypal Donate?"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
If $g_bAndroidAdbScreencap Then chkBackground()
$g_hPicTwoArrowShield = _GUICtrlCreateIcon($g_sLibIconPath, $eIcn2Arrow, $x + 205, $y + 7, 48, 48)
$g_hLblVersion = GUICtrlCreateLabel($g_sModVersion, $x + 200, $y + 62, 60, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, 0x804001)
$g_hLblMod = GUICtrlCreateLabel("AiO++ MOD", $x + 195, $y + 78, 70, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, 0x804001)
$g_hPicArrowLeft = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnArrowLeft, $x + 269, $y + 30, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Bottom", "GrpVillage_Info_01", "Switch between village info and stats")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicArrowRight = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnArrowRight, $x + 247 + 198, $y + 30, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
Local $x = 295, $y = $y_bottom + 20
$g_hGrpVillage = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Bottom", "GrpVillage", "Village"), $x - 0, $y - 20, 160, 94)
$y = $y_bottom + 17
$g_hLblResultGoldNow = GUICtrlCreateLabel("", $x + 10, $y + 2, 60, 15, $SS_RIGHT)
$g_hLblResultGoldHourNow = GUICtrlCreateLabel("", $x + 10, $y + 2, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultGoldNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 71, $y, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultGoldTemp = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 15, $y, 16, 16)
$g_hLblResultElixirNow = GUICtrlCreateLabel("", $x + 10, $y + 22, 60, 15, $SS_RIGHT)
$g_hLblResultElixirHourNow = GUICtrlCreateLabel("", $x + 10, $y + 22, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultElixirNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 71, $y + 20, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultElixirTemp = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 15, $y + 20, 16, 16)
$g_hLblResultDENow = GUICtrlCreateLabel("", $x + 10, $y + 42, 60, 15, $SS_RIGHT)
$g_hLblResultDEHourNow = GUICtrlCreateLabel("", $x + 10, $y + 42, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultDENow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 71, $y + 40, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultDETemp = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 15, $y + 40, 16, 16)
$x += 75
$g_hLblResultTrophyNow = GUICtrlCreateLabel("", $x + 13, $y + 2, 43, 15, $SS_RIGHT)
$g_hPicResultTrophyNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 59, $y , 16, 16)
$g_hLblResultRuntimeNow = GUICtrlCreateLabel("00:00:00", $x + 13, $y + 2, 43, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultRuntimeNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x +57, $y, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblResultBuilderNow = GUICtrlCreateLabel("", $x + 16, $y + 22, 40, 15, $SS_RIGHT)
$g_hPicResultBuilderNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 59, $y + 20, 16, 16)
$g_hLblResultAttackedHourNow = GUICtrlCreateLabel("0", $x + 13, $y + 22, 43, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultAttackedHourNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x +59, $y + 20, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblResultGemNow = GUICtrlCreateLabel("", $x + 13, $y + 42, 43, 15, $SS_RIGHT)
$g_hPicResultGemNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 59, $y + 40, 16, 16)
$g_hLblResultSkippedHourNow = GUICtrlCreateLabel("0", $x + 13, $y + 42, 43, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultSkippedHourNow = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgX, $x + 59, $y + 40, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$x -= 65
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Bottom", "GrpStatus_Info_01", "Gray - Not Read, Green - Ready to Use, Blue - Healing, Red - Upgrading")
$g_hPicHeroGray[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingGrayShield, $x, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicHeroBlue[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingBlueShield, $x, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGreen[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingGreenShield, $x, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroRed[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingRedShield, $x, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGray[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenGrayShield, $x + 24, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicHeroBlue[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenBlueShield, $x + 24, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGreen[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenGreenShield, $x + 24, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroRed[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenRedShield, $x + 24, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGray[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenGrayShield, $x + 48, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicHeroBlue[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenBlueShield, $x + 48, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGreen[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenGreenShield, $x + 48, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroRed[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenRedShield, $x + 48, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Bottom", "GrpStatus_Info_02", "Green - Lab is Running, Red - Lab Has Stopped")
$g_hPicLabGray = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLabGrayShield, $x + 72, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicLabGreen = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLabGreenShield, $x + 72, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicLabRed = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLabRedShield, $x + 72, $y + 59, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblLabTime = GUICtrlCreateLabel("00:00:00", $x + 93, $y + 60, 50, 14, $SS_LEFT)
$x = 331
$g_hLblVillageReportTemp = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Bottom", "LblVillageReportTemp_01", "Village Report") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "LblVillageReportTemp_02", "will appear here") & @CRLF & GetTranslatedFileIni("MBR GUI Design Bottom", "LblVillageReportTemp_03", "on first run."), $x , $y + 3, 88, 50, BITOR($SS_CENTER, $BS_MULTILINE))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_LOG = 0
Global $g_hTxtLog = 0, $g_hDivider = 0, $g_hTxtAtkLog = 0
Global $g_hCmbLogDividerOption, $g_hBtnAtkLogClear, $g_hBtnAtkLogCopyClipboard
Func CreateLogTab($hWHndLogsOnly = False)
Local $x = 0, $y = 0
Local $activeHWnD = WinGetHandle("")
If $hWHndLogsOnly Then
$g_hTxtLog = _GUICtrlRichEdit_Create($hWHndLogsOnly, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, $WS_HSCROLL, $ES_UPPERCASE, $ES_AUTOHSCROLL, $ES_AUTOVSCROLL, $ES_NUMBER, 0x200), $WS_EX_STATICEDGE)
WinSetState($g_hTxtLog, "", @SW_MINIMIZE)
$g_hTxtAtkLog = _GUICtrlRichEdit_Create($hWHndLogsOnly, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, 8908), $WS_EX_STATICEDGE)
WinSetState($g_hTxtAtkLog, "", @SW_MINIMIZE)
WinActivate($activeHWnD)
Return
EndIf
$g_hGUI_LOG = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, 0), -1, $g_hFrmBotEx)
If IsHWnd($g_hTxtLog) Then
SetDebugLog("Re-use existing bot log control")
_WinAPI_SetParent($g_hTxtLog, $g_hGUI_LOG)
_WinAPI_SetWindowLong($g_hTxtLog, $GWL_HWNDPARENT, $g_hGUI_LOG)
WinSetState($g_hTxtLog, "", @SW_RESTORE)
Else
$g_hTxtLog = _GUICtrlRichEdit_Create($g_hGUI_LOG, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, $WS_HSCROLL, $ES_UPPERCASE, $ES_AUTOHSCROLL, $ES_AUTOVSCROLL, $ES_NUMBER, 0x200), $WS_EX_STATICEDGE)
EndIf
$g_hDivider = GUICtrlCreateLabel("", 0, 0, 20, 20, $SS_SUNKEN + $SS_BLACKRECT)
GUICtrlSetCursor(-1, 11)
If IsHWnd($g_hTxtAtkLog) Then
SetDebugLog("Re-use existing attack log control")
_WinAPI_SetParent($g_hTxtAtkLog, $g_hGUI_LOG)
_WinAPI_SetWindowLong($g_hTxtAtkLog, $GWL_HWNDPARENT, $g_hGUI_LOG)
WinSetState($g_hTxtAtkLog, "", @SW_RESTORE)
Else
$g_hTxtAtkLog = _GUICtrlRichEdit_Create($g_hGUI_LOG, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, 8908), $WS_EX_STATICEDGE)
EndIf
WinActivate($activeHWnD)
$y = 410
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Log", "LblLog_Style", "Log Style") & ":", $x, $y + 5, -1, -1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$g_hCmbLogDividerOption = GUICtrlCreateCombo("", $x + 50, $y, 180, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Log", "LblLog_Style_Info_01", "Use these options to set the Log type."))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_01", "Use Divider to Resize Both Logs") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_02", "Bot and Attack Log Same Size") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_03", "Large Bot Log, Small Attack Log") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_04", "Small Bot Log, Large Attack Log") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_05", "Full Bot Log, Hide Attack Log") & "|" & GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_06", "Hide Bot Log, Full Attack Log"), GetTranslatedFileIni("MBR GUI Design Log", "CmbLogDividerOption_Item_01", -1))
GUICtrlSetOnEvent(-1, "cmbLog")
$g_hBtnAtkLogClear = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Log", "BtnAtkLogClear", "Clear Atk. Log"), $x + 270, $y - 1, 80, 23)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Log", "BtnAtkLogClear_Info_01", "Use this to clear the Attack Log."))
GUICtrlSetOnEvent(-1, "btnAtkLogClear")
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
$g_hBtnAtkLogCopyClipboard = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Log", "BtnAtkLogCopyClipboard", "Copy to Clipboard"), $x + 350, $y - 1, 100, 23)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Log", "BtnAtkLogCopyClipboard_Info_01", "Use this to copy the Attack Log to the Clipboard (CTRL+C)"))
GUICtrlSetOnEvent(-1, "btnAtkLogCopyClipboard")
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
EndFunc
Global $g_hGUI_VILLAGE = 0
Global $g_hGUI_MISC = 0, $g_hGUI_MISC_TAB = 0, $g_hGUI_MISC_TAB_ITEM1 = 0, $g_hGUI_MISC_TAB_ITEM2 = 0, $g_hGUI_MISC_TAB_ITEM3 = 0
Global $g_hChkBotStop = 0, $g_hCmbBotCommand = 0, $g_hCmbBotCond = 0, $g_hCmbHoursStop = 0
Global $g_hTxtRestartGold = 0, $g_hTxtRestartElixir = 0, $g_hTxtRestartDark = 0
Global $g_hChkCollect = 1, $g_hChkTombstones = 1, $g_hChkCleanYard = 0, $g_hChkGemsBox = 0
Global $g_hChkCollectCartFirst = 0, $g_hTxtCollectGold = 0, $g_hTxtCollectElixir = 0, $g_hTxtCollectDark = 0
Global $g_hBtnLocateKingAltar = 0, $g_hBtnLocateQueenAltar = 0, $g_hBtnLocateWardenAltar = 0, $g_hBtnLocateLaboratory = 0, $g_hBtnResetBuilding = 0
Global $g_hChkTreasuryCollect = 0, $g_hTxtTreasuryGold = 0, $g_hTxtTreasuryElixir = 0, $g_hTxtTreasuryDark = 0 , $g_hChkFreeMagicItems = 0
Global $g_alblBldBaseStats[4] = ["", "", ""]
Global $g_hChkCollectBuilderBase = 0, $g_hChkStartClockTowerBoost = 0, $g_hChkCTBoostBlderBz = 0, $g_hChkCleanBBYard = 0
Global $g_hChkBBSuggestedUpgrades = 0, $g_hChkBBSuggestedUpgradesIgnoreGold = 0 , $g_hChkBBSuggestedUpgradesIgnoreElixir , $g_hChkBBSuggestedUpgradesIgnoreHall = 0
Global $g_hChkPlacingNewBuildings = 0
Global $g_hChkClanGamesAir = 0, $g_hChkClanGamesGround = 0, $g_hChkClanGamesMisc = 0
Global $g_hChkClanGamesEnabled = 0 , $g_hChkClanGames60 = 0
Global $g_hChkClanGamesLoot = 0 , $g_hChkClanGamesBattle =0 , $g_hChkClanGamesDestruction = 0 , $g_hChkClanGamesAirTroop = 0 , $g_hChkClanGamesGroundTroop = 0 , $g_hChkClanGamesMiscellaneous = 0
Global $g_hChkClanGamesPurge = 0 , $g_hcmbPurgeLimit = 0 , $g_hChkClanGamesStopBeforeReachAndPurge = 0
Global $g_hTxtClanGamesLog = 0
Global $g_hChkClanGamesDebug = 0
Global $g_hLblRemainTime = 0 , $g_hLblYourScore = 0
Func CreateVillageMisc()
$g_hGUI_MISC = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
GUISwitch($g_hGUI_MISC)
$g_hGUI_MISC_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_MISC_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "MISC_TAB_ITEM1", "Normal Village"))
CreateMiscNormalVillageSubTab()
$g_hGUI_MISC_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "MISC_TAB_ITEM2", "Builder Base"))
CreateMiscBuilderBaseSubTab()
$g_hGUI_MISC_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "MISC_TAB_ITEM3", "Clan Games"))
CreateMiscClanGamesV3SubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreateMiscNormalVillageSubTab()
Local $sTxtTip = ""
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_01", "Halt Attack"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 98)
$g_hChkBotStop = GUICtrlCreateCheckbox("", $x - 5, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BotStop_Info_01", "Use these options to set when the bot will stop attacking.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkBotStop")
$g_hCmbBotCommand = GUICtrlCreateCombo("", $x + 20, $y - 3, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_01", "Halt Attack") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_02", "Stop Bot") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_03", "Close Bot") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_04", "Close CoC+Bot") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_05", "Shutdown PC") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_06", "Sleep PC") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_07", "Reboot PC"), GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCommand_Item_01", -1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "LblBotCommand", "When..."), $x + 125, $y, 45, 17)
$g_hCmbBotCond = GUICtrlCreateCombo("", $x + 173, $y - 3, 160, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_01", "G and E Full and Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_02", "(G and E) Full or Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_03", "(G or E) Full and Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_04", "G or E Full or Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_05", "Gold and Elixir Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_06", "Gold or Elixir Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_07", "Gold Full and Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_08", "Elixir Full and Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_09", "Gold Full or Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_10", "Elixir Full or Max.Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_11", "Gold Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_12", "Elixir Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_13", "Reach Max. Trophy") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_14", "Dark Elixir Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_15", "All Storage (G+E+DE) Full") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_16", "Bot running for...") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_17", "Now (Train/Donate Only)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_18", "Now (Donate Only)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_19", "Now (Only stay online)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_20", "W/Shield (Train/Donate Only)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_21", "W/Shield (Donate Only)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_22", "W/Shield (Only stay online)"), GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "CmbBotCond_Item_17", -1))
GUICtrlSetOnEvent(-1, "cmbBotCond")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbHoursStop = GUICtrlCreateCombo("", $x + 337, $y - 3, 80, 35, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
Local $sTxtHours = GetTranslatedFileIni("MBR Global GUI Design", "Hours", "Hours")
GUICtrlSetData(-1, "-|1 " & GetTranslatedFileIni("MBR Global GUI Design", "Hour", "Hour") & "|2 " & $sTxtHours & "|3 " & $sTxtHours & "|4 " & $sTxtHours & "|5 " & $sTxtHours & "|6 " & $sTxtHours & "|7 " & $sTxtHours & "|8 " & $sTxtHours & "|9 " & $sTxtHours & "|10 " & $sTxtHours & "|11 " & $sTxtHours & "|12 " & $sTxtHours & "|13 " & $sTxtHours & "|14 " & $sTxtHours & "|15 " & $sTxtHours & "|16 " & $sTxtHours & "|17 " & $sTxtHours & "|18 " & $sTxtHours & "|19 " & $sTxtHours & "|20 " & $sTxtHours & "|21 " & $sTxtHours & "|22 " & $sTxtHours & "|23 " & $sTxtHours & "|24 " & $sTxtHours, "-")
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "LblBotWillHaltAutomatically", "The bot will Halt automatically when you run out of Resources. It will resume when reaching these minimal values."), $x + 20, $y, 400, 25, $BS_MULTILINE)
$y += 30
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "LblResumeAttack", "Resume Attack") & ":", $x + 20, $y + 2, 80, -1)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 84, $y, 16, 16)
$g_hTxtRestartGold = GUICtrlCreateInput("10000", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtRestartGold_Info_01", "Minimum Gold value for the bot to resume attacking after halting because of low gold."))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 84, $y, 16, 16)
$g_hTxtRestartElixir = GUICtrlCreateInput("25000", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtRestartElixir_Info_01", "Minimum Elixir value for the bot to resume attacking after halting because of low elixir."))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 84, $y, 16, 16)
$g_hTxtRestartDark = GUICtrlCreateInput("500", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtRestartDark_Info_01", "Minimum Dark Elixir value for the bot to resume attacking after halting because of low dark elixir."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 15, $y = 145
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_02", "Collect, Clear, Remove"), $x -10, $y - 20, $g_iSizeWGrpTab3, 217)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x - 5, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 45, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLootCart, $x + 70, $y, 24, 24)
$g_hChkCollect = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollect", "Collect Resources && Loot Cart"), $x + 100, $y - 6, -1, -1, -1)
GUICtrlSetOnEvent(-1, "ChkCollect")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollect_Info_01", "Check this to automatically collect the Villages Resources") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollect_Info_02", "from Gold Mines, Elixir Collectors and Dark Elixir Drills.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollect_Info_03", "This will also search for a Loot Cart in your village and collect it."))
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkCollectCartFirst = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollectCartFirst", "Loot Cart first"), $x + 280, $y - 6, -1, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollectCartFirst_Info_01", "Check this to collect the Loot Cart before Villages Resources."))
GUICtrlSetState(-1, $GUI_CHECKED)
$x += 120
$y += 15
GUICtrlCreateLabel("<", $x, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 62, $y, 16, 16)
$g_hTxtCollectGold = GUICtrlCreateInput("0", $x + 10, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectGold_Info_01", "Minimum Gold Storage amount to collect Gold.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectGold_Info_02", "Set same as Resume Attack values to collect when 'out of gold' error") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectGold_Info_03", "happens while searching for attack.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectGold_Info_04", "Set to zero to always collect."))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel("<", $x, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 62, $y, 16, 16)
$g_hTxtCollectElixir = GUICtrlCreateInput("0", $x + 10, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectElixir_Info_01", "Minimum Elixir Storage amount to collect Elixier.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectElixir_Info_02", "Set same as Resume Attack values to collect when 'out of elixir' error") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectElixir_Info_03", "happens during troop training.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectGold_Info_04", -1))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel("<", $x, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 62, $y, 16, 16)
$g_hTxtCollectDark = GUICtrlCreateInput("0", $x + 10, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectDark_Info_01", "Minimum Dark Elixir Storage amount to collect Dark Elixier.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectElixir_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectElixir_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtCollectGold_Info_04", -1))
GUICtrlSetLimit(-1, 6)
$x -=(120 + 180)
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTreasury, $x + 22, $y - 10, 48, 48)
$g_hChkTreasuryCollect = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect", "Treasury"), $x + 100, $y - 6, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_01", "Check this to automatically collect Treasury when FULL,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_02", "'OR' when Storage values are BELOW minimum values on right,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_03", "Use zero as min values to ONLY collect when Treasury is full") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_04", "Large minimum values will collect Treasury loot more often!"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "ChkTreasuryCollect")
$x += 120
$y += 15
GUICtrlCreateLabel("<", $x, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 62, $y, 16, 16)
$g_hTxtTreasuryGold = GUICtrlCreateInput("1000000", $x + 10, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryGold_Info_01", "Minimum Gold Storage amount to collect Treasury.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryGold_Info_02", "Set same as Resume Attack values to collect when 'out of gold' error") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryGold_Info_03", "happens while searching for attack") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_01", -1))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel("<", $x, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 62, $y, 16, 16)
$g_hTxtTreasuryElixir = GUICtrlCreateInput("1000000", $x + 10, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_01", "Minimum Elixir Storage amount to collect Treasury.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_02", "Set same as Resume Attack values to collect when 'out of elixir' error") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_03", "happens during troop training") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_01", -1))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel("<", $x, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 62, $y, 16, 16)
$g_hTxtTreasuryDark = GUICtrlCreateInput("1000", $x + 10, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryDark_Info_01", "Minimum Dark Elixir Storage amount to collect Treasury.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtTreasuryElixir_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTreasuryCollect_Info_01", -1))
GUICtrlSetLimit(-1, 6)
$x -=(120 + 180)
$y += 22
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTombstone, $x + 32 , $y, 24, 24)
$g_hChkTombstones = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTombstones", "Clear Tombstones"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkTombstones_Info_01", "Check this to automatically clear tombstones after enemy attack."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTree, $x + 20, $y, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBark, $x + 45, $y, 24, 24)
$g_hChkCleanYard = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCleanYard", "Remove Obstacles"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCleanYard_Info_01", "Check this to automatically clear Yard from Trees, Trunks, etc."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGembox, $x + 32, $y, 24, 24)
$g_hChkGemsBox = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkGemsBox", "Remove GemBox"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkGemsBox_Info_01", "Check this to automatically clear GemBox."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnPowerPotion, $x + 300, $y - 42, 48, 48)
$g_hChkFreeMagicItems = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkFreeMagicItems", "Collect Free Magic Items"), $x + 250, $y + 4, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 20, $y = 363
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_03", "Locate Manually"), $x - 15, $y - 20, $g_iSizeWGrpTab3, 60)
Local $sTxtRelocate = GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtRelocate_Info_01", "Relocate your") & " "
$x -= 11
$y -= 2
GUICtrlCreateButton(GetTranslatedFileIni("MBR Global GUI Design", "LblTownhall", -1), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnTH12, 1)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnTownhall", "Town Hall"))
GUICtrlSetOnEvent(-1, "btnLocateTownHall")
$x += 38
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnCC", "Clan Castle"), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnCC, 1)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnCC", "Clan Castle"))
GUICtrlSetOnEvent(-1, "btnLocateClanCastle")
$x += 38
$g_hBtnLocateKingAltar = GUICtrlCreateButton(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", "King"), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnKingBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnAltarKing_Info_01", "Barbarian King Altar"))
GUICtrlSetOnEvent(-1, "btnLocateKingAltar")
$x += 38
$g_hBtnLocateQueenAltar = GUICtrlCreateButton(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", "Queen"), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnQueenBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnAltarQueen_Info_01", "Archer Queen Altar"))
GUICtrlSetOnEvent(-1, "btnLocateQueenAltar")
$x += 38
$g_hBtnLocateWardenAltar = GUICtrlCreateButton(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", "Grand Warden"), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWardenBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnAltarWarden_Info_01", "Grand Warden Altar"))
GUICtrlSetOnEvent(-1, "btnLocateWardenAltar")
$x += 38
$g_hBtnLocateLaboratory = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnLocateLaboratory", "Lab."), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLaboratory)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnLocateLaboratory_Info_01", "Laboratory"))
GUICtrlSetOnEvent(-1, "btnLab")
$x += 195
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnReset", "Reset."), $x, $y, 36, 36, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBldgX)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnReset_Info_01", "Click here to reset all building locations,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "BtnReset_Info_02", "when you have changed your village layout."))
GUICtrlSetOnEvent(-1, "btnResetBuilding")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMiscBuilderBaseSubTab()
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_05", "Builders Base Stats"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 55)
_GUICtrlCreatePic($g_sIcnBldGold, $x, $y - 2, 32, 32)
$g_alblBldBaseStats[$eLootGoldBB] = GUICtrlCreateLabel("---", $x + 40, $y + 2, 100, -1)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
_GUICtrlCreatePic($g_sIcnBldElixir, $x + 140, $y - 2, 32, 32)
$g_alblBldBaseStats[$eLootElixirBB] = GUICtrlCreateLabel("---", $x + 180, $y + 2, 100, -1)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
_GUICtrlCreatePic($g_sIcnBldTrophy, $x + 280, $y - 2, 32, 32)
$g_alblBldBaseStats[$eLootTrophyBB] = GUICtrlCreateLabel("---", $x + 320, $y + 2, 100, -1)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 15, $y = 110
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_04", "Collect && Activate"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 85)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldMineL5, $x + 7, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixirCollectorL5, $x + 32, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGemMine, $x + 57, $y, 24, 24)
$g_hChkCollectBuilderBase = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollectBuilderBase", "Collect Ressources"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCollectBuildersBase_Info_01", "Check this to collect Ressources on the Builder Base"))
$g_hChkCleanBBYard = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCleanBBYard", "Remove Obstacles"), $x + 260, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCleanBBYard_Info_01", "Check this to automatically clear Yard from Trees, Trunks, etc."))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 32
GUICtrlCreateIcon($g_sLibIconPath, $eIcnClockTower, $x + 32, $y, 24, 24)
$g_hChkStartClockTowerBoost = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkActivateClockTowerBoost", "Activate Clock Tower Boost"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkActivateClockTowerBoost_Info_01", "Check this to activate the Clock Tower Boost when it is available.\r\nThis option doesn't use your Gems"))
GUICtrlSetOnEvent(-1, "chkStartClockTowerBoost")
$g_hChkCTBoostBlderBz = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCTBoostBlderBz", "only when builder is busy"), $x + 260, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkCTBoostBlderBz_Info_01", "boost only when the builder is busy"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 15, $y = 205
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_06", "Suggested Upgrades"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 218)
_GUICtrlCreatePic($g_sIcnMBisland, $x , $y , 64, 64)
$g_hChkBBSuggestedUpgrades = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkBBSuggestedUpgrades", "Suggested Upgrades"), $x + 70, $y + 25, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateBBSuggestedUpgrades")
$g_hChkBBSuggestedUpgradesIgnoreGold = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkBBSuggestedUpgradesIgnore_01", "Ignore Gold values"), $x + 200, $y + 15, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateBBSuggestedUpgradesGold")
$g_hChkBBSuggestedUpgradesIgnoreElixir = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkBBSuggestedUpgradesIgnore_02", "Ignore Elixir values"), $x + 200, $y + 40, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateBBSuggestedUpgradesElixir")
$g_hChkBBSuggestedUpgradesIgnoreHall = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkBBSuggestedUpgradesIgnore_03", "Ignore Builder Hall"), $x + 315, $y + 28, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateBBSuggestedUpgradesGold")
Local $x = 15, $y = 200
$g_hChkPlacingNewBuildings = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkPlacingNewBuildings", "Build 'New' tagged buildings"), $x + 70, $y + 65, -1, -1)
GUICtrlSetOnEvent(-1, "chkPlacingNewBuildings")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMiscClanGamesV3SubTab()
Local Const $g_sLibIconPathMOD = @ScriptDir & "\images\ClanGames.bmp"
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "Group_CG", "Clan Games"), $x - 10, $y - 20, $g_iSizeWGrpTab3, 245)
GUICtrlCreatePic($g_sLibIconPathMOD, $x + 5, $y, 94, 128, $SS_BITMAP)
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesTimeRemaining", "Time Remaining"), $x - 5, $y + 135, 110, 40)
$g_hLblRemainTime = GUICtrlCreateLabel("0d 00h", $x + 15, $y + 135 + 15, 65, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, $GUI_FONTNORMAL)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesYourScore", "Your Score"), $x - 5, $y + 158 + 20, 110, 40)
$g_hLblYourScore = GUICtrlCreateLabel("0/0", $x + 15, $y + 158 + 35, 65, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, $GUI_FONTNORMAL)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 150
$g_hChkClanGamesEnabled = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesEnabled", "Clan Games"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkActivateClangames")
$g_hChkClanGames60 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGames60", "No 60min Events"), $x + 100 , $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGames60_Info_01", "will not choose 60 minute events"))
$g_hChkClanGamesDebug = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesDebug", "Debug"), $x + 205, $y, -1, -1)
$x += 25
$y += 25
$g_hChkClanGamesLoot = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesLoot", "Loot Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesBattle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesBattle", "Battle Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesDestruction = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesDestruction", "Destruction Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesAirTroop = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesAirTroop", "Air Troops Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesGroundTroop = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesGroundTroop", "Ground Troops Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesMiscellaneous = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesMiscellaneous", "Miscellaneous Challenges"), $x, $y, -1, -1)
$y += 25
$g_hChkClanGamesPurge = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesPurge", "Purge Versus Battles Events"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkPurgeLimits")
$g_hcmbPurgeLimit = GUICtrlCreateCombo("" , $x + 155, $y, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Unlimited| 1x| 2x| 3x| 4x| 5x| 6x| 7x| 8x| 9x|10x", " 5x")
$y += 25
$g_hChkClanGamesStopBeforeReachAndPurge = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "ChkClanGamesStopBeforeReachAndPurge", "Stop before completing your limit and only Purge"), $x, $y, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 15
$y = 45
$g_hTxtClanGamesLog = GUICtrlCreateEdit("", $x - 10, 275, $g_iSizeWGrpTab3, 127, BitOR($GUI_SS_DEFAULT_EDIT, $ES_READONLY, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Misc", "TxtClanGamesLog", "--------------------------------------------------------- Clan Games LOG ------------------------------------------------"))
EndFunc
Global $g_hGUI_DONATE = 0, $g_hGUI_DONATE_TAB = 0, $g_hGUI_DONATE_TAB_ITEM1 = 0, $g_hGUI_DONATE_TAB_ITEM2 = 0, $g_hGUI_DONATE_TAB_ITEM3 = 0
Global $g_hChkRequestTroopsEnable = 0, $g_hTxtRequestCC = 0, $g_ahChkRequestCCHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkRequestCCHoursE1 = 0, $g_hChkRequestCCHoursE2 = 0
Global $g_hGrpRequestCC = 0, $g_hLblRequestCCHoursAM = 0, $g_hLblRequestCCHoursPM = 0
Global $g_hLblRequestCChour = 0, $g_ahLblRequestCChoursE = 0
Global $g_hLblRequestCChours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLblRequestType, $g_hChkRequestType_Troops, $g_hChkRequestType_Spells, $g_hChkRequestType_Siege
Global $g_hTxtRequestCountCCTroop, $g_hTxtRequestCountCCSpell, $g_hChkClanCastleSpell = 0
Global $g_ahCmbClanCastleTroop[3], $g_ahImgClanCastleTroop[3], $g_ahTxtClanCastleTroop[3]
Global $g_ahCmbClanCastleSpell[3], $g_ahImgClanCastleSpell[3]
Global $g_ahCmbClanCastleSiege[2], $g_ahImgClanCastleSiege[2]
Global $g_hLblOnlyDuringHours = 0
Global $g_hChkRequestCCDefense = 0, $g_hTxtRequestCCDefense = 0, $g_hCmbRequestCCDefenseWhen = 0, $g_hTxtRequestCCDefenseTime = 0, $g_hLblRequestCCDefenseTime = 0
Global $g_hChkSaveCCTroopForDefense = 0, $g_ahCmbCCTroopDefense[3], $g_ahTxtCCTroopDefense[3]
Global $g_hChkExtraAlphabets = 0, $g_hChkExtraChinese = 0, $g_hChkExtraKorean = 0, $g_hChkExtraPersian = 0
Global $g_ahChkDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
Global $g_ahChkDonateAllTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
Global $g_ahTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
Global $g_ahTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
Global $g_ahGrpDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
Global $g_ahLblDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
Global $g_ahBtnDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeMachineCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
Global $g_ahChkDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0]
Global $g_ahChkDonateAllSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0]
Global $g_ahTxtDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0]
Global $g_ahTxtBlacklistSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0]
Global $g_ahGrpDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0]
Global $g_ahLblDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0]
Global $g_ahBtnDonateSpell[$eSpellCount] = [0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0]
Global $g_ahCmbDonateCustomA[3] = [0, 0, 0], $g_ahTxtDonateCustomA[3] = [0, 0, 0], $g_ahPicDonateCustomA[3] = [0, 0, 0]
Global $g_ahCmbDonateCustomB[3] = [0, 0, 0], $g_ahTxtDonateCustomB[3] = [0, 0, 0], $g_ahPicDonateCustomB[3] = [0, 0, 0]
Global $g_ahCmbDonateCustomC[3] = [0, 0, 0], $g_ahTxtDonateCustomC[3] = [0, 0, 0], $g_ahPicDonateCustomC[3] = [0, 0, 0]
Global $g_ahCmbDonateCustomD[3] = [0, 0, 0], $g_ahTxtDonateCustomD[3] = [0, 0, 0], $g_ahPicDonateCustomD[3] = [0, 0, 0]
Global $g_hLblDonateTroopTBD1 = 0, $g_hLblDonateTroopTBD2 = 0, $g_hLblDonateTroopTBD3 = 0, $g_hLblDonateTroopCustomC = 0, $g_hLblDonateTroopCustomD = 0, $g_hLblDonateTroopCustomF = 0, $g_hLblDonateTroopCustomG = 0, $g_hLblDonateTroopCustomH = 0, $g_hLblDonateTroopCustomI = 0, $g_hLblDonateTroopCustomJ = 0, $g_hLblDonateSpellTBD1 = 0
Global $g_hGrpDonateGeneralBlacklist = 0, $g_hTxtGeneralBlacklist = 0
Global $lblBtnCustomE = 0
Global $g_hGrpDonateOptions = 0, $g_hChkClanHop = 0
Global $g_hChkDonateHoursEnable = 0, $g_ahChkDonateHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hCmbFilterDonationsCC = 0, $g_hChkSkipDonateNearFullTroopsEnable = 0
Global $g_hLblDonateHours1 = 0, $g_hLblDonateHoursPM = 0
Global $g_hLblSkipDonateNearFullTroopsText = 0, $g_hTxtSkipDonateNearFullTroopsPercentage = 0, $g_hLblSkipDonateNearFullTroopsText1 = 0
Global $g_hGrpDonateCC = 0, $g_ahChkDonateHoursE1 = 0, $g_ahChkDonateHoursE2 = 0
Global $g_hGUI_RequestCC = 0, $g_hGUI_DONATECC = 0, $g_hGUI_ScheduleCC = 0
Global $g_hGrpDonate = 0, $g_hChkDonate = 1, $g_hLblDonateDisabled = 0, $g_hLblScheduleDisabled = 0
Global $g_hChkDonateQueueTroopOnly = 0, $g_hChkDonateQueueSpellOnly = 0
Global $g_hChkUseCCBalanced = 0, $g_hCmbCCDonated = 0, $g_hCmbCCReceived = 0
GLobal $g_hLblDonateCChour = 0, $g_ahLblDonateCChoursE = 0
GLobal $g_hLblDonateCChours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Func CreateVillageDonate()
$g_hGUI_DONATE = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
Local $x = 82
$g_hChkDonate = GUICtrlCreateCheckbox("", $x + 131, 6, 13, 13)
GUICtrlSetState(-1,$GUI_CHECKED)
GUICtrlSetOnEvent(-1, "Doncheck")
CreateRequestSubTab()
CreateDonateSubTab()
CreateScheduleSubTab()
GUISwitch($g_hGUI_DONATE)
$g_hGUI_DONATE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_DONATE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_01", "Request Troops"))
$g_hGUI_DONATE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_02", "Donate Troops") & "    ")
$g_hLblDonateDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_02_STab_02_STab_Info_01", "Note: Donate is disabled, tick the checkmark on the") & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_02", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 5, 30, $g_iSizeWGrpTab3, 374)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_DONATE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_03", "Schedule Donations"))
$g_hLblScheduleDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_02_STab_02_STab_Info_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02_STab_02", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 5, 30, $g_iSizeWGrpTab3, 374)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateTabItem("")
EndFunc
Func CreateRequestSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
$g_hGUI_RequestCC = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
Local $xStart = 20, $yStart = 20
Local $x = $xStart
Local $y = $yStart
$g_hGrpRequestCC = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "Group_01", "Clan Castle Troops"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
$y += 3
$x -= 6
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCCRequest, $x - 5, $y - 7, 48, 48, $BS_ICON)
$g_hChkRequestTroopsEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestTroopsEnable", "Request Troops / Spells"), $x + 70, $y - 6)
GUICtrlSetOnEvent(-1, "chkRequestCCHours")
$g_hTxtRequestCC = GUICtrlCreateInput(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "TxtRequestCC", "Anything please"), $x + 70, $y + 15, 214, 20, BitOR($ES_CENTER, $ES_AUTOHSCROLL))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "TxtRequestCC_Info_01", "This text is used on your request for troops in the Clan chat."))
$y += 20
$g_hLblRequestType = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "LblRequestType", "When lacking"), $x - 5, $y + 23)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "LblRequestType_Info_01", "Not send request when all the checked items are full."))
$g_hChkRequestType_Troops = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestType_Troops", "Troops"), $x + 70, $y + 20)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestType_Troops_Info_01", "Send request when CC Troop is not full."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkRequestCountCC")
$g_hChkRequestType_Spells = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestType_Spells", "Spells"), $x + 210, $y + 20)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestType_Spells_01", "Send request when CC Spell is not full."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkRequestCountCC")
$g_hChkRequestType_Siege = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestType_Siege", "Siege Machine"), $x + 320, $y + 20)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestType_Siege_Info_01", "Send request when CC Siege Machine is not received."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkRequestCountCC")
$y += 23
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "LblIfLessThan", "If less than"), $x - 5, $y + 23)
$g_hTxtRequestCountCCTroop = GUICtrlCreateInput("0", $x + 70, $y + 20, 25, 16, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "LblIfLessThan_Info_01", "Do not request when already received that many CC Troops. \r\nSet to either ""0"" or ""40+"" when full CC Troop wanted."))
If GUICtrlRead($g_hChkRequestType_Troops) = $GUI_CHECKED Then
GUICtrlSetState(-1, $GUI_ENABLE)
Else
GUICtrlSetState(-1, $GUI_DISABLE)
EndIf
$g_hTxtRequestCountCCSpell = GUICtrlCreateInput("0", $x + 210, $y + 20, 25, 16, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "LblIfLessThan_Info_02", "Do not request when already received that many CC Spells. \r\nSet to either ""0"" or ""2+"" when full CC Spell wanted"))
If GUICtrlRead($g_hChkRequestType_Spells) = $GUI_CHECKED Then
GUICtrlSetState(-1, $GUI_ENABLE)
Else
GUICtrlSetState(-1, $GUI_DISABLE)
EndIf
$y += 42
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "LblOnlyTake", "Only take"), $x - 5, $y + 3)
Local $sCmbTroopList = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtListOfTroops", _ArrayToString($g_asTroopNames) & "|Any")
For $i = 0 To 2
$g_ahTxtClanCastleTroop[$i] = GUICtrlCreateInput("0", $x + 70, $y + $i * 25, 25, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "Onlytake_Info_01", "Set the maximum quantity to stay. \r\nExcessive quantity shall be removed. \r\nSet to ""0"" or ""40+"" means unlimited."))
$g_ahCmbClanCastleTroop[$i] = GUICtrlCreateCombo("", $x + 100, $y + $i * 25, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sCmbTroopList, "Any")
GUICtrlSetOnEvent(-1, "CmbClanCastleTroop")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "Onlytake_Info_02", "Pick a troop type allowed to stay in your Clan Castle. \r\nTroops of other type shall be removed."))
$g_ahImgClanCastleTroop[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 174, $y + $i * 25, 20, 20)
Next
Local $sCmbSpellList = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtListOfSpells", _ArrayToString($g_asSpellNames) & "|Any")
For $i = 0 To 2
$g_ahCmbClanCastleSpell[$i] = GUICtrlCreateCombo("", $x + 210, $y + $i * 25, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sCmbSpellList, "Any")
GUICtrlSetOnEvent(-1, "CmbClanCastleSpell")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "Onlytake_Info_03", "Only keep this spell (1 unit) in Clan Castle. \r\nOther spells or excessive quantity shall be removed."))
$g_ahImgClanCastleSpell[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 284, $y + $i * 25, 20, 20)
Next
Local $sCmbSiegeList = GetTranslatedFileIni("MBR Global GUI Design Names Siege Machines", "TxtListOfSieges", _ArrayToString($g_asSiegeMachineNames) & "|Any")
For $i = 0 To 1
$g_ahCmbClanCastleSiege[$i] = GUICtrlCreateCombo("", $x + 320, $y + $i * 25, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sCmbSiegeList, "Any")
GUICtrlSetOnEvent(-1, "CmbClanCastleSiege")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "Onlytake_Info_04", "Only keep this siege machine in Clan Castle. \r\nSiege machine of other types shall be removed."))
$g_ahImgClanCastleSiege[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 394, $y + $i * 25, 20, 20)
Next
$y += 85
$g_hChkRequestCCDefense = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkRequestCCDefense", "Request Defense Troops"), $x + 70, $y - 6)
GUICtrlSetOnEvent(-1, "chkRequestCCDefense")
$g_hTxtRequestCCDefense = GUICtrlCreateInput(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "TxtRequestCCDefense", "Defense troop please"), $x + 70, $y + 15, 214, 20, BitOR($ES_CENTER, $ES_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "TxtRequestCCDefense_Info_01", "This text is used on your request for defensive troops in the Clan chat."))
$y += 40
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "LblRequestCCDefenseWhen", "When time"), $x - 5, $y + 4)
$g_hCmbRequestCCDefenseWhen = GUICtrlCreateCombo("", $x + 70, $y, 110, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "CmbRequestCCDefenseWhen", "Personal Break" & "|" & "Shield & Guard"), "Personal Break")
GUICtrlCreateLabel("<", $x + 185, $y + 4, 20, 15)
$g_hTxtRequestCCDefenseTime = GUICtrlCreateInput("30", $x + 197, $y, 25, 20, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 3)
GUICtrlSetBkColor(-1, $COLOR_MONEYGREEN)
$g_hLblRequestCCDefenseTime = GUICtrlCreateLabel("min", $x + 227, $y + 4, 17, 15)
$g_hChkSaveCCTroopForDefense = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkSaveCCTroopForDefense", "Save CC Troops for Defense"), $x + 70, $y + 25)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSaveCCTroopForDefense")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "ChkSaveCCTroopForDefense_Info_01", "Not Dropping CC Troops in attack to save for Defense"))
$y += 50
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "LblOnlyTake", -1), $x - 5, $y + 3)
For $i = 0 To 2
$g_ahTxtCCTroopDefense[$i] = GUICtrlCreateInput("0", $x + 70 + $i * 122, $y, 25, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "Onlytake_Info_01", -1))
$g_ahCmbCCTroopDefense[$i] = GUICtrlCreateCombo("", $x + 100 + $i * 122, $y, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sCmbTroopList, "Any")
GUICtrlSetOnEvent(-1, "cmbCCTroopDefense")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate-CC", "Onlytake_Info_02", -1))
Next
$x += 70
$y += 30
$g_hLblOnlyDuringHours = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", "Only during these hours of each day"), $x, $y, 300, 20, $BS_MULTILINE)
$y += 16
$g_hLblRequestCChour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", "Hour") & ":", $x, $y, -1, 15)
Local $sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblRequestCChours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[10] = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblRequestCChours[11] = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahLblRequestCChoursE = GUICtrlCreateLabel("X", $x + 213, $y, 11, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkRequestCCHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkRequestCCHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", "This button will clear or set the entire row of boxes"))
GUICtrlSetOnEvent(-1, "chkRequestCCHoursE1")
$g_hLblRequestCCHoursAM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", "AM"), $x + 5, $y + 2, 15, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkRequestCCHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkRequestCCHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkRequestCCHoursE2")
$g_hLblRequestCCHoursPM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", "PM"), $x + 5, $y + 2, 15, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateDonateSubTab()
Local $xStart = 25, $yStart = 45
$g_hGUI_DONATECC = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
Local $xStart = 20, $yStart = 20
Local $sTxtBlacklist1 = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklist1", "Blacklist")
Local $sDonateTxtCustomA = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "DonateTxtCustom", "Custom Troops")
Local $sDonateTxtCustomB = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "DonateTxtCustom", -1)
Local $sDonateTxtCustomC = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "DonateTxtCustom", -1)
Local $sDonateTxtCustomD = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "DonateTxtCustom", -1)
Local $sTxtNothing = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtNothing", "Nothing")
Local $sTxtDonate = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonate", "Donate")
Local $sTxtDonateTip = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTip", "Check this to donate")
Local $sTxtDonateAll = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateAll", "Donate to All")
Local $sTxtIgnoreAll = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtIgnoreAll", "This will also ignore ALL keywords.")
Local $sTxtKeywords = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtKeywords", "Keywords for donating")
Local $sTxtKeywordsNo = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtKeywordsNo", "Do NOT donate to these keywords")
Local $sTxtKeywordsNoTip = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtKeywordsNoTip", "Blacklist for donating")
Local $sTxtDonateTipTroop = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTipTroop", "if keywords match the Chat Request.")
Local $sTxtDonateTipAll = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTipAll", "to ALL Chat Requests.")
Local $sTxtDonateQueueTroop = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateQueueTroop", "Queued troop only")
Local $sTxtDonateQueueSpell = GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateQueueSpell", "Queued spell only")
Local $sTxtBarbarians = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians")
Local $sTxtArchers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers")
Local $sTxtGiants = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants")
Local $sTxtGoblins = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins")
Local $sTxtWallBreakers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers")
Local $sTxtBalloons = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons")
Local $sTxtWizards = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards")
Local $sTxtHealers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers")
Local $sTxtDragons = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons")
Local $sTxtPekkas = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas")
Local $sTxtMinions = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions")
Local $sTxtHogRiders = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders")
Local $sTxtValkyries = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries")
Local $sTxtGolems = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems")
Local $sTxtWitches = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches")
Local $SetLog = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds")
Local $sTxtBowlers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers")
Local $sTxtIceGolems = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtIceGolems", "Ice Golems")
Local $sTxtBabyDragons = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons")
Local $sTxtMiners = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners")
Local $sTxtElectroDragons = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtElectroDragons", "Electro Dragons")
Local $sTxtWallWreckers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallWreckers", "Wall Wreckers")
Local $sTxtBattleBlimps = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBattleBlimps", "Battle Blimps")
Local $sTxtStoneSlammers = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtStoneSlammers", "Stone Slammers")
Local $sTxtLightningSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortLightningSpells", "Lightning")
Local $sTxtHealSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHealSpells", "Heal")
Local $sTxtRageSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortRageSpells", "Rage")
Local $sTxtJumpSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortJumpSpells", "Jump")
Local $sTxtFreezeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortFreezeSpells", "Freeze")
Local $sTxtPoisonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortPoisonSpells", "Poison")
Local $sTxtEarthquakeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortEarthquakeSpells", "EarthQuake")
Local $sTxtHasteSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHasteSpells", "Haste")
Local $sTxtSkeletonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortSkeletonSpells", "Skeleton")
Local $sTxtBatSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortBatSpells", "Bat")
Local $x = $xStart
Local $y = $yStart
Local $Offx = 38
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "Group_01", "Donate Troops Selection Menu"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 185)
$x = $xStart - 18
$g_ahLblDonateTroop[$eTroopBarbarian] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBarbarian] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBarbarian, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopArcher] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopArcher] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnArcher, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGiant] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGiant] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGiant, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGoblin] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGoblin] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoblin, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopWallBreaker] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWallBreaker] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWallBreaker, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBalloon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBalloon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBalloon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$x += 4
$g_ahLblDonateTroop[$eTroopElectroDragon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopElectroDragon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnElectroDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopMinion] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopMinion] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnMinion, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopHogRider] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopHogRider] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHogRider, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopValkyrie] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopValkyrie] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnValkyrie, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGolem] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGolem] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGolem, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x = $xStart - 18
$y += 40
$g_ahLblDonateTroop[$eTroopWizard] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWizard] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWizard, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopHealer] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopHealer] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHealer, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopDragon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopDragon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopPekka] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopPekka] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnPekka, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBabyDragon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBabyDragon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBabyDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopMiner] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopMiner] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnMiner, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$x += 4
$g_ahLblDonateTroop[$eTroopWitch] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWitch] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWitch, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopLavaHound] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopLavaHound] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLavaHound, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBowler] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBowler] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBowler, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopIceGolem] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopIceGolem] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnIceGolem, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$lblBtnCustomE = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = $xStart - 18
$y += 40
$g_ahLblDonateSpell[$eSpellLightning] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellLightning] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLightSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellHeal] = GUICtrlCreateLabel("", $x , $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellHeal] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHealSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellRage] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellRage] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnRageSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellJump] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellJump] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnJumpSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellFreeze] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellFreeze] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnFreezeSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$lblBtnCustomE = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 4
$x += $Offx
$g_ahLblDonateSpell[$eSpellPoison] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellPoison] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnPoisonSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellEarthquake] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellEarthquake] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnEarthQuakeSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellHaste] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellHaste] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHasteSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellSkeleton] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellSkeleton] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnSkeletonSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellBat] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellBat] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBatSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x = $xStart - 18
$y += 40
$g_ahLblDonateTroop[$eCustomA] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomA] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustom, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eCustomB] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomB] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustomB, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eCustomC] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomC] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustom, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eCustomD] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomD] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustomB, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_hLblDonateTroopCustomH = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomF = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 4
$x += $Offx
$g_ahLblDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWallW, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBattleB, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnStoneS, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_hLblDonateTroopCustomD = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnClanHop, 1)
GUICtrlSetOnEvent(-1, "btnDonateOptions")
$x += $Offx
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonBlacklist, 1)
GUICtrlSetOnEvent(-1, "btnDonateBlacklist")
Local $Offy = $yStart + 185
$x = $xStart
$y = $yStart + 185
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblExtraAlphabets", "Extra Alphabet Recognitions:"), $x - 15, $y + 153, -1, -1)
$g_hChkExtraAlphabets = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraAlphabets", "Cyrillic"), $x + 127 , $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraAlphabets_Info_01", "Check this to enable the Cyrillic Alphabet."))
$g_hChkExtraChinese = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraChinese", "Chinese"), $x + 191, $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraChinese_Info_01", "Check this to enable the Chinese Alphabet."))
$g_hChkExtraKorean = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraKorean", "Korean"), $x + 265, $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraKorean_Info_01", "Check this to enable the Korean Alphabet."))
$g_hChkExtraPersian = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraPersian", "Persian"), $x + 340, $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkExtraPersian_Info_01", "Check this to enable the Persian Alphabet."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_hChkDonateQueueTroopOnly = GUICtrlCreateCheckbox($sTxtDonateQueueTroop, $x + 275, $y + 36, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateQueueTroopTip", "Only donate troops which are ready in 2nd army,\r\nor troops which are training in first slot of 2nd army"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkDonateQueueSpellOnly = GUICtrlCreateCheckbox($sTxtDonateQueueSpell, $x + 275, $y + 36, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateQueueSpellTip", "Only donate spells which are ready in 2nd army,\r\nor spells which are training in first slot of 2nd army"))
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahGrpDonateTroop[$eTroopBarbarian] = GUICtrlCreateGroup($sTxtBarbarians, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBarbarian, $x + 215, $y, 64, 64, $BS_ICON)
$g_ahChkDonateTroop[$eTroopBarbarian] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBarbarians, $x + 285, $y, -1, -1)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBarbarians & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBarbarian] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBarbarians & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBarbarians & ":", $x - 5, $y + 5, -1, -1)
$g_ahTxtDonateTroop[$eTroopBarbarian] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_01", "barbarians\r\nbarb")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBarbarians)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
$g_ahTxtBlacklistTroop[$eTroopBarbarian] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_01", "no barbarians\r\nno barb\r\nbarbarians no\r\nbarb no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBarbarians)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopArcher] = GUICtrlCreateGroup($sTxtArchers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonArcher, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopArcher] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtArchers, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtArchers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopArcher] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtArchers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtArchers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopArcher] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_02", "archers\r\narch")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtArchers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopArcher] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_02", "no archers\r\nno arch\r\narchers no\r\narch no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtArchers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGiant] = GUICtrlCreateGroup($sTxtGiants, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGiant, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGiant] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGiants, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGiants & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGiant] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGiants & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGiants & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGiant] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_03", "giants\r\ngiant\r\nany\r\nreinforcement")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGiants)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGiant] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_03", "no giants\r\ngiants no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGiants)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGoblin] = GUICtrlCreateGroup($sTxtGoblins, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGoblin, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGoblin] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGoblins, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGoblins & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGoblin] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGoblins & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGoblins & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGoblin] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_04", "goblins\r\ngoblin")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGoblins)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGoblin] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_04", "no goblins\r\ngoblins no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGoblins)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWallBreaker] = GUICtrlCreateGroup($sTxtWallBreakers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWallBreaker, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWallBreaker] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWallBreakers, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallBreakers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWallBreaker] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallBreakers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWallBreakers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWallBreaker] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_05", "wall breakers\r\nbreaker")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWallBreakers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWallBreaker] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_05", "no wall breakers\r\nwall breakers no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWallBreakers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBalloon] = GUICtrlCreateGroup($sTxtBalloons, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBalloon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBalloon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBalloons, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBalloons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBalloon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBalloons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBalloons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBalloon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_06", "balloons\r\nballoon")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBalloons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBalloon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_06", "no balloon\r\nballoons no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBalloons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWizard] = GUICtrlCreateGroup($sTxtWizards, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWizard, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWizard] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWizards, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWizards & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWizard] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWizards & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWizards & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWizard] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_07", "wizards\r\nwizard\r\nwiz")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWizards)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWizard] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_07", "no wizards\r\nwizards no\r\nno wizard\r\nwizard no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWizards)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopHealer] = GUICtrlCreateGroup($sTxtHealers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHealer, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopHealer] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHealers, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopHealer] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHealers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopHealer] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_08", "healer")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHealers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopHealer] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_08", "no healer\r\nhealer no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHealers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopDragon] = GUICtrlCreateGroup($sTxtDragons, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopDragon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtDragons, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopDragon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtDragons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopDragon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_09", "dragon")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtDragons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopDragon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_09", "no dragon\r\ndragon no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopPekka] = GUICtrlCreateGroup($sTxtPekkas, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonPekka, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopPekka] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtPekkas, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPekkas & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopPekka] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPekkas & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtPekkas & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopPekka] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_10", "PEKKA\r\npekka")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtPekkas)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopPekka] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_10", "no PEKKA\r\npekka no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtPekkas)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBabyDragon] = GUICtrlCreateGroup($sTxtBabyDragons, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBabyDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBabyDragon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBabyDragons, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBabyDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBabyDragon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBabyDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBabyDragons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBabyDragon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_11", "baby dragon\r\nbaby")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBabyDragons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBabyDragon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_11", "no baby dragon\r\nbaby dragon no\r\nno baby\r\nbaby no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBabyDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopMiner] = GUICtrlCreateGroup($sTxtMiners, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMiner, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopMiner] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtMiners, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMiners & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopMiner] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMiners & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtMiners & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopMiner] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_12", "miner|mine")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtMiners)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopMiner] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_12", "no miner\r\nminer no\r\nno mine\r\nmine no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtMiners)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellLightning] = GUICtrlCreateGroup($sTxtLightningSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellLightning] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtLightningSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLightningSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellLightning] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLightningSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtLightningSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellLightning] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_13", "lightning")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtLightningSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellLightning] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_13", "no lightning\r\nlightning no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtLightningSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellHeal] = GUICtrlCreateGroup($sTxtHealSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellHeal] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHealSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellHeal] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHealSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellHeal] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_14", "heal")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHealSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellHeal] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_14", "no heal\r\nheal no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHealSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellRage] = GUICtrlCreateGroup($sTxtRageSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellRage] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtRageSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtRageSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellRage] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtRageSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtRageSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellRage] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_15", "rage")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtRageSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellRage] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_15", "no rage\r\nrage no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtRageSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellJump] = GUICtrlCreateGroup($sTxtJumpSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellJump] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtJumpSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtJumpSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellJump] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtJumpSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtJumpSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellJump] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_16", "jump")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtJumpSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellJump] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_16", "no jump\r\njump no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtJumpSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellFreeze] = GUICtrlCreateGroup($sTxtFreezeSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellFreeze] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtFreezeSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtFreezeSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellFreeze] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtFreezeSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtFreezeSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellFreeze] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_17", "freeze")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtFreezeSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellFreeze] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_17", "no freeze\r\nfreeze no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtFreezeSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopElectroDragon] = GUICtrlCreateGroup($sTxtElectroDragons, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElectroDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopElectroDragon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtElectroDragons, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtElectroDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopElectroDragon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtElectroDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtElectroDragons & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopElectroDragon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_31", "electro dragon\r\nelectrodrag\r\nedrag")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtElectroDragons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopElectroDragon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_31", "no electro dragon\r\nelectrodrag no\r\nedrag no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtElectroDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopMinion] = GUICtrlCreateGroup($sTxtMinions, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMinion, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopMinion] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtMinions, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMinions & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopMinion] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMinions & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtMinions & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopMinion] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_18", "minions\r\nminion")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtMinions)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopMinion] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_18", "no minions\r\nminions no\r\nno minion\r\nminion no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtMinions)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopHogRider] = GUICtrlCreateGroup($sTxtHogRiders, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHogRider, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopHogRider] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHogRiders, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHogRiders & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopHogRider] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHogRiders & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHogRiders & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopHogRider] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_19", "hogriders\r\nhogs\r\nhog")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHogRiders)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopHogRider] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_19", "no hogs\r\nhog no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHogRiders)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopValkyrie] = GUICtrlCreateGroup($sTxtValkyries, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonValkyrie, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopValkyrie] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtValkyries, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtValkyries & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopValkyrie] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtValkyries & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtValkyries & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopValkyrie] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_20", "valkyries\r\nvalkyrie\r\nvalk")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtValkyries)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopValkyrie] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_20", "no valkyries\r\nvalkyries no\r\nno valk\r\nvalk no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtValkyries)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGolem] = GUICtrlCreateGroup($sTxtGolems, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGolem, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGolem] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGolems, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGolems & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGolem] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGolems & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGolems & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGolem] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_21", "golem")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGolems)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGolem] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_21", "no golem\r\ngolem no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGolems)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWitch] = GUICtrlCreateGroup($sTxtWitches, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWitch, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWitch] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWitches, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWitches & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWitch] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWitches & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWitches & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWitch] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_22", "witches\r\nwitch")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWitches)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWitch] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_22", "no witches\r\nwitch no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWitches)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopLavaHound] = GUICtrlCreateGroup($SetLog, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonLavaHound, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopLavaHound] = GUICtrlCreateCheckbox($sTxtDonate & " " & $SetLog, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $SetLog & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopLavaHound] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $SetLog & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $SetLog & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopLavaHound] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_23", "lavahound\r\nlava\r\nhound")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $SetLog)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopLavaHound] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_23", "no lavahound\r\nlava no\r\nhound no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $SetLog)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBowler] = GUICtrlCreateGroup($sTxtBowlers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBowler, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBowler] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBowlers, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBowlers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBowler] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBowlers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBowlers & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBowler] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_24", "bowler\r\nbowlers\r\nbowl")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBowlers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBowler] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_24", "no bowler\r\nbowl no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBowlers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopIceGolem] = GUICtrlCreateGroup($sTxtIceGolems, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnIceGolem, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopIceGolem] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtIceGolems, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtIceGolems & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopIceGolem] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtIceGolems & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtIceGolems & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopIceGolem] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_35", "ice golem\r\nice golems")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtIceGolems)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopIceGolem] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_36", "no ice golem\r\nice golem no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtIceGolems)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = GUICtrlCreateGroup($sTxtWallWreckers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallW, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWallWreckers, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallWreckers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallWreckers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWallWreckers & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_32", "wall wreckers\r\nsieges\r\nwreckers")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWallWreckers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_32", "no wreckers\r\nsiege no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWallWreckers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = GUICtrlCreateGroup($sTxtBattleBlimps, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBattleB, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBattleBlimps, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBattleBlimps & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBattleBlimps & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBattleBlimps & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_33", "battle blimps\r\nsieges\r\nblimps")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBattleBlimps)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_33", "no blimps\r\nsiege no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBattleBlimps)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = GUICtrlCreateGroup($sTxtStoneSlammers, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnStoneS, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtStoneSlammers, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtStoneSlammers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtStoneSlammers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtStoneSlammers & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_32", "stone slammers\r\nsieges\r\nslammers")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtStoneSlammers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_35", "no slammers\r\nsiege no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtStoneSlammers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellPoison] = GUICtrlCreateGroup($sTxtPoisonSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonPoisonSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellPoison] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtPoisonSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPoisonSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellPoison] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPoisonSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtPoisonSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellPoison] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_25", "poison")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtPoisonSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellPoison] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_25", "no poison\r\npoison no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtPoisonSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellEarthquake] = GUICtrlCreateGroup($sTxtEarthQuakeSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonEarthQuakeSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellEarthquake] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtEarthQuakeSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtEarthQuakeSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellEarthquake] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtEarthQuakeSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtEarthQuakeSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellEarthquake] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_26", "earthquake\r\nquake")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtEarthQuakeSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellEarthquake] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_26", "no earthquake\r\nquake no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtEarthQuakeSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellHaste] = GUICtrlCreateGroup($sTxtHasteSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHasteSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellHaste] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHasteSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHasteSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellHaste] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHasteSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHasteSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellHaste] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_27", "haste")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHasteSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellHaste] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_27", "no haste\r\nhaste no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHasteSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellSkeleton] = GUICtrlCreateGroup($sTxtSkeletonSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonSkeletonSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellSkeleton] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtSkeletonSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtSkeletonSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellSkeleton] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtSkeletonSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtSkeletonSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellSkeleton] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_28", "skeleton|skel")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtSkeletonSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellSkeleton] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_28", "no skeleton\r\nskeleton no\r\nno skel")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtSkeletonSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellBat] = GUICtrlCreateGroup($sTxtBatSpells, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBatSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellBat] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBatSpells, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBatSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellBat] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBatSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBatSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellBat] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_34", "Bat")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBatSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellBat] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_34", "no bat\r\nbat no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBatSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomA] = GUICtrlCreateGroup($sDonateTxtCustomA, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustom, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomA] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomA, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomA & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomA] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomA & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomA & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomA] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_29", "ground support\r\nground")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomA)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_01", "1st") & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWizard, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtWizards)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[0] = GUICtrlCreateInput("2", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_02", "2nd") & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonArcher, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtArchers)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_03", "3rd") & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBarbarian, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtBarbarians)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[2] = GUICtrlCreateInput("1", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomA] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_29", "no ground\r\nground no\r\nonly")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomA)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomB] = GUICtrlCreateGroup($sDonateTxtCustomB, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustomB, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomB] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomB, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomB & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomB] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomB & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomB & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomB] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_30", "air support\r\nany air")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomB)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_01", -1) & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBabyDragon, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtBabyDragons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[0] = GUICtrlCreateInput("1", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_02", -1) & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBalloon, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtBalloons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_03", -1) & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMinion, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtMinions)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[2] = GUICtrlCreateInput("5", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomB] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_30", "no air\r\nair no\r\nonly\r\njust")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomB)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomC] = GUICtrlCreateGroup($sDonateTxtCustomC, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustom, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomC] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomC, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomC & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomC] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomC & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomC & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomC] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_29", -1)))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomC)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_01", -1) & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomC[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWizard, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomC[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtWizards)
GUICtrlSetOnEvent(-1, "cmbDonateCustomC")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomC[0] = GUICtrlCreateInput("1", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_02", -1) & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomC[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonArcher, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomC[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtArchers)
GUICtrlSetOnEvent(-1, "cmbDonateCustomC")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomC[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_03", -1) & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomC[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBarbarian, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomC[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtBarbarians)
GUICtrlSetOnEvent(-1, "cmbDonateCustomC")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomC[2] = GUICtrlCreateInput("5", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomC] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_29", -1)))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomC)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomD] = GUICtrlCreateGroup($sDonateTxtCustomD, $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustomB, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomD] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomD, $x + 285, $y, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomD & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomD] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 20, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomD & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomD & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomD] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtDonateTroop_Item_30", -1)))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomD)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_01", -1) & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomD[0] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBabyDragon, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomD[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtBabyDragons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomD")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomD[0] = GUICtrlCreateInput("1", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_02", -1) & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomD[1] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBalloon, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomD[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtBalloons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomD")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomD[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblDonateCustom_03", -1) & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomD[2] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMinion, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomD[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtElectroDragons & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $SetLog & "|" & $sTxtBowlers & "|" & $sTxtIceGolems & "|" & $sTxtNothing, $sTxtMinions)
GUICtrlSetOnEvent(-1, "cmbDonateCustomD")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomD[2] = GUICtrlCreateInput("5", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomD] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtBlacklistTroop_Item_30", -1)))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomD)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_hGrpDonateGeneralBlacklist = GUICtrlCreateGroup( GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "Group_02", "General Blacklist"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBlacklist, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "LblGeneralBlacklist", "Do NOT donate to any of these keywords") & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hTxtGeneralBlacklist = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtGeneralBlacklist_Item_01", "clan war\r\nwar\r\ncw")))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "TxtGeneralBlacklist_Info_01", "General Blacklist for donation requests"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_hGrpDonateOptions = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "GrpDonateOptions", "Donate Options"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$g_hChkClanHop = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate", "ChkClanHop", "Clan Hop"), $x, $y, -1, -1)
GUICtrlSetState(-1,$GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateScheduleSubTab()
Local $xStart = 25, $yStart = 45
$g_hGUI_ScheduleCC = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
Local $xStart = 20, $yStart = 20
Local $x = $xStart
Local $y = $yStart
$g_hGrpDonateCC = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_01", "Donate Schedule"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 120)
$y += 10
$x += 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCCDonate, $x - 5, $y, 64, 60, $BS_ICON)
$g_hChkDonateHoursEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1), $x + 40 + 30, $y - 6)
GUICtrlSetOnEvent(-1, "chkDonateHours")
$y += 20
$x += 90
$g_hLblDonateCChour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", -1) & ":", $x, $y, -1, 15)
Local $sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDonateCChours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[10] = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDonateCChours[11] = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahLblDonateCChoursE = GUICtrlCreateLabel("X", $x + 213, $y + 2, 11, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkDonateHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkDonateHoursE1")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", -1), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkDonateHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkDonateHoursE2")
$g_hLblDonateHoursPM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", -1), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 16
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $yStart + 130
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_02", "Donation Clan Mates Filter"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 155)
$y += 10
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblOption_donate_members", "Using this option you can choose to donate to all members of your team (No Filter), donate only to certain friends (White List) or give everyone except a few members of your team (Black List)"), $x , $y - 10, 380, 40, $BS_MULTILINE)
$y += 35
$g_hCmbFilterDonationsCC = GUICtrlCreateCombo("", $x, $y, 300, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_01", "No Filter, donate at all Clan Mates") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_02", "No Filter but collect Clan Mates Images") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_03", "Donate only at Clan Mates in White List") & "|" & GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_04", "Donate at all Except at Clan Mates in Black List"), GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbFilterDonationsCC_Item_01", -1))
GUICtrlSetOnEvent(-1, "cmbABAlgorithm")
$y += 35
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblImages_of_Clan_Mates", "Images of Clan Mates are captured and stored in main folder, move to appropriate folder (White or Black List)"), $x , $y - 10, 380, 30, $BS_MULTILINE)
$y += 20
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "BtnOpen_Images_of_Clan_Mates", "Open Clan Mates Image Folder"), $x + 2, $y, 300, 20,-1)
GUICtrlSetOnEvent(-1, "btnFilterDonationsCC")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 60
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_03", "Skip donation near full troops"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 45)
$g_hChkSkipDonateNearFullTroopsEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "ChkSkipDonateNearFullTroopsEnable", "Skip donation near full troops"), $x, $y - 4)
GUICtrlSetState(-1, $GUI_UNCHECKED )
GUICtrlSetOnEvent(-1, "chkskipDonateNearFulLTroopsEnable")
$x += 180
$g_hLblSkipDonateNearFullTroopsText = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblSkipDonateNearFullTroopsText", "if troops army camps are greater than"), $x, $y)
$x += 110
$g_hTxtSkipDonateNearFullTroopsPercentage = GUICtrlCreateInput("90", $x + 40 + 30, $y - 2, 20, 20, BitOR($SS_CENTER, $ES_AUTOHSCROLL))
GUICtrlSetLimit(-1, 2)
$x += 95
$g_hLblSkipDonateNearFullTroopsText1 = GUICtrlCreateLabel("%", $x, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y += 25
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_04", "Balance Donate/Receive"), $x - 20, $y, $g_iSizeWGrpTab3, 40)
$y += 12
$g_hChkUseCCBalanced = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "Group_04", -1), $x, $y+2, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "ChkUseCCBalanced_Info_01", "Disable Clan Castle Usage or Donations if Ratio is not correct. Will Auto Continue when the Ratio is correct again"))
GUICtrlSetOnEvent(-1, "chkBalanceDR")
$x += 290
$g_hCmbCCDonated = GUICtrlCreateCombo("", $x + 40, $y, 30, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbCCDonated_Info_01", "Donated ratio"))
GUICtrlSetData(-1, "1|2|3|4|5", "1")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbBalanceDR")
GUICtrlCreateLabel("/", $x + 73, $y + 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblCCDonated-Received_Info_01", "Wanted donated / received ratio") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "LblCCDonated-Received_Info_02", "1/1 means donated = received, 1/2 means donated = half the received etc."))
$g_hCmbCCReceived = GUICtrlCreateCombo("", $x + 80, $y, 30, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Donate_Schedule", "CmbCCReceived_Info_01", "Received ratio"))
GUICtrlSetData(-1, "1|2|3|4|5", "1")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbBalanceDR")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_UPGRADE = 0, $g_hGUI_UPGRADE_TAB = 0, $g_hGUI_UPGRADE_TAB_ITEM1 = 0, $g_hGUI_UPGRADE_TAB_ITEM2 = 0, $g_hGUI_UPGRADE_TAB_ITEM3 = 0, $g_hGUI_UPGRADE_TAB_ITEM4 = 0, $g_hGUI_UPGRADE_TAB_ITEM5 = 0
Global $g_hChkAutoLabUpgrades = 0, $g_hCmbLaboratory = 0, $g_hLblNextUpgrade = 0, $g_hBtnResetLabUpgradeTime = 0, $g_hPicLabUpgrade = 0
Global $g_hChkAutoStarLabUpgrades = 0, $g_hCmbStarLaboratory = 0, $g_hLblNextSLUpgrade = 0, $g_hBtnResetStarLabUpgradeTime = 0, $g_hPicStarLabUpgrade = 0
Global $g_hChkUpgradeKing = 0, $g_hChkUpgradeQueen = 0, $g_hChkUpgradeWarden = 0, $g_hPicChkKingSleepWait = 0, $g_hPicChkQueenSleepWait = 0, $g_hPicChkWardenSleepWait = 0
Global $g_hCmbHeroReservedBuilder = 0, $g_hLblHeroReservedBuilderTop = 0, $g_hLblHeroReservedBuilderBottom = 0
Global $g_hChkUpgrade[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hPicUpgradeStatus[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeName[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeLevel[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hPicUpgradeType[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeValue[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeTime[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgradeEndTime[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkUpgradeRepeat[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hTxtUpgrMinGold = 0, $g_hTxtUpgrMinElixir = 0, $g_hTxtUpgrMinDark = 0
Global $g_hChkWalls = 0, $g_hTxtWallMinGold = 0, $g_hTxtWallMinElixir = 0, $g_hRdoUseGold = 0, $g_hRdoUseElixir = 0, $g_hRdoUseElixirGold = 0, $g_hChkSaveWallBldr = 0, $g_hCmbWalls = 4
Global $g_hLblWallCost = 0, $g_hBtnFindWalls = 0
Global $g_ahWallsCurrentCount[14] = [-1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahPicWallsLevel[14] = [-1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkAutoUpgrade = 0, $g_hLblAutoUpgrade = 0, $g_hTxtAutoUpgradeLog = 0
Global $g_hTxtSmartMinGold = 0, $g_hTxtSmartMinElixir = 0, $g_hTxtSmartMinDark = 0
Global $g_hChkResourcesToIgnore[3] = [0, 0, 0]
Global $g_hChkUpgradesToIgnore[14] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Func CreateVillageUpgrade()
InitTranslatedTextUpgradeTab()
$g_hGUI_UPGRADE = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
GUISwitch($g_hGUI_UPGRADE)
$g_hGUI_UPGRADE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_UPGRADE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_01", "Laboratory"))
CreateLaboratorySubTab()
$g_hGUI_UPGRADE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_02", "Heroes"))
CreateHeroesSubTab()
$g_hGUI_UPGRADE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_03", "Buildings"))
CreateBuildingsSubTab()
$g_hGUI_UPGRADE_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_05", "Auto Upgrade"))
CreateAutoUpgradeSubTab()
$g_hGUI_UPGRADE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03_STab_04", "Walls"))
CreateWallsSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreateLaboratorySubTab()
Local $sTxtNames = GetTranslatedFileIni("MBR Global GUI Design", "Any", "Any") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtEDragon", "Electro Dragon") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtLightningSpells", "Lightning Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHealingSpells", "Healing Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtRageSpells", "Rage Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtJumpSpells", "Jump Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtFreezeSpells", "Freeze Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtCloneSpells", "Clone Spell")& "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtPoisonSpells", "Poison Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtEarthQuakeSpells", "EarthQuake Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHasteSpells", "Haste Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtSkeletonSpells", "Skeleton Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtBatSpells", "Bat Spell") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtIceGolems", "Ice Golems") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallWreckers", "Wall Wreckers") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBattleBlimps", "Battle Blimps") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtStoneSlammers", "Stone Slammers")
Local $sTxtSLNames = GetTranslatedFileIni("MBR Global GUI Design", "Any", "Any") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtRagedBarbarian", "Raged Barbarian") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtSneakyArcher", "Sneaky Archer") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtBoxerGiant", "Boxer Giant") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtBetaMinion", "Beta Minion") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtBomber", "Bomber") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtBabyDragon", "Baby Dragon") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtCannonCart", "Cannon Cart") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtNightWitch", "Night Witch") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtDropShip", "Drop Ship") & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Builderbase Troops", "TxtSuperPekka", "Super Pekka")
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "Group_01", "Laboratory"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 100)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLaboratory, $x, $y, 64, 64)
$g_hChkAutoLabUpgrades = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "ChkAutoLabUpgrades", "Auto Laboratory Upgrades"), $x + 80, $y + 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "ChkAutoLabUpgrades_Info_01", "Check box to enable automatically starting Upgrades in laboratory"))
GUICtrlSetOnEvent(-1, "chkLab")
$g_hLblNextUpgrade = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "LblNextUpgrade", "Next one") & ":", $x + 80, $y + 38, 50, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbLaboratory = GUICtrlCreateCombo("", $x + 135, $y + 35, 140, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
GUICtrlSetData(-1, $sTxtNames, GetTranslatedFileIni("MBR Global GUI Design", "Any", "Any"))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "CmbLaboratory_Info_01", "Select the troop type to upgrade with this pull down menu") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "CmbLaboratory_Info_02", "The troop icon will appear on the right.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "CmbLaboratory_Info_03", "Any Dark Spell/Troop have priority over Upg Heroes!"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbLab")
$g_hBtnResetLabUpgradeTime = GUICtrlCreateButton("", $x + 120 + 172, $y + 36, 18, 18, BitOR($BS_PUSHLIKE,$BS_DEFPUSHBUTTON))
GUICtrlSetBkColor(-1, $COLOR_ERROR)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_01", "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_02", "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_03", "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_04", "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_05", "Caution - Unnecessary timer reset will force constant checks for lab status"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetOnEvent(-1, "ResetLabUpgradeTime")
$g_hPicLabUpgrade = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlank, $x + 330, $y, 64, 64)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 110
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "Group_02", "Star Laboratory"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 100)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnStarLaboratory, $x, $y, 64, 64)
$g_hChkAutoStarLabUpgrades = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "ChkAutoStarLabUpgrades", "Auto Star Laboratory Upgrades"), $x + 80, $y + 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "ChkAutoStarLabUpgrades_Info_01", "Check box to enable automatically starting Upgrades in star laboratory"))
GUICtrlSetOnEvent(-1, "chkStarLab")
$g_hLblNextSLUpgrade = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "LblNextUpgrade", "Next one") & ":", $x + 80, $y + 38, 50, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbStarLaboratory = GUICtrlCreateCombo("", $x + 135, $y + 35, 140, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
GUICtrlSetData(-1, $sTxtSLNames, GetTranslatedFileIni("MBR Global GUI Design", "Any", "Any"))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "CmbLaboratory_Info_01", "Select the troop type to upgrade with this pull down menu") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "CmbLaboratory_Info_02", "The troop icon will appear on the right."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbStarLab")
$g_hBtnResetStarLabUpgradeTime = GUICtrlCreateButton("", $x + 120 + 172, $y + 36, 18, 18, BitOR($BS_PUSHLIKE,$BS_DEFPUSHBUTTON))
GUICtrlSetBkColor(-1, $COLOR_ERROR)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_01", "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_02", "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_03", "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_04", "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Laboratory", "BtnResetLabUpgradeTime_Info_05", "Caution - Unnecessary timer reset will force constant checks for lab status"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetOnEvent(-1, "ResetStarLabUpgradeTime")
$g_hPicStarLabUpgrade = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlank, $x + 330, $y, 64, 64)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateHeroesSubTab()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "Group_01", "Upgrade Heroes Continuously"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "LblAutoUpgrading_01", "Auto upgrading of your Heroes"), $x - 10, $y, -1, -1)
$y += 20
$g_hChkUpgradeKing = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeKing_Info_01", "Enable upgrading of your King when you have enough Dark Elixir (Saving Min. Dark Elixir)") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeKing_Info_02", "You can manually locate your Kings Altar on Misc Tab") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeHeroes_Info_01", "Verify your Resume Bot Dark Elixir value at Misc Tab vs Saving Min. Dark Elixir here!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeKing_Info_04", "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeKing")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkKingSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$g_hChkUpgradeQueen = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeQueen_Info_01", "Enable upgrading of your Queen when you have enough Dark Elixir (Saving Min. Dark Elixir)") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeQueen_Info_02", "You can manually locate your Queens Altar on Misc Tab") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeHeroes_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeQueen_Info_03", "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeQueen")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkQueenSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$g_hChkUpgradeWarden = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeWarden_Info_01", "Enable upgrading of your Warden when you have enough Elixir (Saving Min. Elixir)") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeWarden_Info_02", "You can manually locate your Wardens Altar on Misc Tab") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeHeroes_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "ChkUpgradeWarden_Info_03", "Enabled with TownHall 11")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeWarden")
GUICtrlSetColor(-1, $COLOR_ERROR )
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkWardenSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$g_hLblHeroReservedBuilderTop = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "LblHeroReservedBuilderTop", "Reserve ") , $x, $y + 15, -1, -1)
$g_hCmbHeroReservedBuilder = GUICtrlCreateCombo("", $x + 50, $y + 11, 30, 21, $CBS_DROPDOWNLIST, $WS_EX_RIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "CmbHeroReservedBuilder", "At least this many builders have to upgrade heroes, or wait for it."))
GUICtrlSetData(-1, "|0|1|2|3", "0")
GUICtrlSetOnEvent(-1, "cmbHeroReservedBuilder")
$g_hLblHeroReservedBuilderBottom = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Heroes", "LblHeroReservedBuilderBottom", "builder/s for hero upgrade"), $x, $y + 35, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateBuildingsSubTab()
Local $sTxtShowType = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowType", "This shows type of upgrade, click to show location")
Local $sTxtStatus = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtStatus", "Status: Red=not programmed, Yellow=programmed, not completed, Green=Completed")
Local $sTxtShowName = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowName", "This box is updated with unit name after upgrades are checked")
Local $sTxtShowLevel = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowLevel", "This unit box is updated with unit level after upgrades are checked")
Local $sTxtShowCost = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowCost", "This upgrade cost box is updated after upgrades are checked")
Local $sTxtShowTime = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowTime", "This box is updated with time length of upgrade after upgrades are checked")
Local $sTxtChkRepeat = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtChkRepeat", "Check box to Enable Upgrade to repeat continuously")
Local $sTxtShowEndTime = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtShowEndTime", "This box is updated with estimate end time of upgrade after upgrades are checked")
Local $sTxtCheckBox = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtCheckBox", "Check box to Enable Upgrade")
Local $sTxtAfterUsing = GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtAfterUsing", "after using Locate Upgrades button")
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Group_01", "Buildings or Heroes"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 30 +($g_iUpgradeSlots * 22))
$x -= 7
$y -= 7
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_01", "Unit Name"), $x + 71, $y, 70, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_02", "Lvl"), $x + 153, $y, 40, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_03", "Type"), $x + 173, $y, 50, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_04", "Cost"), $x + 219, $y, 50, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_05", "Time"), $x + 270, $y, 50, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_06", "Rep."), $x + 392, $y, 50, 18)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "Table header_07", "Estimate End"), $x + 314, $y, 70, 18)
$y += 13
For $i = 0 To $g_iUpgradeSlots - 1
$g_hPicUpgradeStatus[$i]= _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTroops, $x - 10, $y + 1, 14, 14)
_GUICtrlSetTip(-1, $sTxtStatus)
$g_hChkUpgrade[$i] = GUICtrlCreateCheckbox($i + 1 & ":", $x + 5, $y + 1, 34, 15)
_GUICtrlSetTip(-1, $sTxtCheckBox & " #" & $i + 1 & " " & $sTxtAfterUsing)
GUICtrlSetOnEvent(-1, "btnchkbxUpgrade")
$g_hTxtUpgradeName[$i] = GUICtrlCreateInput("", $x + 40, $y, 107, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowName)
$g_hTxtUpgradeLevel[$i] = GUICtrlCreateInput("", $x + 150, $y, 23, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowLevel)
$g_hPicUpgradeType[$i]= _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlank, $x + 178, $y + 1, 15, 15)
_GUICtrlSetTip(-1, $sTxtShowType)
GUICtrlSetOnEvent(-1, "picUpgradeTypeLocation")
$g_hTxtUpgradeValue[$i] = GUICtrlCreateInput("", $x + 197, $y, 65, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowCost)
$g_hTxtUpgradeTime[$i] = GUICtrlCreateInput("", $x + 266, $y, 35, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowTime)
$g_hTxtUpgradeEndTime[$i] = GUICtrlCreateInput("", $x + 305, $y, 85, 17, BitOR($ES_LEFT, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
GUICtrlSetFont(-1, 7)
_GUICtrlSetTip(-1, $sTxtShowEndTime)
$g_hChkUpgradeRepeat[$i] = GUICtrlCreateCheckbox("", $x + 395, $y + 1, 15, 15)
_GUICtrlSetTip(-1, $sTxtChkRepeat)
GUICtrlSetOnEvent(-1, "btnchkbxRepeat")
$y += 22
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x += 5
$y += 8
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 15, $y, 15, 15)
GUICtrlCreateLabel( GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "LblUpgrMinGold", "Min. Gold") & ":", $x + 5, $y + 3, -1, -1)
$g_hTxtUpgrMinGold = GUICtrlCreateInput("250000", $x + 55, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinGold_Info_01", "Save this much Gold after the upgrade completes.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinGold_Info_02", "Set this value as needed to save for searching, or wall upgrades."))
GUICtrlSetLimit(-1, 7)
$y += 18
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 15, $y, 15, 15)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "LblUpgrMinElixir", "Min. Elixir") & ":", $x + 5, $y + 3, -1, -1)
$g_hTxtUpgrMinElixir = GUICtrlCreateInput("250000", $x + 55, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinElixir_Info_01", "Save this much Elixir after the upgrade completes") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinElixir_Info_02", "Set this value as needed to save for making troops or wall upgrades."))
GUICtrlSetLimit(-1, 7)
$x -= 15
$y -= 8
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 140, $y, 15, 15)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "LblUpgrMinDark", "Min. Dark") & ":", $x + 160, $y + 3, -1, -1)
$g_hTxtUpgrMinDark = GUICtrlCreateInput("3000", $x + 210, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinDark_Info_01", "Save this amount of Dark Elixir after the upgrade completes.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "TxtUpgrMinDark_Info_02", "Set this value higher if you want make war troops."))
GUICtrlSetLimit(-1, 6)
$y -= 8
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnLocateUpgrades", "Locate Upgrades"), $x + 290, $y - 4, 120, 18, BitOR($BS_MULTILINE, $BS_VCENTER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnLocateUpgrades_Info_01", "Push button to locate and record information on building/Hero upgrades") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnLocateUpgrades_Info_02", "Any upgrades with repeat enabled are skipped and can not be located again"))
GUICtrlSetOnEvent(-1, "btnLocateUpgrades")
GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnResetUpgrades", "Reset Upgrades"), $x + 290, $y + 16, 120, 18, BitOR($BS_MULTILINE, $BS_VCENTER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnResetUpgrades_Info_01", "Push button to reset & remove upgrade information") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Buildings", "BtnResetUpgrades_Info_02", "If repeat box is checked, data will not be reset"))
GUICtrlSetOnEvent(-1, "btnResetUpgrade")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateWallsSubTab()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "Group_01", "Walls"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 120)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWall, $x - 12, $y - 6, 24, 24)
$g_hChkWalls = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkWalls", "Auto Wall Upgrade"), $x + 18, $y - 2, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkWalls_Info_01", "Check this to upgrade Walls if there are enough resources."))
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkWalls")
$g_hBtnFindWalls = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "BtnFindWalls", "TEST"), $x + 150, $y + 26, 45, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "BtnFindWalls_Info_01", "Click here to test the Wall Detection."))
GUICtrlSetOnEvent(-1, "btnWalls")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
$g_hRdoUseGold = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseGold", "Use Gold"), $x + 25, $y + 16, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseGold_Info_01", "Use only Gold for Walls.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseGold_Info_02", "Available at all Wall levels."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hRdoUseElixir = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixir", "Use Elixir"), $x + 25, $y + 34, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixir_Info_01", "Use only Elixir for Walls.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixir_Info_02", "Available only at Wall levels upgradeable with Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hRdoUseElixirGold = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixirGold", "Try Elixir first, Gold second"), $x + 25, $y + 52, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixirGold_Info_01", "Try to use Elixir first. If not enough Elixir try to use Gold second for Walls.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "RdoUseElixir_Info_02", -1))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x - 12, $y + 72, 20, 20)
$g_hChkSaveWallBldr = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkSaveWallBldr", "Save ONE builder for Walls"), $x + 18, $y + 72, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkSaveWallBldr_Info_01", "Check this to reserve 1 builder exclusively for walls and") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "ChkSaveWallBldr_Info_02", "reduce the available builder by 1 for other upgrades"))
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSaveWallBldr")
$x += 225
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblSearchforWalls", "Search for Walls level") & ":", $x, $y + 2, -1, -1)
$g_hCmbWalls = GUICtrlCreateCombo("", $x + 110, $y, 61, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL), $WS_EX_RIGHT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "CmbWalls_Info_01", "Search for Walls of this level and try to upgrade them one by one."))
GUICtrlSetData(-1, "4   |5   |6   |7   |8   |9   |10   |11   |12   ", "4   ")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbWalls")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblNextWalllevelcosts", "Next Wall level costs") & ":", $x, $y + 25, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblNextWalllevelcosts_Info_01", "Use this value as an indicator.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblNextWalllevelcosts_Info_02", "The value will update if you select an other wall level."))
$g_hLblWallCost = GUICtrlCreateLabel("30 000", $x + 110, $y + 25, 50, -1, $SS_RIGHT)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x, $y + 47, 16, 16)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Goldtosave", "Min. Gold to save"), $x + 20, $y + 47, -1, -1)
$g_hTxtWallMinGold = GUICtrlCreateInput("250000", $x + 110, $y + 45, 61, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Goldtosave_Info_01", "Save this much Gold after the wall upgrade completes,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Goldtosave_Info_02", "Set this value to save Gold for other upgrades, or searching."))
GUICtrlSetLimit(-1, 7)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 2
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x, $y + 67, 16, 16)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Elixirtosave", "Min. Elixir to save"), $x + 20, $y + 70, -1, -1)
$g_hTxtWallMinElixir = GUICtrlCreateInput("250000", $x + 110, $y + 65, 61, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Elixirtosave_Info_01", "Save this much Elixir after the wall upgrade completes,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "LblMin.Elixirtosave_Info_02", "Set this value to save Elixir for other upgrades or troop making."))
GUICtrlSetLimit(-1, 7)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 175
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "Group_02", "Walls counter"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 95)
$g_ahWallsCurrentCount[4] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", "Input number of Walls level") & " 4 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", "you have."))
$g_ahPicWallsLevel[4] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall04, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[5] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 5 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[5] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall05, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[6] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 6 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall06, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[7] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 7 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall07, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[8] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 8 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall08, $x + 27, $y - 2, 24, 24)
Local $x = 25
$y += 40
$g_ahWallsCurrentCount[9] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 9 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall09, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[10] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 10 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall10, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[11] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 11 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall11, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[12] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 12 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall12, $x + 27, $y - 2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[13] = GUICtrlCreateInput("0", $x, $y, 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_01", -1) & " 13 " & GetTranslatedFileIni("MBR GUI Design Child Village - Upgrade_Walls", "WallsCurrentCount_Info_02", -1))
$g_ahPicWallsLevel[13] = _GUICtrlCreateIcon($g_sLibIconPath, $eWall13, $x + 27, $y - 2, 24, 24)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateAutoUpgradeSubTab()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Group_01", "Auto Upgrade"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 100)
$g_hChkAutoUpgrade = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "ChkAutoUpgrade", "Enable Auto Upgrade"), $x - 5, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "ChkAutoUpgrade_Info_01", "Check box to enable automatically starting Upgrades from builders menu"))
GUICtrlSetOnEvent(-1, "chkAutoUpgrade")
$g_hLblAutoUpgrade = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Label_01", "Save"), $x, $y + 32, -1, -1)
$g_hTxtSmartMinGold = GUICtrlCreateInput("150000", $x + 33, $y + 29, 60, 21, BitOR($ES_CENTER, $ES_NUMBER))
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 98, $y + 32, 16, 16)
$g_hTxtSmartMinElixir = GUICtrlCreateInput("150000", $x + 118, $y + 29, 60, 21, BitOR($ES_CENTER, $ES_NUMBER))
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 183, $y + 32, 16, 16)
$g_hTxtSmartMinDark = GUICtrlCreateInput("1500", $x + 203, $y + 29, 60, 21, BitOR($ES_CENTER, $ES_NUMBER))
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 268, $y + 32, 16, 16)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Label_02", "after launching upgrade"), $x + 290, $y + 32, -1, -1)
$g_hChkResourcesToIgnore[0] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Ignore_01", "Ignore Gold Upgrades"), $x, $y + 55, -1, -1)
GUICtrlSetOnEvent(-1, "chkResourcesToIgnore")
$g_hChkResourcesToIgnore[1] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Ignore_02", "Ignore Elixir Upgrades"), $x + 130, $y + 55, -1, -1)
GUICtrlSetOnEvent(-1, "chkResourcesToIgnore")
$g_hChkResourcesToIgnore[2] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Ignore_03", "Ignore Dark Elixir Upgrades"), $x + 258, $y + 55, -1, -1)
GUICtrlSetOnEvent(-1, "chkResourcesToIgnore")
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "Group_02", "Upgrades to ignore"), $x - 20, $y + 85, $g_iSizeWGrpTab3, 137)
Local $x = 21, $y = 100
Local $iIconSize = 32
Local $xOff =(40 - $iIconSize) / 2
Local $yRow1 = 50
Local $yRow2 = 110
Local $yChkOff = 32
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTH11, $x + 5, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[0] = GUICtrlCreateCheckbox("", $x + 20 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x + 80, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[1] = GUICtrlCreateCheckbox("", $x + 95 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x + 125, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[2] = GUICtrlCreateCheckbox("", $x + 140 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x + 170, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[3] = GUICtrlCreateCheckbox("", $x + 185 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x + 245, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[4] = GUICtrlCreateCheckbox("", $x + 260 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLaboratory, $x + 290, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[5] = GUICtrlCreateCheckbox("", $x + 305 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eWall13, $x + 365, $y + $yRow1, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[6] = GUICtrlCreateCheckbox("", $x + 380 - $xOff, $y + $yRow1 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarrack, $x + 5, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[7] = GUICtrlCreateCheckbox("", $x + 20 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkBarrack, $x + 50, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[8] = GUICtrlCreateCheckbox("", $x + 65 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellFactory, $x + 140, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[9] = GUICtrlCreateCheckbox("", $x + 155 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkSpellFactory, $x + 185, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[10] = GUICtrlCreateCheckbox("", $x + 200 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 275, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[11] = GUICtrlCreateCheckbox("", $x + 290 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 320, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[12] = GUICtrlCreateCheckbox("", $x + 335 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 365, $y + $yRow2, $iIconSize, $iIconSize)
$g_hChkUpgradesToIgnore[13] = GUICtrlCreateCheckbox("", $x + 380 - $xOff, $y + $yRow2 + $yChkOff, 17, 17)
GUICtrlSetOnEvent(-1, "chkUpgradesToIgnore")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_hTxtAutoUpgradeLog = GUICtrlCreateEdit("", $x - 16, 275, $g_iSizeWGrpTab3, 127, BitOR($GUI_SS_DEFAULT_EDIT, $ES_READONLY))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "TxtAutoUpgradeLog", "------------------------------------------------ AUTO UPGRADE LOG ------------------------------------------------"))
EndFunc
Global $g_hChkUnbreakable = 0, $g_hTxtUnbreakable = 0, $g_hTxtUnBrkMinGold = 0, $g_hTxtUnBrkMaxGold = 0, $g_hTxtUnBrkMinElixir = 0, $g_hTxtUnBrkMaxElixir = 0, $g_hTxtUnBrkMinDark = 0, $g_hTxtUnBrkMaxDark = 0
Global $g_hLblUnbreakableHelp = 0, $g_hLblUnbreakableLink = 0
Func CreateVillageAchievements()
Local $x = 25
Local $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "Group_01", "Defense Farming"), $x - 20, $y - 20, $g_iSizeWGrpTab2, 150)
$y +=10
$g_hChkUnbreakable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "ChkUnbreakable", "Enable Unbreakable"), $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "ChkUnbreakable_Info_01", "Enable farming Defense Wins for Unbreakable achievement."))
GUICtrlSetOnEvent(-1, "chkUnbreakable")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 10, $y + 51, 32, 32)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 42, $y + 36, 48, 48)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 90, $y + 51, 32, 32)
$x = 150
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "LblUnbreakable", "Wait Time") & ":", $x - 10, $y + 3, 86, -1, $SS_RIGHT)
$g_hTxtUnbreakable = GUICtrlCreateInput("5", $x + 80, $y, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnbreakable_Info_01", "Set the amount of time to stop CoC and wait for enemy attacks to gain defense wins. (1-99 minutes)"))
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Minutes", "Minutes"), $x + 113, $y + 3, -1, -1)
$y += 28
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "Lbl_FarmMin._Info_01", "Farm Min."), $x + 25, $y, -1, -1)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "Lbl_SaveMin._Info_01", "Save Min."), $x + 115, $y, -1, -1)
$y += 16
$g_hTxtUnBrkMinGold = GUICtrlCreateInput("50000", $x + 20, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinGold_Info_01", "Amount of Gold that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinGold_Info_02", "Set this value to amount of Gold you need for searching or upgrades."))
GUICtrlSetLimit(-1, 7)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 80, $y + 2, 16, 16)
$g_hTxtUnBrkMaxGold = GUICtrlCreateInput("600000", $x + 110, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxGold_Info_01", "Amount of Gold in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxGold_Info_02", "Input amount of Gold you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 7)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 170, $y + 2, 16, 16)
$y += 26
$g_hTxtUnBrkMinElixir = GUICtrlCreateInput("50000", $x + 20, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinElixir_Info_01", "Amount of Elixir that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinElixir_Info_02", "Set this value to amount of Elixir you need for making troops or upgrades."))
GUICtrlSetLimit(-1, 7)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 80, $y, 16, 16)
$g_hTxtUnBrkMaxElixir = GUICtrlCreateInput("600000", $x + 110, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxElixir_Info_01", "Amount of Elixir in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxElixir_Info_02", "Input amount of Elixir you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 7)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 170, $y, 16, 16)
$y += 24
$g_hTxtUnBrkMinDark = GUICtrlCreateInput("5000", $x + 20, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinDark_Info_01", "Amount of Dark Elixir that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMinDark_Info_02", "Set this value to amount of Dark Elixir you need for making troops or upgrades."))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 80, $y, 16, 16)
$g_hTxtUnBrkMaxDark = GUICtrlCreateInput("6000", $x + 110, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxDark_Info_01", "Amount of Dark Elixir in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "TxtUnBrkMaxDark_Info_02", "Input amount of Dark Elixir you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 170, $y, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 200
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "Group_02", "How to use Unbreakable Mode"), $x - 20, $y - 20, $g_iSizeWGrpTab2, 200)
Local $txtHelp = GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_01", "Unbreakable mode will help you gain defense wins and the ""Unbreakable"" achievement.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_02", "Set ""Wait Time"" to how long you want the bot to wait for defenses.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_03", "Farm Min is how many resources the bot must have before attacking.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_04", "Save Min is how many resources the bot must have before starting unbreakable mode.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "txtHelp_05", "Click the below link for more information:")
$g_hLblUnbreakableHelp = GUICtrlCreateLabel($txtHelp, $x - 10, $y, 430, 100)
$g_hLblUnbreakableLink = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Achievements", "LblUnbreakableLink", "More Info"), $x - 10, $y + 100, 100, 20)
_GUICtrlSetTip(-1, "https://mybot.run/forums/index.php?/topic/2964-guide-how-to-use-mybot-unbreakable-mode-updated/")
GUICtrlSetFont(-1, 8.5, $FW_BOLD, $GUI_FONTUNDER)
GUICtrlSetColor(-1, $COLOR_INFO)
GUICtrlSetCursor(-1, 0)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_NOTIFY = 0, $g_hGUI_NOTIFY_TAB = 0, $g_hGUI_NOTIFY_TAB_ITEM2 = 0
Global $g_hGrpNotify = 0
Global $g_hChkNotifyTGEnable = 0, $g_hTxtNotifyTGToken = 0
Global $g_hChkNotifyRemote = 0, $g_hTxtNotifyOrigin = 0
Global $g_hChkNotifyAlertMatchFound = 0, $g_hChkNotifyAlertLastRaidIMG = 0, $g_hChkNotifyAlertLastRaidTXT = 0, $g_hChkNotifyAlertCampFull = 0, $g_hChkNotifyAlertUpgradeWall = 0, $g_hChkNotifyAlertOutOfSync = 0, $g_hChkNotifyAlertTakeBreak = 0, $g_hChkNotifyAlertBuilderIdle = 0, $g_hChkNotifyAlertVillageStats = 0, $g_hChkNotifyAlertLastAttack = 0, $g_hChkNotifyAlertAnotherDevice = 0, $g_hChkNotifyAlertMaintenance = 0, $g_hChkNotifyAlertBAN = 0, $g_hChkNotifyBOTUpdate = 0, $g_hChkNotifyAlertSmartWaitTime = 0, $g_hChkNotifyAlertLaboratoryIdle = 0
Global $g_hChkNotifyOnlyHours = 0, $g_hChkNotifyOnlyWeekDays = 0, $g_hChkNotifyhours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_hChkNotifyWeekdays[7] = [0, 0, 0, 0, 0, 0, 0]
GLobal $g_hLblNotifyhour = 0, $g_ahLblNotifyhoursE = 0, $g_hChkNotifyhoursE1 = 0, $g_hChkNotifyhoursE2 = 0, $g_hLblNotifyhoursAM = 0, $g_hLblNotifyhoursPM = 0
GLobal $g_hLblNotifyhours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLblNotifyWeekdays[7] = [0, 0, 0, 0, 0, 0, 0], $g_ahLblNotifyWeekdaysE = 0, $g_ahChkNotifyWeekdaysE = 0, $g_lblHepNotify = 0
Func CreateVillageNotify()
$g_hGUI_NOTIFY = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
GUISwitch($g_hGUI_NOTIFY)
$g_hGUI_NOTIFY_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_NOTIFY_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_05_STab_01", "Telegram"))
CreatePushBulletTelegramSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreatePushBulletTelegramSubTab()
Local $sTxtTip = ""
Local $x = 25, $y = 45
$g_hGrpNotify = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "Group_01", "Telegram Notify") & " " & $g_sNotifyVersion, $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTelegram, $x + 3, $y, 32, 32)
$g_hChkNotifyTGEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyTGEnable", "Enable Telegram"), $x + 40, $y + 5)
GUICtrlSetOnEvent(-1, "chkPBTGenabled")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyTGEnable_Info_01", "Enable Telegram notifications"))
$y += 40
$x -= 10
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyTGToken", "Token (Telegram)") & ":", $x, $y, -1, -1, $SS_RIGHT)
$g_hTxtNotifyTGToken = GUICtrlCreateInput("", $x + 120, $y - 3, 280, 19)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyTGToken_Info_01", "You need a Token to use Telegram notifications. Get a token from Telegram.com"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
$g_hChkNotifyRemote = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyRemote", "Remote Control"), $x + 10, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyRemote_Info_01", "Enables Telegram Remote function"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyOrigin", "Origin") & ":", $x + 120, $y + 3, -1, -1, $SS_RIGHT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyOrigin_Info_01", "Origin - Village name.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtNotifyOrigin = GUICtrlCreateInput("", $x + 170, $y, 230, 19)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyOptions", "Send a Telegram message for these options") & ":", $x, $y, -1, -1, $SS_RIGHT)
$y += 15
$g_hChkNotifyAlertMatchFound = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertMatchFound", "Match Found"), $x + 10, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertMatchFound_Info_01", "Send the amount of available loot when bot finds a village to attack."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastRaidIMG = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastRaidIMG", "Last raid as image"), $x + 100, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastRaidIMG_Info_01", "Send the last raid screenshot."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastRaidTXT = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastRaidTXT", "Last raid as Text"), $x + 210, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastRaidTXT_Info_01", "Send the last raid results as text."))
$g_hChkNotifyAlertCampFull = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertCampFull", "Army Camp Full"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertCampFull_Info_01", "Sent an Alert when your Army Camp is full."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertUpgradeWall = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertUpgradeWall", "Wall upgrade"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertUpgradeWall_Info_01", "Send info about wall upgrades."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertOutOfSync = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertOutOfSync", "Error: Out Of Sync"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertOutOfSync_Info_01", "Send an Alert when you get the Error: Client and Server out of sync"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertTakeBreak = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertTakeBreak", "Take a break"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertTakeBreak_Info_01", "Send an Alert when you have been playing for too long and your villagers need to rest."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertBuilderIdle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertBuilderIdle", "Builder Idle"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertBuilderIdle_Info_01", "Send an Alert when at least one builder is idle."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertVillageStats = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertVillageStats", "Village Report"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertVillageStats_Info_01", "Send a Village Report."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastAttack = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastAttack", "Alert Last Attack"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLastAttack_Info_01", "Send info about the Last Attack."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertAnotherDevice = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertAnotherDevice", "Another device"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertAnotherDevice_Info_01", "Send an Alert when your village is connected to from another device."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertSmartWaitTime = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertSmartWaitTime", "Smart Wait Time"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertSmartWaitTime_Info_02", "Send an Alert when your village take wait troops."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertMaintenance = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertMaintenance", "Maintenance"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertMaintenance_Info_01", "Send an Alert when CoC is under maintenance by SuperCell"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertBAN = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertBAN", "BAN"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertBAN_Info_01", "Send an Alert if your village was BANNED by SuperCell"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyBOTUpdate = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyBOTUpdate", "BOT Update"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyBOTUpdate_Info_01", "Send an Alert when there is a new version of the bot."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLaboratoryIdle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLaboratoryIdle", "Laboratory Idle"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "ChkNotifyAlertLaboratoryIdle_Info_01", "Send an Alert when the laboratory is idle."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$y += 30
$g_hChkNotifyOnlyHours = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", "Only during these hours of each day"), $x + 70, $y )
GUICtrlSetOnEvent(-1, "chkNotifyHours")
$x += 59
$y += 25
$g_hLblNotifyhour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", "Hour") & ":", $x, $y, -1, 15)
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
For $i = 0 to 11
$g_hLblNotifyhours[$i] = GUICtrlCreateLabel(StringFormat("%2s", String($i)), $x + 30 +(15 * $i), $y)
Next
$g_ahLblNotifyhoursE = GUICtrlCreateLabel("X", $x + 214, $y + 1, 11, 11)
$y += 15
For $i = 0 to 11
$g_hChkNotifyhours[$i] = GUICtrlCreateCheckbox("", $x + 30 +(15 * $i), $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
Next
$g_hChkNotifyhoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkNotifyhoursE1")
$g_hLblNotifyhoursAM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", -1), $x + 10, $y)
$y += 15
For $i = 12 to 23
$g_hChkNotifyhours[$i] = GUICtrlCreateCheckbox("", $x + 30 +(15 *($i - 12)), $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
Next
$g_hChkNotifyhoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkNotifyhoursE2")
$g_hLblNotifyhoursPM = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", -1), $x + 10, $y)
$y += 20
$g_hChkNotifyOnlyWeekDays = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", "Only during these day of week"), $x + 11, $y )
GUICtrlSetOnEvent(-1, "chkNotifyWeekDays")
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Day", "Day") & ":", $x, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_hLblNotifyWeekdays[0] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Su", "Su"), $x + 30, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Sunday", "Sunday"))
$g_hLblNotifyWeekdays[1] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Mo", "Mo"), $x + 46, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Monday", "Monday"))
$g_hLblNotifyWeekdays[2] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Tu", "Tu"), $x + 62, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Tuesday", "Tuesday"))
$g_hLblNotifyWeekdays[3] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "We", "We"), $x + 80, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Wednesday", "Wednesday"))
$g_hLblNotifyWeekdays[4] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Th", "Th"), $x + 99, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Thursday", "Thursday"))
$g_hLblNotifyWeekdays[5] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Fr", "Fr"), $x + 116, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Friday", "Friday"))
$g_hLblNotifyWeekdays[6] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Sa", "Sa"), $x + 133, $y)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Saturday", "Saturday"))
$g_ahLblNotifyWeekdaysE = GUICtrlCreateLabel("X", $x + 155, $y + 1, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
$y += 13
For $i = 0 to 6
$g_hChkNotifyWeekdays[$i] = GUICtrlCreateCheckbox("", $x + 30 +(17 * $i), $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
Next
$g_ahChkNotifyWeekdaysE = GUICtrlCreateCheckbox("", $x + 151, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "ChkNotifyWeekdaysE")
$y += 15
$x = 15
$g_lblHepNotify = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyHelp", "Help ?"), $x + 310, $y , 100, 24, $SS_RIGHT)
GUICtrlSetOnEvent($g_lblHepNotify, "ShowControlHelp")
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Village - Notify", "LblNotifyHelp_Info_01", "Click here to get Help about Notify Remote commands to Telegram"))
GUICtrlSetColor(-1, $COLOR_NAVY)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_VILLAGE_TAB = 0, $g_hGUI_VILLAGE_TAB_ITEM1 = 0, $g_hGUI_VILLAGE_TAB_ITEM2 = 0, $g_hGUI_VILLAGE_TAB_ITEM3 = 0, $g_hGUI_VILLAGE_TAB_ITEM4 = 0, $g_hGUI_VILLAGE_TAB_ITEM5 = 0
Func CreateVillageTab()
$g_hGUI_VILLAGE = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
CreateVillageMisc()
CreateVillageDonate()
CreateVillageUpgrade()
CreateVillageNotify()
GUISwitch($g_hGUI_VILLAGE)
$g_hGUI_VILLAGE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_VILLAGE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_01", "Misc"))
$g_hGUI_VILLAGE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_02", "Req. && Donate"))
$g_hGUI_VILLAGE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_03", "Upgrade"))
$g_hGUI_VILLAGE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_04", "Achievements"))
CreateVillageAchievements()
$g_hGUI_VILLAGE_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02_STab_05", "Notify"))
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_ATTACK = 0
Global $g_hGUI_ATTACK_TAB = 0, $g_hGUI_ATTACK_TAB_ITEM1 = 0, $g_hGUI_ATTACK_TAB_ITEM2 = 0, $g_hGUI_ATTACK_TAB_ITEM3 = 0
Global $g_hGUI_DropOrder = 0
Global $g_hGUI_TRAINARMY = 0
Global $g_hGUI_TRAINARMY_TAB = 0, $g_hGUI_TRAINARMY_TAB_ITEM1 = 0, $g_hGUI_TRAINARMY_TAB_ITEM2 = 0, $g_hGUI_TRAINARMY_TAB_ITEM3 = 0, $g_hGUI_TRAINARMY_TAB_ITEM4 = 0
Global $g_hChkUseQuickTrain = 0, $g_ahChkArmy[3] = [0, 0, 0], $g_hChkMultiClick = 0, $g_hLblRemoveArmy = 0, $g_hBtnRemoveArmy = 0
Global $g_ahTxtTrainArmyTroopCount[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahLblTrainArmyTroopLevel[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahTxtTrainArmySpellCount[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahLblTrainArmySpellLevel[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahTxtTrainArmySiegeCount[$eSiegeMachineCount] = [0, 0, 0]
Global $g_ahLblTrainArmySiegeLevel[$eSiegeMachineCount] = [0, 0, 0]
Global $g_hTxtFullTroop = 0, $g_hChkTotalCampForced = 0, $g_hTxtTotalCampForced = 0, $g_hChkForceBrewBeforeAttack = 0
Global $g_hChkDoubleTrain = 0, $g_hChkPreciseArmy = 0
Global $g_hGrpTrainTroops = 0
Global $g_ahPicTrainArmyTroop[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahPicTrainArmySpell[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahPicTrainArmySiege[$eSiegeMachineCount] = [0, 0]
Global $g_hLblTotalTimeCamp = 0, $g_hLblElixirCostCamp = 0, $g_hLblDarkCostCamp = 0, $g_hCalTotalTroops = 0, $g_hLblTotalProgress = 0, $g_hLblCountTotal = 0, $g_hTxtTotalCountSpell = 0, $g_hLblTotalTimeSpell = 0, $g_hLblElixirCostSpell = 0, $g_hLblDarkCostSpell = 0, $g_hLblTotalTimeSiege = 0, $g_hLblCountTotalSiege = 0, $g_hLblGoldCostSiege = 0
Global $g_hCmbBoostBarracks = 0, $g_hCmbBoostSpellFactory = 0, $g_hCmbBoostWorkshop = 0, $g_hCmbBoostBarbarianKing = 0, $g_hCmbBoostArcherQueen = 0, $g_hCmbBoostWarden = 0
Global $g_hCmbBoostTrainingPotion = 0, $g_hCmbBoostResourcePotion = 0
Global $g_hLblBoosthour = 0, $g_ahLblBoosthoursE = 0
Global $g_hLblBoosthours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkBoostBarracksHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $g_hChkBoostBarracksHoursE1 = 0, $g_hChkBoostBarracksHoursE2 = 0
Func LoadTranslatedTrainTroopsOrderList()
Global $g_asTroopOrderList = ["", GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtElectroDragons", "Electro Dragons"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers"), GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtIceGolems", "Ice Golems")]
EndFunc
Global $g_hChkCustomTrainOrderEnable = 0
Global $g_ahCmbTroopOrder[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahImgTroopOrder[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hBtnTroopOrderSet = 0, $g_ahImgTroopOrderSet = 0
Global $g_hBtnRemoveTroops
Func LoadTranslatedBrewSpellsOrderList()
Global $g_asSpellsOrderList = ["", GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortLightningSpells", "Lightning"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHealSpells", "Heal"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortRageSpells", "Rage"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortJumpSpells", "Jump"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortFreezeSpells", "Freeze"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortCloneSpells", "Clone"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortPoisonSpells", "Poison"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortEarthquakeSpells", "EarthQuake"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHasteSpells", "Haste"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortSkeletonSpells", "Skeleton"), GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortBatSpells", "Bat")]
EndFunc
Global $g_hChkCustomBrewOrderEnable = 0
Global $g_ahCmbSpellsOrder[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahImgSpellsOrder[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hBtnSpellsOrderSet = 0, $g_ahImgSpellsOrderSet = 0
Global $g_hBtnRemoveSpells
Global $g_hChkCloseWhileTraining = 0, $g_hChkCloseWithoutShield = 0, $g_hChkCloseEmulator = 0, $g_hChkSuspendComputer = 0, $g_hChkRandomClose = 0, $g_hRdoCloseWaitExact = 0, $g_hRdoCloseWaitRandom = 0, $g_hCmbCloseWaitRdmPercent = 0, $g_hCmbMinimumTimeClose = 0, $g_hSldTrainITDelay = 0, $g_hChkTrainAddRandomDelayEnable = 0, $g_hTxtAddRandomDelayMin = 0, $g_hTxtAddRandomDelayMax = 0
Global $g_hLblCloseWaitRdmPercent = 0, $g_hLblCloseWaitingTroops = 0, $g_hLblSymbolWaiting = 0, $g_hLblWaitingInMinutes = 0, $g_hLblTrainITDelay = 0, $g_hLblTrainITDelayTime = 0, $g_hLblAddDelayIdlePhaseBetween = 0, $g_hLblAddDelayIdlePhaseSec = 0, $g_hPicCloseWaitTrain = 0, $g_hPicCloseWaitStop = 0, $g_hPicCloseWaitExact = 0
Global $g_hChkTrainLogoutMaxTime = 0, $g_hTxtTrainLogoutMaxTime = 0, $g_hLblTrainLogoutMaxTime = 0
Func CreateAttackTroops()
$g_hGUI_TRAINARMY = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
$g_hGUI_TRAINARMY_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
CreateTroopsSpellsSubTab()
CreateBoostSubTab()
CreateTrainOrderSubTab()
CreateOptionsSubTab()
EndFunc
Func CreateTroopsSpellsSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01_STab_01", "Army"))
Local $sTxtSetPerc = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "TxtSetTroop_Info_01", "Enter the No. of")
Local $sTxtSetPerc2 = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "TxtSetTroop_Info_02", "to make.")
Local $iStartX = 12
Local $x = 0
Local $y = 12
$g_hChkUseQuickTrain = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkUseQuickTrain", "Use Quick Train"), $x + 15, $y + 19, -1, 15)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkUseQTrain")
For $i = 0 To 2
$g_ahChkArmy[$i] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkArmy", "Army ") & $i + 1, $x + 120 + $i * 60, $y + 20, 50, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
If $i = 0 Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkQuickTrainCombo")
Next
$g_hChkMultiClick = GUICtrlCreateCheckbox("Multi-click Army 3", $x + 120 + 3 * 60, $y + 20, -1, 15)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblRemoveArmy = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Btn_Remove_Army", "Remove Army"), $x + 335, $y + 22, -1, 15, $SS_LEFT)
$g_hBtnRemoveArmy = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnResetButton, $x + 405, $y + 17, 24, 24)
GUICtrlSetOnEvent(-1, "Removecamp")
$x = 10
$y = 49
$g_hGrpTrainTroops = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Group_01", "Train Army"), $x - 5, $y, $g_iSizeWGrpTab3, 323)
$x = $iStartX
$y += 20
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBarbarians", "Barbarians")
$g_ahPicTrainArmyTroop[$eTroopBarbarian] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarbarian, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", "Level") & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", "Mouse Left Click to Up level" & @CRLF & "Shift + Mouse Left Click to Down level"))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBarbarian] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBarbarian] = GUICtrlCreateInput("58", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGiants", "Giants")
$g_ahPicTrainArmyTroop[$eTroopGiant] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGiant, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGiant] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGiant] = GUICtrlCreateInput("4", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWallBreakers", "Wall Breakers")
$g_ahPicTrainArmyTroop[$eTroopWallBreaker] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallBreaker, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWallBreaker] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWallBreaker] = GUICtrlCreateInput("4", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWizards", "Wizards")
$g_ahPicTrainArmyTroop[$eTroopWizard] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizard, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWizard] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWizard] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtDragons", "Dragons")
$g_ahPicTrainArmyTroop[$eTroopDragon] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopDragon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopDragon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBabyDragons", "Baby Dragons")
$g_ahPicTrainArmyTroop[$eTroopBabyDragon] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBabyDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBabyDragon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBabyDragon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 40
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtElectroDragons", "Electro Dragons")
$g_ahPicTrainArmyTroop[$eTroopElectroDragon] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElectroDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopElectroDragon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopElectroDragon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMinions", "Minions")
$g_ahPicTrainArmyTroop[$eTroopMinion] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopMinion] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopMinion] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtValkyries", "Valkyries")
$g_ahPicTrainArmyTroop[$eTroopValkyrie] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnValkyrie, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopValkyrie] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopValkyrie] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtWitches", "Witches")
$g_ahPicTrainArmyTroop[$eTroopWitch] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWitch, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWitch] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWitch] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sSiegeName = GetTranslatedFileIni("MBR Global GUI Design Names Siege Machines", "TxtWallWrecker", "Wall Wrecker")
$g_ahPicTrainArmySiege[$eSiegeWallWrecker] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallW, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSiegeName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSiegeLevelClick")
$g_ahLblTrainArmySiegeLevel[$eSiegeWallWrecker] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySiegeCount[$eSiegeWallWrecker] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSiegeName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSiegeCountEdit")
$x += 35
Local $sSiegeName = GetTranslatedFileIni("MBR Global GUI Design Names Siege Machines", "TxtBattleBlimp", "Battle Blimp")
$g_ahPicTrainArmySiege[$eSiegeBattleBlimp] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBattleB, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSiegeName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSiegeLevelClick")
$g_ahLblTrainArmySiegeLevel[$eSiegeBattleBlimp] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySiegeCount[$eSiegeBattleBlimp] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSiegeName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSiegeCountEdit")
$x = $iStartX
$y += 58
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtArchers", "Archers")
$g_ahPicTrainArmyTroop[$eTroopArcher] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopArcher] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopArcher] = GUICtrlCreateInput("115", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGoblins", "Goblins")
$g_ahPicTrainArmyTroop[$eTroopGoblin] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoblin, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGoblin] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGoblin] = GUICtrlCreateInput("19", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBalloons", "Balloons")
$g_ahPicTrainArmyTroop[$eTroopBalloon] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBalloon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBalloon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBalloon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHealers", "Healers")
$g_ahPicTrainArmyTroop[$eTroopHealer] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealer, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopHealer] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopHealer] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtPekkas", "Pekkas")
$g_ahPicTrainArmyTroop[$eTroopPekka] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPekka, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopPekka] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopPekka] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtMiners", "Miners")
$g_ahPicTrainArmyTroop[$eTroopMiner] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnMiner, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopMiner] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopMiner] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 40
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtBowlers", "Bowlers")
$g_ahPicTrainArmyTroop[$eTroopBowler] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBowler, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBowler] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBowler] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtHogRiders", "Hog Riders")
$g_ahPicTrainArmyTroop[$eTroopHogRider] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHogRider, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopHogRider] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopHogRider] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtGolems", "Golems")
$g_ahPicTrainArmyTroop[$eTroopGolem] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGolem, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGolem] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGolem] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtLavaHounds", "Lava Hounds")
$g_ahPicTrainArmyTroop[$eTroopLavaHound] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLavaHound, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopLavaHound] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopLavaHound] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sTroopName = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "TxtIceGolems", "IceGolems")
$g_ahPicTrainArmyTroop[$eTroopIceGolem] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnIceGolem, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sTroopName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopIceGolem] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopIceGolem] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 35
Local $sSiegeName = GetTranslatedFileIni("MBR Global GUI Design Names Siege Machines", "TxtStoneSlammer", "Stone Slammer")
$g_ahPicTrainArmySiege[$eSiegeStoneSlammer] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnStoneS, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSiegeName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSiegeLevelClick")
$g_ahLblTrainArmySiegeLevel[$eSiegeStoneSlammer] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySiegeCount[$eSiegeStoneSlammer] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSiegeName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSiegeCountEdit")
$x = 210
$y += 40
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSiegeCost, $x - 36, $y + 10, 24, 24)
$g_hLblTotalTimeSiege = GUICtrlCreateLabel(" 0s", $x - 11, $y + 15, 70, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
$g_hLblGoldCostSiege = GUICtrlCreateLabel(" 0", $x + 65, $y + 15, 77, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 63, $y + 14, 16, 16)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCountTotal", "Total"), $x + 138, $y + 15, -1, -1, $SS_RIGHT)
$g_hLblCountTotalSiege = GUICtrlCreateLabel(0, $x + 173, $y + 15, 30, 15, $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCountTotal_Info_02", "The total units of Siege Machines"))
GUICtrlSetBkColor(-1, $COLOR_MONEYGREEN)
GUICtrlCreateLabel("x", $x + 207, $y + 15, -1, -1)
$x = 30
$y += 45
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCamp, $x - 18, $y - 15, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblFullTroop", "'Full' Camps"), $x + 10, $y - 7, 55, 17)
GUICtrlCreateLabel(ChrW(8805), $x + 70, $y - 7, -1, 17)
$g_hTxtFullTroop = GUICtrlCreateInput("100", $x + 82, $y - 10, 35, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "SetComboTroopComp")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "TxtFullTroop_Info_01", "Army camps are 'Full' when reaching this %, then start attack."))
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel("%", $x + 120, $y - 7, -1, 17)
$x += 180
$y -= 23
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTroopsCost, $x - 33, $y + 10, 24, 24)
$g_hLblTotalTimeCamp = GUICtrlCreateLabel(" 0s", $x - 11, $y + 15, 70, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
$g_hLblElixirCostCamp = GUICtrlCreateLabel(" 0", $x + 65, $y + 15, 77, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 63, $y + 14, 16, 16)
$g_hLblDarkCostCamp = GUICtrlCreateLabel(" 0", $x + 148, $y + 15, 62, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 146, $y + 14, 16, 16)
$x -= 195
$y += 35
$g_hChkTotalCampForced = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkTotalCampForced", "Force Total Army Camp") & ":", $x + 3, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkTotalCampForced")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkTotalCampForced_Info_01", "If not detected set army camp values (instead ask)"))
$g_hTxtTotalCampForced = GUICtrlCreateInput("220", $x + 137, $y + 3, 30, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "SetComboTroopComp")
GUICtrlSetLimit(-1, 3)
$g_hCalTotalTroops = GUICtrlCreateProgress($x, $y + 22, 407, 10)
$g_hLblTotalProgress = GUICtrlCreateLabel("", $x, $y + 22, 407, 10)
GUICtrlSetBkColor(-1, $COLOR_RED)
GUICtrlSetState(-1, BitOR($GUI_DISABLE, $GUI_HIDE))
$x += 35
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCountTotal", "Total"), $x + 298, $y + 7, -1, -1, $SS_RIGHT)
$g_hLblCountTotal = GUICtrlCreateLabel(0, $x + 333, $y + 5, 30, 15, $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCountTotal_Info_01", "The total Units of Troops should equal Total Army Camps."))
GUICtrlSetBkColor(-1, $COLOR_MONEYGREEN)
GUICtrlCreateLabel("x", $x + 367, $y + 7, -1, -1)
$x = $iStartX
$y = 250
$y += 17
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellFactory, $x, $y - 5, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "SpellCapacity", "Spell Capacity") & ":", $x + 19, $y, -1, -1, $SS_RIGHT)
$g_hTxtTotalCountSpell = GUICtrlCreateCombo("", $x + 100, $y - 3, 35, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "TxtTotalCountSpell_Info_01", "Enter the No. of Spells Capacity. Set to ZERO if you don't want any Spells"))
GUICtrlSetData(-1, "0|2|4|6|7|8|9|10|11", "0")
GUICtrlSetOnEvent(-1, "TotalSpellCountClick")
$y += 13
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtLightningSpells", "Lightning Spell")
$g_ahPicTrainArmySpell[$eSpellLightning] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellLightning] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellLightning] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHealingSpells", "Healing Spell")
$g_ahPicTrainArmySpell[$eSpellHeal] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellHeal] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellHeal] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtRageSpells", "Rage Spell")
$g_ahPicTrainArmySpell[$eSpellRage] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellRage] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellRage] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtJumpSpells", "Jump Spell")
$g_ahPicTrainArmySpell[$eSpellJump] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellJump] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellJump] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtFreezeSpells", "Freeze Spell")
$g_ahPicTrainArmySpell[$eSpellFreeze] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellFreeze] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellFreeze] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtCloneSpells", "Clone Spell")
$g_ahPicTrainArmySpell[$eSpellClone] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellClone] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellClone] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 45
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtPoisonSpells", "Poison Spell")
$g_ahPicTrainArmySpell[$eSpellPoison] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellPoison] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellPoison] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtEarthQuakeSpells", "EarthQuake Spell")
$g_ahPicTrainArmySpell[$eSpellEarthquake] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellEarthquake] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellEarthquake] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtHasteSpells", "Haste Spell")
$g_ahPicTrainArmySpell[$eSpellHaste] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellHaste] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellHaste] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtSkeletonSpells", "Skeleton Spell")
$g_ahPicTrainArmySpell[$eSpellSkeleton] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellSkeleton] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellSkeleton] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtBatSpells", "Bat Spell")
$g_ahPicTrainArmySpell[$eSpellBat] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBatSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Level", -1) & " " & $sSpellName & ":" & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "Mouse_Left_Click", -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellBat] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellBat] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sSpellName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$y += 53
$x = 17
$g_hChkForceBrewBeforeAttack = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkForceBrewBeforeAttack", "Force Brew Spells"), $x, $y + 12, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$x = 210
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellsCost, $x - 33, $y + 10, 24, 24)
$g_hLblTotalTimeSpell = GUICtrlCreateLabel(" 0s", $x - 11, $y + 15, 70, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
$g_hLblElixirCostSpell = GUICtrlCreateLabel(" 0", $x + 65, $y + 15, 77, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 63, $y + 14, 16, 16)
$g_hLblDarkCostSpell = GUICtrlCreateLabel(" 0", $x + 148, $y + 15, 62, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 146, $y + 14, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $iStartX
$y += 45
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrain, $x + 157, $y, 24, 24)
$g_hChkDoubleTrain = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkDoubleTrain", "Double Train Army"), $x + 187, $y + 4, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "DoubleTrainTip", "Train 2nd set of Troops & Spells after training 1st combo") & @CRLF & GetTranslatedFileIni("MBR Global GUI Design", "DoubleTrainTip1", "Make sure to enter exactly the 'Total Camp',") & @CRLF & GetTranslatedFileIni("MBR Global GUI Design", "DoubleTrainTip2", "'Total Spell' and number of Troops/Spells in your Setting") & @CRLF & GetTranslatedFileIni("MBR Global GUI Design", "DoubleTrainTip3", "Note: Donations + Double Train can produce an unbalanced army!"))
GUICtrlSetOnEvent(-1, "chkUseQTrain")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnPrecise, $x + 307, $y, 24, 24)
$g_hChkPreciseArmy = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkPreciseArmy", "Precise Army"), $x + 337, $y + 4, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkPreciseArmy_Info_01", "Check precision of Troops & Spells before training.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "ChkPreciseArmy_Info_02", "Will remove wrong Troops or Spells if any"))
EndFunc
Func CreateBoostSubTab()
Local $sTextBoostLeft = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "TextBoostLeft", "Boosts left")
Local $sTxtTip = ""
$g_hGUI_TRAINARMY_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01_STab_02", "Boost"))
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_01", "Boost Barracks"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 45)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarrackBoost, $x - 10, $y - 4, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkBarrackBoost, $x + 19, $y - 4, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblBarracksBoost", "Barracks") & " " & $sTextBoostLeft, $x + 20 + 29, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblBarracksBoost_Info_01", "Use this to boost your Barracks with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostBarracks = GUICtrlCreateCombo("", $x + 185, $y - 2, 65, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 47
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_02", "Boost Spell Factories"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 45)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellFactoryBoost, $x - 10, $y - 4, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkSpellBoost, $x + 19, $y - 4, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblSpellFactoryBoost", "Spell Factory") & " " & $sTextBoostLeft, $x + 20 + 29, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblSpellFactoryBoost_Info_01", "Use this to boost your Spell Factory with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostSpellFactory = GUICtrlCreateCombo("", $x + 185, $y - 2, 65, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 47
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_05", "Boost Workshop"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 45)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBattleBBoost, $x - 10, $y - 4, 24, 24)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallWBoost, $x + 19, $y - 4, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblWorkshopBoost", "Workshop") & " " & $sTextBoostLeft, $x + 20 + 29, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblWorkshopBoost_Info_01", "Use this to boost your Workshop with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostWorkshop = GUICtrlCreateCombo("", $x + 185, $y - 2, 65, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 47
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_03", "Boost Heroes"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 95)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingBoost, $x - 10, $y - 4, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & " " & $sTextBoostLeft, $x + 20, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblKingBoost_Info_01", "Use this to boost your Barbarian King with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostBarbarianKing = GUICtrlCreateCombo("", $x + 185, $y - 2, 65, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeKing")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenBoost, $x - 10, $y - 4, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & " " & $sTextBoostLeft, $x + 20, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblQueenBoost_Info_01", "Use this to boost your Archer Queen with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostArcherQueen = GUICtrlCreateCombo("", $x + 185, $y - 2, 65, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeQueen")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenBoost, $x - 10, $y - 4, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & " " & $sTextBoostLeft, $x + 20, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblWardenBoost_Info_01", "Use this to boost your Grand Warden with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostWarden = GUICtrlCreateCombo("", $x + 185, $y - 2, 65, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeWarden")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 47
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_04", "Boost Everything"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 70)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrainingPotion, $x - 10, $y - 4, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Potion_01", "Training Potion") & " " & $sTextBoostLeft, $x + 20, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblBoostPotion_Info_01", "Use this to boost everything with Training POTIONS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostTrainingPotion = GUICtrlCreateCombo("", $x + 185, $y - 2, 65, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnResourcePotion, $x - 10, $y - 4, 24, 24)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Potion_02", "Resource Potion") & " " & $sTextBoostLeft, $x + 20, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "LblBoostPotion_Info_02", "Use this to boost everything with Resource POTIONS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostResourcePotion = GUICtrlCreateCombo("", $x + 185, $y - 2, 65, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|No limit", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 47
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Boost", "Group_04", "Boost Schedule"), $x - 20, $y - 20, $g_iSizeWGrpTab3, 70)
$g_hLblBoosthour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", -1) & ":", $x, $y, -1, 15)
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblBoosthours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y)
$g_hLblBoosthours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y)
$g_hLblBoosthours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y)
$g_hLblBoosthours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y)
$g_hLblBoosthours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y)
$g_hLblBoosthours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y)
$g_hLblBoosthours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y)
$g_hLblBoosthours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y)
$g_hLblBoosthours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y)
$g_hLblBoosthours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y)
$g_hLblBoosthours[10] = GUICtrlCreateLabel("10", $x + 180, $y)
$g_hLblBoosthours[11] = GUICtrlCreateLabel("11", $x + 195, $y)
$g_ahLblBoosthoursE = GUICtrlCreateLabel("X", $x + 213, $y + 2, 11, 11)
$y += 15
$g_hChkBoostBarracksHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", "This button will clear or set the entire row of boxes"))
GUICtrlSetOnEvent(-1, "chkBoostBarracksHoursE1")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", "AM"), $x + 5, $y)
$y += 15
$g_hChkBoostBarracksHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkBoostBarracksHoursE2")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", "PM"), $x + 5, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
EndFunc
Func CreateTrainOrderSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01_STab_03", "Train Order"))
SetDefaultTroopGroup(False)
LoadTranslatedTrainTroopsOrderList()
LoadTranslatedBrewSpellsOrderList()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "Group_01", "Training Order"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3)
$g_hChkCustomTrainOrderEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomTrainOrderEnable", "Troops Order"), $x - 5, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomTrainOrderEnable_Info_01", "Enable to select a custom troop training order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomTrainOrderEnable_Info_02", "Changing train order can be useful with CSV scripted attack armies!"))
GUICtrlSetOnEvent(-1, "chkTroopOrder2")
If UBound($g_asTroopOrderList) - 1 <> $eTroopCount Then
If $g_bDebugSetlogTrain Then SetLog("UBound($g_asTroopOrderList) - 1: " & UBound($g_asTroopOrderList) - 1 & " = " & "$eTroopCount: " & $eTroopCount, $COLOR_DEBUG)
SetLog("Monkey ate bad banana, fix $g_asTroopOrderList & $eTroopCount arrays!", $COLOR_RED)
EndIf
Local $sComboData = ""
For $j = 0 To UBound($g_asTroopOrderList) - 1
$sComboData &= $g_asTroopOrderList[$j] & "|"
Next
Local $txtTroopOrder = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "TxtTroopOrder", "Enter sequence order for training of troop #")
$y += 23
For $z = 0 To $eTroopCount - 1
If $z < 12 Then
GUICtrlCreateLabel($z + 1 & ":", $x - 16, $y + 2, -1, 18)
$g_ahCmbTroopOrder[$z] = GUICtrlCreateCombo("", $x, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgTroopOrder[$z] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 96, $y + 1, 18, 18)
$y += 22
Else
If $z = 12 Then
$x += 128
$y = 45 + 23
EndIf
GUICtrlCreateLabel($z + 1 & ":", $x - 13, $y + 2, -1, 18)
$g_ahCmbTroopOrder[$z] = GUICtrlCreateCombo("", $x + 4, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgTroopOrder[$z] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 100, $y + 1, 18, 18)
$y += 22
EndIf
Next
$y += 23
$g_hBtnRemoveTroops = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnRemoveTroops", "Empty troop list"), $x, $y, 110, 22)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnRemoveTroops_Info_01", "Push button to remove all troops from list and start over"))
GUICtrlSetOnEvent(-1, "btnRemoveTroops")
$x = 25
$y = 45 + 291
$g_hBtnTroopOrderSet = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnTroopOrderSet", "Apply New Order"), $x, $y, 222, 20)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnTroopOrderSet_Info_01", "Push button when finished selecting custom troop training order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnTroopOrderSet_Info_02", "Icon changes color based on status: Red= Not Set, Green = Order Set") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnTroopOrderSet_Info_03", "When not all troop slots are filled, will use random troop order in empty slots!"))
GUICtrlSetOnEvent(-1, "btnTroopOrderSet")
$g_ahImgTroopOrderSet = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 226, $y + 2, 18, 18)
Local $x = 300, $y = 45
$g_hChkCustomBrewOrderEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomBrewOrderEnable", "Spells Order"), $x - 5, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomBrewOrderEnable_Info_01", "Enable to select a Brew Spells order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "ChkCustomBrewOrderEnable_Info_02", "Changing spells order can be useful with CSV scripted attack armies!"))
GUICtrlSetOnEvent(-1, "chkSpellsOrder")
Local $sComboData = ""
For $j = 0 To UBound($g_asSpellsOrderList) - 1
$sComboData &= $g_asSpellsOrderList[$j] & "|"
Next
Local $txtSpellsOrder = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "txtSpellsOrder", "Enter sequence order for brew Spells #")
$y += 23
For $z = 0 To $eSpellCount - 1
GUICtrlCreateLabel($z + 1 & ":", $x - 16, $y + 2, -1, 18)
$g_ahCmbSpellsOrder[$z] = GUICtrlCreateCombo("", $x, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUISpellsOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtSpellsOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgSpellsOrder[$z] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 96, $y + 1, 18, 18)
$y += 22
Next
$y += 20
$g_hBtnRemoveSpells = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnRemoveSpells", "Empty Spell list"), $x, $y, 94, 22)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnRemoveSpells_Info_01", "Push button to remove all spells from list and start over"))
GUICtrlSetOnEvent(-1, "BtnRemoveSpells")
$y += 25
$g_hBtnSpellsOrderSet = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnSpellsOrderSet", "Apply New Order"), $x, $y, 94, 22)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnSpellsOrderSet_Info_01", "Push button when finished selecting custom spells brew order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnSpellsOrderSet_Info_02", "Icon changes color based on status: Red= Not Set, Green = Order Set") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_TrainingOrder", "BtnSpellsOrderSet_Info_03", "When not all spells slots are filled, will use random spell order in empty slots!"))
GUICtrlSetOnEvent(-1, "BtnSpellsOrderSet")
$g_ahImgSpellsOrderSet = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 98, $y + 2, 18, 18)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateOptionsSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01_STab_04", "Options"))
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "Group_01", "Training Idle Time"), $x - 20, $y - 20, 171, 315)
$g_hChkCloseWhileTraining = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWhileTraining", "Close While Training"), $x - 12, $y, 140, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWhileTraining_Info_01", "Option will exit CoC game for time required to complete TROOP training when SHIELD IS ACTIVE") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWhileTraining_Info_02", "Close for Spell creation will be enabled when 'Wait for Spells' is selected on Search tabs") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWhileTraining_Info_03", "Close for Hero healing will be enabled when 'Wait for Heroes' is enabled on Search tabs"))
GUICtrlSetOnEvent(-1, "chkCloseWaitEnable")
$y += 28
$g_hChkCloseWithoutShield = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWithoutShield", "Without Shield"), $x + 18, $y + 1, 110, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWithoutShield_Info_01", "Option will ALWAYS close CoC for idle training time and when NO SHIELD IS ACTIVE!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseWithoutShield_Info_02", "Note - You can be attacked and lose trophies when this option is enabled!")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkCloseWaitTrain")
$g_hPicCloseWaitTrain = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnNoShield, $x - 13, $y, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hChkCloseEmulator = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseEmulator", "Close Emulator"), $x + 18, $y + 1, 110, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseEmulator_Info_01", "Option will close Android Emulator completely when selected") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkCloseEmulator_Info_02", "Adding this option may increase offline time slightly due to variable times required for startup")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "btnCloseWaitStop")
$g_hPicCloseWaitStop = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRecycle, $x - 13, $y + 13, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hChkSuspendComputer = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkSuspendComputer", "Suspend Computer"), $x + 18, $y + 1, 110, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkSuspendComputer_Info_01", "Option will suspend computer when selected\r\nAdding this option may increase offline time slightly due to variable times required for startup")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "btnCloseWaitSuspendComputer")
$y += 28
$g_hChkRandomClose = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkRandomClose", "Random Close"), $x + 18, $y + 1, 110, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkRandomClose_Info_01", "Option will Randomly choose between time out, close CoC, or Close emulator when selected") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkRandomClose_Info_02", "Adding this option may increase offline time slightly due to variable times required for startup"))
GUICtrlSetOnEvent(-1, "btnCloseWaitStopRandom")
$y += 28
$g_hRdoCloseWaitExact = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitExact", "Exact Time"), $x + 18, $y + 1, 110, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitExact_Info_01", "Select to wait exact time required for troops to complete training"))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "btnCloseWaitRandom")
$g_hPicCloseWaitExact = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 13, $y + 13, 24, 24)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitExact_Info_02", "Select how much time to wait when feature enables"))
$y += 24
$g_hRdoCloseWaitRandom = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitRandom", "Random Time"), $x + 18, $y + 1, 110, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "RdoCloseWaitRandom_Info_01", "Select to ADD a random extra wait time like human who forgets to clash"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "btnCloseWaitRandom")
$y += 28
$g_hCmbCloseWaitRdmPercent = GUICtrlCreateCombo("", $x + 36, $y, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "CmbCloseWaitRdmPercent_Info_01", "Enter maximum percentage of additional time to be used creating random wait times,") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "CmbCloseWaitRdmPercent_Info_02", "Bot will compute a random wait time between exact time needed, and") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "CmbCloseWaitRdmPercent_Info_03", "maximum random percent entered to appear more human like")
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15", "10")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblCloseWaitRdmPercent = GUICtrlCreateLabel("%", $x + 84, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hLblCloseWaitingTroops = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblCloseWaitingTroops", "Minimum Time To Close") & ": ", $x - 12, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblCloseWaitingTroops_Info_01", "Will be close CoC If train time troops >= (Minimum time required to close)" & @CRLF & "Just stay in the main screen if train time troops < (Minimum time required to close)"))
GUICtrlSetOnEvent(-1, "chkCloseWaitEnable")
$y += 22
$g_hLblSymbolWaiting = GUICtrlCreateLabel(">", $x + 26, $y + 3, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblSymbolWaiting_Info_01", "Enter number Minimum time to close in minutes for close CoC which you want, Default Is (2)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbMinimumTimeClose = GUICtrlCreateCombo("", $x + 36, $y, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "2|3|4|5|6|7|8|9|10", "2")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWaitingInMinutes = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", "min."), $x + 84, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hChkTrainLogoutMaxTime = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "TrainLogoutMaxTime", "Max Logout Time") & ": ", $x - 14, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "TrainLogoutMaxTime_Info_01", "Only allow logout for a maximum amount of time")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTrainLogoutMaxTime")
$g_hTxtTrainLogoutMaxTime = GUICtrlCreateInput("4", $x + 95, $y + 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$g_hLblTrainLogoutMaxTime = GUICtrlCreateLabel("min.", $x + 127, $y + 4, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 50
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "Group_02", "Train Click Timing"), $x - 20, $y - 20, 171, 60)
$g_hLblTrainITDelay = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblTrainITDelay", "delay"), $x - 10, $y, 37, 30)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblTrainITDelay_Info_01", "Increase the delay if your PC is slow or to create human like training click speed")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainITDelayTime = GUICtrlCreateLabel("40 ms", $x - 10, $y + 15, 37, 30)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hSldTrainITDelay = GUICtrlCreateSlider($x + 30, $y, 90, 25, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblTrainITDelay_Info_01", -1))
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-100, 100)
GUICtrlSetLimit(-1, 500, 1)
GUICtrlSetData(-1, 40)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldTrainITDelay")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 55 + 151 + 5
$y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "Group_03", "Training Add Random Delay"), $x - 20, $y - 20, 173, 81)
$y += 15
$g_hChkTrainAddRandomDelayEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkTrainAddRandomDelayEnable", "Add Random Delay"), $x + 18, $y - 11, 130, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkTrainAddRandomDelayEnable_Info_01", "Add random delay between two calls of train army.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "ChkTrainAddRandomDelayEnable_Info_02", "This option reduces the calls to the training window  humanizing the bot spacing calls each time with a causal interval chosen between the minimum and maximum values indicated below.")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkAddDelayIdlePhaseEnable")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelay, $x - 13, $y - 13, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 18
$y += 18
$g_hLblAddDelayIdlePhaseBetween = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblTrainAddRandomDelay_Info_01", "Between"), $x - 12, $y, 50, 30)
$g_hTxtAddRandomDelayMin = GUICtrlCreateInput($g_iTrainAddRandomDelayMin, $x + 32, $y - 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 999)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops_Options", "LblTrainAddRandomDelay_Info_02", "And"), $x + 61, $y, 20, 30)
$g_hTxtAddRandomDelayMax = GUICtrlCreateInput($g_iTrainAddRandomDelayMax, $x + 82, $y - 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 999)
$g_hLblAddDelayIdlePhaseSec = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", "sec."), $x + 110, $y, 20, 30)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_SEARCH = 0
Global $g_ahChkMaxMortar[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxWizTower[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxAirDefense[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxXBow[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxInferno[$g_iModeCount] = [0, 0, 0], $g_ahChkMaxEagle[$g_iModeCount] = [0, 0, 0]
Global $g_ahCmbWeakMortar[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakWizTower[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakAirDefense[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakXBow[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakInferno[$g_iModeCount] = [0, 0, 0], $g_ahCmbWeakEagle[$g_iModeCount] = [0, 0, 0]
Global $g_ahPicWeakMortar[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakWizTower[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakAirDefense[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakXBow[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakInferno[$g_iModeCount] = [0, 0, 0], $g_ahPicWeakEagle[$g_iModeCount] = [0, 0, 0]
Global $g_ahChkMeetOne[$g_iModeCount] = [0, 0, 0]
Global $g_hGUI_DEADBASE = 0
Global $g_hGUI_DEADBASE_ATTACK_STANDARD = 0
Global $g_hCmbStandardDropOrderDB = 0, $g_hCmbStandardDropSidesDB = 0, $g_hCmbStandardUnitDelayDB = 0, $g_hCmbStandardWaveDelayDB = 0, $g_hChkRandomSpeedAtkDB = 0, $g_hChkSmartAttackRedAreaDB = 0, $g_hCmbSmartDeployDB = 0, $g_hChkAttackNearGoldMineDB = 0, $g_hChkAttackNearElixirCollectorDB = 0, $g_hChkAttackNearDarkElixirDrillDB = 0
Global $g_hLblSmartDeployDB = 0, $g_hPicAttackNearDarkElixirDrillDB = 0
Global $g_hBtnCustomDropOrderDB = 0
Func CreateAttackSearchDeadBaseStandard()
$g_hGUI_DEADBASE_ATTACK_STANDARD = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $sTxtTip = ""
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Group_01", "Deploy"), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Label_01", "Troop Drop Order"), $x, $y, 143, 18, $SS_LEFT)
$y += 15
$g_hCmbStandardDropOrderDB = GUICtrlCreateCombo("", $x, $y, 150, Default, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_01", "Default(All Troops)") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_02", "Barch/BAM/BAG") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_03", "GiBarch"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_01", "Select a preset troop drop order.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_02", "Each option deploys troops in a different order and in different waves") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_03", "Only the troops selected in the ""Only drop these troops"" option will be dropped"))
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Label_02", "Attack on") & ":", $x, $y + 5, -1, -1)
$g_hCmbStandardDropSidesDB = GUICtrlCreateCombo("", $x + 55, $y, 120, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_01", "Attack on a single side, penetrates through base") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_02", "Attack on two sides, penetrates through base") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_03", "Attack on three sides, gets outer and some inside of base") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_04", "Select the No. of sides to attack on."))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_01", "one side") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_02", "two sides") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_03", "three sides") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_04", "all sides equally") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_07", "Classic Four Fingers"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_04", -1))
GUICtrlSetOnEvent(-1, "cmbStandardDropSidesDB")
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay", "Delay Unit") & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay_Info_01", "This delays the deployment of troops, 1 (fast) = like a Bot, 10 (slow) = Like a Human.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay_Info_02", "Random will make bot more varied and closer to a person.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardUnitDelayDB = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlSetOnEvent(-1, "chkSpeedAtkDB")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardWaveDelay_Info_01", "Wave") & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardWaveDelayDB = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlSetOnEvent(-1, "chkSpeedAtkDB")
$y += 22
$g_hChkRandomSpeedAtkDB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkRandomSpeedAtk", "Randomize delay for Units && Waves"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkDB")
$y +=22
$g_hChkSmartAttackRedAreaDB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkSmartAttackRedArea", "Use Smart Attack: Near Red Line."), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkSmartAttackRedArea_Info_01", "Use Smart Attack to detect the outer 'Red Line' of the village to attack. And drop your troops close to it."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSmartAttackRedAreaDB")
$y += 22
$g_hLblSmartDeployDB = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy", "Drop Type") & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_01", "Select the Deploy Mode for the waves of Troops.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_02", "Type 1: Drop a single wave of troops on each side then switch troops, OR") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_03", "Type 2: Drop a full wave of all troops (e.g. giants, barbs and archers) on each side then switch sides.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbSmartDeployDB = GUICtrlCreateCombo("", $x + 55, $y, 120, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_01", "Sides, then Troops") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_02", "Troops, then Sides"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_01", -1))
_GUICtrlSetTip(-1, $sTxtTip)
$y += 26
$g_hChkAttackNearGoldMineDB = GUICtrlCreateCheckbox("", $x + 20, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearGoldMine_Info_01", "Drop troops near Gold Mines")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 40 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
$g_hChkAttackNearElixirCollectorDB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearElixirCollector_Info_01", "Drop troops near Elixir Collectors")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 55
$g_hChkAttackNearDarkElixirDrillDB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearDarkElixirDrill_Info_01", "Drop troops near Dark Elixir Drills")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicAttackNearDarkElixirDrillDB = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 20 , $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 40
$x = 98
$g_hBtnCustomDropOrderDB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder", "Drop Order"), $x, $y, 85, 25)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder_Info_01", "Select Custom Troops Dropping Order"))
GUICtrlSetOnEvent(-1, "CustomDropOrder")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_DEADBASE_ATTACK_SCRIPTED = 0
Global $g_hCmbScriptNameDB = 0, $g_hCmbScriptRedlineImplDB = 0, $g_hCmbScriptDroplineDB = 0
Global $g_hLblNotesScriptDB = 0, $g_hBtnAttNowDB = 0
Func CreateAttackSearchDeadBaseScripted()
$g_hGUI_DEADBASE_ATTACK_SCRIPTED = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "Group_01", "Deploy"), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
$g_hCmbScriptNameDB = GUICtrlCreateCombo("", $x, $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptName", "Choose the script; You can edit/add new scripts located in folder: 'CSV/Attack'"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptNameDB")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnReload, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconReload_Info_01", "Reload Script Files"))
GUICtrlSetOnEvent(-1, 'UpdateComboScriptNameDB')
$y += 25
$g_hLblNotesScriptDB = GUICtrlCreateLabel("", $x, $y + 3, 200, 195)
$g_hBtnAttNowDB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "btnAttNow", "Attack Now"), $x + 70, $y + 198, 91, 23)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "btnAttNow_Info_01", "Attack now Button Which it will make CSV Makers/testers life Easy. You should be in Attack Screen"))
GUICtrlSetBkColor(-1, 0xBAD9C8)
GUICtrlSetOnEvent(-1, "AttackNowDB")
$g_hCmbScriptRedlineImplDB = GUICtrlCreateCombo("", $x, $y + 225, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptRedlineImpl", "ImgLoc Raw Redline (default)|ImgLoc Redline Drop Points|Original Redline|External Edges"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrRedlineRoutine[$DB])
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptRedlineImpl_Info_01", "Choose the Redline implementation. ImgLoc Redline is default and best."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptRedlineImplDB")
$g_hCmbScriptDroplineDB = GUICtrlCreateCombo("", $x, $y + 250, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptDropline", "Drop line fix outer corner|Drop line fist Redline point|Full Drop line fix outer corner|Full Drop line fist Redline point|No Drop line"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrDroplineEdge[$DB])
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptDropline_Info_01", "Choose the drop line edges. Default is outer corner and safer. First Redline point can improve attack."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptDroplineDB")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CSVSpeed", "CSV Deployment Speed"), $x + 25, $y + 280, -1, 18)
$cmbCSVSpeed[$DB] = GUICtrlCreateCombo("", $x + 150, $y + 276, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0.5x|0.75x|1x|1.25x|1.5x|2x|3x|4x|5x", "1x")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEdit, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconShow-Edit_Info_01", "Show/Edit current Attack Script"))
GUICtrlSetOnEvent(-1, "EditScriptDB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnAddcvs, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconCreate_Info_01", "Create a new Attack Script"))
GUICtrlSetOnEvent(-1, "NewScriptDB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCopy, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconCopy_Info_01", "Copy current Attack Script to a new name"))
GUICtrlSetOnEvent(-1, "DuplicateScriptDB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrain, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconApply_Info_01", "Apply Settings of troop, spell, redline, dropline, and request"))
GUICtrlSetOnEvent(-1, "ApplyScriptDB")
GUICtrlCreateGroup("", -99, -99, 1, 1)
UpdateComboScriptNameDB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $g_sAttackScrScriptName[$DB])
If $tempindex = -1 Then $tempindex = 0
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, $tempindex)
EndFunc
Global $g_hGUI_DEADBASE_ATTACK_SMARTFARM = 0
Global $g_hCmbStandardUnitDelayDB1, $g_hCmbStandardWaveDelayDB1, $g_hChkRandomSpeedAtkDB1
Global $g_hTxtInsidePercentage = 0, $g_hTxtOutsidePercentage = 0, $g_hBtnCustomDropOrderDB1 = 0, $g_hChkDebugSmartFarm = 0
Func CreateAttackSearchDeadBaseSmartFarm()
$g_hGUI_DEADBASE_ATTACK_SMARTFARM = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $sTxtTip = ""
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "Group_01", "Options"), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "Lbl-CmbStandardUnitDelay", "Delay Unit") & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "Lbl-CmbStandardUnitDelay_Info_01", "This delays the deployment of troops, 1 (fast) = like a Bot, 10 (slow) = Like a Human.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "Lbl-CmbStandardUnitDelay_Info_02", "Random will make bot more varied and closer to a person.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardUnitDelayDB1 = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlSetOnEvent(-1, "chkSpeedAtkDB")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "Lbl-CmbStandardWaveDelay_Info_01", "Wave") & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardWaveDelayDB1 = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlSetOnEvent(-1, "chkSpeedAtkDB")
$y += 22
$g_hChkRandomSpeedAtkDB1 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "ChkRandomSpeedAtk", "Randomize delay for Units && Waves"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkDB")
$y += 40
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "Lbl-TxtInsidePercentage", "Inside resources") & ":", $x, $y + 2, -1, -1)
$g_hTxtInsidePercentage = GUICtrlCreateInput("65" , $x + 90, $y , 25 , -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "txt-TxtInsidePercentage", "Percentage to force attack in one side only"))
GUICtrlCreateLabel("%" , $x + 117 , $y + 3)
$y += 22
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "Lbl-TxtOutsidePercentage", "Outside resources") & ":", $x, $y + 2, -1, -1)
$g_hTxtOutsidePercentage = GUICtrlCreateInput("80" , $x + 90 , $y , 25 , -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "txt-TxtOutsidePercentage", "Percentage to force attack in 4 sides"))
GUICtrlCreateLabel("%" , $x + 117 , $y + 3)
$y += 40
$x = 98
$g_hBtnCustomDropOrderDB1 = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder", -1), $x, $y, 85, 25)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder_Info_01", -1))
GUICtrlSetOnEvent(-1, "CustomDropOrder")
$x = 35
$g_hChkDebugSmartFarm = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Smart Farm", "ChkDebugSmartFarm", "Debug Smart Farm"), $x, $y + 100, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkDBActivateSearches = 0, $g_hTxtDBSearchesMin = 0, $g_hTxtDBSearchesMax = 0
Global $g_hChkDBActivateTropies = 0, $g_hTxtDBTropiesMin = 0, $g_hTxtDBTropiesMax = 0
Global $g_hChkDBActivateCamps = 0, $g_hTxtDBArmyCamps = 0
Global $g_hChkDBKingWait = 0, $g_hChkDBQueenWait = 0, $g_hChkDBWardenWait = 0, $g_hChkNotWaitHeros = 0, $g_hChkDBNotWaitHeroes = 0
Global $g_hChkDBSpellsWait = 0, $g_hChkDBWaitForCastle = 0
Global $g_hLblDBSearches = 0, $g_hLblDBTropies = 0, $g_hLblDBArmyCamps = 0
Global $g_hPicDBHeroesWait = 0, $g_hTxtDBHeroesWait = 0, $g_hPicDBKingWait = 0, $g_hPicDBKingSleepWait = 0, $g_hPicDBQueenWait = 0, $g_hPicDBQueenSleepWait = 0, $g_hPicDBWardenWait = 0, $g_hPicDBWardenSleepWait = 0
Global $g_hPicDBLightSpellWait = 0, $g_hPicDBHealSpellWait = 0, $g_hPicDBRageSpellWait = 0, $g_hPicDBJumpSpellWait = 0, $g_hPicDBFreezeSpellWait = 0, $g_hPicDBPoisonSpellWait = 0, $g_hPicDBEarthquakeSpellWait = 0, $g_hPicDBHasteSpellWait = 0
Global $g_hCmbDBMeetGE = 0, $g_hTxtDBMinGold = 0, $g_hTxtDBMinElixir = 0, $g_hTxtDBMinGoldPlusElixir = 0
Global $g_hChkDBMeetDE = 0, $g_hTxtDBMinDarkElixir = 0
Global $g_hChkDBMeetTrophy = 0, $g_hTxtDBMinTrophy = 0, $g_hTxtDBMaxTrophy = 0
Global $g_hChkDBMeetTH = 0, $g_hCmbDBTH = 0, $g_hChkDBMeetTHO = 0
Global $g_hGrpDBFilter = 0, $g_hPicDBMinGold = 0, $g_hPicDBMinElixir = 0, $g_hPicDBMinGPEGold = 0, $g_hPicDBMinDarkElixir = 0, $g_hPicDBMinTrophies = 0
Global $g_ahPicDBMaxTH[13]
Func CreateAttackSearchDeadBaseSearch()
Local $sTxtLightningSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortLightningSpells", -1)
Local $sTxtHealSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHealSpells", -1)
Local $sTxtRageSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortRageSpells", -1)
Local $sTxtJumpSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortJumpSpells", -1)
Local $sTxtFreezeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortFreezeSpells", -1)
Local $sTxtPoisonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortPoisonSpells", -1)
Local $sTxtEarthquakeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortEarthquakeSpells", -1)
Local $sTxtHasteSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHasteSpells", -1)
Local $sTxtSkeletonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortSkeletonSpells", -1)
Local $sTxtBatSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortBatSpells", -1)
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_01", "Start Search IF"), $x - 20, $y - 20, 190, $g_iSizeHGrpTab4)
$x -= 15
$g_hChkDBActivateSearches = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches", "Search"), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", "Note - enables SEARCH range for this attack type ONLY.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", "Setting will not set search limit to restart search process!"))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBActivateSearches")
$g_hTxtDBSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinSearches_Info_01", "Set the Min. number of searches to activate this attack option") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblDBSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtDBSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxSearches_Info_01", "Set the Max number of searches to activate this attack option") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkDBActivateTropies = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", "Trophies"), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", "This option will NOT adjust tropies to stay in range entered!"))
GUICtrlSetOnEvent(-1, "chkDBActivateTropies")
$g_hTxtDBTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinTropies_Info_01", "Set the Min. number of tropies where this attack will be used") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblDBTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtDBTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxTropies_Info_01", "Set the Max number of tropies where this attack will be used") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkDBActivateCamps = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps", "Army Camps"), $x, $y, 110, 18)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps_Info_01", "Set the % Army camps required to enable this attack option while searching")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBActivateCamps")
$g_hLblDBArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtDBArmyCamps = GUICtrlCreateInput("80", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 23
$g_hPicDBHeroesWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 1, $y + 3, 16, 16)
$g_hTxtDBHeroesWait = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtHeroesWait", "Wait for Heroes to be Ready") & ":", $x + 20, $y + 4, 180, 18)
$y += 20
$x += 20
$g_hChkDBKingWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
Local $sTxtKingWait = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtHeroesWait_Info_01", "Wait for Hero option disabled when continuous Upgrade Hero selected!")
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtKingWait_Info_01", "Wait for King to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtKingWait_Info_02", "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBKingWait")
$g_hPicDBKingWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBKingSleepWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$x += 55
$g_hChkDBQueenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtQueenWait_Info_01", "Wait for Queen to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtQueenWait_Info_02", "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBQueenWait")
$g_hPicDBQueenWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBQueenSleepWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$x += 55
$g_hChkDBWardenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWardenWait_Info_01", "Wait for Warden to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWardenWait_Info_02", "Enabled with TownHall 11")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBWardenWait")
$g_hPicDBWardenWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBWardenSleepWait=_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 70
$x = 10
$g_hChkDBNotWaitHeroes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkNotWaitHeroes", "Not wait for Heroes when upgrade"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkNotWaitHeroes_Info_01", "Continue to attack, when Upgrade heroes and enable Wait for heroes."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkNotWaitHeroes")
$y += 22
$x = 8
$g_hPicDBLightSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 22, 22)
$g_hPicDBHealSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x + 23, $y, 22, 22)
$g_hPicDBRageSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x + 46, $y, 22, 22)
$g_hPicDBJumpSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x + 69, $y, 22, 22)
$g_hPicDBFreezeSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 92, $y, 22, 22)
$g_hPicDBPoisonSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x + 115, $y, 22, 22)
$g_hPicDBEarthquakeSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x + 138, $y, 22, 22)
$g_hPicDBHasteSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x + 161, $y, 22, 22)
$y += 25
$x = 10
$g_hChkDBSpellsWait = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait", "Wait for Spells to be Ready"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait_Info_01", "Stop searching for this attack type when Spells are not ready") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait_Info_02", "Warning: Do not enable unless you have spell factory or bot will not attack!"))
GUICtrlSetOnEvent(-1, "chkDBSpellsWait")
$g_hChkDBWaitForCastle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastle", "Wait for Clan Castle"), $x, $y + 20, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastle_Info_01", "Wait until your Clan Castle is filled, as requested."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpDBFilter = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_02", "Filters"), $x - 20, $y - 20, 225, $g_iSizeHGrpTab4)
$x -= 15
$g_hCmbDBMeetGE = GUICtrlCreateCombo("", $x, $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", "G And E") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_02", "G Or E") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_03", "G + E"), GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_01", "Search for a base that meets the values set for Gold And/Or/Plus Elixir.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_02", "AND: Both conditions must meet, Gold and Elixir.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_03", "OR: One condition must meet, Gold or Elixir.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_04", "+ (PLUS): Total amount of Gold + Elixir must meet."))
GUICtrlSetOnEvent(-1, "cmbDBGoldElixir")
$g_hTxtDBMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGold_Info_01", "Set the Min. amount of Gold to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicDBMinGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinElixir_Info_01", "Set the Min. amount of Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicDBMinElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtDBMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGoldPlusElixir_Info_01", "Set the Min. amount of Gold + Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicDBMinGPEGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 140, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkDBMeetDE = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE", "Dark Elixir"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetDE")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE_Info_01", "Search for a base that meets the value set for Min. Dark Elixir."))
$g_hTxtDBMinDarkElixir = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinDarkElixir_Info_01", "Set the Min. amount of Dark Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicDBMinDarkElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkDBMeetTrophy = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetTrophy")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_01", "Search for a base that meets the value set for Min. Trophies."))
$g_hTxtDBMinTrophy = GUICtrlCreateInput("0", $x + 85, $y, 20, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_02", "Set the Min. amount of Trophies to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel("-", $x + 109, $y + 2, -1, -1)
$g_hTxtDBMaxTrophy = GUICtrlCreateInput("0", $x + 115, $y, 20, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_03", "Set the Max. amount of Trophies to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
$g_hPicDBMinTrophies = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkDBMeetTH = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "LblTownhall", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetTH")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTH_Info_01", "Search for a base that meets the value set for Max. Townhall Level."))
$g_hCmbDBTH = GUICtrlCreateCombo("", $x + 85, $y - 1, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbDBTH", "Set the Max. level of the Townhall to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "4-6|7|8|9|10|11|12", "4-6")
GUICtrlSetOnEvent(-1, "CmbDBTH")
$g_ahPicDBMaxTH[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_SHOW)
$g_ahPicDBMaxTH[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDBMaxTH[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDBMaxTH[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDBMaxTH[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDBMaxTH[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahPicDBMaxTH[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV12, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 24
$g_hChkDBMeetTHO = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTHO", "Townhall Outside"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTHO_Info_01", "Search for a base that has an exposed Townhall. (Outside of Walls)"))
$y += 24
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_03", "Weak base | max defenses"), $x, $y, 215, 100)
$x += 5
$y += 20
Local $xStartColumn = $x, $yStartColumn = $y
$g_ahChkMaxMortar[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxMortar", "Search for a base that has Mortar below this level."))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakMortar[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 52, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxMortar_Info_01", "Set the Max. level of the Mortar to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10|Lvl 11", "Lvl 5")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakMortar[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnMortar, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxWizTower[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxWizTower", "Search for a base that has Wizard Tower below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakWizTower[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 52, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxWizTower_Info_01", "Set the Max. level of the Wizard Tower to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10|Lvl 11", "Lvl 4")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakWizTower[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizTower, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxAirDefense[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxAirDefense", "Search for a base that has Air Defense below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakAirDefense[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 53, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxAirDefense_Info_01", "Set the Max. level of the Air Defense to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10", "Lvl 7")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakAirDefense[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnAirdefense, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStartColumn + 104
$y = $yStartColumn
$g_ahChkMaxXBow[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxXBow", "Search for a base that has X-Bow below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakXBow[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxXBow_Info_01", "Set the Max. level of the X-Bow to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakXBow[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnXBow3, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxInferno[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxInferno", "Search for a base that has Inferno below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakInferno[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxInferno_Info_01", "Set the Max. level of the Inferno Tower to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakInferno[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnInferno4, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxEagle[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxEagle", "Search for a base that has Eagle Artillery below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakEagle[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxEagle_Info_01", "Set the Max. level of the Eagle Artillery to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3", "Lvl 1")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakEagle[$DB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEagleArt, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 44
$x = $xStartColumn
$g_ahChkMeetOne[$DB] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetOne", "Meet One Then Attack"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetOne_Info_01", "Just meet only ONE of the above conditions, then Attack."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbDBAlgorithm = 0, $g_hCmbDBSelectTroop = 0, $g_hChkDBKingAttack = 0, $g_hChkDBQueenAttack = 0, $g_hChkDBWardenAttack = 0, $g_hChkDBDropCC = 0
Global $g_hChkDBLightSpell = 0, $g_hChkDBHealSpell = 0, $g_hChkDBRageSpell = 0, $g_hChkDBJumpSpell = 0, $g_hChkDBFreezeSpell = 0, $g_hChkDBCloneSpell = 0, $g_hChkDBPoisonSpell = 0, $g_hChkDBEarthquakeSpell = 0, $g_hChkDBHasteSpell = 0, $g_hChkDBSkeletonSpell = 0, $g_hChkDBBatSpell = 0
Global $g_hPicDBKingAttack = 0, $g_hPicDBQueenAttack = 0, $g_hPicDBWardenAttack = 0, $g_hPicDBDropCC = 0
Global $g_hPicDBLightSpell = 0, $g_hPicDBHealSpell = 0, $g_hPicDBRageSpell = 0, $g_hPicDBJumpSpell = 0, $g_hPicDBFreezeSpell = 0, $g_hPicDBCloneSpell = 0, $g_hPicDBPoisonSpell = 0, $g_hPicDBEarthquakeSpell = 0, $g_hPicDBHasteSpell = 0, $g_hPicDBSkeletonSpell = 0, $g_hPicDBBatSpell = 0
Global $g_hChkTHSnipeBeforeDBEnable = 0, $g_hTxtTHSnipeBeforeDBTiles = 0, $g_hCmbTHSnipeBeforeDBScript = 0
Global $g_hLblTHSnipeBeforeDBTiles = 0
Global $g_hCmbDBSiege = 0, $g_hCmbDBWardenMode = 0
Func CreateAttackSearchDeadBaseAttack()
Local $sTxtTip = ""
Local $x = 25, $y = 40
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_01", "Attack with"), $x - 20, $y - 15, 145, 263)
$x -= 15
$y += 2
$g_hCmbDBAlgorithm = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, "")
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_01", "Standard Attack") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_02", "Scripted Attack") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_04", "SmartFarm Attack"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_01", -1))
GUICtrlSetOnEvent(-1, "cmbDBAlgorithm")
$y += 27
$g_hCmbDBSelectTroop = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", "Use All Troops") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_02", "Use Troops in Barracks") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_03", "Barb Only") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_04", "Arch Only") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_05", "B+A") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_06", "B+Gob") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_07", "A+Gob") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_08", "B+A+Gi") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_09", "B+A+Gob+Gi") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_10", "B+A+Hog Rider") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_11", "B+A+Minion"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Info_01", "Select the troops to use in attacks"))
$y += 27
$g_hPicDBKingAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x , $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_01", "Use your King when Attacking...") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_02", "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBQueenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_01", "Use your Queen when Attacking...") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_02", "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 46
$g_hPicDBWardenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_01", "Use your Warden when Attacking...") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_02", "Enabled with Townhall 11")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBWardenAttack")
$x += 46
$g_hCmbDBWardenMode = GUICtrlCreateCombo("", $x, $y, 89, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Item_01", "Ground mode") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Item_02", "Air mode") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Item_03", "Default mode"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Item_03", -1))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Tip", "Select Grand Warden's mode 'Ground' or 'Air'" & @CRLF & "The Bot will always check Grand Warden's mode before every attack" & @CRLF & "Choose 'Default mode' to bypass Grand Warden check")
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 46
$g_hPicDBDropCC = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clan Castle_Info_01", "Drop your Clan Castle in battle if it contains troops.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBDropCC")
$x += 46
$g_hCmbDBSiege = GUICtrlCreateCombo("", $x, $y, 89, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_01", "Castle only") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_02", "Wall Wrecker") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_03", "Battle Blimp") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_04", "Stone Slammer") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_05", "Any Siege") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_06", "Default"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_06", -1))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Tip", "Select Castle or Siege to be used." & @CRLF & "The Bot will always check Castle/Siege type before every attack." & @CRLF & "Choose 'Default' to bypass Castle/Siege check")
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 46
$g_hPicDBLightSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Light_Info_01", "Use your Light Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBHealSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Healing_Info_01", "Use your Healing Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBRageSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Rage_Info_01", "Use your Rage Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicDBJumpSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Jump_Info_01", "Use your Jump Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBFreezeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Freeze_Info_01", "Use your Freeze Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBCloneSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clone_Info_01", "Use your Clone Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBCloneSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicDBPoisonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Poison_Info_01", "Use your Poison Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBEarthquakeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Earthquake_Info_01", "Use your Earthquake Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBHasteSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Haste_Info_01", "Use your Haste Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicDBSkeletonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Skeleton_Info_01", "Use your Skeletons Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBSkeletonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBBatSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBatSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Bat_Info_01", "Use your Bats Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBBatSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 308
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_02", "TH Snipe"), $x - 5, $y - 20, 145, 84, $SS_CENTER)
$g_hChkTHSnipeBeforeDBEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkTHSnipeBeforeEnable", "Snipe TH External first"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkTHSnipeBeforeEnable_Info_01", "If TH is external start with a TH Snipe"))
GUICtrlSetOnEvent(-1, "chkTHSnipeBeforeDBEnable")
$y += 16
$g_hLblTHSnipeBeforeDBTiles = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblTHSnipeBeforeTiles", "Add Tiles")& ":", $x, $y + 3, 70, -1, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTHSnipeBeforeDBTiles = GUICtrlCreateInput("2", $x + 75, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblTHSnipeBeforeTiles_Info_01", "Max numbers of tiles from border to consider TH as external")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 107, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hCmbTHSnipeBeforeDBScript = GUICtrlCreateCombo("", $x, $y, 130, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "CmbTHSnipeBeforeScript_Info_01", "You can add/edit CSV settings in the CSV\THSnipe folder"))
GUICtrlSetState(-1, $GUI_DISABLE)
LoadDBSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, "Bam"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkStopAtkDBNoLoot1 = 0, $g_hTxtStopAtkDBNoLoot1 = 0, $g_hChkStopAtkDBNoLoot2 = 0, $g_hTxtStopAtkDBNoLoot2 = 0, $g_hTxtDBMinGoldStopAtk2 = 0, $g_hTxtDBMinElixirStopAtk2 = 0, $g_hTxtDBMinDarkElixirStopAtk2 = 0, $g_hChkDBEndNoResources = 0, $g_hChkDBEndOneStar = 0, $g_hChkDBEndTwoStars = 0, $g_hChkDBEndPercentHigher = 0, $g_hTxtDBPercentHigher = 0, $g_hChkDBEndPercentChange = 0, $g_hTxtDBPercentChange = 0
Global $g_hGrpDBEndBattle = 0, $g_hLblStopAtkDBNoLoot1a = 0, $g_hLblStopAtkDBNoLoot1b = 0, $g_hLblStopAtkDBNoLoot2a = 0, $g_hLblStopAtkDBNoLoot2b = 0, $g_hLblDBMinRerourcesAtk2 = 0, $g_hPicDBMinGoldStopAtk2 = 0, $g_hPicDBMinElixirStopAtk2 = 0, $g_hPicDBMinDarkElixirStopAtk2 = 0, $g_hLblDBPercentHigher = 0, $g_hLblDBPercentHigherSec = 0, $g_hLblDBPercentChange = 0, $g_hLblDBPercentChangeSec = 0
Func CreateAttackSearchDeadBaseEndBattle()
Local $sTxtTip = ""
Local $x = 10, $y = 45
$g_hGrpDBEndBattle = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "Group_01", "Exit Battle"), $x - 5, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
$y -= 5
$g_hChkStopAtkDBNoLoot1 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot", "When no New loot"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_01", "End Battle if there is no extra loot raided within this No. of seconds.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_02", "Countdown is started after all Troops and Royals are deployed in battle.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkDBNoLoot1")
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 20
$g_hLblStopAtkDBNoLoot1a = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblStopAtkNoLoot", "raided within") & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkDBNoLoot1 = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$g_hLblStopAtkDBNoLoot1b = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
$y += 20
$g_hChkStopAtkDBNoLoot2 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkDBNoLoot2")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hLblStopAtkDBNoLoot2a = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblStopAtkNoLoot", -1) & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkDBNoLoot2 = GUICtrlCreateInput("5", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblStopAtkDBNoLoot2b = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
$y += 21
$g_hLblDBMinRerourcesAtk2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblMinRerourcesAtk2", "And Resources are below") & ":", $x + 16, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblMinRerourcesAtk2_Info_01", "End Battle if below this amount of Gold.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
$g_hTxtDBMinGoldStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinGoldStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinElixirStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinElixirStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinDarkElixirStopAtk2 = GUICtrlCreateInput("50", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinDarkElixirStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hChkDBEndNoResources = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndNoResources", "When no Resources left"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndNoResources_Info_01", "End Battle when all Gold, Elixir and Dark Elixir = 0"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndOneStar = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar", "When One Star is won"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar_Info_01", "Will End the Battle if 1 star is won in battle"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndTwoStars = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndTwoStars", "When Two Stars are won"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndTwoStars_Info_01", "Will End the Battle if 2 stars are won in battle"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndPercentHigher = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher", "When Percentage is"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher_Info_01", "End Battle if Overall Damage Percentage is above"))
GUICtrlSetOnEvent(-1, "chkDBEndPercentHigher")
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 20
$g_hLblDBPercentHigher = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblPercentHigher", "above") & ":", $x + 16, $y + 2, -1, -1)
$g_hTxtDBPercentHigher = GUICtrlCreateInput("60", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher_Info_01", -1))
GUICtrlSetLimit(-1, 3)
$g_hLblDBPercentHigherSec = GUICtrlCreateLabel("%", $x + 120, $y + 3, -1, -1)
$y += 21
$g_hChkDBEndPercentChange = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange", "When Percentage doesn't"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange_Info_01", "End Battle when Percentage doesn't change in"))
GUICtrlSetOnEvent(-1, "chkDBEndPercentChange")
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 20
$g_hLblDBPercentChange = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblPercentChange", "change in") & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtDBPercentChange = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange_Info_01", -1))
GUICtrlSetLimit(-1, 2)
$g_hLblDBPercentChangeSec = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkDBDisableCollectorsFilter = 0
Global $g_ahChkDBCollectorLevel[14] = [-1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahCmbDBCollectorLevel[14] = [-1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hCmbMinCollectorMatches = 0, $g_hSldCollectorTolerance = 0, $g_hLblCollectorWarning = 0
Func CreateAttackSearchDeadBaseCollectors()
Local $x = 10, $y = 45
Local $s_TxtTip1 = GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel_Info_01", "If this box is checked, then the bot will look")
Local $g_hTxtFull = GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel_Info_02", "Full")
Local $sTxtTip = ""
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "Group_01", "Collectors"), $x - 5, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel", "Choose which collectors to search for while looking for a dead base. Also, choose how full they must be."), $x, $y, 250, 28)
$g_hChkDBDisableCollectorsFilter = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkDisableCollectorsFilter", "Disable Collector Filter"), $x + 250, $y + 60, 150, 18)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkDisableCollectorsFilter_Info_01", "Disable Collector Filter CHANGES DeadBase into another ActiveBase search"))
$y += 15
For $i = 6 To 13
$y += 25
$g_ahChkDBCollectorLevel[$i] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "ChkCollectorLevel" & $i & "_Info_01", "for level " & $i & " elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,($i = 6 ? GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE)) : $GUI_CHECKED))
GUICtrlSetOnEvent(-1, "chkDBCollector")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel" & $i, "Lvl " & $i & ". Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[$i] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorLevel" & $i & "_Info_01", "Select how full a level " & $i & ' collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "100%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
Next
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblMinCollectorMatches", "Collectors required"), $x, $y + 3, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "CmbMinCollectorMatches_Info_01", 'Select how many collectors are needed to consider village "dead"')
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbMinCollectorMatches = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6", "3")
GUICtrlSetOnEvent(-1, "cmbMinCollectorMatches")
$y += 25
GUICtrlCreateLabel("-15" & _PadStringCenter(GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "LblCollectorTolerance", "Tolerance"), 66, " ") & "15", $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 15
$g_hSldCollectorTolerance = GUICtrlCreateSlider($x, $y, 250, 20, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "SldCollectorTolerance_Info_01", "Use this slider to adjust the tolerance of ALL images.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "SldCollectorTolerance_Info_02", "If you want to adjust individual images, you must edit the files.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Deadbase-Collectors", "SldCollectorTolerance_Info_03", "WARNING: Do not change this setting unless you know what you are doing. Set it to 0 if you're not sure."))
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 15, -15)
GUICtrlSetData(-1, 0)
GUICtrlSetOnEvent(-1, "sldCollectorTolerance")
GUICtrlSetState(-1, $GUI_HIDE)
$y += 25
$g_hLblCollectorWarning = GUICtrlCreateLabel("Warning: no collecters are selected. The bot will never find a dead base.", $x, $y, 255, 30)
GUICtrlSetFont(-1, 10, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_ERROR)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_DEADBASE_TAB = 0, $g_hGUI_DEADBASE_TAB_ITEM1 = 0, $g_hGUI_DEADBASE_TAB_ITEM2 = 0, $g_hGUI_DEADBASE_TAB_ITEM3 = 0, $g_hGUI_DEADBASE_TAB_ITEM4 = 0
Func CreateAttackSearchDeadBase()
$g_hGUI_DEADBASE = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
CreateAttackSearchDeadBaseStandard()
CreateAttackSearchDeadBaseScripted()
CreateAttackSearchDeadBaseSmartFarm()
GUISwitch($g_hGUI_DEADBASE)
$g_hGUI_DEADBASE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_DEADBASE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_01", "Search"))
CreateAttackSearchDeadBaseSearch()
$g_hGUI_DEADBASE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_02", "Attack"))
CreateAttackSearchDeadBaseAttack()
$g_hGUI_DEADBASE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_03", "End Battle"))
CreateAttackSearchDeadBaseEndBattle()
$g_hGUI_DEADBASE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_01_STab_01", "Collectors"))
CreateAttackSearchDeadBaseCollectors()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_ACTIVEBASE = 0
Global $g_hGUI_ACTIVEBASE_ATTACK_STANDARD = 0
Global $g_hCmbStandardDropOrderAB = 0, $g_hCmbStandardDropSidesAB = 0, $g_hCmbStandardUnitDelayAB = 0, $g_hCmbStandardWaveDelayAB = 0, $g_hChkRandomSpeedAtkAB = 0, $g_hChkSmartAttackRedAreaAB = 0, $g_hCmbSmartDeployAB = 0, $g_hChkAttackNearGoldMineAB = 0, $g_hChkAttackNearElixirCollectorAB = 0, $g_hChkAttackNearDarkElixirDrillAB = 0
Global $g_hLblSmartDeployAB = 0, $g_hPicAttackNearDarkElixirDrillAB = 0
Global $g_hBtnCustomDropOrderAB = 0
Func CreateAttackSearchActiveBaseStandard()
$g_hGUI_ACTIVEBASE_ATTACK_STANDARD = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ACTIVEBASE)
Local $sTxtTip = ""
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Group_01", -1), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Label_01", -1), $x, $y, 143, 18, $SS_LEFT)
$y += 15
$g_hCmbStandardDropOrderAB = GUICtrlCreateCombo("", $x, $y, 150, Default, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_03", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropOrder_Info_03", -1))
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Label_02", "Attack on") & ":", $x, $y + 5, -1, -1)
$g_hCmbStandardDropSidesAB = GUICtrlCreateCombo("", $x + 55, $y, 120, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_05", "Attack on the single side closest to the Dark Elixir Storage") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_06", "Attack on the single side closest to the Townhall") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Info_04", -1))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_03", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_04", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_07", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_05", "DE Side Attack") & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_06", "TH Side Attack"), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbStandardDropSides_Item_04", -1))
GUICtrlSetOnEvent(-1, "cmbStandardDropSidesAB")
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay", -1) & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardUnitDelay_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardUnitDelayAB = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "Lbl-CmbStandardWaveDelay_Info_01", -1) & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardWaveDelayAB = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$y += 22
$g_hChkRandomSpeedAtkAB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkRandomSpeedAtk", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkAB")
$y +=22
$g_hChkSmartAttackRedAreaAB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkSmartAttackRedArea", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkSmartAttackRedArea_Info_01", -1))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSmartAttackRedAreaAB")
$y += 22
$g_hLblSmartDeployAB = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy", -1) & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "LblSmartDeploy_Info_03", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbSmartDeployAB = GUICtrlCreateCombo("", $x + 55, $y, 120, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_02", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "CmbSmartDeploy_Info_01", -1))
_GUICtrlSetTip(-1, $sTxtTip)
$y += 26
$g_hChkAttackNearGoldMineAB = GUICtrlCreateCheckbox("", $x + 20, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearGoldMine_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 40 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
$g_hChkAttackNearElixirCollectorAB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearElixirCollector_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 55
$g_hChkAttackNearDarkElixirDrillAB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Standard", "ChkAttackNearDarkElixirDrill_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicAttackNearDarkElixirDrillAB = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 20 , $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 40
$x = 98
$g_hBtnCustomDropOrderAB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder", -1), $x, $y, 85, 25)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnCustomDropOrder_Info_01", -1))
GUICtrlSetOnEvent(-1, "CustomDropOrder")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED = 0
Global $g_hCmbScriptNameAB = 0, $g_hCmbScriptRedlineImplAB = 0, $g_hCmbScriptDroplineAB = 0
Global $g_hLblNotesScriptAB = 0, $g_hBtnAttNowAB = 0
Func CreateAttackSearchActiveBaseScripted()
$g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED = _GUICreate("", $_GUI_MAIN_WIDTH - 195, $g_iSizeHGrpTab4, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ACTIVEBASE)
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "Group_01", -1), $x - 20, $y - 20, 270, $g_iSizeHGrpTab4)
$g_hCmbScriptNameAB = GUICtrlCreateCombo("", $x , $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptName", -1))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptNameAB")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnReload, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconReload_Info_01", -1))
GUICtrlSetOnEvent(-1, 'UpdateComboScriptNameAB')
$y += 25
$g_hLblNotesScriptAB = GUICtrlCreateLabel("", $x, $y + 3, 200, 195)
$g_hBtnAttNowAB = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "btnAttNow", -1), $x + 70, $y + 198, 91, 23)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "btnAttNow_Info_01", -1))
GUICtrlSetBkColor(-1, 0xBAD9C8)
GUICtrlSetOnEvent(-1, "AttackNowAB")
$g_hCmbScriptRedlineImplAB = GUICtrlCreateCombo("", $x, $y + 225, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptRedlineImpl", "ImgLoc Raw Redline (default)|ImgLoc Redline Drop Points|Original Redline|External Edges"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrRedlineRoutine[$LB])
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptRedlineImpl_Info_01", "Choose the Redline implementation. ImgLoc Redline is default and best."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptRedlineImplAB")
$g_hCmbScriptDroplineAB = GUICtrlCreateCombo("", $x, $y + 250, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptDropline", "Drop line fix outer corner|Drop line fist Redline point|Full Drop line fix outer corner|Full Drop line fist Redline point|No Drop line"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrDroplineEdge[$LB])
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CmbScriptDropline_Info_01", "Choose the drop line edges. Default is outer corner and safer. First Redline point can improve attack."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptDroplineAB")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "CSVSpeed", -1), $x + 25, $y + 280, -1, 18)
$cmbCSVSpeed[$LB] = GUICtrlCreateCombo("", $x + 150, $y + 276, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0.5x|0.75x|1x|1.25x|1.5x|2x|3x|4x|5x", "1x")
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEdit, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconShow-Edit_Info_01", -1))
GUICtrlSetOnEvent(-1, "EditScriptAB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnAddcvs, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconCreate_Info_01", -1))
GUICtrlSetOnEvent(-1, "NewScriptAB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCopy, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconCopy_Info_01", -1))
GUICtrlSetOnEvent(-1, "DuplicateScriptAB")
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrain, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack Scripted", "IconApply_Info_01", -1))
GUICtrlSetOnEvent(-1, "ApplyScriptAB")
GUICtrlCreateGroup("", -99, -99, 1, 1)
UpdateComboScriptNameAB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $g_sAttackScrScriptName[$LB])
If $tempindex = -1 Then $tempindex = 0
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, $tempindex)
EndFunc
Global $g_hChkABActivateSearches = 0, $g_hTxtABSearchesMin = 0, $g_hTxtABSearchesMax = 0
Global $g_hChkABActivateTropies = 0, $g_hTxtABTropiesMin = 0, $g_hTxtABTropiesMax = 0
Global $g_hChkABActivateCamps = 0, $g_hTxtABArmyCamps = 0
Global $g_hChkABKingWait = 0, $g_hChkABQueenWait = 0, $g_hChkABWardenWait = 0, $g_hChkABNotWaitHeroes = 0
Global $g_hChkABSpellsWait = 0, $g_hChkABWaitForCastle = 0
Global $g_hLblABSearches = 0, $g_hLblABTropies = 0, $g_hLblABArmyCamps = 0
Global $g_hPicABHeroesWait = 0, $g_hTxtABHeroesWait = 0, $g_hPicABKingWait = 0, $g_hPicABKingSleepWait = 0, $g_hPicABQueenWait = 0, $g_hPicABQueenSleepWait = 0, $g_hPicABWardenWait = 0, $g_hPicABWardenSleepWait = 0
Global $g_hPicABLightSpellWait = 0, $g_hPicABHealSpellWait = 0, $g_hPicABRageSpellWait = 0, $g_hPicABJumpSpellWait = 0, $g_hPicABFreezeSpellWait = 0, $g_hPicABPoisonSpellWait = 0, $g_hPicABEarthquakeSpellWait = 0, $g_hPicABHasteSpellWait = 0
Global $g_hCmbABMeetGE = 0, $g_hTxtABMinGold = 0, $g_hTxtABMinElixir = 0, $g_hTxtABMinGoldPlusElixir = 0
Global $g_hChkABMeetDE = 0, $g_hTxtABMinDarkElixir = 0
Global $g_hChkABMeetTrophy = 0, $g_hTxtABMinTrophy = 0, $g_hTxtABMaxTrophy = 0
Global $g_hChkABMeetTH = 0, $g_hCmbABTH = 0, $g_hChkABMeetTHO = 0
Global $g_hGrpABFilter = 0, $g_hPicABMinGold = 0, $g_hPicABMinElixir = 0, $g_hPicABMinGPEGold = 0, $g_hPicABMinDarkElixir = 0, $g_hPicABMinTrophies = 0
Global $g_ahPicABMaxTH[13]
Func CreateAttackSearchActiveBaseSearch()
Local $sTxtLightningSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortLightningSpells", -1)
Local $sTxtHealSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHealSpells", -1)
Local $sTxtRageSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortRageSpells", -1)
Local $sTxtJumpSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortJumpSpells", -1)
Local $sTxtFreezeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortFreezeSpells", -1)
Local $sTxtPoisonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortPoisonSpells", -1)
Local $sTxtEarthquakeSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortEarthquakeSpells", -1)
Local $sTxtHasteSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortHasteSpells", -1)
Local $sTxtSkeletonSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortSkeletonSpells", -1)
Local $sTxtBatSpells = GetTranslatedFileIni("MBR Global GUI Design Names Spells", "TxtShortBatSpells", -1)
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_01", -1), $x - 20, $y - 20, 190, $g_iSizeHGrpTab4)
$x -= 15
$g_hChkABActivateSearches = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches", -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkABActivateSearches")
$g_hTxtABSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinSearches_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblABSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtABSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxSearches_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_01", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkABActivateTropies = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkABActivateTropies")
$g_hTxtABTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinTropies_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblABTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtABTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxTropies_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkABActivateCamps = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps", -1), $x, $y, 110, 18)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABActivateCamps")
$g_hLblABArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtABArmyCamps = GUICtrlCreateInput("100", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 23
$g_hPicABHeroesWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 1, $y + 3, 16, 16)
$g_hTxtABHeroesWait = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtHeroesWait", -1) & ":", $x + 20, $y + 4, 180, 18)
$y += 20
$x += 20
$g_hChkABKingWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
Local $sTxtKingWait = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtHeroesWait_Info_01", -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtKingWait_Info_01", -1) & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtKingWait_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABKingWait")
$g_hPicABKingWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABKingSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$x += 55
$g_hChkABQueenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtQueenWait_Info_01", -1) & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtQueenWait_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABQueenWait")
$g_hPicABQueenWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABQueenSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$x += 55
$g_hChkABWardenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWardenWait_Info_01", -1) & @CRLF & $sTxtKingWait & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtWardenWait_Info_02", -1)
GUICtrlSetOnEvent(-1, "chkABWardenWait")
$g_hPicABWardenWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABWardenSleepWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 70
$x = 10
$g_hChkABNotWaitHeroes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkNotWaitHeroes", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkNotWaitHeroes_Info_01", -1))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkNotWaitHeroes")
$y += 22
$x = 8
$g_hPicABLightSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 22, 22)
$g_hPicABHealSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x + 23, $y, 22, 22)
$g_hPicABRageSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x + 46, $y, 22, 22)
$g_hPicABJumpSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x + 69, $y, 22, 22)
$g_hPicABFreezeSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 92, $y, 22, 22)
$g_hPicABPoisonSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x + 115, $y, 22, 22)
$g_hPicABEarthquakeSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x + 138, $y, 22, 22)
$g_hPicABHasteSpellWait = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x + 161, $y, 22, 22)
$y += 25
$x = 10
$g_hChkABSpellsWait = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkSpellsWait_Info_02", -1))
GUICtrlSetOnEvent(-1, "chkABSpellsWait")
$g_hChkABWaitForCastle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastle", -1), $x, $y + 20, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkWaitForCastle_Info_01", -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpABFilter = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_02", -1), $x - 20, $y - 20, 225, $g_iSizeHGrpTab4)
$x -= 15
$g_hCmbABMeetGE = GUICtrlCreateCombo("", $x, $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_03", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_04", -1))
GUICtrlSetOnEvent(-1, "cmbABGoldElixir")
$g_hTxtABMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGold_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicABMinGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicABMinElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtABMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGoldPlusElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicABMinGPEGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkABMeetDE = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetDE")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE_Info_01", -1))
$g_hTxtABMinDarkElixir = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinDarkElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicABMinDarkElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkABMeetTrophy = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetTrophy")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_01", -1))
$g_hTxtABMinTrophy = GUICtrlCreateInput("0", $x + 85, $y, 20, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel("-", $x + 109, $y + 2, -1, -1)
$g_hTxtABMaxTrophy = GUICtrlCreateInput("0", $x + 115, $y, 20, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTrophy_Info_03", -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
$g_hPicABMinTrophies = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkABMeetTH = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR Global GUI Design", "LblTownhall", -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetTH")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTH_Info_01", -1))
$g_hCmbABTH = GUICtrlCreateCombo("", $x + 85, $y - 1, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbDBTH", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "4-6|7|8|9|10|11|12", "4-6")
GUICtrlSetOnEvent(-1, "CmbABTH")
$g_ahPicABMaxTH[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_SHOW)
$g_ahPicABMaxTH[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicABMaxTH[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicABMaxTH[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicABMaxTH[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicABMaxTH[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahPicABMaxTH[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV12, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 24
$g_hChkABMeetTHO = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTHO", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetTHO_Info_01", -1))
$y += 24
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_03", -1), $x, $y, 215, 100)
$x += 5
$y += 20
Local $xStartColumn = $x, $yStartColumn = $y
$g_ahChkMaxMortar[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxMortar", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakMortar[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 52, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxMortar_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10|Lvl 11", "Lvl 5")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakMortar[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnMortar, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxWizTower[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxWizTower", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakWizTower[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 52, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxWizTower_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10|Lvl 11", "Lvl 4")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakWizTower[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizTower, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxAirDefense[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxAirDefense", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakAirDefense[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 53, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxAirDefense_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9|Lvl 10", "Lvl 7")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakAirDefense[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnAirdefense, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStartColumn + 104
$y = $yStartColumn
$g_ahChkMaxXBow[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxXBow", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakXBow[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxXBow_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakXBow[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnXBow3, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxInferno[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxInferno", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakInferno[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxInferno_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakInferno[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnInferno4, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxEagle[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMaxEagle", -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakEagle[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMaxEagle_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3", "Lvl 1")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakEagle[$LB] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEagleArt, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 44
$x = $xStartColumn
$g_ahChkMeetOne[$LB] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetOne", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetOne_Info_01", -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbABAlgorithm = 0, $g_hCmbABSelectTroop = 0, $g_hChkABKingAttack = 0, $g_hChkABQueenAttack = 0, $g_hChkABWardenAttack = 0, $g_hChkABDropCC = 0
Global $g_hChkABLightSpell = 0, $g_hChkABHealSpell = 0, $g_hChkABRageSpell = 0, $g_hChkABJumpSpell = 0, $g_hChkABFreezeSpell = 0, $g_hChkABCloneSpell = 0, $g_hChkABPoisonSpell = 0, $g_hChkABEarthquakeSpell = 0, $g_hChkABHasteSpell = 0, $g_hChkABSkeletonSpell = 0, $g_hChkABBatSpell = 0
Global $g_hGrpABAttack = 0, $g_hPicABKingAttack = 0, $g_hPicABQueenAttack = 0, $g_hPicABWardenAttack = 0, $g_hPicABDropCC = 0
Global $g_hPicABLightSpell = 0, $g_hPicABHealSpell = 0, $g_hPicABRageSpell = 0, $g_hPicABJumpSpell = 0, $g_hPicABFreezeSpell = 0, $g_hPicABCloneSpell = 0, $g_hPicABPoisonSpell = 0, $g_hPicABEarthquakeSpell = 0, $g_hPicABHasteSpell = 0, $g_hPicABSkeletonSpell = 0, $g_hPicABBatSpell = 0
Global $g_hChkTHSnipeBeforeLBEnable = 0, $g_hTxtTHSnipeBeforeLBTiles = 0, $g_hCmbTHSnipeBeforeLBScript = 0
Global $g_hLblTHSnipeBeforeLBTiles = 0
Global $g_hCmbABSiege = 0, $g_hCmbABWardenMode = 0
Func CreateAttackSearchActiveBaseAttack()
Local $sTxtTip = ""
Local $x = 25, $y = 40
$g_hGrpABAttack = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_01", -1), $x - 20, $y - 15, 145, 263)
$x -= 15
$y += 2
$g_hCmbABAlgorithm = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, "")
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_02", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Algorithm_Item_01", -1))
GUICtrlSetOnEvent(-1, "cmbABAlgorithm")
$y += 27
$g_hCmbABSelectTroop = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_03", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_04", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_05", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_06", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_07", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_08", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_09", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_10", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_11", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Info_01", -1))
$y += 27
$g_hPicABKingAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x , $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABQueenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 46
$g_hPicABWardenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABWardenAttack")
$x += 46
$g_hCmbABWardenMode = GUICtrlCreateCombo("", $x, $y, 89, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Item_03", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Item_03", -1))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-WardenMode_Tip", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 46
$g_hPicABDropCC = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clan Castle_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABDropCC")
$x += 46
$g_hCmbABSiege = GUICtrlCreateCombo("", $x, $y, 89, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_03", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_04", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_05", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_06", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Item_06", -1))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-Siege_Tip", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 46
$g_hPicABLightSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Light_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABHealSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Healing_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABRageSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Rage_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicABJumpSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Jump_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABFreezeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Freeze_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABCloneSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clone_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABCloneSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicABPoisonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Poison_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABEarthquakeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Earthquake_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABHasteSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Haste_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicABSkeletonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Skeleton_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABSkeletonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABBatSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBatSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Bat_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABBatSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 308
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_02", -1), $x - 5, $y - 20, 145, 84,$SS_CENTER)
$g_hChkTHSnipeBeforeLBEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkTHSnipeBeforeEnable", -1), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkTHSnipeBeforeEnable_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkTHSnipeBeforeLBEnable")
$y += 16
$g_hLblTHSnipeBeforeLBTiles = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblTHSnipeBeforeTiles", -1) & ":", $x, $y + 3, 70, -1, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTHSnipeBeforeLBTiles = GUICtrlCreateInput("2", $x + 75, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblTHSnipeBeforeTiles_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 107, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hCmbTHSnipeBeforeLBScript = GUICtrlCreateCombo("", $x, $y, 130, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "CmbTHSnipeBeforeScript_Info_01", -1))
GUICtrlSetState(-1, $GUI_DISABLE)
LoadABSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, "Bam"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkStopAtkABNoLoot1 = 0, $g_hTxtStopAtkABNoLoot1 = 0, $g_hChkStopAtkABNoLoot2 = 0, $g_hTxtStopAtkABNoLoot2 = 0, $g_hTxtABMinGoldStopAtk2 = 0, $g_hTxtABMinElixirStopAtk2 = 0, $g_hTxtABMinDarkElixirStopAtk2 = 0, $g_hChkABEndNoResources = 0, $g_hChkABEndOneStar = 0, $g_hChkABEndTwoStars = 0, $g_hChkABEndPercentHigher = 0, $g_hTxtABPercentHigher = 0, $g_hChkABEndPercentChange = 0, $g_hTxtABPercentChange = 0
Global $g_hChkDESideEB = 0, $g_hTxtDELowEndMin = 0, $g_hChkDisableOtherEBO = 0, $g_hChkDEEndOneStar = 0, $g_hChkDEEndBk = 0, $g_hChkDEEndAq = 0
Global $g_hGrpABEndBattle = 0, $g_hLblABTimeStopAtka = 0, $g_hLblABTimeStopAtk = 0, $g_hLblABTimeStopAtk2a = 0, $g_hLblABTimeStopAtk2 = 0, $g_hLblABMinRerourcesAtk2 = 0, $g_hPicABMinGoldStopAtk2 = 0, $g_hPicABMinElixirStopAtk2 = 0, $g_hPicABMinDarkElixirStopAtk2 = 0
Global $g_hLblDELowEndMin = 0, $g_hLblDEEndAq = 0, $g_hLblABPercentHigher = 0, $g_hLblABPercentHigherSec = 0, $g_hLblABPercentChange = 0, $g_hLblABPercentChangeSec = 0
Func CreateAttackSearchActiveBaseEndBattle()
Local $sTxtTip = ""
Local $x = 10, $y = 45
$g_hGrpABEndBattle = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "Group_01", -1), $x - 5, $y - 20, 155, $g_iSizeHGrpTab4)
$y -=5
$g_hChkStopAtkABNoLoot1 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkABNoLoot1")
GUICtrlSetState(-1, $GUI_CHECKED)
$y +=20
$g_hLblABTimeStopAtka = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblStopAtkNoLoot", -1) & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkABNoLoot1 = GUICtrlCreateInput("20", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$g_hLblABTimeStopAtk = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
$y += 20
$g_hChkStopAtkABNoLoot2 = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkStopAtkNoLoot_Info_02", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkABNoLoot2")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hLblABTimeStopAtk2a = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblStopAtkNoLoot", -1) & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkABNoLoot2 = GUICtrlCreateInput("5", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblABTimeStopAtk2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
$y += 21
$g_hLblABMinRerourcesAtk2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblMinRerourcesAtk2", -1) & ":", $x + 16, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblMinRerourcesAtk2_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
$g_hTxtABMinGoldStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinGoldStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinElixirStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinElixirStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinDarkElixirStopAtk2 = GUICtrlCreateInput("50", $x + 65, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinDarkElixirStopAtk2 = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hChkABEndNoResources = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndNoResources", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndNoResources_Info_01", -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndOneStar = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar_Info_01", -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndTwoStars = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndTwoStars", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndTwoStars_Info_01", -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndPercentHigher = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkABEndPercentHigher")
GUICtrlSetState(-1, $GUI_ENABLE)
$y +=20
$g_hLblABPercentHigher = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblPercentHigher", -1) & ":", $x + 16, $y + 2, -1, -1)
$g_hTxtABPercentHigher = GUICtrlCreateInput("60", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentHigher_Info_01", -1))
GUICtrlSetLimit(-1, 2)
$g_hLblABPercentHigherSec = GUICtrlCreateLabel("%", $x + 120, $y + 3, -1, -1)
$y += 21
$g_hChkABEndPercentChange = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkABEndPercentChange")
GUICtrlSetState(-1, $GUI_ENABLE)
$y +=20
$g_hLblABPercentChange = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblPercentChange", -1) & ":", $x + 16, $y + 3, -1, -1)
$g_hTxtABPercentChange = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndPercentChange_Info_01", -1))
GUICtrlSetLimit(-1, 2)
$g_hLblABPercentChangeSec = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 120, $y + 3, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 185, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "Group_02", "DE side End Battle options"), $x - 20, $y - 20, 259, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LabelDE_01", "Attack Dark Elixir Side, End Battle Options") & ":", $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LabelDE_Info_01", "Enabled by selecting DE side attack in ActiveBase Deploy - Attack On: options"))
$y += 15
$x -= 10
$g_hChkDESideEB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDESideEB", "When below") & ":", $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDESideEB_Info_01", "Enables Special conditions for Dark Elixir side attack.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDESideEB_Info_02", "If no additional filters are selected will end battle when below Total Dark Elixir Percent.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDESideEB")
$g_hTxtDELowEndMin = GUICtrlCreateInput("25", $x + 92, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDELowEndMin = GUICtrlCreateLabel("%", $x + 136, $y + 2, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 147, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDisableOtherEBO = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDisableOtherEBO", "Disable Normal End Battle Options"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDisableOtherEBO_Info_01", "Disable Normal End Battle Options when DE side attack is found."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkDEEndOneStar = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar", -1) & ":", $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkEndOneStar_Info_02", "Will End the Battle when below min DE and One Star is won.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 135, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDEEndBk = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDEEnd", "When"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDEEnd_Info_01", "Will End the Battle when below min DE and King is weak")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x + 50, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblDEEnd", "is weak"), $x + 70, $y + 4, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDEEndAq = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDEEnd", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "ChkDEEnd_Info_02", "Will End the Battle when below min DE and Queen is weak")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x + 50, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDEEndAq = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblDEEnd", -1), $x + 70, $y + 4, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ACTIVEBASE_TAB = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM1 = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM2 = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM3 = 0
Func CreateAttackSearchActiveBase()
$g_hGUI_ACTIVEBASE = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
CreateAttackSearchActiveBaseStandard()
CreateAttackSearchActiveBaseScripted()
GUISwitch($g_hGUI_ACTIVEBASE)
$g_hGUI_ACTIVEBASE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ACTIVEBASE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_01", -1))
CreateAttackSearchActiveBaseSearch()
$g_hGUI_ACTIVEBASE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_02", -1))
CreateAttackSearchActiveBaseAttack()
$g_hGUI_ACTIVEBASE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_03", -1))
CreateAttackSearchActiveBaseEndBattle()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_THSNIPE = 0
Global $g_hChkTSActivateSearches = 0, $g_hTxtTSSearchesMin = 0, $g_hTxtTSSearchesMax = 0, $g_hChkTSActivateTropies = 0, $g_hTxtTSTropiesMin = 0, $g_hTxtTSTropiesMax = 0, $g_hChkTSActivateCamps = 0, $g_hTxtTSArmyCamps = 0
Global $g_hLblTSSearches = 0, $g_hLblTSTropies = 0, $g_hLblTSArmyCamps = 0
Global $g_hCmbTSMeetGE = 0, $g_hTxtTSMinGold = 0, $g_hTxtTSMinElixir = 0, $g_hTxtTSMinGoldPlusElixir = 0
Global $g_hChkTSMeetDE = 0, $g_hTxtTSMinDarkElixir = 0
Global $g_hTxtSWTTiles = 0, $g_hTxtTHaddTiles = 0
Global $g_hGrpTSFilter = 0, $g_hPicTSMinGold = 0, $g_hPicTSMinElixir = 0, $g_hPicTSMinGPEGold = 0, $g_hPicTSMinDarkElixir = 0
Global $g_hLblAddTiles = 0, $g_hLblAddTiles2 = 0, $g_hLblSWTTiles = 0, $g_hLblTHadd = 0
Func CreateAttackSearchTHSnipeSearch()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_01", -1), $x - 20, $y - 20, 190, $g_iSizeHGrpTab4)
$x -= 15
$g_hChkTSActivateSearches = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches", -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTSActivateSearches")
$g_hTxtTSSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinSearches_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblTSSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtTSSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxSearches_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_02", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkTSActivateTropies = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies", -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetOnEvent(-1, "chkTSActivateTropies")
$g_hTxtTSTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMinTropies_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
$g_hLblTSTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTSTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblActivateMaxTropies_Info_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateSearches_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateTropies_Info_01", -1))
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkTSActivateCamps = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps", -1), $x, $y, 110, 18)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkActivateCamps_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkTSActivateCamps")
$g_hLblTSArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTSArmyCamps = GUICtrlCreateInput("50", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpTSFilter = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "Group_02", -1), $x - 20, $y - 20, 225, $g_iSizeHGrpTab4)
$x -= 15
$g_hCmbTSMeetGE = GUICtrlCreateCombo("", $x, $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Info_04", -1)
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_03", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "CmbMeetGE_Item_01", -1))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "cmbTSGoldElixir")
$g_hTxtTSMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGold_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicTSMinGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtTSMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicTSMinElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtTSMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinGoldPlusElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicTSMinGPEGold = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkTSMeetDE = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE", -1), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "ChkMeetDE_Info_01", -1)
GUICtrlSetOnEvent(-1, "chkTSMeetDE")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTSMinDarkElixir = GUICtrlCreateInput("600", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "TxtMinDarkElixir_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicTSMinDarkElixir = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$y += 35
$g_hLblAddTiles = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblAddTiles_01", "TownHall, Distance From"), $x, $y + 4, -1, -1, $SS_LEFT)
$y += 16
$g_hLblAddTiles2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblAddTiles_02", "Border, Add Tiles") & ":", $x + 5, $y + 4, -1, -1, $SS_LEFT)
$y += 21
$g_hLblSWTTiles = GUICtrlCreateLabel("- " & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblSWTTiles", "While Train"), $x, $y + 4, 100, -1, $SS_LEFT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblSWTTiles_Info_01", "Add number of tiles from Base Edges")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSWTTiles = GUICtrlCreateInput("2", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hLblTHadd = GUICtrlCreateLabel("- " & GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblFullTroop", -1), $x, $y + 4, -1, 17, $SS_LEFT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblTHadd_Info_01", "Enter how many 'Grass' 1x1 tiles the TH may be from the Base edges to be seen as a TH Outside.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblTHadd_Info_02", "Ex: (0) tiles; TH must be exactly at the edge. (4) tiles: TH may be 4 tiles farther from edges and closer to the center of the village.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Search", "LblTHadd_Info_03", "If the TH is farther away then the No. of tiles set, the base will be skipped.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTHaddTiles = GUICtrlCreateInput("2", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbAttackTHType = 0, $g_hCmbTSSelectTroop = 0, $g_hChkTSKingAttack = 0, $g_hChkTSQueenAttack = 0, $g_hChkTSWardenAttack = 0, $g_hChkTSDropCC = 0
Global $g_hChkTSLightSpell = 0, $g_hChkTSHealSpell = 0, $g_hChkTSRageSpell = 0, $g_hChkTSJumpSpell = 0, $g_hChkTSFreezeSpell = 0,$g_hChkTSPoisonSpell = 0, $g_hChkTSEarthquakeSpell = 0, $g_hChkTSHasteSpell = 0
Global $g_hLblAttackTHType = 0, $g_hLblTSSelectTroop = 0, $g_hLblTSSelectSpecialTroop = 0, $g_hPicTSKingAttack = 0, $g_hPicTSQueenAttack = 0, $g_hPicTSWardenAttack = 0, $g_hPicTSDropCC = 0
Global $g_hPicTSLightSpell = 0, $g_hPicTSHealSpell = 0, $g_hPicTSRageSpell = 0, $g_hPicTSJumpSpell = 0, $g_hPicTSFreezeSpell = 0, $g_hPicTSPoisonSpell = 0, $g_hPicTSEarthquakeSpell = 0, $g_hPicTSHasteSpell = 0
Func CreateAttackSearchTHSnipeAttack()
Local $sTxtTip
Local $x = 25, $y = 40
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_01", -1), $x - 20, $y - 15, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
$x -= 15
$g_hLblAttackTHType = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblAttackType", "Attack Type") & ":", $x, $y, 135, 18, $SS_LEFT)
$y += 15
$g_hCmbAttackTHType = GUICtrlCreateCombo("", $x, $y, 128, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "CmbTHSnipeBeforeScript_Info_01", -1))
GUICtrlSetOnEvent(-1, "cmbAttackTHType")
LoadThSnipeAttacks()
$y += 25
$g_hLblTSSelectTroop = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblSelectTroop", "Only drop these troops") & ":", $x, $y, 135, 18,$SS_LEFT)
$y += 15
$g_hCmbTSSelectTroop = GUICtrlCreateCombo("", $x, $y, 128, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_02", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_03", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_04", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_05", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_06", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_07", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_08", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_09", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_10", -1) & "|" & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_11", -1), GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Item_01", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Cmb-SelectTroop_Info_01", -1))
$y += 25
$g_hLblTSSelectSpecialTroop = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "LblSelectSpecialTroop", "Special troops to use") & ":", $x, $y, 135, 18, $SS_LEFT)
$y += 18
$g_hPicTSKingAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-King_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSQueenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Queen_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSWardenAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Warden_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicTSDropCC = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Clan Castle_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSLightSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Light_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSHealSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Healing_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicTSRageSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Rage_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSJumpSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Jump_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSFreezeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Freeze_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 27
$x -= 92
$g_hPicTSPoisonSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Poison_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSEarthquakeSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Earthquake_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSHasteSpell = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Chk-Use-Haste_Info_01", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkTSActivateCamps2 = 0, $g_hTxtTSArmyCamps2 = 0
Global $g_hGrpTSEndBattle = 0, $g_hLblTSArmyCamps2 = 0
Func CreateAttackSearchTHSnipeEndBattle()
Local $x = 10, $y = 45
$g_hGrpTSEndBattle = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "Group_01", -1), $x - 5, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "LblSwitch_DB_Attack_at_END", "Switch DB Attack at END") & ":", $x, $y, -1, 18, $SS_LEFT)
$y += 15
$g_hChkTSActivateCamps2 = GUICtrlCreateCheckbox("", $x + 2, $y + 3, 16, 16)
GUICtrlSetOnEvent(-1, "chkTSActivateCamps2")
$g_hLblTSArmyCamps2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCamps", "Camps") & " >=", $x + 20, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTSArmyCamps2 = GUICtrlCreateInput("50", $x + 75, $y, 35, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - EndBattle", "TxtArmyCamps2_Info_01", "Set the % Army camps before activate this option"))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 115, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 26
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_THSNIPE_TAB = 0, $g_hGUI_THSNIPE_TAB_ITEM1 = 0, $g_hGUI_THSNIPE_TAB_ITEM2 = 0, $g_hGUI_THSNIPE_TAB_ITEM3 = 0
Func CreateAttackSearchTHSnipe()
$g_hGUI_THSNIPE = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
GUISwitch($g_hGUI_THSNIPE)
$g_hGUI_THSNIPE_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_THSNIPE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_01", -1))
CreateAttackSearchTHSnipeSearch()
$g_hGUI_THSNIPE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_02", -1))
CreateAttackSearchTHSnipeAttack()
$g_hGUI_THSNIPE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_03", -1))
CreateAttackSearchTHSnipeEndBattle()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_BULLY = 0
Global $g_hTxtATBullyMode = 0, $g_hCmbBullyMaxTH = 0, $g_hRadBullyUseDBAttack = 0, $g_hRadBullyUseLBAttack = 0
Global $g_hGrpBullyAtkCombo = 0, $g_hLblBullyMode = 0, $g_hLblATBullyMode = 0
Global $g_ahPicBullyMaxTH[13]
Func CreateAttackSearchBully()
$g_hGUI_BULLY = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
GUISwitch($g_hGUI_BULLY)
Local $sTxtTip = ""
Local $x = 20, $y = 130 - 105
$g_hGrpBullyAtkCombo = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "Group_01", "Bully Attack Combo"), $x - 20, $y - 20, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3 - 6)
$y -= 5
$x -= 10
$g_hLblBullyMode = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblBullyMode", "In Bully Mode, ALL bases that meet the TH level requirement below will be attacked."), $x - 5, $y + 3, 209, 30, $SS_LEFT)
$y += 35
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblSearch", "Enable Bully after"), $x, $y + 3)
$g_hTxtATBullyMode = GUICtrlCreateInput("150", $x + 95, $y, 35, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 3)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblSearch_Info_01", "TH Bully: No. of searches to wait before activating."))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "search(es).", "search(es)."), $x + 135, $y + 5, -1, -1)
$y += 25
$g_hLblATBullyMode = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblATBullyMode", "Max TH level") & ":", $x - 5, $y + 3, 90, -1, $SS_RIGHT)
$g_hCmbBullyMaxTH = GUICtrlCreateCombo("", $x + 85, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "CmbBullyMaxTH_Info_01", "TH Bully: Max. Townhall level to bully.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "4-6|7|8|9|10|11|12", "4-6")
GUICtrlSetOnEvent(-1, "CmbBullyMaxTH")
$g_ahPicBullyMaxTH[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_SHOW)
$g_ahPicBullyMaxTH[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicBullyMaxTH[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicBullyMaxTH[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicBullyMaxTH[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicBullyMaxTH[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahPicBullyMaxTH[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV12, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 24
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "LblWhenFound", "When found, Attack with settings from") & ":", $x + 10, $y, -1, -1, $SS_RIGHT)
$y += 14
$g_hRadBullyUseDBAttack = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "RadBullyUseDBAttack", "DeadBase Atk."), $x + 20, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "RadBullyUseDBAttack_Info_01", "Use Dead Base attack settings when attacking a TH Bully match."))
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hRadBullyUseLBAttack = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "RadBullyUseLBAttack", "Active Base Atk."), $x + 115, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Bully", "RadBullyUseLBAttack_Info_01", "Use Active Base attack settings when attacking a TH Bully match."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ATTACKOPTION = 0
Global $g_hChkSearchReduction = 0, $g_hTxtSearchReduceCount = 0, $g_hTxtSearchReduceGold = 0, $g_hTxtSearchReduceElixir = 0, $g_hTxtSearchReduceGoldPlusElixir = 0, $g_hTxtSearchReduceDark = 0, $g_hTxtSearchReduceTrophy = 0
Global $g_hSldVSDelay = 0, $g_hSldMaxVSDelay = 0
Global $g_hChkAttackNow = 0, $g_hCmbAttackNowDelay = 0, $g_hChkRestartSearchLimit = 0, $g_hTxtRestartSearchlimit = 0, $g_hChkAlertSearch = 0
Global $g_hLblVSDelay = 0, $g_hLblTextVSDelay = 0, $g_hLblMaxVSDelay = 0, $g_hLblTextMaxVSDelay = 0, $g_hLblAttackNow = 0, $g_hLblAttackNowSec = 0
Global $g_hChkRestartSearchPickupHero = 0
Global $g_hChkSearchTimeout = 0, $g_hLblSearchTimeout = 0, $g_hTxtSearchTimeout = 0, $g_hLblSearchTimeoutminutes = 0
Func CreateAttackSearchOptionsSearch()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "Group_01", "Search Reduction"), $x - 20, $y - 20, 223, 165)
$x -= 13
$g_hChkSearchReduction = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkSearchReduction", "Enable Search Reduction"), $x, $y - 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkSearchReduction_Info_01", "Check this if you want the search values to automatically be lowered after a certain amount of searches."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSearchReduction")
$y += 15
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceCount", "Reduce targets every"), $x, $y + 3, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceCount_Info_01", "Enter the No. of searches to wait before each reduction occurs.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceCount = GUICtrlCreateInput("20", $x + 115, $y + 2, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "search(es).", -1), $x + 160, $y + 3, -1, -1)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceGold", "- Reduce Gold"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceGold_Info_01", "Lower value for Gold by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceGold = GUICtrlCreateInput("2000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceElixir", "- Reduce Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceElixir_Info_01", "Lower value for Elixir by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceElixir = GUICtrlCreateInput("2000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceGoldPlusElixir", "- Reduce Gold + Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceGoldPlusElixir_Info_01", "Lower total sum for G+E by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceGoldPlusElixir = GUICtrlCreateInput("4000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 160, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("+", $x + 176, $y + 1, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 182, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceDark", "- Reduce Dark Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceDark_Info_01", "Lower value for Dark Elixir by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceDark = GUICtrlCreateInput("100", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceTrophy", "- Reduce Tropies"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblSearchReduceTrophy_Info_01", "Lower value for Trophies by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceTrophy = GUICtrlCreateInput("2", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 212
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "Group_02", "Village Search Delay"), $x - 20, $y - 20, 223, 72)
$x += 20
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMinVSDelay_Info_01", "Use this slider to change the time to wait between Next clicks when searching for a Village to Attack.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMinVSDelay_Info_02", "This might compensate for Out of Sync errors on some PC's.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMinVSDelay_Info_03", "NO GUARANTEES! This will not always have the same results!")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Mini", "Min"), $x - 20, $y - 2, 25, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblVSDelay = GUICtrlCreateLabel("0", $x + 7, $y - 2, 12, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTextVSDelay = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"), $x + 23, $y - 2, -1, -1)
$g_hSldVSDelay = GUICtrlCreateSlider($x + 70, $y - 4, 105, 25, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 12, 0)
GUICtrlSetData(-1, 1)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldVSDelay")
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Maxi", "Max"), $x - 20, $y - 2, 25, 15, $SS_RIGHT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMaxVSDelay_Info_01", "Enable random village search delay value by setting") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblMaxVSDelay_Info_02", "bottom Max slide value higher than the top minimum slide")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblMaxVSDelay = GUICtrlCreateLabel("0", $x + 7, $y - 2, 12, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTextMaxVSDelay = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "seconds", -1), $x + 23, $y - 2, 45, -1)
$g_hSldMaxVSDelay = GUICtrlCreateSlider($x + 70, $y - 4, 105, 25, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 15, 0)
GUICtrlSetData(-1, 4)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldMaxVSDelay")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 253
$y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "Group_03", "Search Options"), $x - 20, $y - 20, 189, 215)
$x -= 5
$g_hChkAttackNow = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAttackNow", "Attack Now! option."), $x - 5, $y - 4, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAttackNow_Info_01", "Check this if you want the option to have an 'Attack Now!' button next to") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAttackNow_Info_02", "the Start and Pause buttons to bypass the dead base or all base search values.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAttackNow_Info_03", "The Attack Now! button will only appear when searching for villages to Attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkAttackNow")
$g_hLblAttackNow = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblAttackNow", "Add") & ":", $x + 10, $y + 20, 27, -1, $SS_RIGHT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "LblAttackNow_Info_01", "Add this amount of reaction time to slow down the search.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbAttackNowDelay = GUICtrlCreateCombo("", $x + 45, $y + 17, 35, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "0|1|2|3|4|5", "3")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblAttackNowSec = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 85, $y + 20, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 49
$g_hChkRestartSearchLimit = GUICtrlCreateCheckbox( GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkRestartSearchLimit", "Restart every") & ":", $x - 5, $y - 8, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkRestartSearchLimit_Info_01", "Return To Base after x searches and restart to search enemy villages.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkRestartSearchLimit")
$g_hTxtRestartSearchlimit = GUICtrlCreateInput("50", $x + 15, $y + 15, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "search(es).", -1), $x + 47, $y + 17, -1, -1)
$y += 45
$g_hChkRestartSearchPickupHero = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkRestartSearchPickupHero", "Restart to pickup healed hero"), $x - 5, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkRestartSearchPickupHero_Info_01", "Return to base when a hero is healed and ready to join the attack"))
$y += 25
$g_hChkAlertSearch = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAlertSearch", "Alert me when Village found"), $x - 5, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkAlertSearch_Info_01", "Check this if you want an Audio alarm & a Balloon Tip when a Base to attack is found."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 32
$g_hChkSearchTimeout = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkSearchTimeout", "Restart search IF Cloud Time"), $x - 5, $y - 8, -1, -1)
_GUICtrlSetTip(-1,GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Search", "ChkSearchTimeout_Info_01", "Will Return to home and restart search if clouding time is > xx minutes"))
GUICtrlSetOnEvent(-1, "chkSearchTimeout")
$g_hLblSearchTimeout = GUICtrlCreateLabel(ChrW(62), $x + 5, $y + 17, -1, -1)
$g_hTxtSearchTimeout = GUICtrlCreateInput("10", $x + 15, $y + 15, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$g_hLblSearchTimeoutminutes = GUICtrlCreateLabel("minutes", $x + 50, $y + 17, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hRadAutoQueenAbility = 0, $g_hRadAutoKingAbility = 0, $g_hRadAutoWardenAbility = 0
Global $g_hRadManQueenAbility = 0, $g_hRadManKingAbility = 0, $g_hRadManWardenAbility = 0
Global $g_hTxtManQueenAbility = 0, $g_hTxtManKingAbility = 0, $g_hTxtManWardenAbility = 0
Global $g_hRadBothQueenAbility = 0, $g_hRadBothKingAbility = 0, $g_hRadBothWardenAbility = 0
Global $g_hChkAttackPlannerEnable = 0, $g_hChkAttackPlannerCloseCoC = 0, $g_hChkAttackPlannerCloseAll = 0, $g_hChkAttackPlannerSuspendComputer = 0, $g_hChkAttackPlannerRandom = 0, $g_hCmbAttackPlannerRandom = 0, $g_hChkAttackPlannerDayLimit = 0, $g_hCmbAttackPlannerDayMin = 0, $g_hCmbAttackPlannerDayMax = 0
Global $g_ahChkAttackWeekdays[7] = [0, 0, 0, 0, 0, 0, 0], $g_ahChkAttackHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLbAttackPlannerRandom = 0, $g_hLbAttackPlannerDayLimit = 0, $g_ahChkAttackWeekdaysE = 0, $g_ahChkAttackHoursE1 = 0, $g_ahChkAttackHoursE2 = 0
Global $g_hChkDropCCHoursEnable = 0, $g_ahChkDropCCHours[24] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
GLobal $g_hLblDropCChour = 0, $g_ahLblDropCChoursE = 0
GLobal $g_hLblDropCChours[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahChkDropCCHoursE1 = 0, $g_ahChkDropCCHoursE2 = 0
Func CreateAttackSearchOptionsAttack()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "Group_01", "Hero Abilities"), $x - 20, $y - 20, $g_iSizeWGrpTab4, 95)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 22, 22)
GUIStartGroup()
$x += 30
$g_hRadAutoQueenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities", "Auto activate (red zone)"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_01", "Activate the Ability when the Hero becomes weak.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_02", "Heroes are checked and activated individually.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$x += 145
$g_hRadManQueenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities", "Timed after") & ":", $x , $y , -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_01", "Activate the Ability on a timer.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_02", "All Heroes are activated at the same time.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hTxtManQueenAbility = GUICtrlCreateInput("9", $x + 80, $y + 3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtManAbilities_Info_01", "Set the time in seconds for Timed Activation of Hero Abilities.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 115, $y + 4, -1, -1)
$x += 145
$g_hRadBothQueenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_01", "Check Both"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_02", "Activate the Ability when Hero becomes weak or when timer runs out")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
Local $x = 25, $y = 69
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x, $y, 22, 22)
GUIStartGroup()
$x += 30
$g_hRadAutoKingAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities", "Auto activate (red zone)"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_01", "Activate the Ability when the Hero becomes weak.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_02", "Heroes are checked and activated individually.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$x += 145
$g_hRadManKingAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities", "Timed after") & ":", $x , $y , -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_01", "Activate the Ability on a timer.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_02", "All Heroes are activated at the same time.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hTxtManKingAbility = GUICtrlCreateInput("9", $x + 80, $y + 3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtManAbilities_Info_01", "Set the time in seconds for Timed Activation of Hero Abilities.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 115, $y + 4, -1, -1)
$x += 145
$g_hRadBothKingAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_01", "Check Both"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_02", "Activate the Ability when Hero becomes weak or when timer runs out")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
Local $x = 25, $y = 95
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y , 22, 22)
GUIStartGroup()
$x += 30
$g_hRadAutoWardenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities", "Auto activate (red zone)"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_01", "Activate the Ability when the Hero becomes weak.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadAutoAbilities_Info_02", "Heroes are checked and activated individually.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$x += 145
$g_hRadManWardenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities", "Timed after") & ":", $x , $y , -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_01", "Activate the Ability on a timer.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadManAbilities_Info_02", "All Heroes are activated at the same time.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hTxtManWardenAbility = GUICtrlCreateInput("9", $x + 80, $y + 3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtManAbilities_Info_01", "Set the time in seconds for Timed Activation of Hero Abilities.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 115, $y + 4, -1, -1)
$x += 145
$g_hRadBothWardenAbility = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_01", "Check Both"), $x, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "RadBothAbilities_Info_02", "Activate the Ability when Hero becomes weak or when timer runs out")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 145
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "Group_02", "Attack Schedule"), $x - 20, $y - 20, $g_iSizeWGrpTab4, 138)
$x -= 5
$g_hChkAttackPlannerEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerEnable", "Enable Schedule"), $x, $y - 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerEnable_Info_01", "This option will allow you to schedule attack times") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerEnable_Info_02", "Bot continues to run and will attack only when schedule allows"))
GUICtrlSetOnEvent(-1, "chkAttackPlannerEnable")
$g_hChkAttackPlannerCloseCoC = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerCloseCoC", "Close CoC"), $x, $y + 15, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerCloseCoC_Info_01", "This option will close CoC app when not scheduled to Search & Attack!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01", "Bot Continues to run and will restart when schedule allows"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerCloseCoC")
$g_hChkAttackPlannerCloseAll = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerCloseAll", "Close emulator"), $x, $y + 34, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerCloseAll_Info_01", "This option will close emulator when not scheduled to Search & Attack!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01",-1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerCloseAll")
$g_hChkAttackPlannerSuspendComputer = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerSuspendComputer", "Suspend Computer"), $x, $y + 53, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerSuspendComputer_Info_01", "This option will suspend computer when not scheduled to Search & Attack!") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01",-1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerSuspendComputer")
$g_hChkAttackPlannerRandom = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerRandom", "Random Disable"), $x, $y + 72, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerRandom_Info_01", "This option will randomly stop attacking") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01",-1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerRandom")
$g_hCmbAttackPlannerRandom = GUICtrlCreateCombo("", $x + 110, $y + 70, 37, 16, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerRandom_Info_02", "Select number of hours to stop attacking"))
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20", "4")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerRandom")
$g_hLbAttackPlannerRandom = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "hrs", "hrs"), $x + 148, $y + 74, -1,-1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkAttackPlannerDayLimit = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerDayLimit", "Daily Limit"), $x, $y + 92, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlannerDayLimit_Info_01", "Will randomly stop attacking when exceed random number of attacks between range selected") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkAttackPlanner_Info_01",-1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerDayLimit")
$g_hCmbAttackPlannerDayMin = GUICtrlCreateInput("12", $x + 110, $y + 94, 37, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtMinLbAttackPlannerDayLimit_Info_01", "Enter minimum number of attacks allowed per day"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerDayMin")
$g_hLbAttackPlannerDayLimit = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "LbAttackPlannerDayLimit", "To"), $x + 152, $y + 96, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbAttackPlannerDayMax = GUICtrlCreateInput("15", $x + 167, $y + 94, 37, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "TxtMaxLbAttackPlannerDayLimit_Info_01", "Enter maximum number of attacks allowed per day"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerDayMax")
$x += 198
$y -= 5
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Day", -1) & ":", $x, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Su", -1), $x + 30, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Sunday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Mo", -1), $x + 46, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Monday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Tu", -1), $x + 63, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Tuesday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "We", -1), $x + 79, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Wednesday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Th", -1), $x + 99, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Thursday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Fr", -1), $x + 117, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Friday", -1))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Sa", -1), $x + 133, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Saturday", -1))
GUICtrlCreateLabel("X", $x + 155, $y+1, -1, 15)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
$y += 13
$g_ahChkAttackWeekdays[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[1] = GUICtrlCreateCheckbox("", $x + 47, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[2] = GUICtrlCreateCheckbox("", $x + 64, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[3] = GUICtrlCreateCheckbox("", $x + 81, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[4] = GUICtrlCreateCheckbox("", $x + 99, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[5] = GUICtrlCreateCheckbox("", $x + 117, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdays[6] = GUICtrlCreateCheckbox("", $x + 133, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Only_during_day", -1))
$g_ahChkAttackWeekdaysE = GUICtrlCreateCheckbox("", $x + 151, $y, 15, 15, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkattackWeekDaysE")
$x -= 25
$y += 17
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", "Hour") & ":", $x, $y, -1, 15)
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", "Only during these hours of each day")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("X", $x + 214, $y + 1, 11, 11)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 15
$g_ahChkAttackHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahChkAttackHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkattackHoursE1")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", "AM"), $x + 10, $y)
$y += 15
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
$g_ahChkAttackHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkattackHoursE2")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", "PM"), $x + 10, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 290
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "Group_03", "ClanCastle"), $x - 20, $y - 20, $g_iSizeWGrpTab4, 102)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y + 8, 64, 64)
$y -= 8
$g_hChkDropCCHoursEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkDropCCHoursEnable", "Enable CC Drop Schedule" ), $x + 70, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-Attack", "ChkDropCCHoursEnable_Info_01", "Use schedule to define when dropping CC is allowed, \r\n CC is always dropped when schedule is not enabled"))
GUICtrlSetOnEvent(-1, "chkDropCCHoursEnable")
$x += 188
$y += 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1), $x + 8, $y)
$y += 14
$x -= 21
$g_hLblDropCChour = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "Hour", -1) & ":", $x, $y, -1, 15)
Local $sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDropCChours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
$g_hLblDropCChours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
$g_hLblDropCChours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
$g_hLblDropCChours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
$g_hLblDropCChours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
$g_hLblDropCChours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
$g_hLblDropCChours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
$g_hLblDropCChours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
$g_hLblDropCChours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
$g_hLblDropCChours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
$g_hLblDropCChours[10] = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
$g_hLblDropCChours[11] = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
$g_ahLblDropCChoursE = GUICtrlCreateLabel("X", $x + 213, $y + 2, 11, 11)
$y += 15
$g_ahChkDropCCHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED )
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkDropCCHoursE1")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "AM", -1), $x + 10, $y)
$y += 15
$sTxtTip = GetTranslatedFileIni("MBR Global GUI Design", "Only_during_hours", -1)
$g_ahChkDropCCHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
_GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED )
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Global GUI Design", "Clear_set_row_of_boxes", -1))
GUICtrlSetOnEvent(-1, "chkDropCCHoursE2")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "PM", -1), $x + 10, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkSmartLightSpell = 0, $g_hChkSmartEQSpell = 0, $g_hChkNoobZap = 0, $g_hChkSmartZapDB = 0, $g_hChkSmartZapSaveHeroes = 0, $g_hTxtSmartZapMinDE = 0, $g_hTxtSmartExpectedDE = 0, $g_hChkDebugSmartZap = 0, $g_hChkSmartZapFTW = 0
Global $g_hLblSmartUseLSpell = 0, $g_hLblSmartUseEQSpell = 0, $g_hLblSmartZap = 0, $g_hLblNoobZap = 0, $g_hLblSmartLightningUsed = 0, $g_hLblSmartEarthQuakeUsed = 0
Func CreateAttackNewSmartZap()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "Group_01", "SmartZap/NoobZap"), $x - 20, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblUse_This_Spell_to_Zap", "Use This Spell to Zap Dark Drills"), $x + 20, $y, -1, -1)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnNewSmartZap, $x - 10, $y, 25, 25)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x + 45, $y + 20, 25, 25)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x + 125, $y + 20, 25, 25)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x - 10, $y + 90, 25, 25)
$y += 50
$g_hLblSmartUseLSpell = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseLSpell", "Use LSpells"), $x + 27, $y + 15, -1, -1)
GUICtrlSetOnEvent(-1, "chkSmartLightSpell")
GUICtrlSetState(-1,$GUI_HIDE)
$g_hChkSmartLightSpell = GUICtrlCreateCheckbox("", $x + 51, $y - 3, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseLSpell_Info_01", "Check this to drop Lightning Spells on top of Dark Elixir Drills.") & @CRLF & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseLSpell_Info_02", "Remember to go to the tab 'troops' and put the maximum capacity") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseLSpell_Info_03", "of your spell factory and the number of spells so that the bot can function perfectly."))
GUICtrlSetOnEvent(-1, "chkSmartLightSpell")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hLblSmartUseEQSpell = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseEQSpell", "Use EQSpell"), $x + 105, $y + 15, -1, -1)
GUICtrlSetOnEvent(-1, "chkEarthQuakeZap")
GUICtrlSetState(-1,$GUI_HIDE)
$g_hChkSmartEQSpell = GUICtrlCreateCheckbox("", $x + 131, $y - 3, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartUseEQSpell_Info_01", "Check this to drop EarthQuake Castle Spell on any Dark Elixir Drill"))
GUICtrlSetOnEvent(-1, "chkEarthQuakeZap")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hChkNoobZap = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkNoobZap", "Use NoobZap"), $x + 20 + 2, $y + 35, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkNoobZap_Info_01", "Check this to drop lightning spells on any Dark Elixir Drills"))
GUICtrlSetOnEvent(-1, "chkNoobZap")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hChkSmartZapDB = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapDB", "Only Zap Drills in Dead Bases"), $x + 20 + 2, $y + 55, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapDB_Info_01", "This will only SmartZap a Dead Base (Recommended)"))
GUICtrlSetOnEvent(-1, "chkSmartZapDB")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkSmartZapSaveHeroes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapSaveHeroes", "TH Snipe Not Zap if Heroes Deployed"), $x + 20 + 2, $y + 75, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapSaveHeroes_Info_01", "This will stop SmartZap from zapping a base on a Town Hall Snipe if your Heroes were deployed"))
GUICtrlSetOnEvent(-1, "chkSmartZapSaveHeroes")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkSmartZapFTW = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapFTW", "Strike For The Win"), $x + 20 + 2, $y + 95, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapFTW_Info_01", "SmartZap/NoobZap will try to reach 50% Destruction to get the win.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "ChkSmartZapFTW_Info_02", "It will not zap, if one Star is already reached, or if there is no chance to win."))
GUICtrlSetOnEvent(-1, "chkSmartZapFTW")
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$y -= 55
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 200 + 9, $y + 11, 24, 24)
GUICtrlCreateGroup("", $x + 199, $y - 1, 192, 106)
$g_hLblSmartZap = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartZap", "Min. amount of Dark Elixir") & ":", $x + 160 + 79, $y + 12, -1, -1)
$g_hTxtSmartZapMinDE = GUICtrlCreateInput("350", $x + 289, $y + 32, 90, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblSmartZap_Info_01", "Set the Value of the minimum amount of Dark Elixir in the Drills"))
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "txtMinDark")
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 200 + 9, $y + 57, 24, 24)
$g_hLblNoobZap = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblNoobZap", "Expected gain of Dark Drills") & ":", $x + 160 + 79, $y + 58, -1, -1)
$g_hTxtSmartExpectedDE = GUICtrlCreateInput("320", $x + 289, $y + 78, 90, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblNoobZap_Info_01", "Set value for expected gain every dark drill") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Options-SmartZap", "LblNoobZap_Info_02", "NoobZap will be stopped if the last zap gained less DE than expected"))
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "txtExpectedDE")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkShareAttack = 0, $g_hLblShareMinLoot = 0, $g_hTxtShareMinGold = 0, $g_hTxtShareMinElixir = 0, $g_hTxtShareMinDark = 0, $g_hTxtShareMessage = 0, $g_hChkTakeLootSS = 0, $g_hChkScreenshotLootInfo = 0
Global $g_hLblShareMinGold = 0, $g_hLblShareMinElixir = 0, $g_hLblShareMinDark = 0
Func CreateAttackSearchOptionsEndBattle()
Local $x = 20, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "Group_01", "Share Replay"), $x - 15, $y - 20, $g_iSizeWGrpTab4, 204)
$g_hChkShareAttack = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkShareAttack", "Share Replays in your clan's chat."), $x, $y - 7, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkShareAttack_Info_01", "Check this to share your battle replay in the clan chat."))
GUICtrlSetOnEvent(-1, "chkShareAttack")
$x -= 15
$y -= 2
$y -=5
$y += 25
$g_hLblShareMinLoot = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "LblShareMinLoot", "When Loot Gained") & ":", $x + 20, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblShareMinGold = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinGold = GUICtrlCreateInput("300000", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "TxtShareMinGold_Info_01", "Only Share Replay when the battle loot is more than this amount of Gold."))
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 182, $y, 16, 16)
$y += 22
$g_hLblShareMinElixir = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinElixir = GUICtrlCreateInput("300000", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "TxtShareMinElixir_Info_01", "Only Share Replay when the battle loot is more than this amount of Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 182, $y, 16, 16)
$y += 22
$g_hLblShareMinDark = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinDark = GUICtrlCreateInput("0", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "TxtShareMinDark_Info_01", "Only Share Replay when the battle loot is more than this amount of Dark Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 5)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 182, $y, 16, 16)
$y += 25
$x += 5
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "LblRandomMessage", "Use a random message from this list") & ":", $x, $y - 2, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 27
$g_hTxtShareMessage = GUICtrlCreateEdit("", $x, $y - 10, 205, 72, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, StringFormat(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ListShareMessage_Item_01", "Nice\r\nGood\r\nThanks \r\nWowwww")))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ListShareMessage_Info_01", "Message to send with the Share Replay"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 20
$y += 100
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "Group_02", "Take Loot Snapshot"), $x - 15, $y - 20, $g_iSizeWGrpTab4, 67)
$g_hChkTakeLootSS = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "Group_02", -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkTakeLootSS_Info_01", "Check this if you want to save a Loot snapshot of the Village that was attacked."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTakeLootSS")
$y += 18
$g_hChkScreenshotLootInfo = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkScreenshotLootInfo", "Include loot info in filename"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-EndBattle", "ChkScreenshotLootInfo_Info_01", "Include loot info in the screenshot filename"))
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkTrophyRange = 0, $g_hTxtDropTrophy = 0, $g_hTxtMaxTrophy = 0, $g_hChkTrophyHeroes = 0, $g_hCmbTrophyHeroesPriority = 0, $g_hChkTrophyAtkDead = 0, $g_hTxtDropTrophyArmyMin = 0
Global $g_hPicMinTrophies[$eLeagueCount] = [0,0,0,0,0,0,0,0,0], $g_hLblMinTrophies = 0
Global $g_hPicMaxTrophies[$eLeagueCount] = [0,0,0,0,0,0,0,0,0], $g_hLblMaxTrophies = 0
Global $g_hLblTrophyHeroesPriority = 0, $g_hLblDropTrophyArmyMin = 0, $g_hLblDropTrophyArmyPercent = 0
Func CreateAttackSearchOptionsTrophySettings()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "Group_01", "Trophy Settings"), $x - 20, $y - 20, $g_iSizeWGrpTab4, $g_iSizeHGrpTab4)
$x += 25
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 15, $y, 64, 64, $BS_ICON)
$x += 50
$g_hChkTrophyRange = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyRange", "Trophy range") & ":", $x + 20, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkTrophyRange")
$g_hTxtDropTrophy = GUICtrlCreateInput("5000", $x + 110, $y, 35, -1, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 4)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "TxtDropTrophy_Info_01", "MIN: The Bot will drop trophies until below this value."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "TxtDropTrophy")
$g_hPicMinTrophies[$eLeagueUnranked] = _GUICtrlCreateIcon($g_sLibIconPath, $eUnranked, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_SHOW)
$g_hPicMinTrophies[$eLeagueBronze] = _GUICtrlCreateIcon($g_sLibIconPath, $eBronze, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueSilver] = _GUICtrlCreateIcon($g_sLibIconPath, $eSilver, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueGold] = _GUICtrlCreateIcon($g_sLibIconPath, $eGold, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueCrystal] = _GUICtrlCreateIcon($g_sLibIconPath, $eCrystal, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueMaster] = _GUICtrlCreateIcon($g_sLibIconPath, $eMaster, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueChampion] = _GUICtrlCreateIcon($g_sLibIconPath, $eChampion, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueTitan] = _GUICtrlCreateIcon($g_sLibIconPath, $eTitan, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMinTrophies[$eLeagueLegend] = _GUICtrlCreateIcon($g_sLibIconPath, $eLegend, $x + 116, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hLblMinTrophies = GUICtrlCreateLabel("", $x + 133, $y - 15, 17, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateLabel("-", $x + 148, $y + 4, -1, -1)
$g_hTxtMaxTrophy = GUICtrlCreateInput("5000", $x + 155, $y, 35, -1, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 4)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "TxtMaxTrophy_Info_01", "MAX: The Bot will drop trophies if your trophy count is greater than this value."))
GuiCtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetOnEvent(-1, "TxtMaxTrophy")
$g_hPicMaxTrophies[$eLeagueUnranked] = _GUICtrlCreateIcon($g_sLibIconPath, $eUnranked, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_SHOW)
$g_hPicMaxTrophies[$eLeagueBronze] = _GUICtrlCreateIcon($g_sLibIconPath, $eBronze, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueSilver] = _GUICtrlCreateIcon($g_sLibIconPath, $eSilver, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueGold] = _GUICtrlCreateIcon($g_sLibIconPath, $eGold, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueCrystal] = _GUICtrlCreateIcon($g_sLibIconPath, $eCrystal, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueMaster] = _GUICtrlCreateIcon($g_sLibIconPath, $eMaster, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueChampion] = _GUICtrlCreateIcon($g_sLibIconPath, $eChampion, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueTitan] = _GUICtrlCreateIcon($g_sLibIconPath, $eTitan, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hPicMaxTrophies[$eLeagueLegend] = _GUICtrlCreateIcon($g_sLibIconPath, $eLegend, $x + 161, $y - 30, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$g_hLblMaxTrophies = GUICtrlCreateLabel("", $x + 178, $y - 15, 17, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
$y += 24
$x += 20
$g_hChkTrophyHeroes = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyHeroes", "Use Heroes To Drop Trophies"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyHeroes_Info_01", "Use Heroes to drop Trophies if Heroes are available."))
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkTrophyHeroes")
$y += 25
$g_hLblTrophyHeroesPriority = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "LblTrophyHeroesPriority", "Priority Hero to Use") & ":", $x + 16, $y, 110, -1)
$g_hCmbTrophyHeroesPriority = GUICtrlCreateCombo("", $x + 125, $y - 4 , 170, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "LblTrophyHeroesPriority_Info_01", "Set the order on which Hero the Bot drops first when available."))
Local $txtPriorityConnector = ">"
Local $txtPriorityDefault = GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1)
Local $txtPriorityList = "" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & "|" & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Grand Warden", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "Queen", -1) & $txtPriorityConnector & GetTranslatedFileIni("MBR Global GUI Design Names Troops", "King", -1) & "|" & ""
If $g_bDebugSetlog Then SetDebugLog($txtPriorityDefault)
If $g_bDebugSetlog Then SetDebugLog($txtPriorityList)
GUICtrlSetData(-1, $txtPriorityList , $txtPriorityDefault)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkTrophyAtkDead = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyAtkDead", "Attack Dead Bases During Drop"), $x, $y + 2, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "ChkTrophyAtkDead_Info_01", "Attack a Deadbase found on the first search while dropping Trophies."))
GUICtrlSetOnEvent(-1, "chkTrophyAtkDead")
GUICtrlSetState(-1,$GUI_DISABLE)
$y += 24
$g_hLblDropTrophyArmyMin = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "LblDropTrophyArmyMin", "Wait until Army Camp are at least") & " " & ChrW(8805), $x + 16, $y + 6, 200, -1, $SS_LEFT)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Attack - Options-TrophySettings", "LblDropTrophyArmyMin_Info_01", "Enter the percent of full army required for dead base attack before starting trophy drop.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtDropTrophyArmyMin = GUICtrlCreateInput("70", $x + 215, $y + 2, 27, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDropTrophyArmyPercent = GUICtrlCreateLabel("%", $x + 245, $y + 6, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ATTACKOPTION_TAB = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM1 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM2 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM3 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM4 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM5 = 0
Func CreateAttackSearchOptions()
$g_hGUI_ATTACKOPTION = _GUICreate("", $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
GUISwitch($g_hGUI_ATTACKOPTION)
$g_hGUI_ATTACKOPTION_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab3, $g_iSizeHGrpTab3, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ATTACKOPTION_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_01", -1))
CreateAttackSearchOptionsSearch()
$g_hGUI_ATTACKOPTION_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_02", -1))
CreateAttackSearchOptionsAttack()
$g_hGUI_ATTACKOPTION_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_05_STab_01", "SmartZap"))
CreateAttackNewSmartZap()
$g_hGUI_ATTACKOPTION_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_0X_STab_03", -1))
CreateAttackSearchOptionsEndBattle()
$g_hGUI_ATTACKOPTION_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_05_STab_02", "Trophy Settings"))
CreateAttackSearchOptionsTrophySettings()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_SEARCH_TAB = 0, $g_hGUI_SEARCH_TAB_ITEM1 = 0, $g_hGUI_SEARCH_TAB_ITEM2 = 0, $g_hGUI_SEARCH_TAB_ITEM3 = 0, $g_hGUI_SEARCH_TAB_ITEM4 = 0, $g_hGUI_SEARCH_TAB_ITEM5 = 0
Global $g_hChkDeadbase = 0, $g_hChkActivebase = 0, $g_hChkTHSnipe = 0, $g_hChkBully = 0
Global $g_hLblDeadbaseDisabled = 0, $g_hLblActivebaseDisabled = 0, $g_hLblTHSnipeDisabled = 0, $g_hLblBullyDisabled = 0
Func CreateAttackSearch()
$g_hGUI_SEARCH = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
Local $x = 82
$g_hChkDeadbase = GUICtrlCreateCheckbox("", $x, 6, 13, 13)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "DBcheck")
$g_hChkActivebase = GUICtrlCreateCheckbox("", $x + 100, 4, 13, 13)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "Abcheck")
$g_hChkTHSnipe = GUICtrlCreateCheckbox("", $x + 190, 4, 13, 13)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "TScheck")
$g_hChkBully = GUICtrlCreateCheckbox("", $x + 260, 4, 13, 13)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "Bullycheck")
CreateAttackSearchDeadBase()
CreateAttackSearchActiveBase()
CreateAttackSearchTHSnipe()
CreateAttackSearchBully()
CreateAttackSearchOptions()
GUISwitch($g_hGUI_SEARCH)
$g_hGUI_SEARCH_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_SEARCH_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_01", "DeadBase") & "    ")
$g_hLblDeadbaseDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_01", "Note: This Strategy is disabled, tick the checkmark on the") & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", "tab to enable it!"), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_02", "ActiveBase") & "    ")
$g_hLblActivebaseDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_02", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_03", "TH Snipe") & "    ")
$g_hLblTHSnipeDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_03", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_04", "Bully") & "    ")
$g_hLblBullyDisabled = GUICtrlCreateLabel(GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_01", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_04", -1) & " " & GetTranslatedFileIni("MBR Main GUI", "disabled_Tab_03_STab_02_STab_Info_02", -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02_STab_05", "Options"))
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_STRATEGIES = 0
Global $g_hGUI_STRATEGIES_TAB = 0, $g_hGUI_STRATEGIES_TAB_ITEM1 = 0, $g_hGUI_STRATEGIES_TAB_ITEM2 = 0
Global $g_hCmbPresetList = 0, $g_hTxtPresetMessage = 0, $g_hLblLoadPresetMessage = 0, $g_hBtnGUIPresetLoadConf = 0, $g_hChkDeleteConf = 0, $g_hBtnGUIPresetDeleteConf = 0, $g_hBtnStrategyFolder = 0, $g_hTxtPresetSaveFilename = 0, $g_hTxtSavePresetMessage = 0, $g_hBtnGUIPresetSaveConf = 0
Func CreateAttackStrategies()
$g_hGUI_STRATEGIES = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
GUISwitch($g_hGUI_STRATEGIES)
Local $xStart = 5, $yStart = 25
$g_hGUI_STRATEGIES_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_STRATEGIES_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_03_STab_01", "Load Strategy"))
Local $x = $xStart, $y = $yStart
$g_hCmbPresetList = GUICtrlCreateCombo("", $x, $y, 200, 300, $WS_VSCROLL)
GUICtrlSetOnEvent(-1, "PresetLoadConfigInfo")
$x += 205
$g_hTxtPresetMessage = GUICtrlCreateEdit("", $x, $y, 225, 250, BitOR($ES_WANTRETURN, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
Local $loadmessage = GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "LblLoadPresetMessage", "LOAD PRECONFIGURED SETTINGS.\n\n- Load ALL Train Army Tab Settings\n- Load ALL Search && Attack Tab Settings\n\n- EXCEPT: Share Replay Settings\n- EXCEPT: Take Loot Snapshot Settings\n- EXCEPT: Gem Boost Settings")
$g_hLblLoadPresetMessage = GUICtrlCreateLabel(StringReplace($loadmessage, "\n", @crlf ), $x + 15, $y + 25, 400)
$x += 5
$y += 255
$g_hBtnGUIPresetLoadConf = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "BtnGUIPresetLoadConf", "Load Configuration"), $x, $y, 130, 20)
GUICtrlSetOnEvent(-1, "PresetLoadConf")
GUICtrlSetState(-1, $GUI_HIDE)
$x += 145
$g_hChkDeleteConf = GUICtrlCreateCheckbox("", $x, $y + 2, 15, 15)
GUICtrlSetOnEvent(-1, "chkCheckDeleteConf")
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnGUIPresetDeleteConf = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "BtnGUIPresetDeleteConf", "Delete"), $x + 15, $y, 60, 20)
GUICtrlSetOnEvent(-1, "PresetDeleteConf")
GUICtrlSetState(-1, $GUI_HIDE + $GUI_DISABLE)
$g_hBtnStrategyFolder = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "BtnStrategyFolder", "Open Strategy folder"), $xStart + 40, $y + 40, 120, 30)
GUICtrlSetOnEvent(-1, "btnStrategyFolder")
$g_hGUI_STRATEGIES_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_03_STab_02", "Save Strategy"))
$x = $xStart
$y = $yStart
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "LblSaveFilename", "Strategy file name") & ":", $x, $y + 4, 200, 25, $SS_RIGHT)
$x += 205
$g_hTxtPresetSaveFilename = GUICtrlCreateInput("strategy " & @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & "." & @MIN & "." & @SEC, $x, $y, 200, 25)
$x = $xStart
$y += 30
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "LblSaveFilenameNote", "Notes") & ":" , $x, $y + 4, 200, 25, $SS_RIGHT)
Local $savemessage = GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "LblSavePresetMessage", "SAVE SETTINGS\n--------------------------------------\nSave ALL:\n- Train Army Tab Settings\n- Search && Attack Tab Settings\n\nExcept:\n- Share Replay Settings\n- Take Loot Snapshot Settings\n- Gem Boost Settings\n--------------------------------------")
GUICtrlCreateLabel(StringReplace($savemessage, "\n", @crlf), $x + 15, $y + 4 + 25, 280)
$x += 205
$g_hTxtSavePresetMessage = GUICtrlCreateEdit("", $x, $y, 223, 230, BitOR($ES_WANTRETURN, $ES_AUTOVSCROLL))
$y += 235
$g_hBtnGUIPresetSaveConf = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Strategies", "BtnGUIPresetSaveConf", "Save Configuration"), $x + 13, $y, 200, 20)
GUICtrlSetOnEvent(-1, "PresetSaveConf")
GUICtrlCreateTabItem("")
EndFunc
Func LoadTranslatedDropOrderList()
Global $g_asDropOrderList = ["", "Barbarians", "Archers", "Giants", "Goblins", "Wall Breakers", "Balloons", "Wizards", "Healers", "Dragons", "Pekkas", "Baby Dragons", "Miners", "Electro Dragons", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers", "Ice Golems", "Clan Castle", "Heroes"]
EndFunc
Global $g_hChkCustomDropOrderEnable = 0
Global $g_ahCmbDropOrder[$eDropOrderCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahImgDropOrder[$eDropOrderCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hBtnDropOrderSet = 0, $g_ahImgDropOrderSet = 0
Global $g_hBtnRemoveDropOrder = 0
Func CreateAttackTab()
$g_hGUI_ATTACK = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
CreateAttackTroops()
CreateAttackSearch()
CreateAttackStrategies()
GUISwitch($g_hGUI_ATTACK)
$g_hGUI_ATTACK_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ATTACK_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_01", "Train Army"))
$g_hGUI_ATTACK_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_02", "Search && Attack"))
$g_hGUI_ATTACK_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03_STab_03", "Strategies"))
CreateDropOrderGUI()
GUICtrlCreateTabItem("")
EndFunc
Func CreateDropOrderGUI()
$g_hGUI_DropOrder = _GUICreate(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "GUI_DropOrder", "Attack Custom Dropping Order"), 322, 448, -1, -1, $WS_BORDER, $WS_EX_CONTROLPARENT)
SetDefaultDropOrderGroup(False)
LoadTranslatedDropOrderList()
Local $x = 25, $y = 25
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "Group_03", "Custom Dropping Order"), $x - 20, $y - 20, 308, 345)
$x += 10
$y += 20
$g_hChkCustomDropOrderEnable = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkCustomDropOrderEnable", "Enable Custom Dropping Order"), $x - 13, $y - 22, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkCustomDropOrderEnable_Info_01", "Enable to select a custom troops dropping order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkCustomDropOrderEnable_Info_02", "Will not have effect on CSV Scripted Attack! It's only for Standard Attack.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "ChkCustomDropOrderEnable_Info_03", "For Live and Dead Bases"))
GUICtrlSetOnEvent(-1, "chkDropOrder")
Local $sComboData = ""
For $j = 0 To UBound($g_asDropOrderList) - 1
$sComboData &= $g_asDropOrderList[$j] & "|"
Next
Local $g_hTxtDropOrder = GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "TxtDropOrder", "Enter sequence order for drop of troop #")
$y += 5
For $p = 0 To $eDropOrderCount - 1
If $p < 12 Then
GUICtrlCreateLabel($p + 1 & ":", $x - 19, $y + 3, -1, 18)
$g_ahCmbDropOrder[$p] = GUICtrlCreateCombo("", $x, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUIDropOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $g_hTxtDropOrder & $p + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgDropOrder[$p] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 96, $y + 1, 18, 18)
$y += 25
Else
If $p = 12 Then
$x += 128
$y = 49
EndIf
GUICtrlCreateLabel($p + 1 & ":", $x - 5, $y + 4, -1, 18)
$g_ahCmbDropOrder[$p] = GUICtrlCreateCombo("", $x + 20, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUIDropOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $g_hTxtDropOrder & $p + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgDropOrder[$p] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 120, $y + 1, 18, 18)
$y += 25
EndIf
Next
$x = 25
$y = 355
$g_hBtnDropOrderSet = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnDropOrderSet", "Apply New Order"), $x, $y, 100, 25)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_ENABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnDropOrderSet_Info_01", "Push button when finished selecting custom troops dropping order") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnDropOrderSet_Info_02", "When not all troop slots are filled, will use random troop order in empty slots!"))
GUICtrlSetOnEvent(-1, "BtnDropOrderSet")
$g_ahImgDropOrderSet = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 104, $y + 4, 18, 18)
$x += 150
$g_hBtnRemoveDropOrder = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnRemoveDropOrder", "Empty Drop List"), $x, $y, 118, 25)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnRemoveDropOrder_Info_01", "Push button to remove all troops from list and start over"))
GUICtrlSetOnEvent(-1, "BtnRemoveDropOrder")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $g_hBtnClose = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Attack - Attack", "BtnClose", "Close"), 229, 388, 85, 25)
GUICtrlSetOnEvent(-1, "CloseCustomDropOrder")
EndFunc
Global $g_hGUI_BOT = 0
Global $g_hCmbGUILanguage = 0
Global $g_hChkDisableSplash = 0, $g_hChkForMBRUpdates = 0, $g_hChkDeleteLogs = 0, $g_hTxtDeleteLogsDays = 0, $g_hChkDeleteTemp = 0, $g_hTxtDeleteTempDays = 0, $g_hChkDeleteLoots = 0, $g_hTxtDeleteLootsDays = 0
Global $g_hChkAutostart = 0, $g_hTxtAutostartDelay = 0, $g_hChkCheckGameLanguage = 0, $g_hChkAutoAlign = 0, $g_hTxtAlignOffsetX = 0, $g_hTxtAlignOffsetY = 0, $g_hCmbAlignmentOptions = 0
Global $g_hTxtGlobalActiveBotsAllowed = 0, $g_hTxtGlobalThreads = 0, $g_hTxtThreads = 0
Global $g_hChkBotCustomTitleBarClick = 0, $g_hChkBotAutoSlideClick = 0, $g_hChkHideWhenMinimized = 0, $g_hChkUseRandomClick = 0, $g_hChkScreenshotType = 0, $g_hChkScreenshotHideName = 0, $g_hTxtTimeAnotherDevice = 0
Global $g_hChkSinglePBTForced = 0, $g_hTxtSinglePBTimeForced = 0, $g_hTxtPBTimeForcedExit = 0, $g_hChkFixClanCastle = 0, $g_hChkAutoResume = 0, $g_hTxtAutoResumeTime = 0, $g_hChkDisableNotifications = 0
Global $g_hChkSqlite = 0
Global $g_hBtnExportData = 0
Global $g_hChkEnableAuto = 0, $g_hChkAutoDock = 0, $g_hChkAutoHideEmulator = 0, $g_hChkAutoMinimizeBot = 0
Func CreateBotOptions()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_01", "GUI Language"), $x - 20, $y - 20, 210, 47)
$y -= 2
$g_hCmbGUILanguage = _GUICtrlComboBoxEx_Create($g_hGUI_BOT, "", $x - 8, $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(_GUICtrlComboBoxEx_GetComboControl($g_hCmbGUILanguage), GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbGUILanguage_Info_01", "Use this to switch to a different GUI language"), Default, Default, Default, False)
LoadLanguagesComboBox()
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 50
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_02", "When Bot Loads"), $x - 20, $y - 20, 210, 120)
$y -= 4
$g_hChkDisableSplash = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDisableSplash", "Disable Splash Screen"), $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDisableSplash_Info_01", "Disables the splash screen on startup."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hChkForMBRUpdates = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkForMBRUpdates", "Check for Updates"), $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkForMBRUpdates_Info_01", "Check if you are running the latest version of the bot."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 20
$g_hChkDeleteLogs = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteLogs", "Delete Log Files")& ":", $x - 10, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteLogs_Info_01", "Delete log files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDeleteLogs")
$g_hTxtDeleteLogsDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "days", "days"), $x + 150, $y + 4, 27, 15)
$y += 20
$g_hChkDeleteTemp = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteTemp", "Delete Temp Files") & ":", $x - 10, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteTemp_Info_01", "Delete temp files older than this specified No. of days."))
GUICtrlSetOnEvent(-1, "chkDeleteTemp")
$g_hTxtDeleteTempDays = GUICtrlCreateInput("5", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "days", -1), $x + 150, $y + 4, 27, 15)
$y += 20
$g_hChkDeleteLoots = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteLoots", "Delete Loot Images") & ":", $x - 10, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDeleteLoots_Info_01", "Delete loot image files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDeleteLoots")
$g_hTxtDeleteLootsDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "days", -1), $x + 150, $y + 4, 27, 15)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 44
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_03", "When Bot Starts"), $x - 20, $y - 20, 210, 162)
$y -= 5
$g_hChkAutostart = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutostart", "Auto START after") & ":", $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutostart_Info_01", "Auto START the Bot after this No. of seconds."))
GUICtrlSetOnEvent(-1, "chkAutostart")
$g_hTxtAutostartDelay = GUICtrlCreateInput("10", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "sec.", -1), $x + 150, $y + 4, 27, 18)
$y += 20
$g_hChkEnableAuto = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkEnableAuto", "Enable Auto Dock/Hide for Emulator") & ":", $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkEnableAuto_Info_01", "Check it to Enable Auto Dock/Hide for Emulator after Start bot & Restart Emulator"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkEnableAuto")
$y += 20
$g_hChkAutoDock = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoDock", "Auto Dock"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoDock_Info_01", "Auto use Dock Android Window after Start bot & Restart Emulator"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "btnEnableAuto")
$g_hChkAutoHideEmulator = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoHideEmulator", "Auto HIDE"), $x + 90, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoHideEmulator_Info_01", "Auto Hidden the Emulator after Start bot & Restart Emulator"))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "btnEnableAuto")
$y += 20
$g_hChkAutoMinimizeBot = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoMinimizeBot", "Auto Minimize the Bot after Start"), $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoMinimizeBot_Info_01", "Check it to enable Auto Minimize the Bot after Start"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hChkCheckGameLanguage = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkCheckGameLanguage", "Check Game Language (EN)"), $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkCheckGameLanguage_Info_01", "Check if the Game is set to the correct language (Must be set to English)."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 20
$g_hChkAutoAlign = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoAlign", "Auto Align"), $x - 10, $y, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoAlign_Info_01", "Reposition/Align Android Emulator and BOT windows on the screen.")
GUICtrlSetOnEvent(-1, "chkDisposeWindows")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblAlignOffsetX", "Offset") & ":", $x + 85, $y + 4, -1, -1)
$g_hTxtAlignOffsetX = GUICtrlCreateInput("", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtAlignOffsetX_Info_01", "Offset horizontal pixels between Android Emulator and BOT windows.")
$g_hTxtAlignOffsetY= GUICtrlCreateInput("", $x + 150, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtAlignOffsetY_Info_01", "Offset vertical pixels between Android Emulator and BOT windows.")
$y += 20
$g_hCmbAlignmentOptions = GUICtrlCreateCombo("", $x - 10, $y, 185, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_01", "0,0: Android Emulator-Bot") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_02", "0,0: Bot-Android Emulator") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_03", "SNAP: Bot TopRight to Android") &"|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_04", "SNAP: Bot TopLeft to Android") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_05", "SNAP: Bot BottomRight to Android") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_06", "SNAP: Bot BottomLeft to Android") & "|" & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_07", "DOCK: Android into Bot"), GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Item_07", -1))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Info_01", "0,0: Reposition Android Emulator screen to position 0,0 on windows desktop and align Bot window right or left to it.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "CmbAlignmentOptions_Info_02", "SNAP: Only reorder windows, Align Bot window to Android Emulator window at Top Right, Top Left, Bottom Right or Bottom Left.\r\n" & "DOCK: Integrate Android Screen into bot window."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 47
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_08", "Processor/Thread Advanced"), $x - 20, $y - 20, 210, 80)
$y -= 2
$g_hTxtGlobalActiveBotsAllowed = GUICtrlCreateInput($g_iGlobalActiveBotsAllowed, $x - 10, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtGlobalActiveBotsAllowed_Info_01", "When running multiple bots, specify how many can run at the same time.\r\nThis reduces your CPU utilization significantly.\r\nHalf of available logical processors is a good number.\r\nThis configuration is shared across all profiles/instances and a restart of all bots is required (close all, wait, and start all again!).")
GUICtrlSetOnEvent(-1, "txtGlobalActiveBotsAllowed")
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblGlobalActiveBotsAllowed_Info_01", "Bots can run at the same time"), $x + 20, $y + 3)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hTxtGlobalThreads = GUICtrlCreateInput($g_iGlobalThreads, $x - 10, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtGlobalThreads_Info_01", "When running multiple bots, specify how many global threads for image processing tasks can run at the same time.\r\nThis reduces your CPU utilization significantly.\r\nHalf of available logical processors is a good number.\r\nThis configuration is shared across all profiles/instances and a restart of all bots is required (close all, wait, and start all again!).")
GUICtrlSetOnEvent(-1, "txtGlobalThreads")
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblGlobalThreads_Info_01", "Image Threads for all bots"), $x + 30, $y + 3)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hTxtThreads = GUICtrlCreateInput($g_iThreads, $x - 10, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtThreads_Info_01", "When images are processed, multiple threads are used. Here you specifiy how many threads this bot can use.\r\nLess threads reduce your CPU utilization significantly.\r\nHalf of available logical processors is a good number. Use 0 for all available. Global threads setting has priority.")
GUICtrlSetOnEvent(-1, "txtThreads")
GUICtrlSetLimit(-1, 2)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblThreads_Info_01", "Image Threads for this bot"), $x + 30, $y + 3)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 240, $y = 45, $yGroup = $y
Local $hGroup = GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_04", "Advanced"), $x - 20, $y - 20, 225, 140)
$g_hChkBotCustomTitleBarClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkBotCustomTitleBarClick", "My Bot design Title Bar"), $x - 10, $y, -1, -1)
If BitAND($g_iBotDesignFlags, 1) Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkBotCustomTitleBarClick")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkBotCustomTitleBarClick_Info_01", "Enable optimized My Bot Window Title Bar and\r\nthin Window Border (restart of bot is required)"))
$y += 19
$g_hChkBotAutoSlideClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkBotAutoSlideClick", "Auto Slide when docked"), $x - 10, $y, -1, -1)
If BitAND($g_iBotDesignFlags, 1) = 0 Then GUICtrlSetState(-1, $GUI_DISABLE)
If BitAND($g_iBotDesignFlags, 2) Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkBotAutoSlideClick")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkBotAutoSlideClick_Info_01", "Enable auto sliding when Android is docked\r\non bot window activation/deactivation"))
$y += 19
$g_hChkHideWhenMinimized = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkHideWhenMinimized", "Hide when minimized"), $x - 10, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkHideWhenMinimized")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkHideWhenMinimized_Info_01", "Hide bot window in taskbar when minimized.\r\nUse trayicon 'Show bot' to display bot window again."))
$y += 19
$g_hChkAutoResume = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoResume", "Auto resume Bot after") & ":", $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1,GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkAutoResume_Info_01", "This will auto resume your bot after x minutes"))
GUICtrlSetOnEvent(-1, "chkAutoResume")
$g_hTxtAutoResumeTime = GUICtrlCreateInput("5",$x + 132, $y + 2, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", -1), $x + 167, $y + 3, -1, -1)
$y += 19
$g_hChkDisableNotifications = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDisableNotifications", "Disable Notifications"), $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1,GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkDisableNotifications_Info_01", "Disable Notifications sent by the Bot"))
GUICtrlSetOnEvent(-1, "chkDisableNotifications")
$y += 19
$g_hChkUseRandomClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkUseRandomClick", "Random Click"), $x - 10, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkUseRandomClick")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_05", "Photo Screenshot Options"), $x - 20, $y - 17, 225, 60)
$g_hChkScreenshotType = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkScreenshotType", "Make in PNG format"), $x - 10, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkScreenshotType")
$y += 19
$g_hChkScreenshotHideName = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkScreenshotHideName", "Hide Village and Clan Castle Name"), $x - 10, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkScreenshotHideName")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 48
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_06", "Remote Device"), $x - 20, $y - 20 , 225, 42)
$y -= 5
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblTimeAnotherDevice", "When 'Another Device' wait") & ":", $x - 10, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblTimeAnotherDevice_Info_01", "Enter the time to wait (in Minutes) before the Bot reconnects when another device took control.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTimeAnotherDevice = GUICtrlCreateInput("2", $x + 132, $y, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", -1), $x + 167, $y + 2, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 51
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "Group_07", "Other Options"), $x - 20, $y - 20, 225, 122)
$g_hChkSinglePBTForced = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkSinglePBTForced", "Force Single PB logoff"), $x - 10, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkSinglePBTForced")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkSinglePBTForced_Info_01", "This forces bot to exit CoC only one time prior to normal start of PB"))
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hTxtSinglePBTimeForced = GUICtrlCreateInput("17", $x + 132, $y + 2, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "TxtSinglePBTimeForced_Info_01", "Type in number of minutes to keep CoC closed. Set to 15 minimum to reset PB timer!"))
GUICtrlSetOnEvent(-1, "txtSinglePBTimeForced")
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", -1), $x + 167, $y + 4, -1, -1)
$y += 20
GUICtrlCreateLabel( GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblPBTimeForcedExit", "Subtract time for early PB exit"), $x - 10, $y + 3)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "LblPBTimeForcedExit_Info_01", "Type in number of minutes to quit CoC early! Setting below 10 minutes may not function!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtPBTimeForcedExit = GUICtrlCreateInput("15", $x + 132, $y, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "txtSinglePBTimeForced")
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "min.", -1), $x + 167, $y + 3, -1, -1)
$y += 20
$g_hChkFixClanCastle = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkFixClanCastle", "Force Clan Castle Detection"), $x - 10, $y + 2, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkFixClanCastle_Info_01", "If clan Castle it is undetected and it is NOT placed in the last slot, force bot to consider the undetected slot as Clan Castle"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hChkSqlite = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkSqlite", "Use SQLite for statistics"), $x - 10, $y + 2, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkSqlite_Info_01", "Will collect data from attacks to SQlite, exporting to CSV.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "ChkSqlite_Info_02", "Excellent to use with Smart-Farm, to collect sides, resources inside and outside, etc."))
GUICtrlSetOnEvent(-1, "chkSQLite")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hBtnExportData = GUICtrlCreateButton( GetTranslatedFileIni("MBR GUI Design Child Bot - Options", "BtnExportData", "ExportData"), $x + 137 , $y + 14)
GUICtrlSetOnEvent(-1, "SQLiteExport")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbCOCDistributors = 0, $g_hCmbAndroidBackgroundMode = 0, $g_hCmbAndroidZoomoutMode = 0, $g_hCmbSuspendAndroid = 0, $g_hChkAndroidAdbClick = 0, $g_hChkAndroidAdbClickDragScript = 0, $g_hBtnAndroidAdbShell = 0, $g_hBtnAndroidHome = 0, $g_hBtnAndroidBack = 0, $g_hTxtAndroidRebootHours = 0, $g_hChkAndroidCloseWithBot = 0, $g_hChkUpdateSharedPrefs = 0, $g_hBtnAndroidEnableTouch = 0, $g_hBtnAndroidDisableTouch = 0, $g_lblHelpBot = 0
Func CreateBotAndroid()
Local $x = 25, $y = 45, $y2, $w = 240, $h = 50, $sTxtTip
GUICtrlCreateGroup(GetTranslatedFileIni("MBR Distributors", "Group_01", "Distributors"), $x - 20, $y - 20, $w, $h)
$y -= 2
$g_hCmbCOCDistributors = GUICtrlCreateCombo("", $x - 8, $y, $w - 25, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Distributors", "CmbCOCDistributors_Info_01", "Allow bot to launch COC based on the distribution chosen"))
GUICtrlSetOnEvent(-1, "cmbCOCDistributors")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += $h + 5
$y2 = $y
$w = $g_iSizeWGrpTab2 - 2
$h = 21 + 6 * 25
GUICtrlCreateGroup(GetTranslatedFileIni("Android", "Android_Options", "Android Options"), $x - 20, $y - 20, $w, $h)
GUICtrlCreateLabel(GetTranslatedFileIni("Android", "LblBackgroundMode", "Screencapture Background Mode"), $x - 8, $y + 5, 180, 22, $SS_RIGHT)
$g_hCmbAndroidBackgroundMode = GUICtrlCreateCombo("", $x - 8 + 180 + 5, $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("Android", "CmbBackgroundMode", "Default|Use WinAPI (need Android DirectX)|Use ADB screencap"))
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "CmbBackgroundMode_Info", 'Control how the Android screenshot is taken in background mode.\nDefault chooses WinAPI or screencap based on Android Emulator.\nInfo: WinAPI is faster than screencap, but screencap always works,\neven if screen is off (we call that the "True Background Mode")!'))
_GUICtrlComboBox_SetCurSel(-1, $g_iAndroidBackgroundMode)
GUICtrlSetOnEvent(-1, "cmbAndroidBackgroundMode")
$y += 25
GUICtrlCreateLabel(GetTranslatedFileIni("Android", "LblZoomoutMode", "Zoomout Mode"), $x - 8, $y + 5, 180, 22, $SS_RIGHT)
$g_hCmbAndroidZoomoutMode = GUICtrlCreateCombo("", $x - 8 + 180 + 5, $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("Android", "CmbZoomoutMode", "Default|Use Minitouch script|Use dd script|WinAPI"))
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "CmbZoomoutMode_Info", 'Control how the zoomout is done. Default chooses usually Minitouch script, which is most stable.'))
_GUICtrlComboBox_SetCurSel(-1, $g_iAndroidZoomoutMode)
GUICtrlSetOnEvent(-1, "cmbAndroidBackgroundMode")
$y += 25
$g_hChkAndroidAdbClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("Android", "ChkAdbClick", "Use minitouch for Click"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "ChkAdbClick_Info", "Use minitouch for Android clicks.\r\nIf unchecked use WinAPI control messages."))
GUICtrlSetState(-1,(($g_bAndroidAdbClickEnabled) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
$y += 25
$g_hChkAndroidAdbClickDragScript = GUICtrlCreateCheckbox(GetTranslatedFileIni("Android", "ChkAdbClickDragScript", "Use minitouch for accurate Click && Drag"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "ChkAdbClickDragScript_Info", "Use minitouch for accurate Click & Drag.\r\nIf unchecked use more compatible 'input swipe' or WinAPI."))
GUICtrlSetState(-1,(($g_bAndroidAdbClickDragScript) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
$y += 25
$g_hChkAndroidCloseWithBot = GUICtrlCreateCheckbox(GetTranslatedFileIni("Android", "ChkAndroidCloseWithBot", "Close Android with bot"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "ChkAndroidCloseWithBot_Info", "Close also Android Emulator when bot exists."))
GUICtrlSetState(-1,(($g_bAndroidCloseWithBot) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
$y += 25
$g_hChkUpdateSharedPrefs = GUICtrlCreateCheckbox(GetTranslatedFileIni("Android", "ChkUpdateSharedPrefs", "Update shared_prefs"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("Android", "ChkUpdateSharedPrefs_Info", "Pull and push shared_prefs to reset zoom,\nset language to English, disable snow and rate popup."))
GUICtrlSetState(-1,(($g_bUpdateSharedPrefs) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
GUICtrlCreateLabel(GetTranslatedFileIni("Android", "LblAndroidRebootHours", "Reboot Android in") & ":", $x + 217, $y + 2, -1, -1)
$sTxtTip = GetTranslatedFileIni("Android", "LblAndroidRebootHours_Info", "Enter hours when Android will be automatically rebooted after specified run-time.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtAndroidRebootHours = GUICtrlCreateInput($g_iAndroidRebootHours, $x + 327, $y + 1, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "hrs", -1), $x + 362, $y + 2, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y = $y2 + $h + 5
$w = $g_iSizeWGrpTab2 - 2
$h = 50
GUICtrlCreateGroup(GetTranslatedFileIni("MBR Distributors", "Group_02", "Advanced Android Options"), $x - 20, $y - 20, $w, $h)
$y -= 2
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Distributors", "LblAdvanced_Android_Options", "Suspend/Resume Android"), $x - 8, $y + 5, 180, 22, $SS_RIGHT)
$g_hCmbSuspendAndroid = GUICtrlCreateCombo("", $x - 8 + 180 + 5, $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslatedFileIni("MBR Distributors", "CmbSuspendAndroid_Item_01", "Disabled|Only during Search/Attack|For every Image processing call"))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR Distributors", "CmbSuspendAndroid_Info_01", 'Specify if Android will be suspended for brief time only during search and attack or\r\nfor every ImgLoc/Image processing call. If you experience more frequent network issues\r\ntry to use "Only during Search/Attack" option or disable this feature.'))
_GUICtrlComboBox_SetCurSel(-1, AndroidSuspendFlagsToIndex($g_iAndroidSuspendModeFlags))
GUICtrlSetOnEvent(-1, "cmbSuspendAndroid")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += $h + 5
$y2 = $y
$w = 240
$h = 120
GUICtrlCreateGroup(GetTranslatedFileIni("Android Control", "Group_03", "Android Control"), $x - 20, $y - 20, $w, $h)
$y -= 2
$g_hBtnAndroidAdbShell = GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnAndroidAdbShell", "Start ADB Shell in new Console Window"), $x - 8, $y, 220, 25)
GUICtrlSetOnEvent(-1, "OpenAdbShell")
$y += 30
$g_hBtnAndroidHome = GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnAndroidHome", "Send Home"), $x - 8, $y, 105, 25)
GUICtrlSetOnEvent(-1, "AndroidHomeButton")
$g_hBtnAndroidBack = GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnAndroidBack", "Send Back"), $x - 8 + 115, $y, 105, 25)
GUICtrlSetOnEvent(-1, "AndroidBackButton")
$y += 30
$g_hBtnAndroidEnableTouch = GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "EnableShowTouchs", "Enable Touchs"), $x - 8, $y, 105, 25)
GUICtrlSetOnEvent(-1, "EnableShowTouchs")
$g_hBtnAndroidDisableTouch = GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "DisableShowTouchs", "Disable Touchs"), $x - 8 + 115, $y, 105, 25)
GUICtrlSetOnEvent(-1, "DisableShowTouchs")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25 + 240 + 10 + 30
$y = $y2
$w = 145
$h = 110
GUICtrlCreateGroup(GetTranslatedFileIni("Android Control", "Group_04", "Install Play Store Apps"), $x - 20, $y - 20, $w, $h)
$y -= 2
GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnPlayStoreGame", "Clash of Clans"), $x - 8, $y, $w - 24, 25)
GUICtrlSetOnEvent(-1, "OpenPlayStoreGame")
$y += 30
GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnPlayStoreGooglePlayServices", "Google Play Services"), $x - 8, $y, $w - 24, 25)
GUICtrlSetOnEvent(-1, "OpenPlayStoreGooglePlayServices")
$y += 30
GUICtrlCreateButton(GetTranslatedFileIni("Android Control", "BtnPlayStoreNovaLauncher", "Nova Launcher"), $x - 8, $y, $w - 24, 25)
GUICtrlSetOnEvent(-1, "OpenPlayStoreNovaLauncher")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 105
$x -= 60
$g_lblHelpBot = GUICtrlCreateLabel("Command line Help ?", $x - 20, $y - 20, 220, 24, $SS_RIGHT)
GUICtrlSetOnEvent($g_lblHelpBot, "ShowControlHelp")
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
_GUICtrlSetTip(-1, "Click here to get help about command line and option for MyBot.run!")
GUICtrlSetColor(-1, $COLOR_NAVY)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkDebugSetlog = 0, $g_hChkDebugAndroid = 0, $g_hChkDebugClick = 0, $g_hChkDebugOCR = 0, $g_hChkDebugImageSave = 0, $g_hChkdebugBuildingPos = 0, $g_hChkdebugTrain = 0, $g_hChkDebugOCRDonate = 0
Global $g_hChkdebugAttackCSV = 0, $g_hChkMakeIMGCSV = 0, $g_hChkDebugDisableZoomout = 0, $g_hChkDebugDisableVillageCentering = 0, $g_hChkDebugDeadbaseImage = 0, $g_hChkDebugFunc = 0
Global $g_hBtnTestTrain = 0, $g_hBtnTestDonateCC = 0, $g_hBtnTestRequestCC = 0, $g_hBtnTestSendText = 0, $g_hBtnTestAttackBar = 0, $g_hBtnTestClickDrag = 0, $g_hBtnTestImage = 0
Global $g_hBtnTestVillageSize = 0, $g_hBtnTestDeadBase = 0, $g_hBtnTestTHimgloc = 0, $g_hBtnTestTrainsimgloc = 0, $g_hBtnTestQuickTrainsimgloc = 0, $g_hTxtTestFindButton = 0
Global $g_hBtnTestFindButton = 0, $g_hBtnTestDeadBaseFolder = 0, $g_hBtnTestCleanYard = 0, $g_hBtnTestAttackCSV = 0, $g_hBtnTestBuildingLocation = 0, $g_hBtnTestArmyWindow = 0
Global $g_hBtnTestConfigSave = 0, $g_hBtnTestConfigApply = 0, $g_hBtnTestConfigRead = 0, $g_hBtnTestOcrMemory = 0, $g_hBtnTestWeakBase = 0, $g_hBtnTestClickAway = 0, $g_hBtnTestAutoUpgrade = 0
Global $g_hBtnTestUpgradeWindow = 0, $g_hBtnTestSmartWait = 0, $g_hBtnConsoleWindow = 0
Func CreateBotDebug()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "Group_01", "Debug"), $x - 20, $y - 20, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2)
$g_hChkDebugSetlog = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugSetlog", "Messages"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugSetlog_Info_01", "Debug: Enables debug SetLog messages in code for Troubleshooting."))
$y += 20
$g_hChkDebugAndroid = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugAndroid", "Android"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugAndroid_Info_01", "Debug: Enables additional log debug messages for Android operations."))
$y += 20
$g_hChkDebugClick = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugClick", "Click"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugClick_Info_01", "Debug: Write the clicked (x,y) coordinates to the log."))
$y += 20
$g_hChkDebugFunc = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugFunc", "Functions"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugFunc_Info_01", "Debug: Enables debug function times and call hierarchy."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugOCR = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugOCR", "OCR"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugOCR_Info_01", "Debug: Enables Saving OCR images for troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugImageSave = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugImageSave", "Images"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugImageSave_Info_01", "Debug: Enables Saving images for troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugBuildingPos = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugBuildingPos", "Buildings"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugBuildingPos_Info_01", "Debug: Enables showing positions of buildings in log."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugTrain = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugTrain", "Training"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugTrain_Info_01", "Debug: Enables showing debug during training."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugOCRDonate = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugOCRDonate", "Online debug donations"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugOCRDonate_Info_01", "Debug: make ocr of donations and simulate only donate but no donate any troop"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugAttackCSV = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugAttackCSV", "Attack CSV"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkdebugAttackCSV_Info_01", "Debug: Generates special CSV parse log files"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkMakeIMGCSV = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkMakeIMGCSV", "Attack CSV Image"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkMakeIMGCSV_Info_01", "Debug: Enables saving clean and location marked up images of bases attacked by CSV scripts"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDisableZoomout = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDisableZoomout", "Disable Zoomout"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDisableZoomout_Info_01", "Debug: Disables zoomout of village."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDisableVillageCentering = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDisableVillageCentering", "Disable Village Centering"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDisableVillageCentering_Info_01", "Debug: Disables centering of village."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDeadbaseImage = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDeadbaseImage", "Deadbase Image save"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugDeadbaseImage_Info_01", "Debug: Saves images of skipped deadbase villages."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugSmartZap = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugSmartZap", "Debug SmartZap"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ChkDebugSmartZap_Info_01", "Use it to debug SmartZap"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
Local $x = 300
$y = 40
Local $yNext = 30
$g_hBtnTestTrain = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestTrain", "Smart Farm"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestDonateCC = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestDonateCC", "Test Donate"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestRequestCC = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestRequestCC", "Test Request"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestAttackBar = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestAttackBar", "Test Attack Bar"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestClickDrag = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestClickDrag", "Test Click Drag"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestImage = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestImage", "Test Image"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestVillageSize = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestVillageSize", "Test Village Size"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestDeadBase = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestDeadBase", "Test Dead Base"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestTHimgloc = GUICtrlCreateButton("imgloc TH", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestTrainsimgloc = GUICtrlCreateButton("Queued Spells", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestQuickTrainsimgloc = GUICtrlCreateButton("Queued Troops", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestOcrMemory = GUICtrlCreateButton("OCR Memory Test", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestSmartWait = GUICtrlCreateButton("Smart Wait Test", $x, $y, 140, 25)
$x -= 145
$g_hTxtTestFindButton = GUICtrlCreateInput("BoostOne", $x - 90, $y + 3, 85, 20)
$g_hBtnTestFindButton = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestFindButton", "Test Find Button"), $x, $y, 140, 25)
$y -= $yNext
$g_hBtnTestDeadBaseFolder = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestDeadBaseFolder", "Test Dead Base Folder"), $x, $y, 140, 25)
$g_hBtnTestCleanYard = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestCleanYard", "Test Clean Yard"), $x - 145, $y, 140, 25)
$y -= $yNext
$g_hBtnTestAttackCSV = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestAttackCSV", "Test Attack CSV"), $x, $y, 140, 25)
$g_hBtnTestBuildingLocation = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestBuildingLocation", "Find Building"), $x - 145, $y, 140, 25)
$y -= $yNext
$g_hBtnTestConfigSave = GUICtrlCreateButton("Config Save", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestConfigApply = GUICtrlCreateButton("Config Apply", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestConfigRead = GUICtrlCreateButton("Config Read", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestSendText = GUICtrlCreateButton("Send Text", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestWeakBase = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestWeakBase", "Test Weak Base"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestClickAway = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestClickAway", "Test Click Away"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestAutoUpgrade = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestAutoUpgrade", "Test Auto Upgrade"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestUpgradeWindow = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "TestUpgradeWindow", "Test Upgrade Window"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnConsoleWindow = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "ConsoleWindow", "Show/hide Console"), $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestArmyWindow = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Debug", "BtnTestArmyWindow", "Army Window"), $x + 20, $y, 120, 25)
$y -= $yNext
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbProfile = 0, $g_hTxtVillageName = 0, $g_hBtnAddProfile = 0, $g_hBtnConfirmAddProfile = 0, $g_hBtnConfirmRenameProfile = 0, $g_hChkOnlySCIDAccounts = 0, $g_hCmbWhatSCIDAccount2Use = 0 , $g_hBtnDeleteProfile = 0, $g_hBtnCancelProfileChange = 0, $g_hBtnRenameProfile = 0, $g_hBtnPullSharedPrefs = 0, $g_hBtnPushSharedPrefs = 0 , $g_hBtnSaveprofile = 0
Func CreateBotProfiles()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Group_01", "Switch Profiles"), $x - 20, $y - 20, $g_iSizeWGrpTab2, 55)
$x -= 5
$g_hCmbProfile = GUICtrlCreateCombo("", $x - 3, $y + 1, 115, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbProfile_Info_01", "Use this to switch to a different profile")& @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbProfile_Info_02", "Your profiles can be found in") & ": " & @CRLF & $g_sProfilePath)
setupProfileComboBox()
PopulatePresetComboBox()
GUICtrlSetState(-1, $GUI_SHOW)
GUICtrlSetOnEvent(-1, "cmbProfile")
$g_hTxtVillageName = GUICtrlCreateInput(GetTranslatedFileIni("MBR Popups", "MyVillage", "MyVillage"), $x - 3, $y, 115, 22, $ES_AUTOHSCROLL)
GUICtrlSetLimit(-1, 100, 0)
GUICtrlSetFont(-1, 9, 400, 1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "TxtVillageName_Info_01", "Your village/profile's name"))
GUICtrlSetState(-1, $GUI_HIDE)
Static $bIconAdd = 0
If $bIconAdd = 0 Then
$bIconAdd = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd.bmp")
EndIf
Static $bIconConfirm = 0
If $bIconConfirm = 0 Then
$bIconConfirm = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm.bmp")
EndIf
Static $bIconDelete = 0
If $bIconDelete = 0 Then
$bIconDelete = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete.bmp")
EndIf
Static $bIconCancel = 0
If $bIconCancel = 0 Then
$bIconCancel = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel.bmp")
EndIf
Static $bIconEdit = 0
If $bIconEdit = 0 Then
$bIconEdit = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit.bmp")
EndIf
Static $bIconPush = 0
If $bIconPush = 0 Then
$bIconPush = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconPush, @ScriptDir & "\images\Button\iconPush.bmp")
EndIf
Static $bIconPull = 0
If $bIconPull = 0 Then
$bIconPull = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconPull, @ScriptDir & "\images\Button\iconPull.bmp")
EndIf
Static $bIconSave = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconSave, @ScriptDir & "\images\Button\iconConfirm.bmp")
$x -= 15
$g_hBtnAddProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnAddProfile, $bIconAdd, 4)
GUICtrlSetOnEvent(-1, "btnAddConfirm")
GUICtrlSetState(-1, $GUI_SHOW)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnAddProfile_Info_01", "Add New Profile"))
$g_hBtnConfirmAddProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnConfirmAddProfile, $bIconConfirm, 4)
GUICtrlSetOnEvent(-1, "btnAddConfirm")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnConfirmAddProfile_Info_01", "Confirm"))
$g_hBtnConfirmRenameProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnConfirmRenameProfile, $bIconConfirm, 4)
GUICtrlSetOnEvent(-1, "btnRenameConfirm")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnConfirmAddProfile_Info_01", -1))
$g_hBtnDeleteProfile = GUICtrlCreateButton("", $x + 164, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnDeleteProfile, $bIconDelete, 4)
GUICtrlSetOnEvent(-1, "btnDeleteCancel")
GUICtrlSetState(-1, $GUI_SHOW)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnDeleteProfile_Info_01", "Delete Profile"))
$g_hBtnCancelProfileChange = GUICtrlCreateButton("", $x + 164, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnCancelProfileChange, $bIconCancel, 4)
GUICtrlSetOnEvent(-1, "btnDeleteCancel")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnCancelProfileChange_Info_01", "Cancel"))
$g_hBtnRenameProfile = GUICtrlCreateButton("", $x + 194, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnRenameProfile, $bIconEdit, 4)
GUICtrlSetOnEvent(-1, "btnRenameConfirm")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnRenameProfile_Info_01", "Rename Profile"))
$g_hBtnPullSharedPrefs = GUICtrlCreateButton("", $x + 224, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnPullSharedPrefs, $bIconPull, 4)
GUICtrlSetOnEvent(-1, "btnPullSharedPrefs")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnPullSharedPrefs_Info_01", "Pull CoC shared_prefs folder"))
$g_hBtnPushSharedPrefs = GUICtrlCreateButton("", $x + 254, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnPushSharedPrefs, $bIconPush, 4)
GUICtrlSetOnEvent(-1, "btnPushSharedPrefs")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnPushSharedPrefs_Info_01", "Push CoC shared_prefs folder"))
$g_hBtnSaveprofile = GUICtrlCreateButton("", $x + 284, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnSaveprofile, $bIconSave, 4)
GUICtrlSetOnEvent(-1, "BtnSaveprofile")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BtnSaveprofile_Info_01", "Save your current setting."))
$x += 17
$g_hChkOnlySCIDAccounts = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkOnlySCIDAccounts", "SCID"), $x + 297, $y + 1, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkOnlySCIDAccounts_Info_01", "Are you using SC_ID?"))
GUICtrlSetOnEvent(-1, "OnlySCIDAccounts")
$g_hCmbWhatSCIDAccount2Use = GUICtrlCreateCombo("", $x + 295 + 47, $y + 1, 75, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Account 1|Account 2|Account 3|Account 4|Account 5", "Account 1")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "WhatSCIDAccount2Use_Info_01", "Select the correct account from Login Window!"))
GUICtrlSetOnEvent(-1, "WhatSCIDAccount2Use")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_STATS = 0, $g_hGUI_STATS_TAB = 0, $g_hGUI_STATS_TAB_ITEM1 = 0, $g_hGUI_STATS_TAB_ITEM2 = 0, $g_hGUI_STATS_TAB_ITEM3 = 0, $g_hGUI_STATS_TAB_ITEM4 = 0, $g_hGUI_STATS_TAB_ITEM5 = 0
Global $btnResetStats = 0
Global $g_ahPicTHLevels[13], $g_hLblTHLevels = 0
Global $g_ahPicLeague[$eLeagueCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0], $g_hLblLeague = 0
Global $g_ahLblStatsStartedWith[$eLootCount] = [0, 0, 0, 0], $g_ahLblStatsGainPerHour[$eLootCount] = [0, 0, 0, 0]
Global $g_ahLblStatsTotalGain[$eLootCount] = [0, 0, 0, 0], $g_ahLblStatsLastAttack[$eLootCount] = [0, 0, 0, 0]
Global $g_ahLblStatsBonusLast[$eLootCount] = [0, 0, 0, 0], $g_ahLblStatsTop[$eLootCount] = [0, 0, 0, 0]
Global $g_hPicResultDEStart = 0, $g_hLblStatsSZRev1 = 0, $g_hLblStatsSZRev2 = 0, $g_hPicHourlyStatsDark = 0, $g_hPicDarkLoot = 0, $g_hPicDarkLastAttack = 0
Global $g_hLblResultRuntime = 0, $g_hLblNbrOfOoS = 0, $g_hLblResultVillagesAttacked = 0, $g_hLblResultVillagesSkipped = 0, $g_hLblResultTrophiesDropped = 0
Global $g_hLblSearchCost = 0, $g_hLblTrainCostElixir = 0, $g_hLblTrainCostDElixir = 0, $g_hLblTrainCostGold = 0, $g_hLblGoldFromMines = 0, $g_hLblElixirFromCollectors = 0, $g_hLblDElixirFromDrills = 0
Global $g_hLblWallGoldMake = 0, $g_hLblWallElixirMake = 0, $g_hLblNbrOfBuildingUpgGold = 0, $g_hLblNbrOfBuildingUpgElixir = 0, $g_hLblNbrOfHeroUpg = 0
Global $g_hLblWallUpgCostGold = 0, $g_hLblWallUpgCostElixir = 0, $g_hLblBuildingUpgCostGold = 0, $g_hLblBuildingUpgCostElixir = 0, $g_hLblHeroUpgCost = 0
Global $g_hLblAttacked[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblTotalGoldGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblTotalElixirGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblTotalDElixirGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblTotalTrophyGain[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblNbrOfTSSuccess = 0, $g_hLblNbrOfTSFailed = 0
Global $g_hLblNbrOfDetectedMines[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblNbrOfDetectedCollectors[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblNbrOfDetectedDrills[$g_iModeCount + 3] = [0, 0, 0, 0, 0, 0], $g_hLblSmartZap = 0, $g_hLblSmartLightningUsed = 0, $g_hLblSmartEarthQuakeUsed = 0
Global $g_hLblDonTroop[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLblDonSpell[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hLblDonSiegel[$eSiegeMachineCount] = [0, 0, 0]
Global $g_hLblTotalTroopsQ = 0, $g_hLblTotalTroopsXP = 0, $g_hLblTotalSpellsQ = 0, $g_hLblTotalSpellsXP = 0
Global $g_ahGrpVillageAcc[8], $g_ahGrpDefaultAcc[8], $g_ahGrpReportAcc[8], $g_ahGrpStatsAcc[8]
Global $g_ahLblResultGoldNowAcc[8], $g_ahPicResultGoldNowAcc[8], $g_ahLblResultTrophyNowAcc[8], $g_ahPicResultTrophyNowAcc[8], $g_ahLblResultElixirNowAcc[8], $g_ahPicResultElixirNowAcc[8], $g_ahLblResultBuilderNowAcc[8], $g_ahPicResultBuilderNowAcc[8], $g_ahLblResultDENowAcc[8], $g_ahPicResultDENowAcc[8], $g_ahLblResultGemNowAcc[8], $g_ahPicResultGemNowAcc[8]
Global $g_ahLblHourlyStatsGoldAcc[8], $g_ahLblResultRuntimeNowAcc[8], $g_ahPicResultRuntimeNowAcc[8], $g_ahLblHourlyStatsElixirAcc[8], $g_ahLblResultAttacked[8], $g_ahPicResultAttacked[8], $g_ahLblHourlyStatsDarkAcc[8], $g_ahLblResultSkipped[8], $g_ahPicResultSkipped[8]
Global $g_ahPicArrowLeft[8], $g_ahPicArrowRight[8], $g_ahPicResultGoldTemp[8], $g_ahPicResultElixirTemp[8], $g_ahPicResultDETemp[8], $g_ahLblVillageReportTemp[8], $g_ahGrpTempAcc[8], $g_ahLblTroopTime[8], $g_ahPicTroopTime[8]
Global $g_hPicHeroGrayStatus[3][8], $g_hPicHeroBlueStatus[3][8], $g_hPicHeroGreenStatus[3][8], $g_hPicHeroRedStatus[3][8], $g_hPicLabGrayStatus[8], $g_hPicLabGreenStatus[8], $g_hPicLabRedStatus[8], $g_hLblLabTimeStatus[8]
Func CreateBotStats()
GUISwitch($g_hGUI_STATS)
$g_hGUI_STATS_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$btnResetStats = GUICtrlCreateButton(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "BtnResetStats", "Reset Stats"), 375, 0, 60, 20)
GUICtrlSetOnEvent(-1, "btnResetStats")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hGUI_STATS_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_01", "Gain"))
CreateGainSubTab()
$g_hGUI_STATS_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_02", "Misc"))
CreateMiscSubTab()
$g_hGUI_STATS_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_03", "Attacks"))
CreateAttacksSubTab()
$g_hGUI_STATS_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_04", "Donations"))
CreateDonationsSubTab()
$g_hGUI_STATS_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05_STab_05", "Multi Stats"))
CreateMultiStatsSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreateGainSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart, $y = $yStart
GUICtrlCreatePic(@ScriptDir & "\images\Stats\Stats001.jpg", $x - 18, $y - 20, 426, 80)
$x = $xStart + 276
$y = $yStart - 14
$g_ahPicTHLevels[4] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV04, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[5] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV05, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[6] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[7] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[8] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[9] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[10] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[11] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicTHLevels[12] = _GUICtrlCreateIcon($g_sLibIconPath, $eHdV12, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR Global GUI Design", "LblTownhall", "TownHall"), $x - 11, $y, -1, -1, $SS_CENTER)
$g_hLblTHLevels = GUICtrlCreateLabel("", $x + 38, $y + 53, 17, 17, $SS_CENTER)
GUICtrlSetFont($g_hLblTHLevels, 11, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 340
$y = $yStart - 14
$g_ahPicLeague[$eLeagueUnranked] = _GUICtrlCreateIcon($g_sLibIconPath, $eUnranked, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_SHOW)
$g_ahPicLeague[$eLeagueBronze] = _GUICtrlCreateIcon($g_sLibIconPath, $eBronze, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueSilver] = _GUICtrlCreateIcon($g_sLibIconPath, $eSilver, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueGold] = _GUICtrlCreateIcon($g_sLibIconPath, $eGold, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueCrystal] = _GUICtrlCreateIcon($g_sLibIconPath, $eCrystal, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueMaster] = _GUICtrlCreateIcon($g_sLibIconPath, $eMaster, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueChampion] = _GUICtrlCreateIcon($g_sLibIconPath, $eChampion, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueTitan] = _GUICtrlCreateIcon($g_sLibIconPath, $eTitan, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicLeague[$eLeagueLegend] = _GUICtrlCreateIcon($g_sLibIconPath, $eLegend, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLeague", "League"), $x + 3, $y, -1, -1, $SS_CENTER)
$g_hLblLeague = GUICtrlCreateLabel("", $x + 43, $y + 53, 17, 17, $SS_CENTER)
GUICtrlSetFont(-1, 11, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 100
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStats", "Stats"), $x - 20, $y - 32, 87, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblGold", "Gold"), $x - 18 + 85, $y - 32, 95, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblElixir", "Elixir"), $x - 18 +(60 * 3), $y - 32, 75, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDarkE", "DarkE"), $x - 23 +(65 * 4), $y - 32, 90, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrophy", "Trophy"), $x - 23 +(70 * 5), $y - 32, 75, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStartedWith", "Started with") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsStartedWith_Info_01", "The amount of Gold you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsStartedWith_Info_02", "The amount of Elixir you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicResultDEStart = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsStartedWith_Info_03", "The amount of Dark Elixir you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsStartedWith_Info_04", "The amount of Trophies you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 125
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblGainPerHour", "Gain per Hour") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsGainPerHour_Info_01", "Gold gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootGold] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsGainPerHour_Info_02", "Elixir gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootElixir] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicHourlyStatsDark = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsGainPerHour_Info_03", "Dark Elixir gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootDarkElixir] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsGainPerHour_Info_04", "Trophy gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootTrophy] = GUICtrlCreateLabel("0/h", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 150
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTotalGain", "Total Gain") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_01", "The total amount of Gold you gained or lost while the Bot is running.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_02", "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_03", "The total amount of Elixir you gained or lost while the Bot is running.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_02", "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicDarkLoot = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_04", "The total amount of Dark Elixir you gained or lost while the Bot is running.") & @CRLF & GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_02", "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTotalGain_Info_05", "The amount of Trophies you gained or lost while the Bot is running.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 195
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLastAttack", "Last Attack") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsLastAttack_Info_01", "The amount of Gold you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsLastAttack_Info_02", "The amount of Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicDarkLastAttack = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsLastAttack_Info_03", "The amount of Dark Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsLastAttack_Info_04", "The amount of Trophies you gained or lost on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 220
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLeagueBonus", "League Bonus") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsBonusLast_Info_01", "The amount of Bonus Gold you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsBonusLast_Info_02", "The amount of Bonus Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsBonusLast_Info_03", "The amount of Bonus Dark Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 265
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTopLoot", "Top Loot") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTop_Info_01","Top Gold gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTop_Info_02", "Top Elixir gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTop_Info_03", "Top Dark gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsTop_Info_04", "Top Trophy gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMiscSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblRun", "Run"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblCost-Collect", "Cost && Collect"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblRuntime_Info_01", "The total Running Time of the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblRuntime", "Runtime") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultRuntime = GUICtrlCreateLabel("00:00:00", $x + 35, $y + 2, 150, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnRecycle, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblNbr-of-OoS_Info_01", "The number of Out of Sync error occurred")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblNbr-of-OoS", "Nbr of OoS") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfOoS = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblAttacked_Info_01", "The No. of Villages that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblAttacked", "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultVillagesAttacked = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgX, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblSkipped_Info_01", "The No. of Villages that were skipped during search by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblSkipped", "Skipped")& ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultVillagesSkipped = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDropped_Info_01", "The amount of Trophies dropped by the Bot due to Trophy Settings (on Misc Tab).")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDropped", "Dropped") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultTrophiesDropped = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 25
$y -= 15
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblSearch-Cost_Info_01", "Search cost for skipping villages in gold")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblSearch-Cost", "Search Cost") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblSearchCost = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-Elixir_Info_01", "Elixir spent for training Barrack Troops")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-Elixir", "Train Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-DElixir_Info_01", "Dark Elixir spent for training Dark Barrack Troops")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-DElixir", "Train Cost DElixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainCostDElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallW, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-Gold_Info_01", "Gold spent for Building Siege Machines")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTrain-Cost-Gold", "Build Cost Gold") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainCostGold = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblGold-collected_Info_01", "Gold gained by collecting mines")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblGold-collected", "Gold collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblGoldFromMines = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblElixir-collected_Info_01", "Elixir gained by collecting collectors")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblElixir-collected", "Elixir collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblElixirFromCollectors = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDElixir-collected_Info_01", "Dark Elixir gained by collecting drills")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDElixir-collected", "DElixir collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDElixirFromDrills = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 185
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpgrades-Made", "Upgrades Made"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpgrade-Costs", "Upgrade Costs"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-by-Gold_Info_01", "The No. of Walls upgraded by Gold.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpg-by-Gold", "Upg. by Gold") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallGoldMake = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-by-Elixir_Info_01", "The No. of Walls upgraded by Elixir.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpg-by-Elixir", "Upg. by Elixir") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallElixirMake = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBuilUpg-by-Gold_Info_01", "The number of buildings upgraded using gold")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpg-by-Gold", "Upg. by Gold") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfBuildingUpgGold = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBuilUpg-by-Elixir_Info_01", "The number of buildings upgraded using elixir")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblUpg-by-Elixir", "Upg. by Elixir") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfBuildingUpgElixir = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHeroes, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblHeroesUpg_Info_01", "The number of heroes upgraded")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblHeroesUpg", "Hero Upgrade") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfHeroUpg = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 185
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Gold_Info_01", "The cost of gold used by bot while upgrading walls")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Gold", "Upg. Cost Gold") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallUpgCostGold = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Elixir_Info_01", "The cost of elixir used by bot while upgrading walls")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Elixir", "Upg. Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallUpgCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBuilUpg-Cost-by-Gold_Info_01", "The cost of gold used by bot while upgrading buildings")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Gold", "Upg. Cost Gold") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblBuildingUpgCostGold = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBuilUpg-Cost-by-Elixir_Info_01", "The cost of elixir used by bot while upgrading buildings")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblWallUpg-Cost-by-Elixir", "Upg. Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblBuildingUpgCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHeroes, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblheroesUpg-Cost_Info_01", "The cost of dark elixir used by bot while upgrading heroes")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblheroesUpg-Cost", "Upg. Cost DElixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblHeroUpgCost = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x -= 20
$y -= 85
GUICtrlCreateLabel("", $x + 28, $y - 160, 5, 300)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateAttacksSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base", "Dead Base"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base", "Live Base"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base_Info_01", "The No. of Dead Base that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBase-Attacked", "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain-Gold_Info_01", "The amount of Gold gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain","gain") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain-Elixir_Info_01", "The amount of Elixir gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain-Dark_Info_01", "The amount of Dark Elixir gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain-Trophies_Info_01", "The amount of Trophies gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 30
$y += 25
$g_hLblNbrOfDetectedMines[$DB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$DB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$DB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 25
$y -= 15
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base_Info_01", "The No. of Live Base that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBase-Attacked", "Attacked") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base-Gain-Gold_Info_01", "The amount of Gold gained from Live Bases attacked by the Bot")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base-Gain-Elixir_Info_01", "The amount of Elixir gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base-Gain-Dark_Info_01", "The amount of Dark Elixir gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblLive-Base-Gain-Trophy_Info_01", "The amount of Trophy gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 62
$y += 25
$g_hLblNbrOfDetectedMines[$LB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$LB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$LB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 165
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe", "TH Snipe"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully", "TH Bully"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe_Info_01", "The No. of TH Snipes attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBase-Attacked", "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Gain-Gold_Info_01", "The amount of Gold gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Gain-Elixir_Info_01", "The amount of Elixir gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Gain-Dark_Info_01", "The amount of Dark Elixir gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Gain-Trophy_Info_01", "The amount of Trophy gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 25
$y += 25
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGreenLight, $x - 15, $y - 4, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Win_Info_01", "The number of successful TH Snipes")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfTSSuccess = GUICtrlCreateLabel("0", $x + 13, $y - 2, 25, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 50
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnRedLight, $x + 35, $y - 4, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Snipe-Lost_Info_01", "The number of failed TH Snipe attempt")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfTSFailed = GUICtrlCreateLabel("0", $x + 63, $y - 2, 25, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 165
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully_Info_01", "The No. of TH Bully bases that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblBase-Attacked", "Attacked") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully-Gain-Gold_Info_01", "The amount of Gold gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully-Gain-Elixir_Info_01", "The amount of Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully-Gain-Dark_Info_01", "The amount of Dark Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblTH-Bully-Gain-Trophy_Info_01", "The amount of Trophy gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 64
$y += 25
$g_hLblNbrOfDetectedMines[$TB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$TB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$TB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
$x -= 124
$y -= 110
GUICtrlCreateLabel("", $x + 28, $y - 160, 5, 300)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x = $xStart + 5
$y = $yStart + 310
$g_hLblStatsSZRev1 = GUICtrlCreateLabel("", $x - 20, $y - 32, 420, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblStatsSZRev2 = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSZRev2", "Smart Zap"), $x + 155, $y - 32, 60, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x - 10, $y, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartLightningUsed_Info_01", "The amount of Lightning Spells used to zap"))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSZRev2-Used", "Used") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartLightningUsed_Info_01", -1))
$g_hLblSmartLightningUsed = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartLightningUsed_Info_01", -1))
$x += 145
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x - 10, $y, 16, 16)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartEarthQuakeUsed_Info_01", "The amount of Earthquake Spells used to zap"))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSZRev2-Used", -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartEarthQuakeUsed_Info_01", -1))
$g_hLblSmartEarthQuakeUsed = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartEarthQuakeUsed_Info_01", -1))
$x += 145
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y -1, 18, 18)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartZap_Info_01", "The amount of Dark Elixir won while zapping"))
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblDead-Base-Gain",-1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartZap_Info_01", -1))
$g_hLblSmartZap = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsSmartZap_Info_01", -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateDonationsSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonElixir-Troops", "Elixir Troops / Siege Machines"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonDark-Troops", "Dark Elixir Troops"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarbarian, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBarbarian] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizard, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWizard] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnElectroDragon, $x + 145, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 175, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopElectroDragon] = GUICtrlCreateLabel("0", $x + 165, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopArcher] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealer, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopHealer] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGiant, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGiant] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnDragon, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopDragon] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoblin, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGoblin] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnPekka, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopPekka] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallW, $x + 145, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 175, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSiegel[$eSiegeWallWrecker] = GUICtrlCreateLabel("0", $x + 165, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallBreaker, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWallBreaker] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBabyDragon, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBabyDragon] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBattleB, $x + 145, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 175, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSiegel[$eSiegeBattleBlimp] = GUICtrlCreateLabel("0", $x + 165, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBalloon, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBalloon] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 40, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMiner, $x + 65, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 95, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopMiner] = GUICtrlCreateLabel("0", $x + 85, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnStoneS, $x + 145, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 175, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSiegel[$eSiegeStoneSlammer] = GUICtrlCreateLabel("0", $x + 165, $y + 4, 50, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 232
$y = $yStart + 25
$y -= 15
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopMinion] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBowler, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBowler] = GUICtrlCreateLabel("0", $x + 100, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHogRider, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopHogRider] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnIceGolem, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopIceGolem] = GUICtrlCreateLabel("0", $x + 100, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnValkyrie, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopValkyrie] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnGolem, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGolem] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnWitch, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWitch] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLavaHound, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopLavaHound] = GUICtrlCreateLabel("0", $x + 5, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 210
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonTotal", "Total Donated") & ":", $x - 20, $y - 32, 187, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalTroopsQ = GUICtrlCreateLabel("0", $x + 105, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonTotalXP", "Total XP") & ":", $x - 18 + 212, $y - 32, 207, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalTroopsXP = GUICtrlCreateLabel("0", $x + 320, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x = $xStart + 3
$y = $yStart + 235
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonElixir-Spells", "Elixir Spells"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonDark-Spells", "Dark Elixir Spells"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellLightning] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellFreeze] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellHeal] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellRage] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellJump] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 210
$y = $yStart + 235
$y -= 10
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellPoison] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnBatSpell, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellBat] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellEarthquake] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellHaste] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
_GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellSkeleton] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 370
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonTotal", "Total Donated") & ":", $x - 20, $y - 32, 187, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalSpellsQ = GUICtrlCreateLabel("0", $x + 105, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Stats", "LblStatsDonTotalXP", "Total XP") & ":", $x - 18 + 212, $y - 32, 207, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalSpellsXP = GUICtrlCreateLabel("0", $x + 320, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x += 155
$y -= 250
GUICtrlCreateLabel("", $x + 50, $y - 130, 5, 188)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 28, $y + 90, 5, 128)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMultiStatsSubTab()
Local $sTxtTip = ""
For $i = 0 To 7
Local $x = 25
Local $y = 27
Local $i_X = Mod($i, 2), $i_Y = Int($i / 2)
Local $delY = 17, $delY2 = 95, $delX = 90, $delX2 = 215
$g_ahGrpVillageAcc[$i] = GUICtrlCreateGroup("", $x - 3 + $i_X * $delX2, $y + $i_Y * $delY2, 180, 90)
$g_ahLblResultGoldNowAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 70, 17, $SS_RIGHT)
$g_ahPicResultGoldNowAcc[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 75 + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 16, 16)
$g_ahLblResultTrophyNowAcc[$i] = GUICtrlCreateLabel("", $x + $delX + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 55, 17, $SS_RIGHT)
$g_ahPicResultTrophyNowAcc[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 60 + $delX + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 16, 14)
$g_ahLblResultElixirNowAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 70, 17, $SS_RIGHT)
$g_ahPicResultElixirNowAcc[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 75 + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 16, 16)
$g_ahLblResultBuilderNowAcc[$i] = GUICtrlCreateLabel("", $x + $delX + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 55, 17, $SS_RIGHT)
$g_ahPicResultBuilderNowAcc[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 60 + $delX + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 16, 15)
$g_ahLblResultDENowAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 70, 17, $SS_RIGHT)
$g_ahPicResultDENowAcc[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 75 + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 16, 16)
$g_ahLblResultGemNowAcc[$i] = GUICtrlCreateLabel("", $x + $delX + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 55, 17, $SS_RIGHT)
$g_ahPicResultGemNowAcc[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 60 + $delX + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 16, 16)
$g_ahPicArrowLeft[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnArrowLeft, $x - 20 + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 16, 16)
Local $sTxtTip = GetTranslatedFileIni("MBR GUI Design Bottom", "GrpVillage_Info_01", "Switch between village info and stats")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "SwitchVillageInfo")
$g_ahPicArrowRight[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnArrowRight, $x + 180 + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "SwitchVillageInfo")
$g_ahLblHourlyStatsGoldAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 70, 17, $SS_RIGHT)
$g_ahLblResultRuntimeNowAcc[$i] = GUICtrlCreateLabel("00:00:00", $x + $delX + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 55, 17, $SS_RIGHT)
$g_ahPicResultRuntimeNowAcc[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 60 + $delX + $i_X * $delX2, $y + $delY + $i_Y * $delY2, 16, 16)
$g_ahLblHourlyStatsElixirAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 70, 17, $SS_RIGHT)
$g_ahLblResultAttacked[$i] = GUICtrlCreateLabel("", $x + $delX + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 55, 17, $SS_RIGHT)
$g_ahPicResultAttacked[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x + 60 + $delX + $i_X * $delX2, $y + $delY * 2 + $i_Y * $delY2, 16, 16)
$g_ahLblHourlyStatsDarkAcc[$i] = GUICtrlCreateLabel("", $x + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 70, 17, $SS_RIGHT)
$g_ahLblResultSkipped[$i] = GUICtrlCreateLabel("", $x + $delX + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 55, 17, $SS_RIGHT)
$g_ahPicResultSkipped[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgX, $x + 60 + $delX + $i_X * $delX2, $y + $delY * 3 + $i_Y * $delY2, 16, 16)
$g_ahLblTroopTime[$i] = GUICtrlCreateLabel("", $x + $delX + $i_X * $delX2, $y + 4 + $delY * 4 + $i_Y * $delY2, 55, 17, $SS_RIGHT)
$g_ahPicTroopTime[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrain, $x + 60 + $delX + $i_X * $delX2, $y + 2 + $delY * 4 + $i_Y * $delY2, 16, 16)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Bottom", "GrpStatus_Info_01", -1)
$g_hPicHeroGrayStatus[0][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingGrayShield, $x + 2 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicHeroBlueStatus[0][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingBlueShield, $x + 2 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGreenStatus[0][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingGreenShield, $x + 2 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroRedStatus[0][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingRedShield, $x + 2 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGrayStatus[1][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenGrayShield, $x + 26 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicHeroBlueStatus[1][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenBlueShield, $x + 26 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGreenStatus[1][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenGreenShield, $x + 26 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroRedStatus[1][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenRedShield, $x + 26 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGrayStatus[2][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenGrayShield, $x + 51 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicHeroBlueStatus[2][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenBlueShield, $x + 51 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroGreenStatus[2][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenGreenShield, $x + 51 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicHeroRedStatus[2][$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenRedShield, $x + 51 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$sTxtTip = GetTranslatedFileIni("MBR GUI Design Bottom", "GrpStatus_Info_02", -1)
$g_hPicLabGrayStatus[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLabGrayShield, $x + 75 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicLabGreenStatus[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLabGreenShield, $x + 75 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicLabRedStatus[$i] = _GUICtrlCreateIcon($g_sLibIconPath, $eIcnLabRedShield, $x + 75 + $i_X * $delX2, $y + 3 + $delY * 4 + $i_Y * $delY2, 15, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblLabTimeStatus[$i] = GUICtrlCreateLabel("00:00:00", $x + 95 + $i_X * $delX2, $y + 4 + $delY * 4 + $i_Y * $delY2, 90, 17, $SS_LEFT)
$g_ahGrpDefaultAcc[$i] = $g_ahGrpVillageAcc[$i] & "#" & $g_ahPicArrowLeft[$i] & "#" & $g_ahPicArrowRight[$i] & "#" & $g_ahPicResultGoldNowAcc[$i] & "#" & $g_ahPicResultElixirNowAcc[$i] & "#" & $g_ahPicResultDENowAcc[$i]
$g_ahGrpReportAcc[$i] = $g_ahLblResultGoldNowAcc[$i] & "#" & $g_ahLblResultTrophyNowAcc[$i] & "#" & $g_ahPicResultTrophyNowAcc[$i] & "#" & $g_ahLblResultElixirNowAcc[$i] & "#" & $g_ahLblResultBuilderNowAcc[$i] & "#" & $g_ahPicResultBuilderNowAcc[$i] & "#" & $g_ahLblResultDENowAcc[$i] & "#" & $g_ahLblResultGemNowAcc[$i] & "#" & $g_ahPicResultGemNowAcc[$i] & "#" & $g_ahLblTroopTime[$i] & "#" & $g_ahPicTroopTime[$i]
$g_ahGrpStatsAcc[$i] = $g_ahLblHourlyStatsGoldAcc[$i] & "#" & $g_ahLblResultRuntimeNowAcc[$i] & "#" & $g_ahPicResultRuntimeNowAcc[$i] & "#" & $g_ahLblHourlyStatsElixirAcc[$i] & "#" & $g_ahLblResultAttacked[$i] & "#" & $g_ahPicResultAttacked[$i] & "#" & $g_ahLblHourlyStatsDarkAcc[$i] & "#" & $g_ahLblResultSkipped[$i] & "#" & $g_ahPicResultSkipped[$i] & "#" & $g_hLblLabTimeStatus[$i]
GUICtrlCreateGroup("", -99, -99, 1, 1)
_GUI_Value_STATE("HIDE", $g_ahGrpDefaultAcc[$i] & "#" & $g_ahGrpReportAcc[$i] & "#" & $g_ahGrpStatsAcc[$i])
_GUI_Value_STATE("HIDE", $g_hPicHeroGrayStatus[0][$i] & "#" & $g_hPicHeroGrayStatus[1][$i] & "#" & $g_hPicHeroGrayStatus[2][$i] & "#" & $g_hPicLabGrayStatus[$i])
Next
EndFunc
Global $g_hGUI_SWITCH_OPTIONS = 0, $g_hGUI_SWITCH_OPTIONS_TAB = 0, $g_hGUI_SWITCH_OPTIONS_TAB_ITEM1 = 0, $g_hGUI_SWITCH_OPTIONS_TAB_ITEM2 = 0, $g_hGUI_SWITCH_OPTIONS_TAB_ITEM3 = 0
Global $g_hGUI_LOG_SA = 0
Global $g_hChkSwitchAcc = 0, $g_hCmbSwitchAcc = 0, $g_hChkSharedPrefs = 0, $g_hCmbTotalAccount = 0, $g_hChkSmartSwitch = 0, $g_hCmbTrainTimeToSkip = 0, $g_hChkDonateLikeCrazy = 0, $g_ahChkAccount[8], $g_ahCmbProfile[8], $g_ahChkDonate[8], $g_hRadSwitchGooglePlay = 0, $g_hRadSwitchSuperCellID = 0, $g_hRadSwitchSharedPrefs = 0
Global $g_ahChk_SwitchMax[4], $g_ahCmb_SwitchMax[4], $g_ahChk_BotTypeMax[4], $g_ahCmb_BotTypeMax[4], $g_ahLbl_SwitchMax[4], $g_ahTxt_ConditionMax[4], $g_ahChk_SwitchMin[4], $g_ahCmb_SwitchMin[4], $g_ahChk_BotTypeMin[4], $g_ahCmb_BotTypeMin[4], $g_ahLbl_SwitchMin[4], $g_ahTxt_ConditionMin[4]
Global $g_ahChkSetFarm[8], $g_ahCmbAction1[8], $g_ahCmbCriteria1[8], $g_ahTxtResource1[8], $g_ahCmbTime1[8], $g_ahCmbAction2[8], $g_ahCmbCriteria2[8], $g_ahTxtResource2[8], $g_ahCmbTime2[8]
Global $g_hTxtSALog = 0
Func CreateSwitchOptions()
$g_hGUI_LOG_SA = _GUICreate("", 205, 200, 235, 150, BitOR($WS_CHILD, 0), -1, $g_hGUI_SWITCH_OPTIONS)
GUISwitch($g_hGUI_SWITCH_OPTIONS)
$g_hGUI_SWITCH_OPTIONS_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab2 + 2, $g_iSizeHGrpTab4 + 5, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_SWITCH_OPTIONS_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_04_STab_01", "Switch Accounts"))
CreateSwitchAccount()
$g_hGUI_SWITCH_OPTIONS_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_04_STab_02", "Switch Profiles"))
CreateSwitchProfile()
$g_hGUI_SWITCH_OPTIONS_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_04_STab_03", "Farming Schedule"))
CreateFarmSchedule()
$g_hLastControlToHide = GUICtrlCreateDummy()
ReDim $g_aiControlPrevState[$g_hLastControlToHide + 1]
CreateBotSwitchAccLog()
GUICtrlCreateTabItem("")
EndFunc
Func CreateSwitchAccount()
Local $x = 15, $y = 30
$x -= 8
$g_hCmbSwitchAcc = GUICtrlCreateCombo("", $x, $y, 175, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
Local $s = "No Switch Accounts Group"
For $i = 1 To UBound($g_ahChkAccount)
$s &= "|Switch Accounts Group " & $i
Next
GUICtrlSetData(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbSwitchAcc", $s), "No Switch Accounts Group")
GUICtrlSetOnEvent(-1, "cmbSwitchAcc")
$y += 25
$g_hChkSwitchAcc = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkSwitchAcc", "Enable Switch Accounts"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkSwitchAcc")
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkSwitchAcc_Info_01", "Enable or disable current selected Switch Accounts Group"))
$g_hCmbTotalAccount = GUICtrlCreateCombo("", $x + 345, $y - 1, 77, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "2 accounts|3 accounts|4 accounts|5 accounts|6 accounts|7 accounts|8 accounts", "2 accounts")
GUICtrlSetOnEvent(-1, "cmbTotalAcc")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbTotalAccount", "Total CoC Accounts") & ": ", $x + 220, $y + 4, -1, -1)
$g_hRadSwitchSharedPrefs = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchSharedPrefs", "Shared_prefs"), $x + 185, $y - 30, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchSharedPrefs_Info_01", "Support for Google Play and SuperCell ID accounts"))
If $g_bChkSharedPrefs Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkAccSwitchMode")
$g_hRadSwitchGooglePlay = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchGooglePlay", "Google Play"), $x + 270, $y - 30, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchGooglePlay_Info_01", "Only support for all Google Play accounts"))
If $g_bChkGooglePlay Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkAccSwitchMode")
$g_hRadSwitchSuperCellID = GUICtrlCreateRadio(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchSuperCellID", "SuperCell ID"), $x + 347, $y - 30, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "RadSwitchSuperCellID_Info_01", "Only support for all SuperCell ID accounts"))
If $g_bChkSuperCellID Then GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkAccSwitchMode")
$y += 23
$g_hChkSmartSwitch = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkSmartSwitch", "Smart switch"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "ChkSmartSwitch_Info_01", "Switch to account with the shortest remain training time"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSmartSwitch")
$g_hChkDonateLikeCrazy = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "DonateLikeCrazy", "Donate like Crazy"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "DonateLikeCrazy_Info_01", "Enable it allows account switching in the order: Donate - Shortest Active - Donate - Shortest Active  - Donate...!"))
GUICtrlSetOnEvent(-1, "chkSmartSwitch")
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "CmbTrainTime", "Skip switch if train time") & " <", $x + 220, $y + 4, -1, -1)
$g_hCmbTrainTimeToSkip = GUICtrlCreateCombo("", $x + 345, $y - 1, 77, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0 minute|1 minute|2 minutes|3 minutes|4 minutes|5 minutes|6 minutes|7 minutes|8 minutes|9 minutes", "1 minute")
$y += 23
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Description", "Using Switch Accounts requires that not more Google Accounts are registered in Android than configured here. " & "Maximum of 8 Google/CoC Accounts is supported."), $x, $y, $g_iSizeWGrpTab2 - 20, 42, $SS_CENTER)
$y += 29
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Label_01", "Accounts"), $x - 5, $y, 60, -1, $SS_CENTER)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Label_02", "Profile name"), $x + 82, $y, 70, -1, $SS_CENTER)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Label_03", "Donate only"), $x + 170, $y, 60, -1, $SS_CENTER)
GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Label_04", "SwitchAcc log"), $x + 285, $y, -1, -1, $SS_CENTER)
$y += 14
GUICtrlCreateGraphic($x, $y, 422, 1, $SS_GRAYRECT)
$y += 7
For $i = 0 To UBound($g_ahChkAccount) - 1
$g_ahChkAccount[$i] = GUICtrlCreateCheckbox("Acc " & $i + 1 & ".", $x, $y +($i) * 25, -1, -1)
GUICtrlSetOnEvent(-1, "chkAccountX")
$g_ahCmbProfile[$i] = GUICtrlCreateCombo("", $x + 65, $y +($i) * 25, 110, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "cmbSwitchAccProfileX")
GUICtrlSetData(-1, _GUICtrlComboBox_GetList($g_hCmbProfile))
$g_ahChkDonate[$i] = GUICtrlCreateCheckbox("", $x + 190, $y +($i) * 25 - 3, -1, 25)
Next
EndFunc
Func CreateSwitchProfile()
Local $asText[4] = ["Gold", "Elixir", "Dark Elixir", "Trophy"]
Local $aIcon[4] = [$eIcnGold, $eIcnElixir, $eIcnDark, $eIcnTrophy]
Local $aiValueMax[4] = ["12000000", "12000000", "240000", "5000"]
Local $aiValueMin[4] = ["1000000", "1000000", "20000", "3000"]
Local $aiLimitMax[4] = [8, 8, 6, 4]
Local $aiLimitMin[4] = [7, 7, 5, 4]
Local $x = 25, $y = 41
Local $profileString = _GUICtrlComboBox_GetList($g_hCmbProfile)
For $i = 0 To 3
GUICtrlCreateGroup("        " & $asText[$i] & " " & GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Group_03", "conditions"), $x - 20, $y - 15 + $i * 51, $g_iSizeWGrpTab3, 78)
_GUICtrlCreateIcon($g_sLibIconPath, $aIcon[$i], $x - 10, $y - 17 + $i * 51, 20, 20)
$g_ahChk_SwitchMax[$i] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Switch", "Switch to.."), $x - 10, $y + 7 + $i * 51, -1, -1)
GUICtrlSetOnEvent(-1, "chkSwitchProfile")
$g_ahCmb_SwitchMax[$i] = GUICtrlCreateCombo("", $x + 60, $y + 7 + $i * 51, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $profileString, "<No Profiles>")
$g_ahChk_BotTypeMax[$i] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BotType", "Turn.."), $x + 145, $y + 7 + $i * 51, -1, -1)
GUICtrlSetOnEvent(-1, "chkSwitchBotType")
$g_ahCmb_BotTypeMax[$i] = GUICtrlCreateCombo("", $x + 195, $y + 7 + $i * 51, 58, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Off|Donate|Active", "Donate")
$g_ahLbl_SwitchMax[$i] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Condition", "when") & " " & $asText[$i] & " >", $x + 262, $y + 11 + $i * 51, -1, -1)
$g_ahTxt_ConditionMax[$i] = GUICtrlCreateInput($aiValueMax[$i], $x + 352, $y + 7 + $i * 51, 55, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Condition_Info_01", "Set the amount of") & " " & $asText[$i] & " " & GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Condition_Info_02", "to trigger switching Profile & Bot Type."))
GUICtrlSetLimit(-1, $aiLimitMax[$i])
$y += 30
$g_ahChk_SwitchMin[$i] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Switch", -1), $x - 10, $y + 5 + $i * 51, -1, -1)
GUICtrlSetOnEvent(-1, "chkSwitchProfile")
$g_ahCmb_SwitchMin[$i] = GUICtrlCreateCombo("", $x + 60, $y + 5 + $i * 51, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $profileString, "<No Profiles>")
$g_ahChk_BotTypeMin[$i] = GUICtrlCreateCheckbox(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "BotType", -1), $x + 145, $y + 5 + $i * 51, -1, -1)
GUICtrlSetOnEvent(-1, "chkSwitchBotType")
$g_ahCmb_BotTypeMin[$i] = GUICtrlCreateCombo("", $x + 195, $y + 5 + $i * 51, 58, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Off|Donate|Active", "Active")
$g_ahLbl_SwitchMin[$i] = GUICtrlCreateLabel(GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Condition", -1) & " " & $asText[$i] & " <", $x + 262, $y + 9 + $i * 51, -1, -1)
$g_ahTxt_ConditionMin[$i] = GUICtrlCreateInput($aiValueMin[$i], $x + 352, $y + 5 + $i * 51, 55, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Condition_Info_01", -1) & " " & $asText[$i] & " " & GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Condition_Info_02", -1))
GUICtrlSetLimit(-1, $aiLimitMin[$i])
GUICtrlCreateGroup("", -99, -99, 1, 1)
Next
EndFunc
Func CreateFarmSchedule()
Local $x = 10, $y = 30
GUICtrlCreateLabel("Account", $x - 5, $y, 60, -1, $SS_CENTER)
GUICtrlCreateLabel("Farm Schedule 1", $x + 80, $y, 150, -1, $SS_CENTER)
GUICtrlCreateLabel("Farm Schedule 2", $x + 260, $y, 150, -1, $SS_CENTER)
$y += 18
GUICtrlCreateGraphic($x, $y, 425, 1, $SS_GRAYRECT)
$y += 8
For $i = 0 To 7
$x = 10
$g_ahChkSetFarm[$i] = GUICtrlCreateCheckbox("Acc " & $i + 1 & ".", $x, $y + $i * 30, -1, -1)
GUICtrlSetOnEvent(-1, "chkSetFarmSchedule")
$g_ahCmbAction1[$i] = GUICtrlCreateCombo("Turn...", $x + 60, $y + $i * 30, 58, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Idle|Donate|Active")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
$g_ahCmbCriteria1[$i] = GUICtrlCreateCombo("when...", $x + 123, $y + $i * 30, 62, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Gold >|Elixir >|DarkE >|Trop. >|Time:")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "cmbCriteria1")
$g_ahTxtResource1[$i] = GUICtrlCreateInput("", $x + 187, $y + $i * 30, 50, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$g_ahCmbTime1[$i] = GUICtrlCreateCombo("", $x + 187, $y + $i * 30, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0 am|1 am|2 am|3 am|4 am|5 am|6 am|7 am|8 am|9 am|10am|11am|" & "12pm|1 pm|2 pm|3 pm|4 pm|5 pm|6 pm|7 pm|8 pm|9 pm|10pm|11pm")
GUICtrlSetState(-1, $GUI_HIDE)
$x = 248 + 10 - 60
$g_ahCmbAction2[$i] = GUICtrlCreateCombo("Turn...", $x + 60, $y + $i * 30, 58, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Idle|Donate|Active")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
$g_ahCmbCriteria2[$i] = GUICtrlCreateCombo("when...", $x + 123, $y + $i * 30, 62, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "Gold <|Elixir <|DarkE <|Trop. <|Time:")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "cmbCriteria2")
$g_ahTxtResource2[$i] = GUICtrlCreateInput("", $x + 187, $y + $i * 30, 50, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$g_ahCmbTime2[$i] = GUICtrlCreateCombo("", $x + 187, $y + $i * 30, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0 am|1 am|2 am|3 am|4 am|5 am|6 am|7 am|8 am|9 am|10am|11am|" & "12pm|1 pm|2 pm|3 pm|4 pm|5 pm|6 pm|7 pm|8 pm|9 pm|10pm|11pm")
GUICtrlSetState(-1, $GUI_HIDE)
Next
EndFunc
Func CreateBotSwitchAccLog()
Local $x = 0, $y = 0
Local $activeHWnD1 = WinGetHandle("")
$g_hTxtSALog = _GUICtrlRichEdit_Create($g_hGUI_LOG_SA, "", $x, $y, 205, 200, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, $WS_HSCROLL, $ES_UPPERCASE, $ES_AUTOHSCROLL, $ES_AUTOVSCROLL, $ES_NUMBER, 0x200), $WS_EX_STATICEDGE)
WinActivate($activeHWnD1)
EndFunc
Global $g_hGUI_BOT_TAB = 0, $g_hGUI_BOT_TAB_ITEM1 = 0, $g_hGUI_BOT_TAB_ITEM2 = 0, $g_hGUI_BOT_TAB_ITEM3 = 0, $g_hGUI_BOT_TAB_ITEM4 = 0, $g_hGUI_BOT_TAB_ITEM5 = 0
Func CreateBotTab()
$g_hGUI_BOT = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
$g_hGUI_SWITCH_OPTIONS = _GUICreate("", $g_iSizeWGrpTab2 + 2, $g_iSizeHGrpTab4 + 5, 5, 80, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_BOT)
CreateSwitchOptions()
$g_hGUI_STATS = _GUICreate("", $g_iSizeWGrpTab2, $g_iSizeHGrpTab2, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_BOT)
GUISwitch($g_hGUI_BOT)
$g_hGUI_BOT_TAB = GUICtrlCreateTab(0, 0, $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_BOT_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_01", "Options"))
CreateBotOptions()
$g_hGUI_BOT_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_02", "Android"))
CreateBotAndroid()
$g_hGUI_BOT_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_03", "Debug"))
CreateBotDebug()
$g_hGUI_BOT_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_04", "Profiles"))
CreateBotProfiles()
$g_hGUI_BOT_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04_STab_05", "Stats"))
$g_hLastControlToHide = GUICtrlCreateDummy()
ReDim $g_aiControlPrevState[$g_hLastControlToHide + 1]
CreateBotStats()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_ABOUT = 0
Global $g_hLblCreditsBckGrnd = 0, $g_hLblMyBotURL = 0, $g_hLblForumURL = 0
Global $g_hGUI_CommandLineHelp = 0
Func CreateAboutTab()
$g_hGUI_ABOUT = _GUICreate("", $g_iSizeWGrpTab1, $g_iSizeHGrpTab1, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
Local $sText = ""
Local $x = 18, $y = 10 + $_GUI_MAIN_TOP
$sText = "My Bot is brought to you by a worldwide team of open source" & @CRLF & "programmers and a vibrant community of forum members!"
GUICtrlCreateLabel($sText, $x + 8, $y - 10, 400, 35, $SS_CENTER)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$y += 30
$sText = "Please visit our web forums:"
GUICtrlCreateLabel($sText, $x + 44, $y, 180, 30, $SS_CENTER)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
$g_hLblMyBotURL = GUICtrlCreateLabel("https://mybot.run/forums", $x + 223, $y, 150, 20)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_INFO)
$y += 22
GUICtrlCreateLabel("Credits belong to following programmers for donating their time:", $x - 5, $y, 420, 20)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
$y += 30
$sText = "Active developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Cosote, Demen, Fliegerfaust and TripleM"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 35
$sText = "Special participation at v7.6.6: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "ViperZ"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 35
$sText = "Inactive developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Hervidero, Kaganus, Sardo, Trlopes"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 50
$sText = "Retired developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Antidote, AtoZ, Barracoda, Boju, Codeslinger69, Didipe, Dinobot, DixonHill, DkEd, GkevinOD, HungLe, KnowJack, LunaEclipse, MonkeyHunter, ProMac, Safar46, Saviart, TheMaster1st, Zengzeng, and others"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 71
$sText = "Special thanks to all contributing forum members helping to make this" & @CRLF & "software better! And a special note to: @KevinM our server admin!"
GUICtrlCreateLabel($sText, $x + 14, $y, 390, 30, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $ES_CENTER), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 40
$sText = "The latest release of 'My Bot' can be found at:"
GUICtrlCreateLabel($sText, $x - 5, $y, 400, 15, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
$y += 18
$g_hLblForumURL = GUICtrlCreateLabel("https://mybot.run/forums/index.php?/forum/4-official-releases/", $x + 25, $y, 450, 20)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_INFO)
$y = 380
$sText = "By running this program, the user accepts all responsibility that arises from the use of this software." & @CRLF & "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even " & @CRLF & "the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General " & @CRLF & "Public License for more details. The license can be found in the main code folder location." & @CRLF & "Copyright (C) 2015-2019 MyBot.run"
GUICtrlCreateLabel($sText, $x + 1, $y, 415, 56, BitOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT, $ES_CENTER), 0)
GUICtrlSetColor(-1, 0x000053)
GUICtrlSetFont(-1, 6.5, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
EndFunc
Func ShowCommandLineHelp()
Return ShowHelp(Default)
EndFunc
Func ShowControlHelp()
Return ShowHelp(@GUI_CtrlId)
EndFunc
Func ShowHelp($Source = Default)
SetDebugLog("Help File called from: " & $source)
Local $PathHelp = "CommandLineParameter"
Switch $source
Case $g_lblHelpBot
$PathHelp = "CommandLineParameter"
Case $g_lblHepNotify
$PathHelp = "NotifyHelp"
EndSwitch
UpdateBotTitle()
$g_hGUI_CommandLineHelp = GUICreate($g_sBotTitle & " - Command Line Help", 650, 700, -1, -1, BitOR($WS_CAPTION, $WS_POPUPWINDOW, $DS_MODALFRAME), $WS_EX_TOPMOST, $g_hFrmBot)
GUISetIcon($g_sLibIconPath, $eIcnGUI, $g_hGUI_CommandLineHelp)
Local $hClose = GUICtrlCreateButton("Close", 300, 670, 50)
Local $hRichEdit = _GUICtrlRichEdit_Create($g_hGUI_CommandLineHelp, "", 2, 0, 646, 667, $WS_VSCROLL + $ES_MULTILINE)
Local $sHelpFile = @ScriptDir & "\Help\" & $PathHelp
If $g_sLanguage <> $g_sDefaultLanguage Then
If FileExists($sHelpFile & "_" & $g_sLanguage & ".rtf") Then
$sHelpFile &= "_" & $g_sLanguage
Else
SetDebugLog("Help file not available: " & $sHelpFile & "_" & $g_sLanguage & ".rtf")
EndIf
EndIf
_GUICtrlRichEdit_StreamFromFile($hRichEdit, $sHelpFile & ".rtf")
_GUICtrlRichEdit_SetReadOnly($hRichEdit)
_GUICtrlRichEdit_SetScrollPos($hRichEdit, 0, 0)
Local $iOpt = Opt("GUIOnEventMode", 0)
GUISetState(@SW_SHOW, $g_hGUI_CommandLineHelp)
While 1
Switch GUIGetMsg()
Case $GUI_EVENT_CLOSE, $hClose
ExitLoop
EndSwitch
WEnd
GUIDelete($g_hGUI_CommandLineHelp)
Opt("GUIOnEventMode", $iOpt)
EndFunc
Global $g_hGUI_MOD_TAB = 0, $g_hGUI_MOD_TAB_ITEM1 = 0, $g_hGUI_MOD_TAB_ITEM2 = 0, $g_hGUI_MOD_TAB_ITEM3 = 0, $g_hGUI_MOD_TAB_ITEM4 = 0
Func CreateMainGUI()
Local $iStyle = $WS_BORDER
If BitAND($g_iBotDesignFlags, 1) = 0 Then
$g_bCustomTitleBarActive = False
$iStyle = $WS_CAPTION
$_GUI_MAIN_TOP = 5
$_GUI_CHILD_TOP = 110 + $_GUI_MAIN_TOP
Else
$g_bCustomTitleBarActive = True
EndIf
Switch $g_iGuiMode
Case 0
Case 2
$_GUI_MAIN_WIDTH = $_MINIGUI_MAIN_WIDTH
$_GUI_MAIN_HEIGHT = $_MINIGUI_MAIN_HEIGHT
EndSwitch
$g_hFrmBot = GUICreate($g_sBotTitle, $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT + $_GUI_MAIN_TOP,($g_iFrmBotPosX = $g_WIN_POS_DEFAULT ? -1 : $g_iFrmBotPosX),($g_iFrmBotPosY = $g_WIN_POS_DEFAULT ? -1 : $g_iFrmBotPosY), BitOR($WS_MINIMIZEBOX, $WS_POPUP, $WS_SYSMENU, $WS_CLIPCHILDREN, $WS_CLIPSIBLINGS, $iStyle))
If $g_iFrmBotPosX = $g_WIN_POS_DEFAULT Or $g_iFrmBotPosY = $g_WIN_POS_DEFAULT Then
Local $a = WinGetPos($g_hFrmBot)
If UBound($a) > 1 Then
$g_iFrmBotPosX = $a[0]
$g_iFrmBotPosY = $a[1]
Else
$g_iFrmBotPosX = 100
$g_iFrmBotPosY = 100
EndIf
EndIf
GUISetIcon($g_sLibIconPath, $eIcnAiOMOD)
If $g_iGuiMode = 0 Then
UpdateBotTitle()
Return
EndIf
TraySetIcon($g_sLibIconPath, $eIcnAiOMOD)
Opt("TrayMenuMode", 3)
Opt("TrayOnEventMode", 1)
Opt("TrayIconHide", 0)
UpdateBotTitle()
_WindowAppId($g_hFrmBot, "MyBot.run")
$g_hTiShow = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_01", "Show bot"))
TrayItemSetOnEvent(-1, "tiShow")
$g_hTiStartStop = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Start", "Start bot"))
GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Stop", "Stop bot")
TrayItemSetOnEvent(-1, "tiStartStop")
$g_hTiPause = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Pause", "Pause bot"))
GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Resume", "Resume bot")
TrayItemSetState($g_hTiPause, $TRAY_DISABLE)
TrayItemSetOnEvent(-1, "btnPause")
TrayCreateItem("")
$g_hTiHide = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_02", "Hide when minimized"))
TrayItemSetOnEvent(-1, "tiHide")
TrayCreateItem("")
$g_hTiDonate = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_03", "Support Development"))
TrayItemSetOnEvent(-1, "tiDonate")
$g_hTiAbout = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_04", "About"))
TrayItemSetOnEvent(-1, "tiAbout")
TrayCreateItem("")
$g_hTiExit = TrayCreateItem(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_05", "Exit"))
TrayItemSetOnEvent(-1, "tiExit")
EndFunc
Func CreateMainGUIControls($bGuiModeUpdate = False)
If Not $bGuiModeUpdate Then
Local $aBtnSize = $_GUI_MAIN_BUTTON_SIZE
GUISwitch($g_hFrmBot)
Local $sStepText
Switch $g_iGuiMode
Case 0
Return
Case 1
$sStepText = GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_01", "Loading Main GUI...")
Case 2
$sStepText = GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_01_Mini", "Loading Mini GUI...")
EndSwitch
SplashStep($sStepText)
If $g_bCustomTitleBarActive Then
$g_hFrmBotButtons = GUICreate("My Bot Title Buttons", $_GUI_MAIN_BUTTON_COUNT * $aBtnSize[0], $aBtnSize[1], $_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT, 0, BitOR($WS_CHILD, $WS_TABSTOP), BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE,($g_bAndroidShieldPreWin8 ? 0 : $WS_EX_LAYERED)), $g_hFrmBot)
WinSetTrans($g_hFrmBotButtons, "", 254)
EndIf
$g_hFrmBotEx = GUICreate("My Bot Controls", $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), 0, $g_hFrmBot)
$g_hToolTip = _GUIToolTip_Create($g_hFrmBot)
_GUIToolTip_SetMaxTipWidth($g_hToolTip, $_GUI_MAIN_WIDTH)
If $g_bCustomTitleBarActive = False Then
GUICtrlCreateLabel("", 0, 0, $_GUI_MAIN_WIDTH, $_GUI_MAIN_TOP)
GUICtrlSetOnEvent(-1, "BotMoveRequest")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
Else
Local $iTitleX = 25
GUICtrlCreateLabel("", 0, 0, $iTitleX, $_GUI_MAIN_TOP)
GUICtrlSetOnEvent(-1, "BotMoveRequest")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
$g_hLblBotTitle = GUICtrlCreateLabel($g_sBotTitle, $iTitleX, 0, $_GUI_MAIN_WIDTH - $_GUI_MAIN_BUTTON_COUNT * $aBtnSize[0] - 25, $_GUI_MAIN_TOP)
GUICtrlSetOnEvent(-1, "BotMoveRequest")
GUICtrlSetFont(-1, 11, 0, 0, "Segoe UI")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetColor(-1, 0x171717)
GUISwitch($g_hFrmBotButtons)
$g_hLblBotShrink = GUICtrlCreateLabel(ChrW(0x25C4), 0, 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotShrink", "Shrink Bot when docked"))
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotExpand = GUICtrlCreateLabel(ChrW(0x25BA), 0, 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotExpand", "Expand Bot when docked"))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotMiniGUI = GUICtrlCreateLabel(ChrW(0x2584), $aBtnSize[0] *($_GUI_MAIN_BUTTON_COUNT - 3), 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotMiniGUI", "Switch to Mini Mode"))
GUICtrlSetState(-1, $g_iGuiMode = 1 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotNormalGUI = GUICtrlCreateLabel(ChrW(0x2588), $aBtnSize[0] *($_GUI_MAIN_BUTTON_COUNT - 3), 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotNormal", "Switch to Normal Mode"))
GUICtrlSetState(-1, $g_iGuiMode = 2 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotMinimize = GUICtrlCreateLabel("̶", $aBtnSize[0] *($_GUI_MAIN_BUTTON_COUNT - 2), 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotMinimize", "Minimize"))
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xF0F0F0)
GUICtrlSetColor(-1, 0xB8B8B8)
$g_hLblBotClose = GUICtrlCreateLabel("×", $aBtnSize[0] *($_GUI_MAIN_BUTTON_COUNT - 1), 0, $aBtnSize[0], $aBtnSize[1], $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslatedFileIni("MBR GUI Design Title", "LblBotClose", "Close"))
GUICtrlSetFont(-1, 10)
GUICtrlSetBkColor(-1, 0xFF4040)
GUICtrlSetColor(-1, 0xF8F8F8)
$g_hFrmBotLogoUrlSmall = GUICreate("My Bot URL", 290, 13, 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE,($g_bAndroidShieldPreWin8 ? 0 : $WS_EX_LAYERED)), $g_hFrmBot)
$g_hFrmBot_URL_PIC2 = _GUICtrlCreatePic($g_sLogoUrlSmallPath, 0, 0, 290, 13)
GUICtrlSetCursor(-1, 0)
GUISwitch($g_hFrmBotEx)
GUICtrlCreateLabel("", $_GUI_MAIN_WIDTH - $_GUI_MAIN_BUTTON_COUNT * $aBtnSize[0], $aBtnSize[1], $_GUI_MAIN_BUTTON_COUNT * $aBtnSize[0], $_GUI_MAIN_TOP - $aBtnSize[1])
GUICtrlSetOnEvent(-1, "BotMoveRequest")
GUICtrlSetBkColor(-1, $COLOR_WHITE)
EndIf
$g_hFrmBot_MAIN_PIC = _GUICtrlCreatePic($g_sLogoPath, 0, $_GUI_MAIN_TOP, $_GUI_MAIN_WIDTH, 67)
GUICtrlSetOnEvent(-1, "BotMoveRequest")
$g_hLblAndroidInfo = GUICtrlCreateLabel($g_sAndroidEmulator & " v" & $g_sAndroidVersion, $_GUI_MAIN_WIDTH - 395, $_GUI_MAIN_TOP + 54, -1, 12, $SS_LEFT)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
GUICtrlSetColor(-1, 0x804001)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
$g_hFrmBot_URL_PIC = _GUICtrlCreatePic($g_sLogoUrlPath, 0, $_GUI_MAIN_TOP + 67, $_GUI_MAIN_WIDTH, 13)
GUICtrlSetCursor(-1, 0)
GUISwitch($g_hFrmBot)
$g_hFrmBotEmbeddedShieldInput = GUICtrlCreateInput("", 0, 0, -1, -1, $WS_TABSTOP)
GUICtrlSetState($g_hFrmBotEmbeddedShieldInput, $GUI_HIDE)
$g_hFrmBotBottom = GUICreate("My Bot Buttons", $_GUI_MAIN_WIDTH, $_GUI_BOTTOM_HEIGHT, 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, BitOR($WS_CHILD, $WS_TABSTOP), 0, $g_hFrmBot)
GUISwitch($g_hFrmBot)
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_02", "Loading GUI Bottom..."))
GUISwitch($g_hFrmBotBottom)
CreateBottomPanel()
GUISwitch($g_hFrmBotEx)
$g_hStatusBar = _GUICtrlStatusBar_Create($g_hFrmBotBottom)
_GUICtrlStatusBar_SetSimple($g_hStatusBar)
_GUICtrlStatusBar_SetText($g_hStatusBar, "Status : Idle")
Else
GUISwitch($g_hFrmBotEx)
EndIf
If $g_iGuiMode = 2 Then
CreateLogTab($g_hFrmBotEx)
Return
EndIf
$g_hFirstControlToHide = GUICtrlCreateDummy()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_03", "Loading Log tab..."))
CreateLogTab()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_04", "Loading Village tab..."))
CreateVillageTab()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_05", "Loading Attack tab..."))
CreateAttackTab()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_06", "Loading Bot tab..."))
CreateBotTab()
If Not $bGuiModeUpdate Then DistributorsUpdateGUI()
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_07", "Loading About Us tab..."))
CreateAboutTab()
Local $sStepText = ""
Switch $g_iGuiMode
Case 1
$sStepText = GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_08", "Initializing GUI...")
Case 2
$sStepText = GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_08_Mini", "Initializing Mini GUI...")
EndSwitch
SplashStep($sStepText)
GUISwitch($g_hFrmBotEx)
$g_hTabMain = GUICtrlCreateTab(5, 85 + $_GUI_MAIN_TOP, $_GUI_MAIN_WIDTH - 9, $_GUI_MAIN_HEIGHT - 225)
$g_hTabLog = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_01", "Log"))
$g_hTabVillage = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_02", "Village"))
$g_hTabAttack = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_03", "Attack Plan"))
$g_hTabBot = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_04", "Bot"))
$g_hTabAbout = GUICtrlCreateTabItem(GetTranslatedFileIni("MBR Main GUI", "Tab_05", "About Us"))
GUICtrlCreateTabItem("")
GUICtrlSetResizing(-1, $GUI_DOCKBORDERS)
Static $g_hTabMain_ImageList = 0
Static $g_hGUI_VILLAGE_TAB_ImageList = 0
Static $g_hGUI_MISC_TAB_ImageList = 0
Static $g_hGUI_DONATE_TAB_ImageList = 0
Static $g_hGUI_UPGRADE_TAB_ImageList = 0
Static $g_hGUI_NOTIFY_TAB_ImageList = 0
Static $g_hGUI_ATTACK_TAB_ImageList = 0
Static $g_hGUI_TRAINARMY_TAB_ImageList = 0
Static $g_hGUI_SEARCH_TAB_ImageList = 0
Static $g_hGUI_DEADBASE_TAB_ImageList = 0
Static $g_hGUI_ACTIVEBASE_TAB_ImageList = 0
Static $g_hGUI_THSNIPE_TAB_ImageList = 0
Static $g_hGUI_ATTACKOPTION_TAB_ImageList = 0
Static $g_hGUI_STRATEGIES_TAB_ImageList = 0
Static $g_hGUI_MOD_TAB_ImageList = 0
Static $g_hGUI_BOT_TAB_ImageList = 0
Static $g_hGUI_SWITCH_OPTIONS_TAB_ImageList = 0
Static $g_hGUI_STATS_TAB_ImageList = 0
Bind_ImageList($g_hTabMain, $g_hTabMain_ImageList)
Bind_ImageList($g_hGUI_VILLAGE_TAB, $g_hGUI_VILLAGE_TAB_ImageList)
Bind_ImageList($g_hGUI_MISC_TAB, $g_hGUI_MISC_TAB_ImageList)
Bind_ImageList($g_hGUI_DONATE_TAB, $g_hGUI_DONATE_TAB_ImageList)
Bind_ImageList($g_hGUI_UPGRADE_TAB, $g_hGUI_UPGRADE_TAB_ImageList)
Bind_ImageList($g_hGUI_NOTIFY_TAB, $g_hGUI_NOTIFY_TAB_ImageList)
Bind_ImageList($g_hGUI_ATTACK_TAB, $g_hGUI_ATTACK_TAB_ImageList)
Bind_ImageList($g_hGUI_TRAINARMY_TAB, $g_hGUI_TRAINARMY_TAB_ImageList)
Bind_ImageList($g_hGUI_SEARCH_TAB, $g_hGUI_SEARCH_TAB_ImageList)
Bind_ImageList($g_hGUI_DEADBASE_TAB, $g_hGUI_DEADBASE_TAB_ImageList)
Bind_ImageList($g_hGUI_ACTIVEBASE_TAB, $g_hGUI_ACTIVEBASE_TAB_ImageList)
Bind_ImageList($g_hGUI_THSNIPE_TAB, $g_hGUI_THSNIPE_TAB_ImageList)
Bind_ImageList($g_hGUI_ATTACKOPTION_TAB, $g_hGUI_ATTACKOPTION_TAB_ImageList)
Bind_ImageList($g_hGUI_STRATEGIES_TAB, $g_hGUI_STRATEGIES_TAB_ImageList)
Bind_ImageList($g_hGUI_MOD_TAB, $g_hGUI_MOD_TAB_ImageList)
Bind_ImageList($g_hGUI_BOT_TAB, $g_hGUI_BOT_TAB_ImageList)
Bind_ImageList($g_hGUI_SWITCH_OPTIONS_TAB, $g_hGUI_SWITCH_OPTIONS_TAB_ImageList)
Bind_ImageList($g_hGUI_STATS_TAB, $g_hGUI_STATS_TAB_ImageList)
GUICtrlSetState($g_hTabLog, $GUI_SHOW)
tabMain()
cmbLog()
SetDebugLog("$g_hFrmBot=" & $g_hFrmBot, Default, True)
SetDebugLog("$g_hFrmBotEx=" & $g_hFrmBotEx, Default, True)
SetDebugLog("$g_hFrmBotBottom=" & $g_hFrmBotBottom, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedShield=" & $g_hFrmBotEmbeddedShield, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedShieldInput=" & $g_hFrmBotEmbeddedShieldInput, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedGraphics=" & $g_hFrmBotEmbeddedGraphics, Default, True)
EndFunc
Func ShowMainGUI()
If $g_iGuiMode = 0 Then Return
CheckDpiAwareness(False, $g_bBotLaunchOption_ForceDpiAware, True)
If Not $g_bNoFocusTampering Then
GUISetState(@SW_SHOW, $g_hFrmBot)
Else
GUISetState(@SW_SHOW, $g_hFrmBot)
EndIf
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotButtons)
If $g_hFrmBotEx Then GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotEx)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotBottom)
CheckBotShrinkExpandButton()
GUISwitch($g_hFrmBotEx)
$g_bFrmBotMinimized = False
Local $p = WinGetPos($g_hFrmBot)
$g_aFrmBotPosInit[0] = $p[0]
$g_aFrmBotPosInit[1] = $p[1]
$g_aFrmBotPosInit[2] = $p[2]
$g_aFrmBotPosInit[3] = $p[3]
$g_aFrmBotPosInit[4] = _WinAPI_GetClientWidth($g_hFrmBot)
$g_aFrmBotPosInit[5] = _WinAPI_GetClientHeight($g_hFrmBot)
$g_aFrmBotPosInit[6] = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)[3]
EndFunc
Func UpdateMainGUI()
If $g_hLibMyBot <> -1 Then
GUICtrlSetState($g_hBtnStart, $GUI_ENABLE)
If $g_iTownHallLevel > 2 Then
GUICtrlSetState($g_hBtnSearchMode, $GUI_ENABLE)
EndIf
EndIf
EndFunc
Func CheckDpiAwareness($bCheckOnlyIfAlreadyAware = False, $bForceDpiAware = False, $bForceDpiAware2 = False)
Static $sbDpiAware = False
Static $sbDpiAlreadyChecked = False
If $bCheckOnlyIfAlreadyAware = True Then Return $sbDpiAware
Local $bDpiAware = False
Local $bChanged = False
If $sbDpiAlreadyChecked = True Or(Not IsBotLaunched() And $bForceDpiAware2 = False) Then Return $bChanged
If $g_iDpiAwarenessMode <> 0 And RegRead("HKCU\Control Panel\Desktop\WindowMetrics", "AppliedDPI") <> 96 Then
$bDpiAware = $bForceDpiAware = True Or $g_bChkBackgroundMode = False Or($g_bAndroidAdbScreencap = False And GetProcessDpiAwareness(GetAndroidPid()))
$bChanged = $bDpiAware And Not $sbDpiAware
If $bChanged Then
$sbDpiAware = True
Local $bWasEmbedded = AndroidEmbedded()
If $bWasEmbedded Then AndroidEmbed(False)
If $g_bCustomTitleBarActive = False Then
Local $g_iDpiAwarenessYcomp = _WinAPI_GetSystemMetrics($SM_CYCAPTION)
Local $aResult = DllCall("user32.dll", "boolean", "SetProcessDPIAware")
$g_aFrmBotPosInit[7] = _WinAPI_GetSystemMetrics($SM_CYCAPTION) - $g_iDpiAwarenessYcomp
SetDebugLog("Enabled DPI Awareness, height compensation: " & $g_aFrmBotPosInit[7])
Else
Local $aResult = DllCall("user32.dll", "boolean", "SetProcessDPIAware")
EndIf
SetDebugLog("SetProcessDPIAware called: " & @error &((UBound($aResult) = 0) ?("") :(", " & $aResult[0])))
If $bWasEmbedded Then AndroidEmbed(True)
EndIf
EndIf
Return $bChanged
EndFunc
Func GetProcessDpiAwareness($iPid)
$iPid = ProcessExists($iPid)
If $iPid = 0 Then
Return SetError(1, 0, 0)
EndIf
Local $hProcess
If _WinAPI_GetVersion() >= 6.0 Then
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_LIMITED_INFORMATION, 0, $iPid)
Else
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_INFORMATION, 0, $iPid)
EndIf
If @error Then
Return SetError(2, 0, 0)
EndIf
Local $aResult = DllCall("user32.dll", "boolean", "GetProcessDpiAwarenessInternal", "handle", $hProcess, "ulong*", 0)
_WinAPI_CloseHandle($hProcess)
If @error Or UBound($aResult) < 3 Then Return SetError(3, 0, 0)
Local $iDpiAwareness = $aResult[2]
Return $iDpiAwareness
EndFunc
Func _GUICreate($title, $width, $height, $left = -1, $top = -1, $style = -1, $exStyle = -1, $parent = 0)
Local $h = GUICreate($title, $width, $height, $left, $top, $style, $exStyle, $parent)
Local $key = String($h)
Local $obj = $h
$g_oGuiNotInMini.Add($key, $obj)
Return $h
EndFunc
Func _GUICtrlCreateIcon($filename, $iconName, $left, $top, $width = 32, $height = 32, $style = -1, $exStyle = -1)
Static $s_hLibIcon = 0
Local $hLib
If $filename = $g_sLibIconPath Then
If $s_hLibIcon = 0 Then
$s_hLibIcon = _WinAPI_LoadLibraryEx($filename, $LOAD_LIBRARY_AS_DATAFILE)
EndIf
$hLib = $s_hLibIcon
Else
$hLib = _WinAPI_LoadLibraryEx($filename, $LOAD_LIBRARY_AS_DATAFILE)
EndIf
Local $hIcon = _WinAPI_LoadImage($hLib, $iconName, $IMAGE_ICON, $width, $height, $LR_DEFAULTCOLOR)
If $hLib <> $s_hLibIcon Then
_WinAPI_FreeLibrary($hLib)
EndIf
Local $hBmp = _WinAPI_Create32BitHBITMAP($hIcon, False, True)
Local $controlID = GUICtrlCreatePic("", $left, $top, $width, $height, $style, $exStyle)
_WinAPI_DeleteObject(GUICtrlSendMsg($controlID, $STM_SETIMAGE, 0, $hBmp))
_WinAPI_DeleteObject($hBmp)
Local $aIconData = [$width, $height]
$g_oCtrlIconData("Icon:" & GUICtrlGetHandle($controlID)) = $aIconData
Return $controlID
EndFunc
Func _GUICtrlSetImage($controlID, $filename, $iconName = -1, $iconType = 1)
Local $aIconData = $g_oCtrlIconData("Icon:" & GUICtrlGetHandle($controlID))
If IsArray($aIconData) = 0 Then
Return GUICtrlSetImage($controlID, $filename, $iconName, $iconType)
EndIf
Static $s_hLibIcon = 0
Local $hLib
If $filename = $g_sLibIconPath Then
If $s_hLibIcon = 0 Then
$s_hLibIcon = _WinAPI_LoadLibraryEx($filename, $LOAD_LIBRARY_AS_DATAFILE)
EndIf
$hLib = $s_hLibIcon
Else
$hLib = _WinAPI_LoadLibraryEx($filename, $LOAD_LIBRARY_AS_DATAFILE)
EndIf
If $hLib = 0 Then Return 0
Local $width = $aIconData[0], $height = $aIconData[1]
Local $hIcon = _WinAPI_LoadImage($hLib, $iconName, $IMAGE_ICON, $width, $height, $LR_DEFAULTCOLOR)
If $hLib <> $s_hLibIcon Then
_WinAPI_FreeLibrary($hLib)
EndIf
If $hIcon = 0 Then Return 0
Local $hBmp = _WinAPI_Create32BitHBITMAP($hIcon, False, True)
If $hBmp = 0 Then Return 0
_WinAPI_DeleteObject(GUICtrlSendMsg($controlID, $STM_SETIMAGE, 0, 0))
GUICtrlSendMsg($controlID, $STM_SETIMAGE, 0, $hBmp)
_WinAPI_InvalidateRect(GUICtrlGetHandle($controlID), 0, False)
_WinAPI_DeleteObject($hBmp)
Return 1
EndFunc
Func GUICtrlGetBkColor($hWnd)
If Not IsHWnd($hWnd) Then
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hDC = _WinAPI_GetDC($hWnd)
Local $iColor = _WinAPI_GetPixel($hDC, 0, 0)
_WinAPI_ReleaseDC($hWnd, $hDC)
Return $iColor
EndFunc
Global $g_bRedrawBotWindow[3] = [True, False, False]
Global $g_hFrmBot_WNDPROC = 0
Global $g_hFrmBot_WNDPROC_ptr = 0
Global $g_aGroupSearchDB = "", $groupHerosDB = "", $groupSearchAB = "", $groupHerosAB = "", $groupSpellsDB = "", $groupSpellsAB = "", $groupSearchTS = ""
Global $g_aGroupAttackDB = "", $g_aGroupAttackDBSpell = "", $groupIMGAttackDB = "", $groupIMGAttackDBSpell = "", $groupAttackAB = "", $groupAttackABSpell = "", $groupIMGAttackAB = "", $groupIMGAttackABSpell = "", $groupAttackTS = "", $groupAttackTSSpell = "", $groupIMGAttackTS = "", $groupIMGAttackTSSpell = ""
Global $g_aGroupListPicMinTrophy = "", $g_aGroupListPicMaxTrophy = ""
Global $g_aGroupEndBattleDB = "", $groupEndBattkeAB = "", $groupKingSleeping = "", $groupQueenSleeping = "", $groupWardenSleeping = "", $groupCloseWhileTraining = "", $grpTrainTroops = "", $grpCookSpell = ""
Global $g_aGroupLightning = "", $groupHeal = "", $groupRage = "", $groupJumpSpell = "", $groupFreeze = "", $groupClone = "", $groupIcnLightning = "", $groupIcnHeal = "", $groupIcnRage = "", $groupIcnJumpSpell = "", $groupIcnFreeze = "", $groupIcnClone = ""
Global $g_aGroupPoison = "", $groupEarthquake = "", $groupHaste = "", $groupSkeleton = "", $groupIcnPoison = "", $groupIcnEarthquake = "", $groupIcnHaste = "", $groupIcnSkeleton = "", $groupIcnBat = "", $groupListSpells = ""
Global $g_aGroupListTHLevels = ""
Global $g_aGroupListPicDBMaxTH = ""
Global $g_aGroupListPicABMaxTH = ""
Global $g_aGroupListPicBullyMaxTH = ""
Global $g_aGroupLeague = ""
Global $aTabControlsVillage, $aTabControlsMisc, $aTabControlsDonate, $aTabControlsUpgrade, $aTabControlsNotify
Global $aTabControlsAttack, $aTabControlsArmy, $aTabControlsSearch, $aTabControlsDeadbase, $aTabControlsActivebase, $aTabControlsTHSnipe, $aTabControlsAttackOptions
Global $aTabControlsStrategies, $aTabControlsMOD, $aTabControlsBot, $aTabControlsSwitchOpt, $aTabControlsStats
Global $oAlwaysEnabledControls = ObjCreate("Scripting.Dictionary")
Func InitializeControlVariables()
$g_aGroupSearchDB = $g_hGrpDBFilter&"#"&$g_hCmbDBMeetGE&"#"&$g_hTxtDBMinGold&"#"&$g_hPicDBMinGold&"#"&$g_hTxtDBMinElixir&"#"&$g_hPicDBMinElixir&"#"& $g_hTxtDBMinGoldPlusElixir&"#"&$g_hPicDBMinGPEGold&"#"&$g_hChkDBMeetDE&"#"&$g_hTxtDBMinDarkElixir&"#"&$g_hPicDBMinDarkElixir&"#"&$g_hChkDBMeetTrophy&"#"& $g_hTxtDBMinTrophy&"#"&$g_hTxtDBMaxTrophy&"#"&$g_hPicDBMinTrophies&"#"&$g_hChkDBMeetTH&"#"&$g_hCmbDBTH&"#"&$g_hChkDBMeetTHO&"#"& $g_ahChkMeetOne[$DB]&"#"& $g_ahChkMaxMortar[$DB]&"#"&$g_ahCmbWeakMortar[$DB]&"#"&$g_ahPicWeakMortar[$DB]&"#"&$g_ahChkMaxWizTower[$DB]&"#"&$g_ahCmbWeakWizTower[$DB]&"#"& $g_ahPicWeakWizTower[$DB]&"#"& $g_ahChkMaxXBow[$DB]&"#"&$g_ahCmbWeakXBow[$DB]&"#"&$g_ahPicWeakXBow[$DB]&"#"&$g_ahChkMaxInferno[$DB]&"#"&$g_ahCmbWeakInferno[$DB]&"#"& $g_ahPicWeakInferno[$DB]&"#"&$g_ahChkMaxEagle[$DB]&"#"&$g_ahCmbWeakEagle[$DB]&"#"&$g_ahPicWeakEagle[$DB]
$groupHerosDB = $g_hPicDBHeroesWait&"#"&$g_hTxtDBHeroesWait&"#"&$g_hChkDBKingWait&"#"&$g_hChkDBQueenWait&"#"&$g_hChkDBWardenWait&"#"&$g_hPicDBKingWait&"#"& $g_hPicDBQueenWait&"#"&$g_hPicDBWardenWait&"#"&$g_hChkDBNotWaitHeroes
$groupSearchAB = $g_hGrpABFilter&"#"&$g_hCmbABMeetGE&"#"&$g_hTxtABMinGold&"#"&$g_hPicABMinGold&"#"&$g_hTxtABMinElixir&"#"&$g_hPicABMinElixir&"#"& $g_hTxtABMinGoldPlusElixir&"#"&$g_hPicABMinGPEGold&"#"&$g_hChkABMeetDE&"#"&$g_hTxtABMinDarkElixir&"#"& $g_hPicABMinDarkElixir&"#"&$g_hChkABMeetTrophy&"#"& $g_hTxtABMinTrophy&"#"&$g_hTxtABMaxTrophy&"#"&$g_hPicABMinTrophies&"#"&$g_hChkABMeetTH&"#"&$g_hCmbABTH&"#"&$g_hChkABMeetTHO&"#"& $g_ahChkMeetOne[$LB]&"#"& $g_ahChkMaxMortar[$LB]&"#"&$g_ahCmbWeakMortar[$LB]&"#"&$g_ahPicWeakMortar[$LB]&"#"&$g_ahChkMaxWizTower[$LB]&"#"&$g_ahCmbWeakWizTower[$LB]&"#"& $g_ahPicWeakWizTower[$LB]&"#"&$g_ahChkMaxXBow[$LB]&"#"&$g_ahCmbWeakXBow[$LB]&"#"&$g_ahPicWeakXBow[$LB]&"#"&$g_ahChkMaxInferno[$LB]&"#"& $g_ahCmbWeakInferno[$LB]&"#"&$g_ahPicWeakInferno[$LB]&"#"&$g_ahChkMaxEagle[$LB]&"#"&$g_ahCmbWeakEagle[$LB]&"#"&$g_ahPicWeakEagle[$LB]
$groupHerosAB = $g_hPicABHeroesWait&"#"&$g_hTxtABHeroesWait&"#"&$g_hChkABKingWait&"#"&$g_hChkABQueenWait&"#"&$g_hChkABWardenWait&"#"&$g_hPicABKingWait&"#"& $g_hPicABQueenWait&"#"&$g_hPicABWardenWait&"#"&$g_hChkABNotWaitHeroes
$groupSpellsDB = $g_hChkDBSpellsWait&"#"&$g_hPicDBLightSpellWait&"#"&$g_hPicDBHealSpellWait&"#"&$g_hPicDBRageSpellWait&"#"&$g_hPicDBJumpSpellWait&"#"& $g_hPicDBFreezeSpellWait&"#"&$g_hPicDBPoisonSpellWait&"#"&$g_hPicDBEarthquakeSpellWait&"#"&$g_hPicDBHasteSpellWait
$groupSpellsAB = $g_hChkABSpellsWait&"#"&$g_hPicABLightSpellWait&"#"&$g_hPicABHealSpellWait&"#"&$g_hPicABRageSpellWait&"#"&$g_hPicABJumpSpellWait&"#"& $g_hPicABFreezeSpellWait&"#"&$g_hPicABPoisonSpellWait&"#"&$g_hPicABEarthquakeSpellWait&"#"&$g_hPicABHasteSpellWait
$groupSearchTS = $g_hGrpTSFilter&"#"&$g_hCmbTSMeetGE&"#"&$g_hTxtTSMinGold&"#"&$g_hPicTSMinGold&"#"&$g_hTxtTSMinElixir&"#"&$g_hPicTSMinElixir&"#"& $g_hTxtTSMinGoldPlusElixir&"#"&$g_hPicTSMinGPEGold&"#"&$g_hChkTSMeetDE&"#"&$g_hTxtTSMinDarkElixir&"#"&$g_hPicTSMinDarkElixir&"#"& $g_hLblAddTiles&"#"&$g_hLblAddTiles2&"#"&$g_hLblSWTTiles&"#"&$g_hTxtSWTTiles&"#"&$g_hLblTHadd&"#"&$g_hTxtTHaddTiles
$g_aGroupAttackDB = $g_hCmbDBAlgorithm&"#"&$g_hCmbDBSelectTroop&"#"&$g_hChkDBKingAttack&"#"&$g_hChkDBQueenAttack&"#"&$g_hChkDBWardenAttack&"#"&$g_hChkDBDropCC&"#"& $g_hChkDBLightSpell&"#"&$g_hChkDBHealSpell&"#"&$g_hChkDBRageSpell&"#"&$g_hChkDBJumpSpell&"#"&$g_hChkDBFreezeSpell&"#"&$g_hChkDBCloneSpell&"#"& $g_hChkDBPoisonSpell&"#"&$g_hChkDBEarthquakeSpell&"#"&$g_hChkDBHasteSpell&"#"&$g_hChkDBSkeletonSpell&"#"&$g_hChkDBBatSpell
$g_aGroupAttackDBSpell = $g_hChkDBLightSpell&"#"&$g_hChkDBHealSpell&"#"&$g_hChkDBRageSpell&"#"&$g_hChkDBJumpSpell&"#"&$g_hChkDBFreezeSpell&"#"&$g_hChkDBCloneSpell&"#"& $g_hChkDBPoisonSpell&"#"&$g_hChkDBEarthquakeSpell&"#"&$g_hChkDBHasteSpell&"#"&$g_hChkDBSkeletonSpell&"#"&$g_hChkDBBatSpell
$groupIMGAttackDB = $g_hPicDBKingAttack&"#"&$g_hPicDBQueenAttack&"#"&$g_hPicDBWardenAttack&"#"&$g_hPicDBDropCC&"#"& $g_hPicDBLightSpell&"#"&$g_hPicDBHealSpell&"#"&$g_hPicDBRageSpell&"#"&$g_hPicDBJumpSpell&"#"&$g_hPicDBFreezeSpell&"#"&$g_hPicDBCloneSpell&"#"& $g_hPicDBPoisonSpell&"#"&$g_hPicDBEarthquakeSpell&"#"&$g_hPicDBHasteSpell&"#"&$g_hPicDBSkeletonSpell&"#"&$g_hPicDBBatSpell
$groupIMGAttackDBSpell = $g_hPicDBLightSpell&"#"&$g_hPicDBHealSpell&"#"&$g_hPicDBRageSpell&"#"&$g_hPicDBJumpSpell&"#"&$g_hPicDBFreezeSpell&"#"&$g_hPicDBCloneSpell&"#"& $g_hPicDBPoisonSpell&"#"&$g_hPicDBEarthquakeSpell&"#"&$g_hPicDBHasteSpell&"#"&$g_hPicDBSkeletonSpell&"#"&$g_hPicDBBatSpell
$groupAttackAB = $g_hCmbDBAlgorithm&"#"&$g_hCmbABSelectTroop&"#"&$g_hChkABKingAttack&"#"&$g_hChkABQueenAttack&"#"&$g_hChkABWardenAttack&"#"&$g_hChkABDropCC&"#"& $g_hChkABLightSpell&"#"&$g_hChkABHealSpell&"#"&$g_hChkABRageSpell&"#"&$g_hChkABJumpSpell&"#"&$g_hChkABFreezeSpell&"#"&$g_hChkABCloneSpell&"#"& $g_hChkABPoisonSpell&"#"&$g_hChkABEarthquakeSpell&"#"&$g_hChkABHasteSpell&"#"&$g_hChkABSkeletonSpell&"#"&$g_hChkABBatSpell
$groupAttackABSpell = $g_hChkABLightSpell&"#"&$g_hChkABHealSpell&"#"&$g_hChkABRageSpell&"#"&$g_hChkABJumpSpell&"#"&$g_hChkABFreezeSpell&"#"&$g_hChkABCloneSpell&"#"& $g_hChkABPoisonSpell&"#"&$g_hChkABEarthquakeSpell&"#"&$g_hChkABHasteSpell&"#"&$g_hChkABSkeletonSpell&"#"&$g_hChkABBatSpell
$groupIMGAttackAB = $g_hPicABKingAttack&"#"&$g_hPicABQueenAttack&"#"&$g_hPicABWardenAttack&"#"&$g_hPicABDropCC&"#"& $g_hPicABLightSpell&"#"&$g_hPicABHealSpell&"#"&$g_hPicABRageSpell&"#"&$g_hPicABJumpSpell&"#"&$g_hPicABFreezeSpell&"#"&$g_hPicABCloneSpell&"#"& $g_hPicABPoisonSpell&"#"&$g_hPicABEarthquakeSpell&"#"&$g_hPicABHasteSpell&"#"&$g_hPicABSkeletonSpell&"#"&$g_hPicABBatSpell
$groupIMGAttackABSpell = $g_hPicABLightSpell&"#"&$g_hPicABHealSpell&"#"&$g_hPicABRageSpell&"#"&$g_hPicABJumpSpell&"#"&$g_hPicABFreezeSpell&"#"&$g_hPicABCloneSpell&"#"& $g_hPicABPoisonSpell&"#"&$g_hPicABEarthquakeSpell&"#"&$g_hPicABHasteSpell&"#"&$g_hPicABSkeletonSpell&"#"&$g_hPicABBatSpell
$groupAttackTS = $g_hGrpABAttack&"#"&$g_hLblAttackTHType&"#"&$g_hCmbAttackTHType&"#"&$g_hLblTSSelectTroop&"#"&$g_hCmbTSSelectTroop&"#"& $g_hLblTSSelectSpecialTroop&"#"&$g_hChkTSKingAttack&"#"&$g_hChkTSQueenAttack&"#"&$g_hChkTSWardenAttack&"#"&$g_hChkTSDropCC&"#"&$g_hChkTSLightSpell&"#"& $g_hChkTSHealSpell&"#"&$g_hChkTSRageSpell&"#"&$g_hChkTSJumpSpell&"#"&$g_hChkTSFreezeSpell&"#"&$g_hChkTSPoisonSpell&"#"&$g_hChkTSEarthquakeSpell&"#"& $g_hChkTSHasteSpell
$groupAttackTSSpell = $g_hChkTSLightSpell&"#"&$g_hChkTSHealSpell&"#"&$g_hChkTSRageSpell&"#"&$g_hChkTSJumpSpell&"#"&$g_hChkTSFreezeSpell&"#"& $g_hChkTSPoisonSpell&"#"&$g_hChkTSEarthquakeSpell&"#"&$g_hChkTSHasteSpell
$groupIMGAttackTS = $g_hPicTSKingAttack&"#"&$g_hPicTSQueenAttack&"#"&$g_hPicTSWardenAttack&"#"&$g_hPicTSDropCC&"#"&$g_hPicTSLightSpell&"#"& $g_hPicTSHealSpell&"#"&$g_hPicTSRageSpell&"#"&$g_hPicTSJumpSpell&"#"&$g_hPicTSFreezeSpell&"#"&$g_hPicTSPoisonSpell&"#"&$g_hPicTSEarthquakeSpell&"#"& $g_hPicTSHasteSpell
$groupIMGAttackTSSpell = $g_hPicTSLightSpell&"#"&$g_hPicTSHealSpell&"#"&$g_hPicTSRageSpell&"#"&$g_hPicTSJumpSpell&"#"&$g_hPicTSFreezeSpell&"#"& $g_hPicTSPoisonSpell&"#"&$g_hPicTSEarthquakeSpell&"#"&$g_hPicTSHasteSpell
$g_aGroupListPicMinTrophy = $g_hPicMinTrophies[$eLeagueUnranked]&"#"&$g_hPicMinTrophies[$eLeagueBronze]&"#"&$g_hPicMinTrophies[$eLeagueSilver]&"#"&$g_hPicMinTrophies[$eLeagueGold] &"#"& $g_hPicMinTrophies[$eLeagueCrystal]&"#"&$g_hPicMinTrophies[$eLeagueMaster]&"#"&$g_hPicMinTrophies[$eLeagueChampion]&"#"&$g_hPicMinTrophies[$eLeagueTitan]&"#"& $g_hPicMinTrophies[$eLeagueLegend]
$g_aGroupListPicMaxTrophy = $g_hPicMaxTrophies[$eLeagueUnranked]&"#"&$g_hPicMaxTrophies[$eLeagueBronze]&"#"&$g_hPicMaxTrophies[$eLeagueSilver]&"#"&$g_hPicMaxTrophies[$eLeagueGold] &"#"& $g_hPicMaxTrophies[$eLeagueCrystal]&"#"&$g_hPicMaxTrophies[$eLeagueMaster]&"#"&$g_hPicMaxTrophies[$eLeagueChampion]&"#"&$g_hPicMaxTrophies[$eLeagueTitan]&"#"& $g_hPicMaxTrophies[$eLeagueLegend]
$g_aGroupEndBattleDB = $g_hGrpDBEndBattle&"#"&$g_hChkStopAtkDBNoLoot1&"#"&$g_hLblStopAtkDBNoLoot1a&"#"&$g_hTxtStopAtkDBNoLoot1&"#"&$g_hLblStopAtkDBNoLoot1b&"#"& $g_hChkStopAtkDBNoLoot2&"#"&$g_hChkStopAtkDBNoLoot2&"#"&$g_hLblStopAtkDBNoLoot2a&"#"&$g_hTxtStopAtkDBNoLoot2&"#"&$g_hLblStopAtkDBNoLoot2b&"#"& $g_hLblDBMinRerourcesAtk2&"#"&$g_hTxtDBMinGoldStopAtk2&"#"&$g_hPicDBMinGoldStopAtk2&"#"&$g_hTxtDBMinElixirStopAtk2&"#"&$g_hPicDBMinElixirStopAtk2&"#"& $g_hTxtDBMinDarkElixirStopAtk2&"#"&$g_hPicDBMinDarkElixirStopAtk2&"#"&$g_hChkDBEndNoResources&"#"&$g_hChkDBEndOneStar&"#"&$g_hChkDBEndTwoStars
$groupEndBattkeAB = $g_hGrpABEndBattle&"#"&$g_hChkStopAtkABNoLoot1&"#"&$g_hLblABTimeStopAtka&"#"&$g_hTxtStopAtkABNoLoot1&"#"&$g_hLblABTimeStopAtk&"#"& $g_hChkStopAtkABNoLoot2&"#"&$g_hChkStopAtkABNoLoot2&"#"&$g_hLblABTimeStopAtk2a&"#"&$g_hTxtStopAtkABNoLoot2&"#"&$g_hLblABTimeStopAtk2&"#"& $g_hLblABMinRerourcesAtk2&"#"&$g_hTxtABMinGoldStopAtk2&"#"&$g_hPicABMinGoldStopAtk2&"#"&$g_hTxtABMinElixirStopAtk2&"#"&$g_hPicABMinElixirStopAtk2&"#"& $g_hTxtABMinDarkElixirStopAtk2&"#"&$g_hPicABMinDarkElixirStopAtk2&"#"&$g_hChkABEndNoResources&"#"&$g_hChkABEndOneStar&"#"&$g_hChkABEndTwoStars
$groupKingSleeping = $g_hPicDBKingSleepWait&"#"&$g_hPicABKingSleepWait&"#"&$g_hPicChkKingSleepWait
$groupQueenSleeping = $g_hPicDBQueenSleepWait&"#"&$g_hPicABQueenSleepWait&"#"&$g_hPicChkQueenSleepWait
$groupWardenSleeping = $g_hPicDBWardenSleepWait&"#"&$g_hPicABWardenSleepWait&"#"&$g_hPicChkWardenSleepWait
$groupCloseWhileTraining = $g_hChkCloseWithoutShield&"#"&$g_hChkCloseEmulator&"#"&$g_hChkSuspendComputer&"#"&$g_hPicCloseWaitTrain&"#"&$g_hChkRandomClose&"#"&$g_hPicCloseWaitStop&"#"& $g_hRdoCloseWaitExact&"#"&$g_hPicCloseWaitExact&"#"&$g_hRdoCloseWaitRandom&"#"&$g_hCmbCloseWaitRdmPercent&"#"&$g_hLblCloseWaitRdmPercent
$grpTrainTroops = $g_ahTxtTrainArmyTroopCount[$eTroopBarbarian]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopArcher]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopGiant]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopGoblin]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopWallBreaker]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopBalloon]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopWizard]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopHealer]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopDragon]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopPekka]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopBabyDragon]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopMiner]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopMinion]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopHogRider]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopValkyrie]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopGolem]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopWitch]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopLavaHound]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopBowler]
$grpCookSpell = $g_ahTxtTrainArmySpellCount[$eSpellLightning]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHeal]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellRage]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellJump]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellFreeze]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellClone]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellPoison]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellEarthquake]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHaste]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellSkeleton]
$g_aGroupLightning = $g_ahPicTrainArmySpell[$eSpellLightning]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellLightning]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellLightning]
$groupHeal = $g_ahPicTrainArmySpell[$eSpellHeal]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHeal]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHeal]
$groupRage = $g_ahPicTrainArmySpell[$eSpellRage]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellRage]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellRage]
$groupJumpSpell = $g_ahPicTrainArmySpell[$eSpellJump]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellJump]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellJump]
$groupFreeze = $g_ahPicTrainArmySpell[$eSpellFreeze]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellFreeze]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellFreeze]
$groupClone = $g_ahPicTrainArmySpell[$eSpellClone]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellClone]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellClone]
$groupIcnLightning = $g_ahPicTrainArmySpell[$eSpellLightning]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellLightning]
$groupIcnHeal = $g_ahPicTrainArmySpell[$eSpellHeal]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHeal]
$groupIcnRage = $g_ahPicTrainArmySpell[$eSpellRage]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellRage]
$groupIcnJumpSpell = $g_ahPicTrainArmySpell[$eSpellJump]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellJump]
$groupIcnFreeze = $g_ahPicTrainArmySpell[$eSpellFreeze]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellFreeze]
$groupIcnClone = $g_ahPicTrainArmySpell[$eSpellClone]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellClone]
$g_aGroupPoison = $g_ahPicTrainArmySpell[$eSpellPoison]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellPoison]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellPoison]
$groupEarthquake = $g_ahPicTrainArmySpell[$eSpellEarthquake]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellEarthquake]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellEarthquake]
$groupHaste = $g_ahPicTrainArmySpell[$eSpellHaste]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHaste]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHaste]
$groupSkeleton = $g_ahPicTrainArmySpell[$eSpellSkeleton]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellSkeleton]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellSkeleton]
$groupIcnPoison = $g_ahPicTrainArmySpell[$eSpellPoison]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellPoison]
$groupIcnEarthquake = $g_ahPicTrainArmySpell[$eSpellEarthquake]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellEarthquake]
$groupIcnHaste = $g_ahPicTrainArmySpell[$eSpellHaste]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHaste]
$groupIcnSkeleton = $g_ahPicTrainArmySpell[$eSpellSkeleton]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellSkeleton]
$groupListSpells = $g_aGroupLightning&"#"&$groupHeal&"#"&$groupRage&"#"&$groupJumpSpell&"#"&$groupFreeze&"#"&$groupClone&"#"&$g_aGroupPoison&"#"& $groupEarthquake&"#"&$groupHaste&"#"&$groupSkeleton
$g_aGroupListTHLevels = $g_ahPicTHLevels[4]&"#"&$g_ahPicTHLevels[5]&"#"&$g_ahPicTHLevels[6]&"#"&$g_ahPicTHLevels[7]&"#"&$g_ahPicTHLevels[8]&"#"& $g_ahPicTHLevels[9]&"#"&$g_ahPicTHLevels[10]&"#"&$g_ahPicTHLevels[11]&"#"&$g_ahPicTHLevels[12]
$g_aGroupListPicDBMaxTH = $g_ahPicDBMaxTH[6]&"#"&$g_ahPicDBMaxTH[7]&"#"&$g_ahPicDBMaxTH[8]&"#"& $g_ahPicDBMaxTH[9]&"#"&$g_ahPicDBMaxTH[10]&"#"&$g_ahPicDBMaxTH[11] & "#" & $g_ahPicDBMaxTH[12]
$g_aGroupListPicABMaxTH = $g_ahPicABMaxTH[6]&"#"&$g_ahPicABMaxTH[7]&"#"&$g_ahPicABMaxTH[8]&"#"& $g_ahPicABMaxTH[9]&"#"&$g_ahPicABMaxTH[10]&"#"&$g_ahPicABMaxTH[11] & "#" & $g_ahPicABMaxTH[12]
$g_aGroupListPicBullyMaxTH = $g_ahPicBullyMaxTH[6]&"#"&$g_ahPicBullyMaxTH[7]&"#"&$g_ahPicBullyMaxTH[8]&"#"& $g_ahPicBullyMaxTH[9]&"#"&$g_ahPicBullyMaxTH[10]&"#"&$g_ahPicBullyMaxTH[11] & "#" & $g_ahPicBullyMaxTH[12]
$g_aGroupLeague = $g_ahPicLeague[$eLeagueUnranked]&"#"&$g_ahPicLeague[$eLeagueBronze]&"#"&$g_ahPicLeague[$eLeagueSilver]&"#"&$g_ahPicLeague[$eLeagueGold] &"#"& $g_ahPicLeague[$eLeagueCrystal]&"#"&$g_ahPicLeague[$eLeagueMaster]&"#"&$g_ahPicLeague[$eLeagueChampion]&"#"&$g_ahPicLeague[$eLeagueTitan]&"#"& $g_ahPicLeague[$eLeagueLegend]
Dim $aTabControlsVillage = [$g_hGUI_VILLAGE_TAB, $g_hGUI_VILLAGE_TAB_ITEM1, $g_hGUI_VILLAGE_TAB_ITEM2, $g_hGUI_VILLAGE_TAB_ITEM3, $g_hGUI_VILLAGE_TAB_ITEM4, $g_hGUI_VILLAGE_TAB_ITEM5]
Dim $aTabControlsMisc = [$g_hGUI_MISC_TAB, $g_hGUI_MISC_TAB_ITEM1, $g_hGUI_MISC_TAB_ITEM2]
Dim $aTabControlsDonate = [$g_hGUI_DONATE_TAB, $g_hGUI_DONATE_TAB_ITEM1, $g_hGUI_DONATE_TAB_ITEM2, $g_hGUI_DONATE_TAB_ITEM3]
Dim $aTabControlsUpgrade = [$g_hGUI_UPGRADE_TAB, $g_hGUI_UPGRADE_TAB_ITEM1, $g_hGUI_UPGRADE_TAB_ITEM2, $g_hGUI_UPGRADE_TAB_ITEM3, $g_hGUI_UPGRADE_TAB_ITEM4, $g_hGUI_UPGRADE_TAB_ITEM5]
Dim $aTabControlsNotify = [$g_hGUI_NOTIFY_TAB, $g_hGUI_NOTIFY_TAB_ITEM2]
Dim $aTabControlsAttack = [$g_hGUI_ATTACK_TAB, $g_hGUI_ATTACK_TAB_ITEM1, $g_hGUI_ATTACK_TAB_ITEM2, $g_hGUI_ATTACK_TAB_ITEM3]
Dim $aTabControlsArmy = [$g_hGUI_TRAINARMY_TAB, $g_hGUI_TRAINARMY_TAB_ITEM1, $g_hGUI_TRAINARMY_TAB_ITEM2, $g_hGUI_TRAINARMY_TAB_ITEM3, $g_hGUI_TRAINARMY_TAB_ITEM4]
Dim $aTabControlsSearch = [$g_hGUI_SEARCH_TAB, $g_hGUI_SEARCH_TAB_ITEM1, $g_hGUI_SEARCH_TAB_ITEM2, $g_hGUI_SEARCH_TAB_ITEM3, $g_hGUI_SEARCH_TAB_ITEM4, $g_hGUI_SEARCH_TAB_ITEM5]
Dim $aTabControlsDeadbase = [$g_hGUI_DEADBASE_TAB, $g_hGUI_DEADBASE_TAB_ITEM1, $g_hGUI_DEADBASE_TAB_ITEM2, $g_hGUI_DEADBASE_TAB_ITEM3, $g_hGUI_DEADBASE_TAB_ITEM4]
Dim $aTabControlsActivebase = [$g_hGUI_ACTIVEBASE_TAB, $g_hGUI_ACTIVEBASE_TAB_ITEM1, $g_hGUI_ACTIVEBASE_TAB_ITEM2, $g_hGUI_ACTIVEBASE_TAB_ITEM3]
Dim $aTabControlsTHSnipe = [$g_hGUI_THSNIPE_TAB, $g_hGUI_THSNIPE_TAB_ITEM1, $g_hGUI_THSNIPE_TAB_ITEM2, $g_hGUI_THSNIPE_TAB_ITEM3]
Dim $aTabControlsAttackOptions = [$g_hGUI_ATTACKOPTION_TAB, $g_hGUI_ATTACKOPTION_TAB_ITEM1, $g_hGUI_ATTACKOPTION_TAB_ITEM2, $g_hGUI_ATTACKOPTION_TAB_ITEM3, $g_hGUI_ATTACKOPTION_TAB_ITEM4, $g_hGUI_ATTACKOPTION_TAB_ITEM5]
Dim $aTabControlsStrategies = [$g_hGUI_STRATEGIES_TAB, $g_hGUI_STRATEGIES_TAB_ITEM1, $g_hGUI_STRATEGIES_TAB_ITEM2]
Dim $aTabControlsMOD = [$g_hGUI_MOD_TAB, $g_hGUI_MOD_TAB_ITEM1, $g_hGUI_MOD_TAB_ITEM2, $g_hGUI_MOD_TAB_ITEM3, $g_hGUI_MOD_TAB_ITEM4]
Dim $aTabControlsBot = [$g_hGUI_BOT_TAB, $g_hGUI_BOT_TAB_ITEM1, $g_hGUI_BOT_TAB_ITEM2, $g_hGUI_BOT_TAB_ITEM3, $g_hGUI_BOT_TAB_ITEM4, $g_hGUI_BOT_TAB_ITEM5]
Dim $aTabControlsSwitchOpt = [$g_hGUI_SWITCH_OPTIONS_TAB, $g_hGUI_SWITCH_OPTIONS_TAB_ITEM1, $g_hGUI_SWITCH_OPTIONS_TAB_ITEM2, $g_hGUI_SWITCH_OPTIONS_TAB_ITEM3]
Dim $aTabControlsStats = [$g_hGUI_STATS_TAB, $g_hGUI_STATS_TAB_ITEM1, $g_hGUI_STATS_TAB_ITEM2, $g_hGUI_STATS_TAB_ITEM3, $g_hGUI_STATS_TAB_ITEM4, $g_hGUI_STATS_TAB_ITEM5]
$oAlwaysEnabledControls($g_hChkHideWhenMinimized) = 1
$oAlwaysEnabledControls($g_hChkDebugSetlog) = 1
$oAlwaysEnabledControls($g_hChkDebugAndroid) = 1
$oAlwaysEnabledControls($g_hChkDebugClick) = 1
$oAlwaysEnabledControls($g_hChkDebugFunc) = 1
$oAlwaysEnabledControls($g_hChkDebugDisableZoomout) = 1
$oAlwaysEnabledControls($g_hChkDebugDisableVillageCentering) = 1
$oAlwaysEnabledControls($g_hChkDebugDeadbaseImage) = 1
$oAlwaysEnabledControls($g_hChkDebugOCR) = 1
$oAlwaysEnabledControls($g_hChkDebugImageSave) = 1
$oAlwaysEnabledControls($g_hChkdebugBuildingPos) = 1
$oAlwaysEnabledControls($g_hChkdebugTrain) = 1
$oAlwaysEnabledControls($g_hChkDebugOCRDonate) = 1
$oAlwaysEnabledControls($g_hChkDebugSmartZap) = 1
$oAlwaysEnabledControls($g_hBtnTestTrain) = 1
$oAlwaysEnabledControls($g_hBtnTestDonateCC) = 1
$oAlwaysEnabledControls($g_hBtnTestRequestCC) = 1
$oAlwaysEnabledControls($g_hBtnTestSendText) = 1
$oAlwaysEnabledControls($g_hBtnTestAttackBar) = 1
$oAlwaysEnabledControls($g_hBtnTestClickDrag) = 1
$oAlwaysEnabledControls($g_hBtnTestImage) = 1
$oAlwaysEnabledControls($g_hBtnTestVillageSize) = 1
$oAlwaysEnabledControls($g_hBtnTestDeadBase) = 1
$oAlwaysEnabledControls($g_hBtnTestDeadBaseFolder) = 1
$oAlwaysEnabledControls($g_hBtnTestTHimgloc) = 1
$oAlwaysEnabledControls($g_hBtnTestQuickTrainsimgloc) = 1
$oAlwaysEnabledControls($g_hChkdebugAttackCSV) = 1
$oAlwaysEnabledControls($g_hChkMakeIMGCSV) = 1
$oAlwaysEnabledControls($g_hBtnTestAttackCSV) = 1
$oAlwaysEnabledControls($g_hBtnTestBuildingLocation) = 1
$oAlwaysEnabledControls($g_hBtnTestFindButton) = 1
$oAlwaysEnabledControls($g_hTxtTestFindButton) = 1
$oAlwaysEnabledControls($g_hBtnTestCleanYard) = 1
$oAlwaysEnabledControls($g_hLblSmartLightningUsed) = 1
$oAlwaysEnabledControls($g_hLblSmartZap) = 1
$oAlwaysEnabledControls($g_hLblSmartEarthQuakeUsed) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigSave) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigRead) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigApply) = 1
$oAlwaysEnabledControls($g_hBtnTestWeakBase) = 1
$oAlwaysEnabledControls($g_hBtnConsoleWindow) = 1
$oAlwaysEnabledControls($g_hBtnAndroidAdbShell) = 1
$oAlwaysEnabledControls($g_hBtnAndroidHome) = 1
$oAlwaysEnabledControls($g_hBtnAndroidBack) = 1
$oAlwaysEnabledControls($g_hBtnPullSharedPrefs) = 1
$oAlwaysEnabledControls($g_hBtnMakeScreenshot) = 1
$oAlwaysEnabledControls($g_hDivider) = 1
$oAlwaysEnabledControls($g_hTabMain) = 1
$oAlwaysEnabledControls($g_hTabLog) = 1
$oAlwaysEnabledControls($g_hTabVillage) = 1
$oAlwaysEnabledControls($g_hTabAttack) = 1
$oAlwaysEnabledControls($g_hTabMOD) = 1
$oAlwaysEnabledControls($g_hTabBot) = 1
$oAlwaysEnabledControls($g_hTabAbout) = 1
For $i in $aTabControlsVillage
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsMisc
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsDonate
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsUpgrade
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsNotify
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsAttack
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsArmy
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsSearch
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsDeadbase
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsActivebase
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsTHSnipe
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsAttackOptions
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsStrategies
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsMOD
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsBot
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsSwitchOpt
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsStats
$oAlwaysEnabledControls($i) = 1
Next
EndFunc
Global $g_aFrmBotBottomCtrlState, $g_hFrmBotEmbeddedShield = 0, $g_hFrmBotEmbeddedMouse = 0, $g_hFrmBotEmbeddedGraphics = 0
Func Initiate()
WinGetAndroidHandle()
If $g_hAndroidWindow <> 0 And($g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable()) Then
SetLogCentered(" " & $g_sBotTitle & " Powered by MyBot.run ", "~", $COLOR_DEBUG)
Local $Compiled = @ScriptName &(@Compiled ? " Executable" : " Script")
SetLog($Compiled & " running on " & @OSVersion & " " & @OSServicePack & " " & @OSArch)
If Not $g_bSearchMode Then
SetLogCentered(" Bot Start ", Default, $COLOR_SUCCESS)
Else
SetLogCentered(" Search Mode Start ", Default, $COLOR_SUCCESS)
EndIf
SetLogCentered("  Current Profile: " & $g_sProfileCurrentName & " ", "-", $COLOR_INFO)
If $g_bDebugSetlog Or $g_bDebugOcr Or $g_bDebugRedArea Or $g_bDebugImageSave Or $g_bDebugBuildingPos Or $g_bDebugOCRdonate Or $g_bDebugAttackCSV Or $g_bDebugAndroid Then
SetLogCentered(" Warning Debug Mode Enabled! ", "-", $COLOR_ERROR)
SetLog("      SetLog : " & $g_bDebugSetlog, $COLOR_ERROR, "Lucida Console", 8)
SetLog("     Android : " & $g_bDebugAndroid, $COLOR_ERROR, "Lucida Console", 8)
SetLog("         OCR : " & $g_bDebugOcr, $COLOR_ERROR, "Lucida Console", 8)
SetLog("     RedArea : " & $g_bDebugRedArea, $COLOR_ERROR, "Lucida Console", 8)
SetLog("   ImageSave : " & $g_bDebugImageSave, $COLOR_ERROR, "Lucida Console", 8)
SetLog(" BuildingPos : " & $g_bDebugBuildingPos, $COLOR_ERROR, "Lucida Console", 8)
SetLog("   OCRDonate : " & $g_bDebugOCRdonate, $COLOR_ERROR, "Lucida Console", 8)
SetLog("   AttackCSV : " & $g_bDebugAttackCSV, $COLOR_ERROR, "Lucida Console", 8)
SetLogCentered(" Warning Debug Mode Enabled! ", "-", $COLOR_ERROR)
EndIf
$g_bFirstStart = True
$g_bInitiateSwitchAcc = True
$g_sLabUpgradeTime = ""
If Not $g_bSearchMode Then
$g_hTimerSinceStarted = __TimerInit()
EndIf
AndroidBotStartEvent()
If Not $g_bRunState Then Return
If Not $g_bSearchMode Then
If $g_bRestarted Then
$g_bRestarted = False
IniWrite($g_sProfileConfigPath, "general", "Restarted", 0)
PushMsg("Restarted")
EndIf
EndIf
If Not $g_bRunState Then Return
AndroidShield("Initiate", True)
checkMainScreen()
If Not $g_bRunState Then Return
ZoomOut()
If Not $g_bRunState Then Return
If Not $g_bSearchMode Then
BotDetectFirstTime()
If Not $g_bRunState Then Return
If $g_bCheckGameLanguage Then TestLanguage()
If Not $g_bRunState Then Return
runBot()
EndIf
Else
SetLog("Not in Game!", $COLOR_ERROR)
btnStop()
EndIf
EndFunc
Func InitiateLayout()
Local $AdjustScreenIfNecessarry = True
WinGetAndroidHandle()
Local $BSsize = getAndroidPos()
If IsArray($BSsize) Then
Local $BSx = $BSsize[2]
Local $BSy = $BSsize[3]
SetDebugLog("InitiateLayout: " & $g_sAndroidTitle & " Android-ClientSize: " & $BSx & " x " & $BSy, $COLOR_INFO)
If Not CheckScreenAndroid($BSx, $BSy) Then
If $AdjustScreenIfNecessarry = True Then
Local $MsgRet = $IDOK
If $MsgRet = $IDOK Then
Return RebootAndroidSetScreen()
EndIf
Else
SetLog("Cannot use " & $g_sAndroidEmulator & ".", $COLOR_ERROR)
SetLog("Please set its screen size manually to " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight, $COLOR_ERROR)
btnStop()
Return False
EndIf
EndIf
DisposeWindows()
Return True
EndIf
Return False
EndFunc
Func chkBackground()
If IsDeclared("g_hChkBackgroundMode") Then
UpdateChkBackground()
AndroidToFront(Default, "chkBackground")
EndIf
EndFunc
Func UpdateChkBackground()
If GUICtrlRead($g_hChkBackgroundMode) = $GUI_CHECKED Then
$g_bChkBackgroundMode = True
updateBtnHideState($GUI_ENABLE)
Else
$g_bChkBackgroundMode = False
updateBtnHideState($GUI_DISABLE)
EndIf
If CheckDpiAwareness() Then
EndIf
EndFunc
Func IsStopped()
If $g_bRunState Then Return False
If $g_bRestart Then Return True
Return False
EndFunc
Func btnStart()
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
Local $bRunNow = $g_iBotAction <> $eBotNoAction
If $bRunNow Then
BotStart()
Else
$g_iBotAction = $eBotStart
EndIf
$g_iActualTrainSkip = 0
EndFunc
Func btnStop()
If $g_bRunState Then
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
$g_bRunState = False
EndIf
$g_iBotAction = $eBotStop
EndFunc
Func btnSearchMode()
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
Local $bRunNow = $g_iBotAction <> $eBotNoAction
If $bRunNow Then
BotSearchMode()
Else
$g_iBotAction = $eBotSearchMode
EndIf
EndFunc
Func btnPause($bRunNow = True)
TogglePause()
GUICtrlSetState($g_hBtnDisableGUI, $GUI_HIDE)
GUICtrlSetState($g_hBtnEnableGUI, $GUI_SHOW)
EndFunc
Func btnResume()
TogglePause()
GUICtrlSetState($g_hBtnDisableGUI, $GUI_HIDE)
GUICtrlSetState($g_hBtnEnableGUI, $GUI_HIDE)
EndFunc
Func btnEnableGUI()
GUICtrlSetState($g_hBtnEnableGUI, $GUI_HIDE)
GUICtrlSetState($g_hBtnDisableGUI, $GUI_SHOW)
GUICtrlSetState($g_hBtnResume, $GUI_DISABLE)
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls as you wished", $COLOR_SUCCESS)
EndFunc
Func btnDisableGUI()
GUICtrlSetState($g_hBtnDisableGUI, $GUI_HIDE)
GUICtrlSetState($g_hBtnEnableGUI, $GUI_SHOW)
GUICtrlSetState($g_hBtnResume, $GUI_ENABLE)
SetLog("Save config and disable bot controls manually", $COLOR_SUCCESS)
AndroidShieldForceDown(False)
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndFunc
Func btnAttackNowDB()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $DB
EndIf
EndFunc
Func btnAttackNowLB()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $LB
EndIf
EndFunc
Func btnAttackNowTS()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $TS
EndIf
EndFunc
Func reHide()
WinGetAndroidHandle()
If $g_bIsHidden And $g_hAndroidWindow <> 0 And Not $g_bAndroidEmbedded Then
SetDebugLog("Hide " & $g_sAndroidEmulator & " Window after restart")
Local $Result = HideAndroidWindow(True, Default, Default, "reHide")
updateBtnHideState()
Return $Result
EndIf
Return 0
EndFunc
Func updateBtnHideState($newState = $GUI_ENABLE)
If $g_hBtnHide = 0 Then Return
Local $hideState = GUICtrlGetState($g_hBtnHide)
Local $newHideState =($g_bAndroidEmbedded = True ? $GUI_DISABLE : $newState)
If $hideState <> $newHideState Then GUICtrlSetState($g_hBtnHide, $newHideState)
Local $sText
If $g_bIsHidden Then
$sText = GetTranslatedFileIni("MBR GUI Control Bottom", "Func_btnHide_False", "Show")
Else
$sText = GetTranslatedFileIni("MBR GUI Control Bottom", "Func_btnHide_True", "Hide")
EndIf
If GUICtrlRead($g_hBtnHide) <> $sText Then
GUICtrlSetData($g_hBtnHide, $sText)
EndIf
EndFunc
Func btnHide()
$g_bIsHidden = Not $g_bIsHidden
HideAndroidWindow($g_bIsHidden, Default, Default, "btnHide")
updateBtnHideState()
EndFunc
Func updateBtnEmbed()
If $g_hBtnEmbed = 0 Then Return False
UpdateFrmBotStyle()
Local $state = GUICtrlGetState($g_hBtnEmbed)
If $g_hAndroidWindow = 0 Or $g_bAndroidBackgroundLaunched = True Or $g_bAndroidEmbed = False Or $g_iGuiMode <> 1 Then
If $state <> $GUI_DISABLE Then GUICtrlSetState($g_hBtnEmbed, $GUI_DISABLE)
updateBtnHideState()
Return False
EndIf
Local $text = GUICtrlRead($g_hBtnEmbed)
Local $newText
If $g_bAndroidEmbedded Then
$newText = GetTranslatedFileIni("MBR GUI Control Bottom", "Func_AndroidEmbedded_False", "Undock")
Else
$newText = GetTranslatedFileIni("MBR GUI Control Bottom", "Func_AndroidEmbedded_True", "Dock")
EndIf
If $text <> $newText Then GUICtrlSetData($g_hBtnEmbed, $newText)
If $state <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnEmbed, $GUI_ENABLE)
updateBtnHideState()
Return True
EndFunc
Func btnEmbed()
ResumeAndroid()
WinGetAndroidHandle()
WinGetPos($g_hAndroidWindow)
If @error <> 0 Then Return SetError(0, 0, 0)
AndroidEmbed(Not $g_bAndroidEmbedded)
EndFunc
Func btnMakeScreenshot()
If $g_bRunState Then
$g_bMakeScreenshotNow = True
Else
If $g_bScreenshotPNGFormat = False Then
MakeScreenshot($g_sProfileTempPath, "jpg")
Else
MakeScreenshot($g_sProfileTempPath, "png")
EndIf
EndIf
EndFunc
Func GetFont()
Local $i, $sText = "", $DefaultFont
$DefaultFont = __EMB_GetDefaultFont()
For $i = 0 To UBound($DefaultFont) - 1
$sText &= " $DefaultFont[" & $i & "]= " & $DefaultFont[$i] & ", "
Next
SetLog($sText, $COLOR_DEBUG)
EndFunc
Func btnVillageStat($source = "")
If $g_iFirstRun = 0 And $g_bRunState And Not $g_bBotPaused Then SetTime(True)
If GUICtrlGetState($g_hLblResultGoldNow) = $GUI_ENABLE + $GUI_SHOW Then
GUICtrlSetState($g_hLblResultGoldNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultDENow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultGemNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultGoldHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultDEHourNow, $GUI_ENABLE + $GUI_SHOW)
If $g_iFirstRun = 0 Or $source = "UpdateStats" Then
GUICtrlSetState($g_hLblResultRuntimeNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultAttackedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultSkippedHourNow, $GUI_ENABLE + $GUI_SHOW)
EndIf
GUICtrlSetState($g_hPicResultTrophyNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultBuilderNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultGemNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultRuntimeNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultAttackedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultSkippedHourNow, $GUI_ENABLE + $GUI_SHOW)
Else
GUICtrlSetState($g_hLblResultGoldNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultDENow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultGemNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultGoldHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultElixirHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultDEHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultRuntimeNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultAttackedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultSkippedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultTrophyNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultBuilderNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultGemNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultRuntimeNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultAttackedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultSkippedHourNow, $GUI_ENABLE + $GUI_HIDE)
EndIf
EndFunc
Func EnableGuiControls($bOptimizedRedraw = True)
Return ToggleGuiControls(True, $bOptimizedRedraw)
EndFunc
Func DisableGuiControls($bOptimizedRedraw = True)
Return ToggleGuiControls(False, $bOptimizedRedraw)
EndFunc
Func ToggleGuiControls($bEnabled, $bOptimizedRedraw = True)
$g_bGuiControlsEnabled = $bEnabled
If $g_iGuiMode <> 1 Then Return
If $bOptimizedRedraw Then Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "ToggleGuiControls")
If Not $bEnabled Then
SetDebugLog("Disable GUI Controls")
Else
SetDebugLog("Enable GUI Controls")
EndIf
$g_bGUIControlDisabled = True
For $i = $g_hFirstControlToHide To $g_hLastControlToHide
If IsAlwaysEnabledControl($i) Then ContinueLoop
If Not $bEnabled Then
$g_aiControlPrevState[$i] = BitAND(GUICtrlGetState($i), $GUI_ENABLE)
If $g_aiControlPrevState[$i] Then GUICtrlSetState($i, $GUI_DISABLE)
Else
If $g_aiControlPrevState[$i] Then GUICtrlSetState($i, $g_aiControlPrevState[$i])
EndIf
Next
If Not $bEnabled Then
ControlDisable("", "", $g_hCmbGUILanguage)
Else
ControlEnable("", "", $g_hCmbGUILanguage)
EndIf
$g_bGUIControlDisabled = False
If $bOptimizedRedraw Then SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "ToggleGuiControls")
EndFunc
Func btnAtkLogClear()
_GUICtrlRichEdit_SetText($g_hTxtAtkLog, "")
AtkLogHead()
EndFunc
Func btnAtkLogCopyClipboard()
Local $text = _GUICtrlRichEdit_GetText($g_hTxtAtkLog)
$text = StringReplace($text, @CR, @CRLF)
ClipPut($text)
EndFunc
Func cmbLog()
Local $x = 0, $y = 0, $w = $_GUI_MAIN_WIDTH - 20, $h = $_GUI_MAIN_HEIGHT - 490 + Int($g_iFrmBotAddH / 2)
If($g_iLogDividerY > $h + Int($h / 2) + $y And $g_iLogDividerY < $h * 2 + $g_iLogDividerHeight + $y) Or $g_iLogDividerY > $h * 2 + $g_iLogDividerHeight + $y Then $g_iLogDividerY = $h + Int($h / 2) + $y
If($g_iLogDividerY < Int($h / 2) + $y And $g_iLogDividerY > 0) Or $g_iLogDividerY < 0 Then $g_iLogDividerY = Int($h / 2)
_SendMessage($g_hTxtLog, $WM_SETREDRAW, False, 0)
_WINAPI_EnableWindow($g_hTxtLog, False)
_SendMessage($g_hTxtAtkLog, $WM_SETREDRAW, False, 0)
_WINAPI_EnableWindow($g_hTxtAtkLog, False)
Switch _GUICtrlComboBox_GetCurSel($g_hCmbLogDividerOption)
Case 0
ControlShow($g_hGUI_LOG, "", $g_hDivider)
ControlMove($g_hGUI_LOG, "", $g_hDivider, $x, $g_iLogDividerY - $y, $w, $g_iLogDividerHeight)
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $g_iLogDividerY - $y)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $g_iLogDividerY + $g_iLogDividerHeight, $w,($h * 2) -($g_iLogDividerY - $y))
Case 1
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h)
$y += $h
ControlHide($g_hGUI_LOG, "", $g_hDivider)
$y += $g_iLogDividerHeight
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h)
Case 2
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h +($h / 2))
$y += $h +($h / 2) + $g_iLogDividerHeight
ControlHide($g_hGUI_LOG, "", $g_hDivider)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h -($h / 2))
Case 3
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h -($h / 2))
$y +=($h / 2) + $g_iLogDividerHeight
ControlHide($g_hGUI_LOG, "", $g_hDivider)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h +($h / 2))
Case 4
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h * 2 + $g_iLogDividerHeight)
ControlHide($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y + $h * 2 + $g_iLogDividerHeight, $w, 0)
ControlHide($g_hGUI_LOG, "", $g_hDivider)
Case 5
ControlHide($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, 0)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h * 2 + $g_iLogDividerHeight)
ControlHide($g_hGUI_LOG, "", $g_hDivider)
EndSwitch
_SendMessage($g_hTxtLog, $WM_SETREDRAW, True, 0)
_WINAPI_EnableWindow($g_hTxtLog, True)
_SendMessage($g_hTxtAtkLog, $WM_SETREDRAW, True, 0)
_WINAPI_EnableWindow($g_hTxtAtkLog, True)
CheckRedrawControls(True, "cmbLog")
EndFunc
Func MoveDivider()
Local $PPos = ControlGetPos($g_hFrmBot, "", $g_hGUI_LOG)
Local $TPos = ControlGetPos($g_hGUI_LOG, "", $g_hTxtLog)
Local $BPos = ControlGetPos($g_hGUI_LOG, "", $g_hTxtAtkLog)
Local $logAndDividerX = $TPos[0] - $PPos[0]
Local $logAndDividerWidth = $TPos[2]
Local $totalLogsHeight = $TPos[3] + $BPos[3]
Local $minVisibleHeight = Ceiling($totalLogsHeight / 4)
Local $snapToMinMax = Ceiling($minVisibleHeight / 3)
Local $halfDividerTopHeight = Ceiling($g_iLogDividerHeight / 2)
Local $halfDividerBottomHeight = Floor($g_iLogDividerHeight / 2)
Local $startLogsY = $TPos[1] - $_GUI_CHILD_TOP
Local $endLogsY = $BPos[1] - $_GUI_CHILD_TOP + $BPos[3]
Do
Local $pos = GUIGetCursorInfo($g_hGUI_LOG)
Local $clickY = $pos[1]
If $clickY - $halfDividerTopHeight <= $startLogsY + $snapToMinMax Then
$clickY = $startLogsY + $halfDividerTopHeight
ElseIf $clickY + $halfDividerBottomHeight >= $endLogsY - $snapToMinMax Then
$clickY = $endLogsY - $halfDividerBottomHeight
ElseIf $clickY - $halfDividerTopHeight > $startLogsY + $snapToMinMax And $clickY - $halfDividerTopHeight <= $startLogsY + $minVisibleHeight Then
$clickY = $startLogsY + $minVisibleHeight + $halfDividerTopHeight
ElseIf $clickY + $halfDividerBottomHeight < $endLogsY - $snapToMinMax And $clickY + $halfDividerBottomHeight >= $endLogsY - $minVisibleHeight Then
$clickY = $endLogsY - $minVisibleHeight - $halfDividerBottomHeight
EndIf
$g_iLogDividerY = $clickY - $halfDividerTopHeight
ControlMove($g_hGUI_LOG, "", $g_hDivider, $logAndDividerX, $g_iLogDividerY, $logAndDividerWidth, $g_iLogDividerHeight)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $logAndDividerX, $startLogsY, $logAndDividerWidth, $clickY - $startLogsY - $halfDividerTopHeight)
If $endLogsY -($clickY + $halfDividerBottomHeight) < 0 Then
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $logAndDividerX, $endLogsY, $logAndDividerWidth, 0)
Else
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $logAndDividerX, $clickY + $halfDividerBottomHeight, $logAndDividerWidth, $endLogsY - $clickY - $halfDividerBottomHeight)
EndIf
_WinAPI_UpdateWindow(WinGetHandle($g_hGUI_LOG))
Until $pos[2] = 0
_GUICtrlRichEdit_SetSel($g_hTxtLog, - 1, -1)
_GUICtrlRichEdit_SetSel($g_hTxtAtkLog, - 1, -1)
SetDebugLog("MoveDivider exit", Default, True)
EndFunc
Func chkUseQTrain()
If GUICtrlRead($g_hChkUseQuickTrain) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_ahChkArmy[0] & "#" & $g_ahChkArmy[1] & "#" & $g_ahChkArmy[2])
chkQuickTrainCombo()
GUICtrlSetState($g_hChkPreciseArmy, $GUI_UNCHECKED + $GUI_DISABLE)
_GUI_Value_STATE("DISABLE", $grpTrainTroops)
_GUI_Value_STATE("DISABLE", $grpCookSpell)
GUICtrlSetData($g_hLblTotalTimeCamp, " 0s")
GUICtrlSetData($g_hLblTotalTimeSpell, " 0s")
GUICtrlSetData($g_hLblElixirCostCamp, "0")
GUICtrlSetData($g_hLblDarkCostCamp, "0")
GUICtrlSetData($g_hLblElixirCostSpell, "0")
GUICtrlSetData($g_hLblDarkCostSpell, "0")
Else
_GUI_Value_STATE("DISABLE", $g_ahChkArmy[0] & "#" & $g_ahChkArmy[1] & "#" & $g_ahChkArmy[2])
chkQuickTrainCombo()
If GUICtrlRead($g_hChkDoubleTrain) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkPreciseArmy, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkPreciseArmy, $GUI_UNCHECKED + $GUI_DISABLE)
EndIf
_GUI_Value_STATE("ENABLE", $grpTrainTroops)
_GUI_Value_STATE("ENABLE", $grpCookSpell)
lblTotalCountTroop1()
TotalSpellCountClick()
EndIf
lblTotalCountSiege()
EndFunc
Func chkQuickTrainCombo()
If GUICtrlRead($g_ahChkArmy[0]) = $GUI_UNCHECKED And GUICtrlRead($g_ahChkArmy[1]) = $GUI_UNCHECKED And GUICtrlRead($g_ahChkArmy[2]) = $GUI_UNCHECKED Then
GUICtrlSetState($g_ahChkArmy[0], $GUI_CHECKED)
ToolTip("QuickTrainCombo: " & @CRLF & "At least 1 Army Check is required! Default Army 1.")
Sleep(2000)
ToolTip('')
EndIf
If GUICtrlRead($g_ahChkArmy[2]) = $GUI_CHECKED And GUICtrlRead($g_hChkUseQuickTrain) = $GUI_CHECKED Then
_GUI_Value_STATE("HIDE", $g_hLblRemoveArmy & "#" & $g_hBtnRemoveArmy)
_GUI_Value_STATE("SHOW", $g_hChkMultiClick)
Else
_GUI_Value_STATE("HIDE", $g_hChkMultiClick)
_GUI_Value_STATE("SHOW", $g_hLblRemoveArmy & "#" & $g_hBtnRemoveArmy)
EndIf
EndFunc
Func SetComboTroopComp()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "SetComboTroopComp")
Local $ArmyCampTemp = 0
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
$ArmyCampTemp = Floor(GUICtrlRead($g_hTxtTotalCampForced) * GUICtrlRead($g_hTxtFullTroop) / 100)
Else
$ArmyCampTemp = Floor($g_iTotalCampSpace * GUICtrlRead($g_hTxtFullTroop) / 100)
EndIf
lblTotalCountTroop1()
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "SetComboTroopComp")
EndFunc
Func chkTotalCampForced()
GUICtrlSetState($g_hTxtTotalCampForced, GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func lblTotalCountTroop1()
Local $TotalTroopsToTrain = 0
Local $ArmyCampTemp = 0
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
$ArmyCampTemp = Floor(GUICtrlRead($g_hTxtTotalCampForced) * GUICtrlRead($g_hTxtFullTroop) / 100)
Else
$ArmyCampTemp = Floor($g_iTotalCampSpace * GUICtrlRead($g_hTxtFullTroop) / 100)
EndIf
For $i = 0 To $eTroopCount - 1
Local $iCount = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
If $iCount > 0 Then
$TotalTroopsToTrain += $iCount * $g_aiTroopSpace[$i]
Else
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$i], 0)
EndIf
Next
GUICtrlSetData($g_hLblCountTotal, String($TotalTroopsToTrain))
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED And GUICtrlRead($g_hLblCountTotal) = GUICtrlRead($g_hTxtTotalCampForced) Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_MONEYGREEN)
ElseIf GUICtrlRead($g_hLblCountTotal) = $ArmyCampTemp Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_MONEYGREEN)
ElseIf GUICtrlRead($g_hLblCountTotal) > $ArmyCampTemp / 2 And GUICtrlRead($g_hLblCountTotal) < $ArmyCampTemp Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_ORANGE)
Else
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_RED)
EndIf
Local $fPctOfForced = Floor((GUICtrlRead($g_hLblCountTotal) / GUICtrlRead($g_hTxtTotalCampForced)) * 100)
Local $fPctOfCalculated = Floor((GUICtrlRead($g_hLblCountTotal) / $ArmyCampTemp) * 100)
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
GUICtrlSetData($g_hCalTotalTroops, $fPctOfForced < 1 ?(GUICtrlRead($g_hLblCountTotal) > 0 ? 1 : 0) : $fPctOfForced)
Else
GUICtrlSetData($g_hCalTotalTroops, $fPctOfCalculated < 1 ?(GUICtrlRead($g_hLblCountTotal) > 0 ? 1 : 0) : $fPctOfCalculated)
EndIf
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED And GUICtrlRead($g_hLblCountTotal) > GUICtrlRead($g_hTxtTotalCampForced) Then
GUICtrlSetState($g_hLblTotalProgress, $GUI_SHOW)
ElseIf GUICtrlRead($g_hLblCountTotal) > $ArmyCampTemp Then
GUICtrlSetState($g_hLblTotalProgress, $GUI_SHOW)
Else
GUICtrlSetState($g_hLblTotalProgress, $GUI_HIDE)
EndIf
lblTotalCountTroop2()
EndFunc
Func lblTotalCountTroop2()
Local $TotalTotalTimeTroop = 0
Local $NbrOfBarrack = 4
Local $NbrOfDarkBarrack = 2
For $i = $eTroopBarbarian To $eTroopElectroDragon
Local $NbrOfTroop = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
Local $LevOfTroop = $g_aiTrainArmyTroopLevel[$i]
If $NbrOfTroop > 0 And $LevOfTroop > 0 Then
If IsInt($NbrOfTroop / $NbrOfBarrack) = 1 Then
$TotalTotalTimeTroop +=($NbrOfTroop / $NbrOfBarrack) * $g_aiTroopTrainTime[$i]
Else
$TotalTotalTimeTroop +=(Ceiling($NbrOfTroop / $NbrOfBarrack)) * $g_aiTroopTrainTime[$i]
$TotalTotalTimeTroop +=((Ceiling($NbrOfTroop / $NbrOfBarrack) - 1) -(Floor($NbrOfTroop / $NbrOfBarrack))) * $g_aiTroopTrainTime[$i]
EndIf
EndIf
Next
For $i = $eTroopMinion To $eTroopIceGolem
Local $NbrOfTroop = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
Local $LevOfTroop = $g_aiTrainArmyTroopLevel[$i]
If $NbrOfTroop > 0 And $LevOfTroop > 0 Then
If IsInt($NbrOfTroop / $NbrOfDarkBarrack) = 1 Then
$TotalTotalTimeTroop +=($NbrOfTroop / $NbrOfDarkBarrack) * $g_aiTroopTrainTime[$i]
Else
$TotalTotalTimeTroop +=(Ceiling($NbrOfTroop / $NbrOfDarkBarrack)) * $g_aiTroopTrainTime[$i]
$TotalTotalTimeTroop +=((Ceiling($NbrOfTroop / $NbrOfDarkBarrack) - 1) -(Floor($NbrOfTroop / $NbrOfDarkBarrack))) * $g_aiTroopTrainTime[$i]
EndIf
EndIf
Next
$TotalTotalTimeTroop = CalculTimeTo($TotalTotalTimeTroop)
GUICtrlSetData($g_hLblTotalTimeCamp, $TotalTotalTimeTroop)
CalCostCamp()
EndFunc
Func lblTotalCountSpell2()
Local $iTotalTotalTimeSpell = 0
$g_iTotalTrainSpaceSpell = 0
For $i = 0 To $eSpellCount - 1
$g_iTotalTrainSpaceSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
$iTotalTotalTimeSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellTrainTime[$i]
Next
For $i = 0 To $eSpellCount - 1
GUICtrlSetBkColor($g_ahTxtTrainArmySpellCount[$i], $g_iTotalTrainSpaceSpell <= GUICtrlRead($g_hTxtTotalCountSpell) ? $COLOR_WHITE : $COLOR_RED)
Next
GUICtrlSetData($g_hLblTotalTimeSpell, CalculTimeTo($iTotalTotalTimeSpell))
CalCostSpell()
EndFunc
Func lblTotalCountSiege()
Local $iTotalTotalTimeSiege = 0
$g_iTotalTrainSpaceSiege = 0
For $i = 0 To $eSiegeMachineCount - 1
$g_iTotalTrainSpaceSiege += $g_aiArmyCompSiegeMachine[$i] * $g_aiSiegeMachineSpace[$i]
$iTotalTotalTimeSiege += $g_aiArmyCompSiegeMachine[$i] * $g_aiSiegeMachineTrainTimePerLevel[$i][$g_aiTrainArmySiegeMachineLevel[$i]]
Next
GUICtrlSetData($g_hLblTotalTimeSiege, CalculTimeTo($iTotalTotalTimeSiege))
GUICtrlSetData($g_hLblCountTotalSiege, $g_iTotalTrainSpaceSiege)
GUICtrlSetBkColor($g_hLblCountTotalSiege, $g_iTotalTrainSpaceSiege <= 3 ? $COLOR_MONEYGREEN : $COLOR_RED)
CalCostSiege()
If $g_iTownHallLevel > 0 And $g_iTownHallLevel < 12 Then
$g_iTotalTrainSpaceSiege = 0
GUICtrlSetBkColor($g_hLblCountTotalSiege,$COLOR_RED)
_GUICtrlSetTip($g_hLblCountTotalSiege, GetTranslatedFileIni("MBR GUI Design Child Attack - Troops", "LblCountTotal_Info_03", "Workshop Level 1 Required!"))
GUICtrlSetData($g_hLblGoldCostSiege, "0")
GUICtrlSetData($g_hLblCountTotalSiege, $g_iTotalTrainSpaceSiege)
GUICtrlSetData($g_hLblTotalTimeSiege, " 0s")
EndIf
EndFunc
Func TotalSpellCountClick()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "TotalSpellCountClick")
_GUI_Value_STATE("HIDE", $groupListSpells)
$g_iTownHallLevel = Int($g_iTownHallLevel)
If $g_iTownHallLevel > 4 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellLightning] > 0 ? $g_aGroupLightning : $groupIcnLightning)
Else
For $i = 0 To $eSpellCount - 1
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
GUICtrlSetData($g_hTxtTotalCountSpell, 0)
EndIf
If $g_iTownHallLevel > 5 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellHeal] > 0 ? $groupHeal : $groupIcnHeal)
Else
For $i = $eSpellRage To $eSpellBat
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
EndIf
If $g_iTownHallLevel > 6 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellRage] > 0 ? $groupRage : $groupIcnRage)
Else
For $i = $eSpellJump To $eSpellBat
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
EndIf
If $g_iTownHallLevel > 7 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellPoison] > 0 ? $g_aGroupPoison : $groupIcnPoison)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellEarthquake] > 0 ? $groupEarthquake : $groupIcnEarthquake)
Else
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellJump], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellFreeze], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellClone], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellHaste], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellSkeleton], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellBat], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellJump], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellFreeze], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellClone], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellHaste], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellSkeleton], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellBat], 0)
EndIf
If $g_iTownHallLevel > 8 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellJump] > 0 ? $groupJumpSpell : $groupIcnJumpSpell)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellFreeze] > 0 ? $groupFreeze : $groupIcnFreeze)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellHaste] > 0 ? $groupHaste : $groupIcnHaste)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellSkeleton] > 0 ? $groupSkeleton : $groupIcnSkeleton)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellBat] > 0 ? $groupSkeleton : $groupIcnBat)
Else
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellClone], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellClone], 0)
EndIf
If $g_iTownHallLevel > 9 Or $g_iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellClone] > 0 ? $groupClone : $groupIcnClone)
EndIf
lblTotalCountSpell2()
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "TotalSpellCountClick")
EndFunc
Func chkBoostBarracksHoursE1()
If GUICtrlRead($g_hChkBoostBarracksHoursE1) = $GUI_CHECKED And GUICtrlRead($g_hChkBoostBarracksHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkBoostBarracksHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkBoostBarracksHoursE2()
If GUICtrlRead($g_hChkBoostBarracksHoursE2) = $GUI_CHECKED And GUICtrlRead($g_hChkBoostBarracksHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkBoostBarracksHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkCloseWaitEnable()
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then
$g_bCloseWhileTrainingEnable = True
_GUI_Value_STATE("ENABLE", $groupCloseWhileTraining)
_GUI_Value_STATE("ENABLE", $g_hLblCloseWaitingTroops & "#" & $g_hCmbMinimumTimeClose & "#" & $g_hLblSymbolWaiting & "#" & $g_hLblWaitingInMinutes & "#" & $g_hChkTrainLogoutMaxTime)
chkTrainLogoutMaxTime()
Else
$g_bCloseWhileTrainingEnable = False
_GUI_Value_STATE("DISABLE", $groupCloseWhileTraining)
_GUI_Value_STATE("DISABLE", $g_hLblCloseWaitingTroops & "#" & $g_hCmbMinimumTimeClose & "#" & $g_hLblSymbolWaiting & "#" & $g_hLblWaitingInMinutes & "#" & $g_hChkTrainLogoutMaxTime & "#" & $g_hTxtTrainLogoutMaxTime & "#" & $g_hLblTrainLogoutMaxTime)
_GUI_Value_STATE("UNCHECKED", $g_hChkTrainLogoutMaxTime)
EndIf
If GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCloseEmulator, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkSuspendComputer, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCloseEmulator, $GUI_ENABLE)
GUICtrlSetState($g_hChkSuspendComputer, $GUI_ENABLE)
EndIf
EndIf
EndFunc
Func chkTrainLogoutMaxTime()
If GUICtrlRead($g_hChkTrainLogoutMaxTime) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_hTxtTrainLogoutMaxTime & "#" & $g_hLblTrainLogoutMaxTime)
Else
_GUI_Value_STATE("DISABLE", $g_hTxtTrainLogoutMaxTime & "#" & $g_hLblTrainLogoutMaxTime)
EndIf
EndFunc
Func chkCloseWaitTrain()
$g_bCloseWithoutShield =(GUICtrlRead($g_hChkCloseWithoutShield) = $GUI_CHECKED)
EndFunc
Func btnCloseWaitStop()
$g_bCloseEmulator =(GUICtrlRead($g_hChkCloseEmulator) = $GUI_CHECKED)
EndFunc
Func btnCloseWaitSuspendComputer()
$g_bSuspendComputer =(GUICtrlRead($g_hChkSuspendComputer) = $GUI_CHECKED)
EndFunc
Func btnCloseWaitStopRandom()
If GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED Then
$g_bCloseRandom = True
$g_bCloseEmulator = False
$g_bSuspendComputer = False
GUICtrlSetState($g_hChkCloseEmulator, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkSuspendComputer, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
$g_bCloseRandom = False
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCloseEmulator, $GUI_ENABLE)
GUICtrlSetState($g_hChkSuspendComputer, $GUI_ENABLE)
EndIf
EndIf
EndFunc
Func btnCloseWaitRandom()
If GUICtrlRead($g_hRdoCloseWaitExact) = $GUI_CHECKED Then
$g_bCloseExactTime = True
$g_bCloseRandomTime = False
GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_DISABLE)
ElseIf GUICtrlRead($g_hRdoCloseWaitRandom) = $GUI_CHECKED Then
$g_bCloseExactTime = False
$g_bCloseRandomTime = True
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_ENABLE)
Else
$g_bCloseExactTime = False
$g_bCloseRandomTime = False
GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_DISABLE)
EndIf
EndFunc
Func sldTrainITDelay()
$g_iTrainClickDelay = GUICtrlRead($g_hSldTrainITDelay)
GUICtrlSetData($g_hLblTrainITDelayTime, $g_iTrainClickDelay & " ms")
EndFunc
Func chkTroopOrder2()
chkTroopOrder()
EndFunc
Func chkTroopOrder($bSetLog = True)
If GUICtrlRead($g_hChkCustomTrainOrderEnable) = $GUI_CHECKED Then
$g_bCustomTrainOrderEnable = True
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_ENABLE)
GUICtrlSetState($g_hBtnRemoveTroops, $GUI_ENABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_ENABLE)
Next
If IsUseCustomTroopOrder() = True Then _GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
$g_bCustomTrainOrderEnable = False
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRemoveTroops, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_DISABLE)
Next
SetDefaultTroopGroup($bSetLog)
If($bSetLog Or $g_bDebugSetlogTrain) And $g_bCustomTrainOrderEnable Then
Local $sNewTrainList = ""
For $i = 0 To $eTroopCount - 1
$sNewTrainList &= $g_asTroopShortNames[$g_aiTrainOrder[$i]] & ", "
Next
$sNewTrainList = StringTrimRight($sNewTrainList, 2)
SetLog("Current train order= " & $sNewTrainList, $COLOR_INFO)
EndIf
EndIf
EndFunc
Func chkSpellsOrder()
If GUICtrlRead($g_hChkCustomBrewOrderEnable) = $GUI_CHECKED Then
$g_bCustomBrewOrderEnable = True
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
GUICtrlSetState($g_ahCmbSpellsOrder[$i], $GUI_ENABLE)
Next
GUICtrlSetState($g_hBtnRemoveSpells, $GUI_ENABLE)
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_ENABLE)
If IsUseCustomSpellsOrder() = True Then _GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
$g_bCustomBrewOrderEnable = False
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
GUICtrlSetState($g_ahCmbSpellsOrder[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_hBtnRemoveSpells, $GUI_DISABLE)
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_DISABLE)
SetDefaultSpellsGroup(False)
EndIf
EndFunc
Func GUISpellsOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iSpellsIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
_GUICtrlSetImage($iCtrlIdImage, $g_sLibIconPath, $g_aiSpellsOrderIcon[$iSpellsIndex])
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
If $iGUI_CtrlId = $g_ahCmbSpellsOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$i]) Then
_GUICtrlSetImage($g_ahImgSpellsOrder[$i], $g_sLibIconPath, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($g_ahCmbSpellsOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate Then
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_DISABLE)
Return
Else
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_ENABLE)
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
EndFunc
Func BtnRemoveSpells()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnRemoveSpells")
Local $sComboData = ""
For $j = 0 To UBound($g_asSpellsOrderList) - 1
$sComboData &= $g_asSpellsOrderList[$j] & "|"
Next
For $i = 0 To $eSpellCount - 1
$g_aiCmbCustomBrewOrder[$i] = -1
_GUICtrlComboBox_ResetContent($g_ahCmbSpellsOrder[$i])
GUICtrlSetData($g_ahCmbSpellsOrder[$i], $sComboData, "")
_GUICtrlSetImage($g_ahImgSpellsOrder[$i], $g_sLibIconPath, $eIcnOptions)
Next
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnSilverStar)
SetDefaultSpellsGroup(False)
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnRemoveSpells")
EndFunc
Func GUITrainOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iTroopIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
_GUICtrlSetImage($iCtrlIdImage, $g_sLibIconPath, $g_aiTroopOrderIcon[$iTroopIndex])
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
If $iGUI_CtrlId = $g_ahCmbTroopOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i]) Then
_GUICtrlSetImage($g_ahImgTroopOrder[$i], $g_sLibIconPath, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate Then
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
Return
Else
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_ENABLE)
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
EndFunc
Func BtnRemoveTroops()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnRemoveTroops")
Local $sComboData = ""
For $j = 0 To UBound($g_asTroopOrderList) - 1
$sComboData &= $g_asTroopOrderList[$j] & "|"
Next
For $i = $eTroopBarbarian To $eTroopCount - 1
$g_aiCmbCustomTrainOrder[$i] = -1
_GUICtrlComboBox_ResetContent($g_ahCmbTroopOrder[$i])
GUICtrlSetData($g_ahCmbTroopOrder[$i], $sComboData, "")
_GUICtrlSetImage($g_ahImgTroopOrder[$i], $g_sLibIconPath, $eIcnOptions)
Next
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnSilverStar)
SetDefaultTroopGroup(False)
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnRemoveTroops")
EndFunc
Func BtnSpellsOrderSet()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnSpellsOrderSet")
Local $bReady = True
Local $sNewTrainList = ""
Local $bMissingTroop = False
Local $aiBrewOrder[$eSpellCount] = [ $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellClone, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton, $eSpellBat]
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
For $j = 0 To UBound($g_ahCmbSpellsOrder) - 1
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$i]) <> -1 And  _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$i]) = _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($g_ahCmbSpellsOrder[$j], -1)
_GUICtrlSetImage($g_ahImgSpellsOrder[$j], $g_sLibIconPath, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($g_ahCmbSpellsOrder[$j], $COLOR_BLACK)
EndIf
Next
$g_aiCmbCustomBrewOrder[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$i])
If $g_aiCmbCustomBrewOrder[$i] = -1 Then $bMissingTroop = True
Next
If $bReady And $bMissingTroop Then
For $i = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
For $j = 0 To UBound($aiBrewOrder) - 1
If $g_aiCmbCustomBrewOrder[$i] = $j Then
$aiBrewOrder[$j] = -1
ExitLoop
EndIf
Next
Next
_ArrayShuffle($aiBrewOrder)
For $i = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
If $g_aiCmbCustomBrewOrder[$i] = -1 Then
For $j = 0 To UBound($aiBrewOrder) - 1
If $aiBrewOrder[$j] <> -1 Then
$g_aiCmbCustomBrewOrder[$i] = $aiBrewOrder[$j]
_GUICtrlComboBox_SetCurSel($g_ahCmbSpellsOrder[$i], $aiBrewOrder[$j])
_GUICtrlSetImage($g_ahImgSpellsOrder[$i], $g_sLibIconPath, $g_aiSpellsOrderIcon[$g_aiCmbCustomBrewOrder[$i] + 1])
$aiBrewOrder[$j] = -1
ExitLoop
EndIf
Next
EndIf
Next
EndIf
If $bReady Then
ChangeSpellsBrewOrder()
If @error Then
Switch @error
Case 1
SetLog("Code problem, can not continue till fixed!", $COLOR_ERROR)
Case 2
SetLog("Bad Combobox selections, please fix!", $COLOR_ERROR)
Case 3
SetLog("Unable to Change Spells Brew Order due bad change count!", $COLOR_ERROR)
Case Else
SetLog("Monkey ate bad banana, something wrong with ChangeSpellsBrewOrder() code!", $COLOR_ERROR)
EndSwitch
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
SetLog("Spells Brew order changed successfully!", $COLOR_SUCCESS)
For $i = 0 To $eSpellCount - 1
$sNewTrainList &= $g_asSpellShortNames[$g_aiBrewOrder[$i]] & ", "
Next
$sNewTrainList = StringTrimRight($sNewTrainList, 2)
SetLog("Spells Brew order= " & $sNewTrainList, $COLOR_INFO)
EndIf
Else
SetLog("Must use all Spells and No duplicate troop names!", $COLOR_ERROR)
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnSpellsOrderSet")
EndFunc
Func BtnTroopOrderSet()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnTroopOrderSet")
Local $bReady = True
Local $sNewTrainList = ""
Local $bMissingTroop = False
Local $aiUsedTroop[$eTroopCount] = [ $eTroopBarbarian, $eTroopArcher, $eTroopGiant, $eTroopGoblin, $eTroopWallBreaker, $eTroopBalloon, $eTroopWizard, $eTroopHealer, $eTroopDragon, $eTroopPekka, $eTroopBabyDragon, $eTroopMiner, $eTroopElectroDragon, $eTroopMinion, $eTroopHogRider, $eTroopValkyrie, $eTroopGolem, $eTroopWitch, $eTroopLavaHound, $eTroopBowler, $eTroopIceGolem]
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
For $j = 0 To UBound($g_ahCmbTroopOrder) - 1
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i]) <> -1 And  _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i]) = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$j], -1)
_GUICtrlSetImage($g_ahImgTroopOrder[$j], $g_sLibIconPath, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($g_ahCmbTroopOrder[$j], $COLOR_BLACK)
EndIf
Next
$g_aiCmbCustomTrainOrder[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i])
If $g_aiCmbCustomTrainOrder[$i] = -1 Then $bMissingTroop = True
Next
If $bReady And $bMissingTroop Then
For $i = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
For $j = 0 To UBound($aiUsedTroop) - 1
If $g_aiCmbCustomTrainOrder[$i] = $j Then
$aiUsedTroop[$j] = -1
ExitLoop
EndIf
Next
Next
_ArrayShuffle($aiUsedTroop)
For $i = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
If $g_aiCmbCustomTrainOrder[$i] = -1 Then
For $j = 0 To UBound($aiUsedTroop) - 1
If $aiUsedTroop[$j] <> -1 Then
$g_aiCmbCustomTrainOrder[$i] = $aiUsedTroop[$j]
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$i], $aiUsedTroop[$j])
_GUICtrlSetImage($g_ahImgTroopOrder[$i], $g_sLibIconPath, $g_aiTroopOrderIcon[$g_aiCmbCustomTrainOrder[$i] + 1])
$aiUsedTroop[$j] = -1
ExitLoop
EndIf
Next
EndIf
Next
EndIf
If $bReady Then
ChangeTroopTrainOrder()
If @error Then
Switch @error
Case 1
SetLog("Code problem, can not continue till fixed!", $COLOR_ERROR)
Case 2
SetLog("Bad Combobox selections, please fix!", $COLOR_ERROR)
Case 3
SetLog("Unable to Change Troop Train Order due bad change count!", $COLOR_ERROR)
Case Else
SetLog("Monkey ate bad banana, something wrong with ChangeTroopTrainOrder() code!", $COLOR_ERROR)
EndSwitch
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
SetLog("Troop training order changed successfully!", $COLOR_SUCCESS)
For $i = 0 To $eTroopCount - 1
$sNewTrainList &= $g_asTroopShortNames[$g_aiTrainOrder[$i]] & ", "
Next
$sNewTrainList = StringTrimRight($sNewTrainList, 2)
SetLog("Troop train order= " & $sNewTrainList, $COLOR_INFO)
EndIf
Else
SetLog("Must use all troops and No duplicate troop names!", $COLOR_ERROR)
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnTroopOrderSet")
EndFunc
Func ChangeSpellsBrewOrder()
If $g_bDebugSetlog Or $g_bDebugSetlogTrain Then SetLog("Begin Func ChangeSpellsBrewOrder()", $COLOR_DEBUG)
Local $NewTroopOrder[$eSpellCount]
Local $iUpdateCount = 0
If Not IsUseCustomSpellsOrder() Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
Local $sComboText = GUICtrlRead($g_ahCmbSpellsOrder[$i])
For $j = 0 To UBound($g_asSpellsOrderList) - 1
If $sComboText = $g_asSpellsOrderList[$j] Then
$NewTroopOrder[$i] = $j - 1
$iUpdateCount += 1
ExitLoop
EndIf
Next
Next
If $iUpdateCount = $eSpellCount Then
For $i = 0 To $eSpellCount - 1
$g_aiBrewOrder[$i] = $NewTroopOrder[$i]
Next
_GUICtrlSetImage($g_ahImgSpellsOrderSet, $g_sLibIconPath, $eIcnGreenLight)
Else
SetLog($iUpdateCount & "|" & $eSpellCount & " - Error - Bad Spells assignment in ChangeSpellsBrewOrder()", $COLOR_ERROR)
SetError(3, 0, False)
Return
EndIf
Return True
EndFunc
Func ChangeTroopTrainOrder()
If $g_bDebugSetlog Or $g_bDebugSetlogTrain Then SetLog("Begin Func ChangeTroopTrainOrder()", $COLOR_DEBUG)
Local $NewTroopOrder[$eTroopCount]
Local $iUpdateCount = 0
If Not IsUseCustomTroopOrder() Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
Local $sComboText = GUICtrlRead($g_ahCmbTroopOrder[$i])
For $j = 0 To UBound($g_asTroopOrderList) - 1
If $sComboText = $g_asTroopOrderList[$j] Then
$NewTroopOrder[$i] = $j - 1
$iUpdateCount += 1
ExitLoop
EndIf
Next
Next
If $iUpdateCount = $eTroopCount Then
For $i = 0 To $eTroopCount - 1
$g_aiTrainOrder[$i] = $NewTroopOrder[$i]
Next
_GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnGreenLight)
Else
SetLog($iUpdateCount & "|" & $eTroopCount & " - Error - Bad troop assignment in ChangeTroopTrainOrder()", $COLOR_ERROR)
SetError(3, 0, False)
Return
EndIf
Return True
EndFunc
Func SetDefaultTroopGroup($bSetLog = True)
For $i = 0 To $eTroopCount - 1
$g_aiTrainOrder[$i] = $i
Next
If($bSetLog Or $g_bDebugSetlogTrain) And $g_bCustomTrainOrderEnable Then SetLog("Default troop training order set", $COLOR_SUCCESS)
EndFunc
Func SetDefaultSpellsGroup($bSetLog = True)
For $i = 0 To $eSpellCount - 1
$g_aiBrewOrder[$i] = $i
Next
If($bSetLog Or $g_bDebugSetlogTrain) And $g_bCustomTrainOrderEnable Then SetLog("Default Spells Brew order set", $COLOR_SUCCESS)
EndFunc
Func IsUseCustomSpellsOrder()
For $i = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
If $g_aiCmbCustomBrewOrder[$i] = -1 Then
If $g_bDebugSetlogTrain And $g_bCustomBrewOrderEnable Then SetLog("Custom Spell order not used...", $COLOR_DEBUG)
Return False
EndIf
Next
If $g_bDebugSetlogTrain And $g_bCustomBrewOrderEnable Then SetLog("Custom Spell order used...", $COLOR_DEBUG)
Return True
EndFunc
Func IsUseCustomTroopOrder()
For $i = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
If $g_aiCmbCustomTrainOrder[$i] = -1 Then
If $g_bDebugSetlogTrain And $g_bCustomTrainOrderEnable Then SetLog("Custom train order not used...", $COLOR_DEBUG)
Return False
EndIf
Next
If $g_bDebugSetlogTrain And $g_bCustomTrainOrderEnable Then SetLog("Custom train order used...", $COLOR_DEBUG)
Return True
EndFunc
Func LevUpDownTroop($iTroopIndex, $NoChangeLev = True)
Local $MaxLev = $g_aiTroopCostPerLevel[$iTroopIndex][0]
Local $TempLev = 0
If $NoChangeLev Then
If _IsPressed("10") Or _IsPressed("02") Then
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex] - 1
Else
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex] + 1
EndIf
Else
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex]
EndIf
Local $hLevel = $g_ahLblTrainArmyTroopLevel[$iTroopIndex]
Local $hCount = $g_ahTxtTrainArmyTroopCount[$iTroopIndex]
If $TempLev > $MaxLev Or $TempLev = 0 Then
$TempLev = 0
GUICtrlSetData($hCount, 0)
$g_aiArmyCompTroops[$iTroopIndex] = 0
If IsGUICtrlHidden($hCount) = False Then GUICtrlSetState($hCount, $GUI_HIDE)
If $NoChangeLev Then lblTotalCountTroop1()
ElseIf $TempLev < 0 Then
$TempLev = $MaxLev
If IsGUICtrlHidden($hCount) Then GUICtrlSetState($hCount, $GUI_SHOW)
ElseIf $TempLev > 0 And $TempLev <= $MaxLev And IsGUICtrlHidden($hCount) Then
GUICtrlSetState($hCount, $GUI_SHOW)
EndIf
$g_aiTrainArmyTroopLevel[$iTroopIndex] = $TempLev
Local $iColor =($TempLev = $MaxLev ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($hLevel, $TempLev)
If GUICtrlGetBkColor($hLevel) <> $iColor Then GUICtrlSetBkColor($hLevel, $iColor)
EndFunc
Func LevUpDownSiege($iSiege, $NoChangeLev = True)
Local $MaxLev = $g_aiSiegeMachineCostPerLevel[$iSiege][0]
Local $TempLev = 0
If $NoChangeLev Then
If _IsPressed("10") Or _IsPressed("02") Then
$TempLev = $g_aiTrainArmySiegeMachineLevel[$iSiege] - 1
Else
$TempLev = $g_aiTrainArmySiegeMachineLevel[$iSiege] + 1
EndIf
Else
$TempLev = $g_aiTrainArmySiegeMachineLevel[$iSiege]
EndIf
Local $hLevel = $g_ahLblTrainArmySiegeLevel[$iSiege]
Local $hCount = $g_ahTxtTrainArmySiegeCount[$iSiege]
If $TempLev > $MaxLev Or $TempLev = 0 Then
$TempLev = 0
GUICtrlSetData($hCount, 0)
$g_aiArmyCompSiegeMachine[$iSiege] = 0
If IsGUICtrlHidden($hCount) = False Then GUICtrlSetState($hCount, $GUI_HIDE)
ElseIf $TempLev < 0 Then
$TempLev = $MaxLev
If IsGUICtrlHidden($hCount) Then GUICtrlSetState($hCount, $GUI_SHOW)
ElseIf $TempLev > 0 And $TempLev <= $MaxLev And IsGUICtrlHidden($hCount) Then
GUICtrlSetState($hCount, $GUI_SHOW)
EndIf
$g_aiTrainArmySiegeMachineLevel[$iSiege] = $TempLev
Local $iColor =($TempLev = $MaxLev ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($hLevel, $TempLev)
If GUICtrlGetBkColor($hLevel) <> $iColor Then GUICtrlSetBkColor($hLevel, $iColor)
lblTotalCountSiege()
CalCostSiege()
EndFunc
Func LevUpDownSpell($iSpellIndex, $NoChangeLev = True)
Local $MaxLev = $g_aiSpellCostPerLevel[$iSpellIndex][0]
Local $TempLev = 0
If $NoChangeLev Then
If _IsPressed("10") Or _IsPressed("02") Then
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex] - 1
Else
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex] + 1
EndIf
Else
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex]
EndIf
Local $hLevel = $g_ahLblTrainArmySpellLevel[$iSpellIndex]
Local $hCount = $g_ahTxtTrainArmySpellCount[$iSpellIndex]
If $TempLev > $MaxLev Or $TempLev = 0 Then
$TempLev = 0
GUICtrlSetData($hCount, 0)
$g_aiArmyCompSpells[$iSpellIndex] = 0
If IsGUICtrlHidden($hCount) = False Then GUICtrlSetState($hCount, $GUI_HIDE)
If $NoChangeLev Then lblTotalCountSpell2()
ElseIf $TempLev < 0 Then
$TempLev = $MaxLev
If IsGUICtrlHidden($hCount) Then GUICtrlSetState($hCount, $GUI_SHOW)
ElseIf $TempLev > 0 And $TempLev <= $MaxLev And IsGUICtrlHidden($hCount) Then
GUICtrlSetState($hCount, $GUI_SHOW)
EndIf
$g_aiTrainArmySpellLevel[$iSpellIndex] = $TempLev
Local $iColor =($TempLev = $MaxLev ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($hLevel, $TempLev)
If GUICtrlGetBkColor($hLevel) <> $iColor Then GUICtrlSetBkColor($hLevel, $iColor)
EndFunc
Func TrainTroopLevelClick()
If $g_bRunState = True Then Return
Local $iTroop = -1
For $i = 0 To $eTroopCount - 1
If @GUI_CtrlId = $g_ahPicTrainArmyTroop[$i] Then
$iTroop = $i
ExitLoop
EndIf
Next
If $iTroop = -1 Then Return
While _IsPressed(01)
LevUpDownTroop($iTroop)
Sleep($DELAYLVUP)
lblTotalCountTroop2()
WEnd
EndFunc
Func TrainSiegeLevelClick()
If $g_bRunState = True Then Return
Local $iSiege = -1
For $i = 0 To $eSiegeMachineCount - 1
If @GUI_CtrlId = $g_ahPicTrainArmySiege[$i] Then
$iSiege = $i
ExitLoop
EndIf
Next
If $iSiege = -1 Then Return
While _IsPressed(01)
LevUpDownSiege($iSiege)
Sleep($DELAYLVUP)
lblTotalCountSiege()
WEnd
EndFunc
Func TrainSpellLevelClick()
If $g_bRunState = True Then Return
Local $iSpell = -1
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahPicTrainArmySpell[$i] Then
$iSpell = $i
ExitLoop
EndIf
Next
If $iSpell = -1 Then Return
While _IsPressed(01)
LevUpDownSpell($iSpell)
Sleep($DELAYLVUP)
lblTotalCountSpell2()
WEnd
EndFunc
Func CalCostCamp()
Local $iElixirCostCamp = 0, $iDarkCostCamp = 0
For $i = $eTroopBarbarian To $eTroopElectroDragon
$iElixirCostCamp += $g_aiArmyCompTroops[$i] * $g_aiTroopCostPerLevel[$i][$g_aiTrainArmyTroopLevel[$i]]
Next
For $i = $eTroopMinion To $eTroopIceGolem
$iDarkCostCamp += $g_aiArmyCompTroops[$i] * $g_aiTroopCostPerLevel[$i][$g_aiTrainArmyTroopLevel[$i]]
Next
GUICtrlSetData($g_hLblElixirCostCamp, _NumberFormat($iElixirCostCamp, True))
GUICtrlSetData($g_hLblDarkCostCamp, _NumberFormat($iDarkCostCamp, True))
EndFunc
Func CalCostSpell()
Local $iElixirCostSpell = 0, $iDarkCostSpell = 0
For $i = $eSpellLightning To $eSpellClone
$iElixirCostSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellCostPerLevel[$i][$g_aiTrainArmySpellLevel[$i]]
Next
For $i = $eSpellPoison To $eSpellBat
$iDarkCostSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellCostPerLevel[$i][$g_aiTrainArmySpellLevel[$i]]
Next
GUICtrlSetData($g_hLblElixirCostSpell, _NumberFormat($iElixirCostSpell, True))
GUICtrlSetData($g_hLblDarkCostSpell, _NumberFormat($iDarkCostSpell, True))
EndFunc
Func CalCostSiege()
Local $iGoldCostSiege = 0
For $i = 0 To $eSiegeMachineCount - 1
$iGoldCostSiege += $g_aiArmyCompSiegeMachine[$i] * $g_aiSiegeMachineCostPerLevel[$i][$g_aiTrainArmySiegeMachineLevel[$i]]
NExt
GUICtrlSetData($g_hLblGoldCostSiege, _NumberFormat($iGoldCostSiege, True))
EndFunc
Func CalculTimeTo($TotalTotalTime)
Local $HourToTrain = 0
Local $MinToTrain = 0
Local $SecToTrain = 0
Local $TotalTotalTimeTo
If $TotalTotalTime >= 3600 Then
$HourToTrain = Int($TotalTotalTime / 3600)
$MinToTrain = Int(($TotalTotalTime - $HourToTrain * 3600) / 60)
$SecToTrain = $TotalTotalTime - $HourToTrain * 3600 - $MinToTrain * 60
$TotalTotalTimeTo = " " & $HourToTrain & "h " & $MinToTrain & "m " & $SecToTrain & "s"
ElseIf $TotalTotalTime < 3600 And $TotalTotalTime >= 60 Then
$MinToTrain = Int(($TotalTotalTime - $HourToTrain * 3600) / 60)
$SecToTrain = $TotalTotalTime - $HourToTrain * 3600 - $MinToTrain * 60
$TotalTotalTimeTo = " " & $MinToTrain & "m " & $SecToTrain & "s"
Else
$SecToTrain = $TotalTotalTime
$TotalTotalTimeTo = " " & $SecToTrain & "s"
EndIf
Return $TotalTotalTimeTo
EndFunc
Func Removecamp()
For $T = 0 To $eTroopCount - 1
$g_aiArmyCompTroops[$T] = 0
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$T], 0)
Next
For $S = 0 To $eSpellCount - 1
$g_aiArmyCompSpells[$S] = 0
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$S], $g_aiArmyCompSpells[$S])
Next
For $S = 0 To $eSiegeMachineCount - 1
$g_aiArmyCompSiegeMachine[$S] = 0
GUICtrlSetData($g_ahTxtTrainArmySiegeCount[$S], $g_aiArmyCompSiegeMachine[$S])
Next
GUICtrlSetData($g_hLblTotalTimeCamp, " 0s")
GUICtrlSetData($g_hLblTotalTimeSpell, " 0s")
GUICtrlSetData($g_hLblElixirCostCamp, "0")
GUICtrlSetData($g_hLblDarkCostCamp, "0")
GUICtrlSetData($g_hLblElixirCostSpell, "0")
GUICtrlSetData($g_hLblDarkCostSpell, "0")
GUICtrlSetData($g_hLblCountTotal, 0)
GUICtrlSetData($g_hLblGoldCostSiege, "0")
GUICtrlSetData($g_hLblCountTotalSiege, 0)
GUICtrlSetData($g_hLblTotalTimeSiege, " 0s")
EndFunc
Func TrainTroopCountEdit()
For $i = 0 To $eTroopCount - 1
If @GUI_CtrlId = $g_ahTxtTrainArmyTroopCount[$i] Then
$g_aiArmyCompTroops[$i] = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
lblTotalCountTroop1()
Return
EndIf
Next
EndFunc
Func TrainSiegeCountEdit()
For $i = 0 To $eSiegeMachineCount - 1
If @GUI_CtrlId = $g_ahTxtTrainArmySiegeCount[$i] Then
$g_aiArmyCompSiegeMachine[$i] = GUICtrlRead($g_ahTxtTrainArmySiegeCount[$i])
lblTotalCountSiege()
Return
EndIf
Next
EndFunc
Func TrainSpellCountEdit()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahTxtTrainArmySpellCount[$i] Then
$g_aiArmyCompSpells[$i] = GUICtrlRead($g_ahTxtTrainArmySpellCount[$i])
lblTotalCountSpell2()
Return
EndIf
Next
EndFunc
Func chkAddDelayIdlePhaseEnable()
$g_bTrainAddRandomDelayEnable =(GUICtrlRead($g_hChkTrainAddRandomDelayEnable) = $GUI_CHECKED)
For $i = $g_hLblAddDelayIdlePhaseBetween To $g_hLblAddDelayIdlePhaseSec
GUICtrlSetState($i, $g_bTrainAddRandomDelayEnable ? $GUI_ENABLE : $GUI_DISABLE)
Next
EndFunc
Func chkRequestCCHours()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "chkRequestCCHours")
If GUICtrlRead($g_hChkRequestTroopsEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtRequestCC, $GUI_SHOW + $GUI_ENABLE)
For $i = $g_hLblRequestType To $g_ahCmbClanCastleSiege[1]
GUICtrlSetState($i, $GUI_ENABLE)
Next
GUIToggle_RequestOnlyDuringHours(True)
chkRequestCountCC()
Else
GUICtrlSetState($g_hTxtRequestCC, $GUI_SHOW + $GUI_DISABLE)
For $i = $g_hLblRequestType To $g_ahCmbClanCastleSiege[1]
GUICtrlSetState($i, $GUI_DISABLE)
Next
If GUICtrlRead($g_hChkRequestCCDefense) = $GUI_UNCHECKED Then GUIToggle_RequestOnlyDuringHours(False)
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGrpRequestCC, "chkRequestCCHours")
EndFunc
Func chkRequestCountCC()
If GUICtrlRead($g_hChkRequestType_Troops) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtRequestCountCCTroop, $GUI_ENABLE)
For $i = $g_ahTxtClanCastleTroop[0] To $g_ahCmbClanCastleTroop[2]
GUICtrlSetState($i, $GUI_ENABLE)
Next
CmbClanCastleTroop()
Else
GUICtrlSetState($g_hTxtRequestCountCCTroop, $GUI_DISABLE)
For $i = $g_ahTxtClanCastleTroop[0] To $g_ahCmbClanCastleTroop[2]
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
If GUICtrlRead($g_hChkRequestType_Spells) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtRequestCountCCSpell, $GUI_ENABLE)
GUICtrlSetState($g_ahCmbClanCastleSpell[0], $GUI_ENABLE)
GUICtrlSetState($g_ahCmbClanCastleSpell[1], $GUI_ENABLE)
GUICtrlSetState($g_ahCmbClanCastleSpell[2], $GUI_ENABLE)
CmbClanCastleSpell()
Else
GUICtrlSetState($g_hTxtRequestCountCCSpell, $GUI_DISABLE)
GUICtrlSetState($g_ahCmbClanCastleSpell[0], $GUI_DISABLE)
GUICtrlSetState($g_ahCmbClanCastleSpell[1], $GUI_DISABLE)
GUICtrlSetState($g_ahCmbClanCastleSpell[2], $GUI_DISABLE)
EndIf
If GUICtrlRead($g_hChkRequestType_Siege) = $GUI_CHECKED Then
GUICtrlSetState($g_ahCmbClanCastleSiege[0], $GUI_ENABLE)
GUICtrlSetState($g_ahCmbClanCastleSiege[1], $GUI_ENABLE)
CmbClanCastleSiege()
Else
GUICtrlSetState($g_ahCmbClanCastleSiege[0], $GUI_DISABLE)
GUICtrlSetState($g_ahCmbClanCastleSiege[1], $GUI_DISABLE)
EndIf
EndFunc
Func CmbClanCastleTroop()
For $i = 0 To UBound($g_ahCmbClanCastleTroop) - 1
If _GUICtrlComboBox_GetCurSel($g_ahCmbClanCastleTroop[$i]) < $eTroopCount Then
GUICtrlSetState($g_ahTxtClanCastleTroop[$i], $GUI_ENABLE)
Else
GUICtrlSetState($g_ahTxtClanCastleTroop[$i], $GUI_DISABLE)
EndIf
Local $g_aiCmbClanCastleTroop = _GUICtrlComboBox_GetCurSel($g_ahCmbClanCastleTroop[$i])
_GUICtrlSetImage($g_ahImgClanCastleTroop[$i], $g_sLibIconPath, $g_aiCCTroopsIcon[$g_aiCmbClanCastleTroop])
Next
EndFunc
Func CmbClanCastleSpell()
For $i = 0 To UBound($g_ahCmbClanCastleSpell) - 1
If _GUICtrlComboBox_GetCurSel($g_ahCmbClanCastleSpell[$i]) = $eCSpell - $eLSpell Then _GUICtrlComboBox_SetCurSel($g_ahCmbClanCastleSpell[$i], $eSpellCount)
Local $g_aiCmbClanCastleSpell = _GUICtrlComboBox_GetCurSel($g_ahCmbClanCastleSpell[$i])
_GUICtrlSetImage($g_ahImgClanCastleSpell[$i], $g_sLibIconPath, $g_aiCCSpellsIcon[$g_aiCmbClanCastleSpell])
Next
EndFunc
Func CmbClanCastleSiege()
For $i = 0 To UBound($g_ahCmbClanCastleSiege) - 1
Local $g_aiCmbClanCastleSiege = _GUICtrlComboBox_GetCurSel($g_ahCmbClanCastleSiege[$i])
_GUICtrlSetImage($g_ahImgClanCastleSiege[$i], $g_sLibIconPath, $g_aiCCSiegesIcon[$g_aiCmbClanCastleSiege])
Next
EndFunc
Func GUIToggle_RequestOnlyDuringHours($Enable = True)
If $Enable Then
For $i = $g_hLblOnlyDuringHours To $g_hLblRequestCCHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hLblOnlyDuringHours To $g_hLblRequestCCHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkRequestCCHoursE1()
If GUICtrlRead($g_hChkRequestCCHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkRequestCCHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkRequestCCHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkRequestCCHoursE2()
If GUICtrlRead($g_hChkRequestCCHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkRequestCCHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkRequestCCHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkDonateHours()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "chkDonateHours")
If GUICtrlRead($g_hChkDonateHoursEnable) = $GUI_CHECKED Then
For $i = $g_hLblDonateCChour To $g_hLblDonateHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hLblDonateCChour To $g_hLblDonateHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGrpDonateCC, "chkDonateHours")
EndFunc
Func chkDonateHoursE1()
If GUICtrlRead($g_ahChkDonateHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkDonateHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkDonateHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkDonateHoursE2()
If GUICtrlRead($g_ahChkDonateHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkDonateHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkDonateHoursE2, $GUI_UNCHECKED)
EndFunc
Func cmbDBGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbDBMeetGE) < 2 Then
GUICtrlSetState($g_hTxtDBMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtDBMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtDBMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtDBMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtDBMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtDBMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkDBMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtDBMinDarkElixir, GUICtrlRead($g_hChkDBMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func chkDBMeetTrophy()
_GUICtrlEdit_SetReadOnly($g_hTxtDBMinTrophy, GUICtrlRead($g_hChkDBMeetTrophy) = $GUI_CHECKED ? False : True)
_GUICtrlEdit_SetReadOnly($g_hTxtDBMaxTrophy, GUICtrlRead($g_hChkDBMeetTrophy) = $GUI_CHECKED ? False : True)
EndFunc
Func chkDBMeetTH()
GUICtrlSetState($g_hCmbDBTH, GUICtrlRead($g_hChkDBMeetTH) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDBWeakBase()
GUICtrlSetState($g_ahCmbWeakMortar[$DB], GUICtrlRead($g_ahChkMaxMortar[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakWizTower[$DB], GUICtrlRead($g_ahChkMaxWizTower[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakAirDefense[$DB], GUICtrlRead($g_ahChkMaxAirDefense[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakXBow[$DB], GUICtrlRead($g_ahChkMaxXBow[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakInferno[$DB], GUICtrlRead($g_ahChkMaxInferno[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakEagle[$DB], GUICtrlRead($g_ahChkMaxEagle[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func cmbABGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbABMeetGE) < 2 Then
GUICtrlSetState($g_hTxtABMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtABMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtABMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtABMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtABMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtABMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkABMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtABMinDarkElixir, GUICtrlRead($g_hChkABMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func chkABMeetTrophy()
_GUICtrlEdit_SetReadOnly($g_hTxtABMinTrophy, GUICtrlRead($g_hChkABMeetTrophy) = $GUI_CHECKED ? False : True)
_GUICtrlEdit_SetReadOnly($g_hTxtABMaxTrophy, GUICtrlRead($g_hChkABMeetTrophy) = $GUI_CHECKED ? False : True)
EndFunc
Func chkABMeetTH()
GUICtrlSetState($g_hCmbABTH, GUICtrlRead($g_hChkABMeetTH) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkABWeakBase()
GUICtrlSetState($g_ahCmbWeakMortar[$LB], GUICtrlRead($g_ahChkMaxMortar[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakWizTower[$LB], GUICtrlRead($g_ahChkMaxWizTower[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakAirDefense[$LB], GUICtrlRead($g_ahChkMaxAirDefense[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakXBow[$LB], GUICtrlRead($g_ahChkMaxXBow[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakInferno[$LB], GUICtrlRead($g_ahChkMaxInferno[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakEagle[$LB], GUICtrlRead($g_ahChkMaxEagle[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkRestartSearchLimit()
GUICtrlSetState($g_hTxtRestartSearchlimit, GUICtrlRead($g_hChkRestartSearchLimit) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func btnConfigureCollectors()
EndFunc
Func btnConfigureReduction()
EndFunc
Func btnConfigureTHBully()
EndFunc
Func btnConfigureDBWeakBase()
EndFunc
Func btnConfigureABWeakBase()
EndFunc
Func chkDBActivateSearches()
If GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDBSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtDBSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBSearchesMax, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func chkDBActivateTropies()
If GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDBTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtDBTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBTropiesMax, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func chkDBActivateCamps()
If GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblDBArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblDBArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBArmyCamps, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func EnableSearchPanels($mode)
Switch $mode
Case $DB
If GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBNotWaitHeroes) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupHerosDB)
_GUI_Value_STATE("SHOW", $g_aGroupSearchDB)
_GUI_Value_STATE("SHOW", $groupSpellsDB)
cmbDBGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupHerosDB)
_GUI_Value_STATE("HIDE", $g_aGroupSearchDB)
_GUI_Value_STATE("HIDE", $groupSpellsDB)
EndIf
Case $LB
If GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED Or GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABNotWaitHeroes) = $GUI_CHECKED Or GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupHerosAB)
_GUI_Value_STATE("SHOW", $groupSearchAB)
_GUI_Value_STATE("SHOW", $groupSpellsAB)
cmbABGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupHerosAB)
_GUI_Value_STATE("HIDE", $groupSearchAB)
_GUI_Value_STATE("HIDE", $groupSpellsAB)
EndIf
Case $TS
If GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupSearchTS)
cmbTSGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupSearchTS)
EndIf
EndSwitch
EndFunc
Func chkABActivateSearches()
If GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtABSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblABSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtABSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblABSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABSearchesMax, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkABActivateTropies()
If GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtABTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtABTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABTropiesMax, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkABActivateCamps()
If GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblABArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblABArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABArmyCamps, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkTSActivateSearches()
If GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtTSSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblTSSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtTSSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblTSSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSSearchesMax, $GUI_DISABLE)
EndIf
tsCheckall()
EndFunc
Func chkTSActivateTropies()
If GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtTSTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblTSTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtTSTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblTSTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSTropiesMax, $GUI_DISABLE)
EndIf
tsCheckAll()
EndFunc
Func chkTSActivateCamps()
If GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTSArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTSArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSArmyCamps, $GUI_DISABLE)
EndIf
tsCheckAll()
EndFunc
Func chkDBKingWait()
If $g_iTownHallLevel > 6 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED Then
If Not $g_bUpgradeKingEnable Then GUICtrlSetState($g_hChkDBKingAttack, $GUI_ENABLE)
Else
If Not $g_bUpgradeKingEnable Then GUICtrlSetState($g_hChkDBKingWait, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBKingAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBQueenWait()
If $g_iTownHallLevel > 8 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED Then
If Not $g_bUpgradeQueenEnable Then GUICtrlSetState($g_hChkDBQueenAttack, $GUI_ENABLE)
Else
If Not $g_bUpgradeQueenEnable Then GUICtrlSetState($g_hChkDBQueenWait, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBQueenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBWardenWait()
If $g_iTownHallLevel > 10 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED Then
If Not $g_bUpgradeWardenEnable Then GUICtrlSetState($g_hChkDBWardenAttack, $GUI_ENABLE)
Else
If Not $g_bUpgradeWardenEnable Then GUICtrlSetState($g_hChkDBWardenWait, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBWardenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABKingWait()
If $g_iTownHallLevel > 6 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED Then
If Not $g_bUpgradeKingEnable Then GUICtrlSetState($g_hChkABKingAttack, $GUI_ENABLE)
Else
If Not $g_bUpgradeKingEnable Then GUICtrlSetState($g_hChkABKingWait, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABKingAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABQueenWait()
If $g_iTownHallLevel > 8 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED Then
If Not $g_bUpgradeQueenEnable Then GUICtrlSetState($g_hChkABQueenAttack, $GUI_ENABLE)
Else
If Not $g_bUpgradeQueenEnable Then GUICtrlSetState($g_hChkABQueenWait, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABQueenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABWardenWait()
If $g_iTownHallLevel > 10 Or $g_iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED Then
If Not $g_bUpgradeWardenEnable Then GUICtrlSetState($g_hChkABWardenAttack, $GUI_ENABLE)
Else
If Not $g_bUpgradeWardenEnable Then GUICtrlSetState($g_hChkABWardenWait, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABWardenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBSpellsWait()
If $g_iTownHallLevel > 4 Or $g_iTownHallLevel = 0 Then
For $i = $g_hPicDBLightSpellWait To $g_hPicDBHasteSpellWait
GUICtrlSetState($i, $GUI_ENABLE)
Next
If GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED Then
$g_abSearchSpellsWaitEnable[$DB] = True
chkSpellWaitError()
If @error Then
GUICtrlSetState($g_hChkDBSpellsWait, $GUI_UNCHECKED)
$g_abSearchSpellsWaitEnable[$DB] = False
SetLog("Wait for Spells disabled due training count error", $COLOR_ERROR)
EndIf
Else
$g_abSearchSpellsWaitEnable[$DB] = False
EndIf
Else
GUICtrlSetState($g_hChkDBSpellsWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
For $i = $g_hPicDBLightSpellWait To $g_hPicDBHasteSpellWait
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkABSpellsWait()
If $g_iTownHallLevel > 4 Or $g_iTownHallLevel = 0 Then
For $i = $g_hPicABLightSpellWait To $g_hPicABHasteSpellWait
GUICtrlSetState($i, $GUI_ENABLE)
Next
If GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED Then
$g_abSearchSpellsWaitEnable[$LB] = True
chkSpellWaitError()
If @error Then
GUICtrlSetState($g_hChkABSpellsWait, $GUI_UNCHECKED)
$g_abSearchSpellsWaitEnable[$LB] = False
SetLog("Wait for Spells disabled due training count error", $COLOR_ERROR)
EndIf
Else
$g_abSearchSpellsWaitEnable[$LB] = False
EndIf
Else
GUICtrlSetState($g_hChkABSpellsWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
For $i = $g_hPicABLightSpellWait To $g_hPicABHasteSpellWait
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkSpellWaitError()
Local Static $bHaveBeenWarned = False
Local $bErrorCondition = False
Local $sErrorText, $sText, $MsgBox1, $MsgBox2, $MsgBox3
If $g_iTotalTrainSpaceSpell > GUICtrlRead($g_hTxtTotalCountSpell) Then
$sErrorText = GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_ErrorText_01", "Total number of trained spells exceeds total set in GUI!") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_ErrorText_02", "Reduce number of trained spells,") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_ErrorText_03", "OR ELSE BOT WILL NEVER ATTACK!!") & @CRLF
$bErrorCondition = True
Else
Return
EndIf
If $bHaveBeenWarned = True And $bErrorCondition = True Then
SetError(1)
Return
ElseIf $bErrorCondition = False Then
Return
EndIf
Local $iCount = 0
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xE00000, 0xFFFF00, 12, "Comic Sans MS", 480)
$sText = $sErrorText & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_01", "Click YES to close this warning message") & @CRLF
$MsgBox1 = _ExtMsgBox(48, GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_02", "YES, I Understand Warning|No"), GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_03", "Wait for Spells Warning!"), $sText, 30, $g_hFrmBot)
Switch $MsgBox1
Case 1
$bHaveBeenWarned = True
ExitLoop
Case Else
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xFFFF00 , 0xE00000, 12, "Comic Sans MS", 480)
$stext = GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_04", "Sorry, must understand warning and click Yes!") & @CRLF
$MsgBox2 = _ExtMsgBox(16, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_07", "User Input Error"), $stext, 15, $g_hFrmBot)
If $iCount = 1 And $MsgBox1 = 9 And $MsgBox2 = 9 Then ExitLoop
EndSwitch
$iCount += 1
If $iCount > 2 Then
$sText = GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_08", "CONGRATULATIONS!!") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_09", "You found the secret message in Bot!") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_10", "Can you find the randomly selected button to close this message?") & @CRLF & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_11", "HaHaHaHa...") & @CRLF & @CRLF & @CRLF
Local $sFunnyText = $sText
Local $iControl = 0
$iCount = 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 480)
While 1
$MsgBox3 = _ExtMsgBox(128, "1|2|3|4|5|6|7", GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_MsgBox_12", "You are a WINNER!!"), $sFunnyText, 900, $g_hFrmBot)
If @error Then SetLog("_ExtMsgBox error: " & @error, $COLOR_ERROR)
If $iCount > 7 And Int($MsgBox3) = Random(1,8,1) Then
ExitLoop
Else
If $iCount <= 7 Then
$iControl = $iCount
Else
$iControl = $MsgBox3
EndIf
Switch $iControl
Case 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x61FF00, 0x020028, 12, "Arial", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_01", "Sorry not that button!") & @CRLF
Case 2
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xDC00FF, 0x011E00, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_02", "Donate £5000 to MyBot.run while you wait 15 minutes for this to time out?") & @CRLF
Case 3
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x000000, 0xFFFFFF, 12, "Tahoma", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_03", "Having trouble finding the exit button?") & @CRLF
Case 4
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x4800FF, 0xD800FF, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_04", "This is fun, can we keep going all day?") & @CRLF
Case 5
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Times New Roman", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_05", "Try four more times, you have to get lucky sooner or later!") & @CRLF
Case 6
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x00FFED, 0x010051, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_06", "Do you have a Banana? This code monkey is Hungry!") & @CRLF
Case 7
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xFF6600, 0x013000, 12, "Lucida Console", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_07", "Maybe try hitting same button till you and Mr. Random pick same?") & @CRLF
Case 0
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x000000, 0xFFFFFF, 12, "Tahoma", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_08", "Sorry, can not 'escape' from this!") & @CRLF
Case Else
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslatedFileIni("MBR GUI Control Tab Search", "Func_chkSpellWaitError_FunnyText_09", "Program error! Programmers can ruin a good joke.") & @CRLF
ExitLoop 2
EndSwitch
$iCount += 1
EndIf
WEnd
EndIf
WEnd
If $bErrorCondition = True Then
SetError(1)
Return
EndIf
EndFunc
Func CmbDBTH()
_GUI_Value_STATE("HIDE", $g_aGroupListPicDBMaxTH)
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbDBTH) + 6
GUICtrlSetState($g_ahPicDBMaxTH[$iCmbValue], $GUI_SHOW)
EndFunc
Func CmbABTH()
_GUI_Value_STATE("HIDE", $g_aGroupListPicABMaxTH)
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbABTH) + 6
GUICtrlSetState($g_ahPicABMaxTH[$iCmbValue], $GUI_SHOW)
EndFunc
Func CmbBullyMaxTH()
_GUI_Value_STATE("HIDE", $g_aGroupListPicBullyMaxTH)
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbBullyMaxTH) + 6
GUICtrlSetState($g_ahPicBullyMaxTH[$iCmbValue], $GUI_SHOW)
EndFunc
Func dbCheckAll()
If BitAND(GUICtrlRead($g_hChkDBActivateSearches), GUICtrlRead($g_hChkDBActivateTropies), GUICtrlRead($g_hChkDBActivateCamps), GUICtrlRead($g_hChkDBSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkDeadbase, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDeadbase, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func abCheckAll()
If BitAND(GUICtrlRead($g_hChkABActivateSearches), GUICtrlRead($g_hChkABActivateTropies), GUICtrlRead($g_hChkABActivateCamps), GUICtrlRead($g_hChkABSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkActivebase, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkActivebase, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func tsCheckAll()
If BitAND(GUICtrlRead($g_hChkTSActivateSearches), GUICtrlRead($g_hChkTSActivateTropies), GUICtrlRead($g_hChkTSActivateCamps)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkTHSnipe, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkTHSnipe, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func chkNotWaitHeroes()
If $g_abAttackTypeEnable[$DB] Then $g_iSearchNotWaitHeroesEnable = $g_aiSearchNotWaitHeroesEnable[$DB]
If $g_abAttackTypeEnable[$LB] Then
If $g_iSearchNotWaitHeroesEnable <> 0 Then $g_iSearchNotWaitHeroesEnable = $g_aiSearchNotWaitHeroesEnable[$LB]
EndIf
EndFunc
Func cmbDBAlgorithm()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
_GUI_Value_STATE($iCmbValue = 1 ? "SHOW" : "HIDE", $g_aGroupAttackDBSpell & "#" & $groupIMGAttackDBSpell)
If BitAND(GUICtrlGetState($g_hGUI_DEADBASE), $GUI_SHOW) And GUICtrlRead($g_hGUI_DEADBASE_TAB) = 1 Then
Select
Case $iCmbValue = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE,$g_hGUI_DEADBASE_ATTACK_SMARTFARM)
Case $iCmbValue = 1
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE,$g_hGUI_DEADBASE_ATTACK_SMARTFARM)
Case $iCmbValue = 2
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_SHOWNOACTIVATE,$g_hGUI_DEADBASE_ATTACK_SMARTFARM)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE,$g_hGUI_DEADBASE_ATTACK_SMARTFARM)
EndSelect
EndIf
EndFunc
Func cmbABAlgorithm()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hcmbABAlgorithm)
_GUI_Value_STATE($iCmbValue = 1 ? "SHOW" : "HIDE", $groupAttackABSpell & "#" & $groupIMGAttackABSpell)
If BitAND(GUICtrlGetState($g_hGUI_ACTIVEBASE), $GUI_SHOW) And GUICtrlRead($g_hGUI_ACTIVEBASE_TAB) = 1 Then
Select
Case $iCmbValue = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
Case $iCmbValue = 1
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
EndSelect
EndIf
EndFunc
Func chkABWardenAttack()
If GUICtrlRead($g_hChkABWardenAttack) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbABWardenMode, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbABWardenMode, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBWardenAttack()
If GUICtrlRead($g_hChkDBWardenAttack) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbDBWardenMode, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbDBWardenMode, $GUI_DISABLE)
EndIf
EndFunc
Func chkABDropCC()
If GUICtrlRead($g_hChkABDropCC) = $GUI_CHECKED Then
GUICtrlSetState($g_hcmbABSiege, $GUI_ENABLE)
Else
GUICtrlSetState($g_hcmbABSiege, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBDropCC()
If GUICtrlRead($g_hChkDBDropCC) = $GUI_CHECKED Then
GUICtrlSetState($g_hcmbDBSiege, $GUI_ENABLE)
Else
GUICtrlSetState($g_hcmbDBSiege, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackNow()
If GUICtrlRead($g_hChkAttackNow) = $GUI_CHECKED Then
$g_bSearchAttackNowEnable = True
GUICtrlSetState($g_hLblAttackNow, $GUI_ENABLE)
GUICtrlSetState($g_hLblAttackNowSec, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_ENABLE)
Else
$g_bSearchAttackNowEnable = False
GUICtrlSetState($g_hLblAttackNow, $GUI_DISABLE)
GUICtrlSetState($g_hLblAttackNowSec, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_DISABLE)
EndIf
EndFunc
Func LoadThSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbAttackTHType)
GUICtrlSetData($g_hCmbAttackTHType, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbAttackTHType, _GUICtrlComboBox_FindStringExact($g_hCmbAttackTHType, $g_sAtkTSType))
EndFunc
Func LoadDBSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbTHSnipeBeforeDBScript)
GUICtrlSetData($g_hCmbTHSnipeBeforeDBScript, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, $g_iTHSnipeBeforeTiles[$DB]))
EndFunc
Func LoadABSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbTHSnipeBeforeLBScript)
GUICtrlSetData($g_hCmbTHSnipeBeforeLBScript, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, $g_iTHSnipeBeforeScript[$LB]))
EndFunc
Func cmbAttackTHType()
Local $arrayattack = _GUICtrlComboBox_GetListArray($g_hCmbAttackTHType)
$g_sAtkTSType = $arrayattack[_GUICtrlComboBox_GetCurSel($g_hCmbAttackTHType) + 1]
EndFunc
Func btnTestTHcsv()
AttackTHParseCSV(True)
EndFunc
Func cmbTSGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbTSMeetGE) < 2 Then
GUICtrlSetState($g_hTxtTSMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtTSMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtTSMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtTSMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtTSMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtTSMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkTHSnipeBeforeDBEnable()
If GUICtrlRead($g_hChkTHSnipeBeforeDBEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTHSnipeBeforeDBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeDBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeDBScript, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTHSnipeBeforeDBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeDBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeDBScript, $GUI_DISABLE)
EndIf
EndFunc
Func chkTHSnipeBeforeLBEnable()
If GUICtrlRead($g_hChkTHSnipeBeforeLBEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTHSnipeBeforeLBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeLBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeLBScript, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTHSnipeBeforeLBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeLBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeLBScript, $GUI_DISABLE)
EndIf
EndFunc
Func radHerosApply()
GUICtrlSetState($g_hRadAutoQueenAbility, $g_iActivateQueen = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadManQueenAbility, $g_iActivateQueen = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBothQueenAbility, $g_iActivateQueen = 2 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtManQueenAbility,($g_iDelayActivateQueen / 1000))
GUICtrlSetState($g_hRadAutoKingAbility, $g_iActivateKing = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadManKingAbility, $g_iActivateKing = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBothKingAbility, $g_iActivateKing = 2 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtManKingAbility,($g_iDelayActivateKing / 1000))
GUICtrlSetState($g_hRadAutoWardenAbility, $g_iActivateWarden = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadManWardenAbility, $g_iActivateWarden = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBothWardenAbility, $g_iActivateWarden = 2 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtManWardenAbility,($g_iDelayActivateWarden / 1000))
EndFunc
Func chkattackHoursE1()
If GUICtrlRead($g_ahChkAttackHoursE1) = $GUI_CHECKED And IschkattackHoursE1() Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_UNCHECKED)
EndFunc
Func IschkattackHoursE1()
For $i = 0 To 11
If GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkattackHoursE2()
If GUICtrlRead($g_ahChkAttackHoursE2) = $GUI_CHECKED And IschkattackHoursE2() Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_UNCHECKED)
EndFunc
Func IschkattackHoursE2()
For $i = 12 To 23
If GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkattackWeekDaysE()
If GUICtrlRead($g_ahChkAttackWeekdaysE) = $GUI_CHECKED And IschkAttackWeekdays() Then
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_UNCHECKED)
EndFunc
Func IschkAttackWeekdays()
For $i = 0 To 6
If GUICtrlRead($g_ahChkAttackWeekdays[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkAttackPlannerEnable()
If GUICtrlRead($g_hChkAttackPlannerEnable) = $GUI_CHECKED Then
$g_bAttackPlannerEnable = True
If GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerSuspendComputer, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
GUICtrlSetState($g_hChkAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $GUI_ENABLE)
chkAttackPlannerDayLimit()
cmbAttackPlannerRandom()
If GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_ENABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_DISABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_DISABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_ENABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_ENABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_ENABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_ENABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_ENABLE)
EndIf
Else
$g_bAttackPlannerEnable = False
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerSuspendComputer, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_DISABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackPlannerCloseCoC()
If GUICtrlRead($g_hChkAttackPlannerCloseCoC) = $GUI_CHECKED Then
$g_bAttackPlannerCloseCoC = True
Else
$g_bAttackPlannerCloseCoC = False
EndIf
EndFunc
Func chkAttackPlannerSuspendComputer()
If GUICtrlRead($g_hChkAttackPlannerSuspendComputer) = $GUI_CHECKED Then
$g_bAttackPlannerSuspendComputer = True
Else
$g_bAttackPlannerSuspendComputer = False
EndIf
EndFunc
Func chkAttackPlannerCloseAll()
If GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_CHECKED Then
$g_bAttackPlannerCloseAll = True
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
$g_bAttackPlannerCloseAll = False
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_ENABLE)
EndIf
EndFunc
Func chkAttackPlannerRandom()
If GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED Then
$g_bAttackPlannerRandomEnable = True
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_ENABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_DISABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
Else
$g_bAttackPlannerRandomEnable = False
chkAttackPlannerEnable()
EndIf
EndFunc
Func cmbAttackPlannerRandom()
$g_iAttackPlannerRandomTime = Int(_GUICtrlComboBox_GetCurSel($g_hCmbAttackPlannerRandom))
GUICtrlSetData($g_hLbAttackPlannerRandom, $g_iAttackPlannerRandomTime > 0 ? GetTranslatedFileIni("MBR Global GUI Design", "hrs", -1) : GetTranslatedFileIni("MBR Global GUI Design", "hr", "hr"))
EndFunc
Func chkAttackPlannerDayLimit()
If GUICtrlRead($g_hChkAttackPlannerDayLimit) = $GUI_CHECKED Then
$g_bAttackPlannerDayLimit = True
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerDayLimit, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_ENABLE)
Else
$g_bAttackPlannerDayLimit = False
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerDayLimit, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_DISABLE)
EndIf
_cmbAttackPlannerDayLimit()
EndFunc
Func cmbAttackPlannerDayMin()
If Int(GUICtrlRead($g_hCmbAttackPlannerDayMax)) < Int(GUICtrlRead($g_hCmbAttackPlannerDayMin)) Then
GUICtrlSetData($g_hCmbAttackPlannerDayMin, GUICtrlRead($g_hCmbAttackPlannerDayMax))
EndIf
$g_iAttackPlannerDayMin = Int(GUICtrlRead($g_hCmbAttackPlannerDayMin))
_cmbAttackPlannerDayLimit()
EndFunc
Func cmbAttackPlannerDayMax()
If Int(GUICtrlRead($g_hCmbAttackPlannerDayMax)) < Int(GUICtrlRead($g_hCmbAttackPlannerDayMin)) Then
GUICtrlSetData($g_hCmbAttackPlannerDayMax, GUICtrlRead($g_hCmbAttackPlannerDayMin))
EndIf
$g_iAttackPlannerDayMax = Int(GUICtrlRead($g_hCmbAttackPlannerDayMax))
_cmbAttackPlannerDayLimit()
EndFunc
Func _cmbAttackPlannerDayLimit()
Switch Int(GUICtrlRead($g_hCmbAttackPlannerDayMin))
Case 0 To 15
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_MONEYGREEN)
Case 16 To 20
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_YELLOW)
Case 21 To 999
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_RED)
EndSwitch
Switch Int(GUICtrlRead($g_hCmbAttackPlannerDayMax))
Case 0 To 15
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_MONEYGREEN)
Case 16 To 25
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_YELLOW)
Case 26 To 999
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_RED)
EndSwitch
EndFunc
Func chkDropCCHoursEnable()
Local $bChk = GUICtrlRead($g_hChkDropCCHoursEnable) = $GUI_CHECKED
$g_bPlannedDropCCHoursEnable =($bChk ? 1 : 0)
For $i = 0 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_ENABLE : $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkDropCCHoursE1, $bChk ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahChkDropCCHoursE2, $bChk ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDropCCHoursE1()
Local $bChk = GUICtrlRead($g_ahChkDropCCHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkDropCCHours[0]) = $GUI_CHECKED
For $i = 0 To 11
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkDropCCHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkDropCCHoursE2()
Local $bChk = GUICtrlRead($g_ahChkDropCCHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkDropCCHours[12]) = $GUI_CHECKED
For $i = 12 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkDropCCHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkShareAttack()
If GUICtrlRead($g_hChkShareAttack) = $GUI_CHECKED Then
For $i = $g_hLblShareMinLoot To $g_hTxtShareMessage
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hLblShareMinLoot To $g_hTxtShareMessage
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkSearchReduction()
If GUICtrlRead($g_hChkSearchReduction) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceCount, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGold, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceElixir, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGoldPlusElixir, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceDark, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceTrophy, False)
Else
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceCount, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGold, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGoldPlusElixir, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceElixir, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceDark, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceTrophy, True)
EndIf
EndFunc
Func sldMaxVSDelay()
$g_iSearchDelayMax = GUICtrlRead($g_hSldMaxVSDelay)
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMax)
If $g_iSearchDelayMax < $g_iSearchDelayMin Then
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMax)
GUICtrlSetData($g_hSldVSDelay, $g_iSearchDelayMax)
$g_iSearchDelayMin = $g_iSearchDelayMax
EndIf
If $g_iSearchDelayMin <= 1 Then
GUICtrlSetData($g_hLblTextVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "second", "second"))
Else
GUICtrlSetData($g_hLblTextVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"))
EndIf
If $g_iSearchDelayMax <= 1 Then
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "second", "second"))
Else
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"))
EndIf
EndFunc
Func sldVSDelay()
$g_iSearchDelayMin = GUICtrlRead($g_hSldVSDelay)
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMin)
If $g_iSearchDelayMin > $g_iSearchDelayMax Then
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hSldMaxVSDelay, $g_iSearchDelayMin)
$g_iSearchDelayMax = $g_iSearchDelayMin
EndIf
If $g_iSearchDelayMin <= 1 Then
GUICtrlSetData($g_hLblTextVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "second", "second"))
Else
GUICtrlSetData($g_hLblTextVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"))
EndIf
If $g_iSearchDelayMax <= 1 Then
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "second", "second"))
Else
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslatedFileIni("MBR Global GUI Design", "seconds", "seconds"))
EndIf
EndFunc
Func dbCheck()
$g_abAttackTypeEnable[$DB] =(GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED)
If IsBotLaunched() Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 0)
If BitAND(GUICtrlRead($g_hChkDBActivateSearches), GUICtrlRead($g_hChkDBActivateTropies), GUICtrlRead($g_hChkDBActivateCamps), GUICtrlRead($g_hChkDBSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkDBActivateSearches, $GUI_CHECKED)
chkDBActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func abCheck()
$g_abAttackTypeEnable[$LB] =(GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED)
If IsBotLaunched() Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 1)
If BitAND(GUICtrlRead($g_hChkABActivateSearches), GUICtrlRead($g_hChkABActivateTropies), GUICtrlRead($g_hChkABActivateCamps), GUICtrlRead($g_hChkABSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkABActivateSearches, $GUI_CHECKED)
chkABActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func tsCheck()
$g_abAttackTypeEnable[$TS] =(GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED)
If IsBotLaunched() Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 2)
If BitAND(GUICtrlRead($g_hChkTSActivateSearches), GUICtrlRead($g_hChkTSActivateTropies), GUICtrlRead($g_hChkTSActivateCamps)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkTSActivateSearches, $GUI_CHECKED)
chkTSActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func bullyCheck()
$g_abAttackTypeEnable[$TB] =(GUICtrlRead($g_hChkBully) = $GUI_CHECKED)
If IsBotLaunched() Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 3)
tabSEARCH()
EndFunc
Func CustomDropOrder()
GUICtrlSetState($g_hBtnCustomDropOrderDB, $GUI_DISABLE)
GUICtrlSetState($g_hBtnCustomDropOrderAB, $GUI_DISABLE)
GUICtrlSetState($g_hBtnCustomDropOrderDB1, $GUI_DISABLE)
GUISetState(@SW_SHOW, $g_hGUI_DropOrder)
EndFunc
Func CloseCustomDropOrder()
GUISetState(@SW_HIDE, $g_hGUI_DropOrder)
GUICtrlSetState($g_hBtnCustomDropOrderDB, $GUI_ENABLE)
GUICtrlSetState($g_hBtnCustomDropOrderAB, $GUI_ENABLE)
GUICtrlSetState($g_hBtnCustomDropOrderDB1, $GUI_ENABLE)
EndFunc
Func chkDropOrder()
If GUICtrlRead($g_hChkCustomDropOrderEnable) = $GUI_CHECKED Then
$g_bCustomDropOrderEnable = True
GUICtrlSetBkColor($g_hBtnCustomDropOrderDB, $COLOR_GREEN)
GUICtrlSetBkColor($g_hBtnCustomDropOrderAB, $COLOR_GREEN)
GUICtrlSetBkColor($g_hBtnCustomDropOrderDB1, $COLOR_GREEN)
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_ENABLE)
GUICtrlSetState($g_hBtnRemoveDropOrder, $GUI_ENABLE)
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
GUICtrlSetState($g_ahCmbDropOrder[$i], $GUI_ENABLE)
Next
If IsUseCustomDropOrder() = True Then _GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
$g_bCustomDropOrderEnable = False
GUICtrlSetBkColor($g_hBtnCustomDropOrderDB, $COLOR_RED)
GUICtrlSetBkColor($g_hBtnCustomDropOrderAB, $COLOR_RED)
GUICtrlSetBkColor($g_hBtnCustomDropOrderDB1, $COLOR_RED)
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRemoveDropOrder, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
GUICtrlSetState($g_ahCmbDropOrder[$i], $GUI_DISABLE)
Next
SetDefaultDropOrderGroup(False)
EndIf
EndFunc
Func GUIDropOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iDropIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
_GUICtrlSetImage($iCtrlIdImage, $g_sLibIconPath, $g_aiDropOrderIcon[$iDropIndex])
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
If $iGUI_CtrlId = $g_ahCmbDropOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$i]) Then
_GUICtrlSetImage($g_ahImgDropOrder[$i], $g_sLibIconPath, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($g_ahCmbDropOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate Then
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_ENABLE)
Return
Else
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_ENABLE)
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
EndFunc
Func BtnRemoveDropOrder()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnRemoveDropOrder")
Local $sComboData = ""
For $j = 0 To UBound($g_asDropOrderList) - 1
$sComboData &= $g_asDropOrderList[$j] & "|"
Next
For $i = 0 To $eDropOrderCount - 1
$g_aiCmbCustomDropOrder[$i] = -1
_GUICtrlComboBox_ResetContent($g_aiCmbCustomDropOrder[$i])
GUICtrlSetData($g_ahCmbDropOrder[$i], $sComboData, "")
_GUICtrlSetImage($g_ahImgDropOrder[$i], $g_sLibIconPath, $eIcnOptions)
Next
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnSilverStar)
SetDefaultDropOrderGroup(False)
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnRemoveDropOrder")
EndFunc
Func BtnDropOrderSet()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnDropOrderSet")
Local $bReady = True
Local $sNewDropList = ""
Local $bMissingDrop = False
Local $aiDropOrder[$eDropOrderCount] = [ $eTroopBarbarianS, $eTroopArcherS, $eTroopGiantS, $eTroopGoblinS, $eTroopWallBreakerS, $eTroopBalloonS, $eTroopWizardS, $eTroopHealerS, $eTroopDragonS, $eTroopPekkaS, $eTroopBabyDragonS, $eTroopMinerS, $eTroopElectroDragonS, $eTroopMinionS, $eTroopHogRiderS, $eTroopValkyrieS, $eTroopGolemS, $eTroopWitchS, $eTroopLavaHoundS, $eTroopBowlerS, $eTroopIceGolemS, $eHeroeS, $eCCS]
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
For $j = 0 To UBound($g_ahCmbDropOrder) - 1
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$i]) <> -1 And  _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$i]) = _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($g_ahCmbDropOrder[$j], -1)
_GUICtrlSetImage($g_ahImgDropOrder[$j], $g_sLibIconPath, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($g_ahCmbDropOrder[$j], $COLOR_BLACK)
EndIf
Next
$g_aiCmbCustomDropOrder[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$i])
If $g_aiCmbCustomDropOrder[$i] = -1 Then $bMissingDrop = True
Next
If $bReady And $bMissingDrop Then
For $i = 0 To UBound($g_aiCmbCustomDropOrder) - 1
For $j = 0 To UBound($aiDropOrder) - 1
If $g_aiCmbCustomDropOrder[$i] = $j Then
$aiDropOrder[$j] = -1
ExitLoop
EndIf
Next
Next
_ArrayShuffle($aiDropOrder)
For $i = 0 To UBound($g_aiCmbCustomDropOrder) - 1
If $g_aiCmbCustomDropOrder[$i] = -1 Then
For $j = 0 To UBound($aiDropOrder) - 1
If $aiDropOrder[$j] <> -1 Then
$g_aiCmbCustomDropOrder[$i] = $aiDropOrder[$j]
_GUICtrlComboBox_SetCurSel($g_ahCmbDropOrder[$i], $aiDropOrder[$j])
_GUICtrlSetImage($g_ahImgDropOrder[$i], $g_sLibIconPath, $g_aiDropOrderIcon[$g_aiCmbCustomDropOrder[$i] + 1])
$aiDropOrder[$j] = -1
ExitLoop
EndIf
Next
EndIf
Next
EndIf
If $bReady Then
ChangeDropOrder()
If @error Then
Switch @error
Case 1
SetLog("Code problem, can not continue till fixed!", $COLOR_ERROR)
Case 2
SetLog("Bad Combobox selections, please fix!", $COLOR_ERROR)
Case 3
SetLog("Unable to Change Troop Drop Order due bad change count!", $COLOR_ERROR)
Case Else
SetLog("Monkey ate bad banana, something wrong with ChangeTroopDropOrder() code!", $COLOR_ERROR)
EndSwitch
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
SetLog("Troop droping order changed successfully!", $COLOR_SUCCESS)
For $i = 0 To $eDropOrderCount - 1
$sNewDropList &= $g_asDropOrderNames[$g_aiCmbCustomDropOrder[$i]] & ", "
Next
$sNewDropList = StringTrimRight($sNewDropList, 2)
SetLog("Troops Dropping Order= " & $sNewDropList, $COLOR_INFO)
EndIf
Else
SetLog("Must use all troops and No duplicate troop names!", $COLOR_ERROR)
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnDropOrderSet")
EndFunc
Func IsUseCustomDropOrder()
For $i = 0 To UBound($g_aiCmbCustomDropOrder) - 1
If $g_aiCmbCustomDropOrder[$i] = -1 Then
Return False
EndIf
Next
Return True
EndFunc
Func ChangeDropOrder()
If $g_bDebugSetlog Then SetDebugLog("Begin Func ChangeDropOrder()", $COLOR_DEBUG)
Local $NewDropOrder[$eDropOrderCount]
Local $iUpdateCount = 0
If Not IsUseCustomDropOrder() Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
Local $sComboText = GUICtrlRead($g_ahCmbDropOrder[$i])
For $j = 0 To UBound($g_asDropOrderList) - 1
If $sComboText = $g_asDropOrderList[$j] Then
$NewDropOrder[$i] = $j - 1
$iUpdateCount += 1
ExitLoop
EndIf
Next
Next
If $iUpdateCount = $eDropOrderCount Then
For $i = 0 To $eDropOrderCount - 1
$g_aiCmbCustomDropOrder[$i] = $NewDropOrder[$i]
Next
_GUICtrlSetImage($g_ahImgDropOrderSet, $g_sLibIconPath, $eIcnGreenLight)
Else
SetLog($iUpdateCount & "|" & $eDropOrderCount & " - Error - Bad troop assignment in ChangeTroopDropOrder()", $COLOR_ERROR)
Return
EndIf
Return True
EndFunc
Func SetDefaultDropOrderGroup($bSetLog = True)
For $i = 0 To $eDropOrderCount - 1
$g_aiDropOrder[$i] = $i
Next
If $bSetLog And $g_bCustomDropOrderEnable Then SetLog("Default drop order set", $COLOR_SUCCESS)
EndFunc
Func chkStopAtkDBNoLoot1()
If GUICtrlRead($g_hChkStopAtkDBNoLoot1) = $GUI_CHECKED Then
$g_abStopAtkNoLoot1Enable[$DB] = True
GUICtrlSetState($g_hTxtStopAtkDBNoLoot1, $GUI_ENABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot1b, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot1Enable[$DB] = False
GUICtrlSetState($g_hTxtStopAtkDBNoLoot1, $GUI_DISABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot1b, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkDBNoLoot2()
If GUICtrlRead($g_hChkStopAtkDBNoLoot2) = $GUI_CHECKED Then
$g_abStopAtkNoLoot2Enable[$DB] = True
GUICtrlSetState($g_hTxtStopAtkDBNoLoot2, $GUI_ENABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot2b, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinGoldStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinDarkElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBMinRerourcesAtk2, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot2Enable[$DB] = False
GUICtrlSetState($g_hTxtStopAtkDBNoLoot2, $GUI_DISABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot2b, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinGoldStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinDarkElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBMinRerourcesAtk2, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkABNoLoot1()
If GUICtrlRead($g_hChkStopAtkABNoLoot1) = $GUI_CHECKED Then
$g_abStopAtkNoLoot1Enable[$LB] = True
GUICtrlSetState($g_hTxtStopAtkABNoLoot1, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTimeStopAtk, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot1Enable[$LB] = False
GUICtrlSetState($g_hTxtStopAtkABNoLoot1, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTimeStopAtk, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkABNoLoot2()
If GUICtrlRead($g_hChkStopAtkABNoLoot2) = $GUI_CHECKED Then
$g_abStopAtkNoLoot2Enable[$LB] = True
GUICtrlSetState($g_hTxtStopAtkABNoLoot2, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTimeStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinGoldStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinDarkElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hLblABMinRerourcesAtk2, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot2Enable[$LB] = False
GUICtrlSetState($g_hTxtStopAtkABNoLoot2, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTimeStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinGoldStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinDarkElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hLblABMinRerourcesAtk2, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBEndPercentHigher()
If GUICtrlRead($g_hChkDBEndPercentHigher) = $GUI_CHECKED Then
$g_abStopAtkPctHigherEnable[$DB] = True
GUICtrlSetState($g_hTxtDBPercentHigher, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBPercentHigherSec, $GUI_ENABLE)
Else
$g_abStopAtkPctHigherEnable[$DB] = False
GUICtrlSetState($g_hTxtDBPercentHigher, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBPercentHigherSec, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBEndPercentChange()
If GUICtrlRead($g_hChkDBEndPercentChange) = $GUI_CHECKED Then
$g_abStopAtkPctNoChangeEnable[$DB] = True
GUICtrlSetState($g_hTxtDBPercentChange, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBPercentChangeSec, $GUI_ENABLE)
Else
$g_abStopAtkPctNoChangeEnable[$DB] = False
GUICtrlSetState($g_hTxtDBPercentChange, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBPercentChangeSec, $GUI_DISABLE)
EndIf
EndFunc
Func chkABEndPercentHigher()
If GUICtrlRead($g_hChkABEndPercentHigher) = $GUI_CHECKED Then
$g_abStopAtkPctHigherEnable[$LB] = True
GUICtrlSetState($g_hTxtABPercentHigher, $GUI_ENABLE)
GUICtrlSetState($g_hLblABPercentHigherSec, $GUI_ENABLE)
Else
$g_abStopAtkPctHigherEnable[$LB] = False
GUICtrlSetState($g_hTxtABPercentHigher, $GUI_DISABLE)
GUICtrlSetState($g_hLblABPercentHigherSec, $GUI_DISABLE)
EndIf
EndFunc
Func chkABEndPercentChange()
If GUICtrlRead($g_hChkABEndPercentChange) = $GUI_CHECKED Then
$g_abStopAtkPctNoChangeEnable[$LB] = True
GUICtrlSetState($g_hTxtABPercentChange, $GUI_ENABLE)
GUICtrlSetState($g_hLblABPercentChangeSec, $GUI_ENABLE)
Else
$g_abStopAtkPctNoChangeEnable[$LB] = False
GUICtrlSetState($g_hTxtABPercentChange, $GUI_DISABLE)
GUICtrlSetState($g_hLblABPercentChangeSec, $GUI_DISABLE)
EndIf
EndFunc
Func chkDESideEB()
If GUICtrlRead($g_hChkDESideEB) = $GUI_CHECKED Then
For $i = $g_hTxtDELowEndMin To $g_hLblDEEndAq
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hTxtDELowEndMin To $g_hLblDEEndAq
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkTSMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtTSMinDarkElixir, GUICtrlRead($g_hChkTSMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func btnConfigureReplayShare()
EndFunc
Func chkTakeLootSS()
GUICtrlSetState($g_hChkScreenshotLootInfo, GUICtrlRead($g_hChkTakeLootSS) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkTSActivateCamps2()
If GUICtrlRead($g_hChkTSActivateCamps2) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTSArmyCamps2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSArmyCamps2, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTSArmyCamps2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSArmyCamps2, $GUI_DISABLE)
EndIf
EndFunc
Func chkSmartLightSpell()
If GUICtrlRead($g_hChkSmartLightSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkSmartZapDB, $GUI_ENABLE)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $GUI_ENABLE)
GUICtrlSetState($g_hChkSmartZapFTW, $GUI_ENABLE)
GUICtrlSetState($g_hChkNoobZap, $GUI_ENABLE)
GUICtrlSetState($g_hChkSmartEQSpell, $GUI_ENABLE)
GUICtrlSetState($g_hLblSmartUseLSpell, $GUI_SHOW)
If GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_ENABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
EndIf
$g_bSmartZapEnable = True
Else
GUICtrlSetState($g_hChkSmartZapDB, $GUI_DISABLE)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $GUI_DISABLE)
GUICtrlSetState($g_hChkSmartZapFTW, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_DISABLE)
GUICtrlSetState($g_hChkNoobZap, $GUI_DISABLE)
GUICtrlSetState($g_hChkSmartEQSpell, $GUI_DISABLE)
GUICtrlSetState($g_hLblSmartUseLSpell, $GUI_HIDE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
$g_bSmartZapEnable = False
EndIf
EndFunc
Func chkNoobZap()
If GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_ENABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_ENABLE)
$g_bNoobZap = True
Else
GUICtrlSetState($g_hTxtSmartZapMinDE, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
$g_bNoobZap = False
EndIf
EndFunc
Func chkEarthQuakeZap()
If GUICtrlRead($g_hChkSmartEQSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblSmartUseEQSpell, $GUI_SHOW)
$g_bEarthQuakeZap = True
Else
GUICtrlSetState($g_hLblSmartUseEQSpell, $GUI_HIDE)
$g_bEarthQuakeZap = False
EndIf
EndFunc
Func chkSmartZapDB()
$g_bSmartZapDB =(GUICtrlRead($g_hChkSmartZapDB) = $GUI_CHECKED)
EndFunc
Func chkSmartZapFTW()
$g_bSmartZapFTW =(GUICtrlRead($g_hChkSmartZapFTW) = $GUI_CHECKED)
EndFunc
Func chkSmartZapSaveHeroes()
$g_bSmartZapSaveHeroes =(GUICtrlRead($g_hChkSmartZapSaveHeroes) = $GUI_CHECKED)
EndFunc
Func txtMinDark()
$g_iSmartZapMinDE = GUICtrlRead($g_hTxtSmartZapMinDE)
EndFunc
Func txtExpectedDE()
$g_iSmartZapExpectedDE = GUICtrlRead($g_hTxtSmartExpectedDE)
EndFunc
Func btnLoots()
Run("Explorer.exe " & $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots")
EndFunc
Func btnLogs()
Run("Explorer.exe " & $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs")
EndFunc
Func btnResetStats()
ResetStats()
EndFunc
Func UpdateMultiStats($bCheckSwitchAccEnable = True)
Local $bEnableSwitchAcc = $g_iCmbSwitchAcc > 0
Local $iCmbTotalAcc = _GUICtrlComboBox_GetCurSel($g_hCmbTotalAccount) + 1
If Not $bCheckSwitchAccEnable Then $bEnableSwitchAcc = True
For $i = 0 To 7
If $bEnableSwitchAcc And $i <= $iCmbTotalAcc Then
_GUI_Value_STATE("SHOW", $g_ahGrpDefaultAcc[$i])
If GUICtrlGetState($g_ahLblHourlyStatsGoldAcc[$i]) = $GUI_ENABLE + $GUI_HIDE Then _GUI_Value_STATE("SHOW", $g_ahGrpReportAcc[$i])
_GUI_Value_STATE("SHOW", $g_hPicHeroGrayStatus[0][$i] & "#" & $g_hPicHeroGrayStatus[1][$i] & "#" & $g_hPicHeroGrayStatus[2][$i] & "#" & $g_hPicLabGrayStatus[$i])
If GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED Then
If GUICtrlRead($g_ahChkDonate[$i]) = $GUI_UNCHECKED Then
GUICtrlSetData($g_ahGrpVillageAcc[$i], GUICtrlRead($g_ahCmbProfile[$i]) & " (Active)")
Else
GUICtrlSetData($g_ahGrpVillageAcc[$i], GUICtrlRead($g_ahCmbProfile[$i]) & " (Donate)")
EndIf
Else
GUICtrlSetData($g_ahGrpVillageAcc[$i], GUICtrlRead($g_ahCmbProfile[$i]) & " (Idle)")
EndIf
Else
_GUI_Value_STATE("HIDE", $g_ahGrpDefaultAcc[$i] & "#" & $g_ahGrpReportAcc[$i] & "#" & $g_ahGrpStatsAcc[$i])
_GUI_Value_STATE("HIDE", $g_hPicHeroGrayStatus[0][$i] & "#" & $g_hPicHeroGrayStatus[1][$i] & "#" & $g_hPicHeroGrayStatus[2][$i] & "#" & $g_hPicLabGrayStatus[$i])
EndIf
Next
EndFunc
Func SwitchVillageInfo()
For $i = 0 To 7
If @GUI_CtrlId = $g_ahPicArrowLeft[$i] Or @GUI_CtrlId = $g_ahPicArrowRight[$i] Then
Return _SwitchVillageInfo($i)
EndIf
Next
EndFunc
Func _SwitchVillageInfo($i)
If GUICtrlGetState($g_ahLblResultGoldNowAcc[$i]) = $GUI_ENABLE + $GUI_SHOW Then
_GUI_Value_STATE("HIDE", $g_ahGrpReportAcc[$i])
_GUI_Value_STATE("SHOW", $g_ahGrpStatsAcc[$i])
Else
_GUI_Value_STATE("HIDE", $g_ahGrpStatsAcc[$i])
_GUI_Value_STATE("SHOW", $g_ahGrpReportAcc[$i])
EndIf
EndFunc
Func checkCollectors($log = False, $showLabel = True)
Local $anyCollectorsEnabled = 0
For $i = 6 To 13
If $g_abCollectorLevelEnabled[$i] Then
$anyCollectorsEnabled = 1
ExitLoop
EndIf
Next
If $anyCollectorsEnabled = 0 Then
If $showLabel Then GUICtrlSetState($g_hLblCollectorWarning, $GUI_SHOW)
If $log Then
SetLog("Warning: Dead base is enabled, but no collectors are selected!", $COLOR_ERROR)
SetLog("Dead base will never be found!", $COLOR_ERROR)
SetLog("Select some in Attack Plan-Search&Attack-DeadBase-Collectors", $COLOR_ERROR)
Return False
EndIf
ElseIf $anyCollectorsEnabled = 1 Then
If $showLabel Then GUICtrlSetState($g_hLblCollectorWarning, $GUI_HIDE)
Return True
EndIf
Return False
EndFunc
Func chkDBCollector()
For $i = 6 To 13
If $g_ahChkDBCollectorLevel[$i] = @GUI_CtrlId Then
If $i = 6 Then
$g_abCollectorLevelEnabled[6] = False
GUICtrlSetState($g_ahCmbDBCollectorLevel[6], $GUI_DISABLE)
Else
$g_abCollectorLevelEnabled[$i] =(GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED ? True : False)
GUICtrlSetState($g_ahCmbDBCollectorLevel[$i], GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndIf
ExitLoop
EndIf
Next
checkCollectors()
EndFunc
Func cmbDBCollector()
For $i = 6 To 13
If $g_ahCmbDBCollectorLevel[$i] = @GUI_CtrlId Then
$g_aiCollectorLevelFill[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbDBCollectorLevel[$i])
ExitLoop
EndIf
Next
EndFunc
Func sldCollectorTolerance()
$g_iCollectorToleranceOffset = GUICtrlRead($g_hSldCollectorTolerance)
EndFunc
Func cmbMinCollectorMatches()
$g_iCollectorMatchesMin = _GUICtrlComboBox_GetCurSel($g_hCmbMinCollectorMatches) + 1
EndFunc
Func chkRandomSpeedAtkAB()
If GUICtrlRead($g_hChkRandomSpeedAtkAB) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbStandardUnitDelayAB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayAB, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbStandardUnitDelayAB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayAB, $GUI_ENABLE)
EndIf
EndFunc
Func chkSmartAttackRedAreaAB()
If GUICtrlRead($g_hChkSmartAttackRedAreaAB) = $GUI_CHECKED Then
$g_abAttackStdSmartAttack[$LB] = 1
For $i = $g_hLblSmartDeployAB To $g_hPicAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_SHOW)
Next
Else
$g_abAttackStdSmartAttack[$LB] = 0
For $i = $g_hLblSmartDeployAB To $g_hPicAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
EndFunc
Func chkRandomSpeedAtkDB()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
If $iCmbValue = 0 Then
If GUICtrlRead($g_hChkRandomSpeedAtkDB) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkRandomSpeedAtkDB1, $GUI_CHECKED)
GUICtrlSetState($g_hCmbStandardUnitDelayDB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardUnitDelayDB1, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB1, $GUI_DISABLE)
Else
GUICtrlSetState($g_hChkRandomSpeedAtkDB1, $GUI_UNCHECKED)
GUICtrlSetState($g_hCmbStandardUnitDelayDB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardUnitDelayDB1, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB1, $GUI_ENABLE)
chkSpeedAtkDB()
EndIf
EndIf
If $iCmbValue = 2 Then
If GUICtrlRead($g_hChkRandomSpeedAtkDB1) = $GUI_CHECKED And $iCmbValue = 2 Then
GUICtrlSetState($g_hChkRandomSpeedAtkDB, $GUI_CHECKED)
GUICtrlSetState($g_hCmbStandardUnitDelayDB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardUnitDelayDB1, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB1, $GUI_DISABLE)
Else
GUICtrlSetState($g_hChkRandomSpeedAtkDB, $GUI_UNCHECKED)
GUICtrlSetState($g_hCmbStandardUnitDelayDB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardUnitDelayDB1, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB1, $GUI_ENABLE)
chkSpeedAtkDB()
EndIf
EndIf
EndFunc
Func chkSpeedAtkDB()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
If $iCmbValue = 2 And GUICtrlRead($g_hChkRandomSpeedAtkDB1) = $GUI_UNCHECKED then
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayDB, _GUICtrlComboBox_GetCurSel($g_hCmbStandardUnitDelayDB1))
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayDB, _GUICtrlComboBox_GetCurSel($g_hCmbStandardWaveDelayDB1))
ElseIf $iCmbValue = 0 And GUICtrlRead($g_hChkRandomSpeedAtkDB) = $GUI_UNCHECKED then
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayDB1, _GUICtrlComboBox_GetCurSel($g_hCmbStandardUnitDelayDB))
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayDB1, _GUICtrlComboBox_GetCurSel($g_hCmbStandardWaveDelayDB))
EndIf
EndFunc
Func chkSmartAttackRedAreaDB()
If GUICtrlRead($g_hChkSmartAttackRedAreaDB) = $GUI_CHECKED Then
$g_abAttackStdSmartAttack[$DB] = 1
For $i = $g_hLblSmartDeployDB To $g_hPicAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_SHOW)
Next
Else
$g_abAttackStdSmartAttack[$DB] = 0
For $i = $g_hLblSmartDeployDB To $g_hPicAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
EndFunc
Func PopulateComboScriptsFilesDB()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbScriptNameDB)
GUICtrlSetData($g_hCmbScriptNameDB, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, ""))
GUICtrlSetData($g_hLblNotesScriptDB, "")
EndFunc
Func PopulateComboScriptsFilesAB()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbScriptNameAB)
GUICtrlSetData($g_hCmbScriptNameAB, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, ""))
GUICtrlSetData($g_hLblNotesScriptAB, "")
EndFunc
Func cmbScriptNameDB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameDB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$tempvect = StringSplit($line, "|", 2)
If UBound($tempvect) >= 2 Then
If StringStripWS(StringUpper($tempvect[0]), 2) = "NOTE" Then $result &= $tempvect[1] & @CRLF
EndIf
WEnd
FileClose($f)
EndIf
GUICtrlSetData($g_hLblNotesScriptDB, $result)
EndFunc
Func cmbScriptNameAB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameAB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$tempvect = StringSplit($line, "|", 2)
If UBound($tempvect) >= 2 Then
If StringStripWS(StringUpper($tempvect[0]), 2) = "NOTE" Then $result &= $tempvect[1] & @CRLF
EndIf
WEnd
FileClose($f)
EndIf
GUICtrlSetData($g_hLblNotesScriptAB, $result)
EndFunc
Func UpdateComboScriptNameDB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
PopulateComboScriptsFilesDB()
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $scriptname))
cmbScriptNameDB()
EndFunc
Func UpdateComboScriptNameAB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
PopulateComboScriptsFilesAB()
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $scriptname))
cmbScriptNameAB()
EndFunc
Func EditScriptDB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameDB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB) + 1]
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
ShellExecute("notepad.exe", $g_sCSVAttacksPath & "\" & $filename & ".csv")
EndIf
EndFunc
Func EditScriptAB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameAB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB) + 1]
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
ShellExecute("notepad.exe", $g_sCSVAttacksPath & "\" & $filename & ".csv")
EndIf
EndFunc
Func AttackCSVAssignDefaultScriptName()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
$NewFile = FileFindNextFile($FileSearch)
If @error Then $output = ""
$output = StringLeft($NewFile, StringLen($NewFile) - 4)
FileClose($FileSearch)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $output))
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $output))
cmbScriptNameDB()
cmbScriptNameAB()
EndFunc
Local $temp1 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Create", "Create New Script File"), $temp2 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_0", "New Script Filename")
Local $temp3 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", "File exists, please input a new name"), $temp4 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", "An error occurred when creating the file.")
Local $temp1 = 0, $temp2 = 0, $temp3 = 0, $temp4 = 0
Func NewScriptDB()
Local $filenameScript = InputBox(GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Create", -1), GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_0", -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", -1))
Else
Local $hFileOpen = FileOpen($g_sCSVAttacksPath & "\" & $filenameScript & ".csv", $FO_APPEND)
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$DB] = $filenameScript
UpdateComboScriptNameDB()
UpdateComboScriptNameAB()
EndIf
EndIf
EndIf
EndFunc
Func NewScriptAB()
Local $filenameScript = InputBox(GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Create", -1), GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_0", -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", -1))
Else
Local $hFileOpen = FileOpen($g_sCSVAttacksPath & "\" & $filenameScript & ".csv", $FO_APPEND)
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$LB] = $filenameScript
UpdateComboScriptNameAB()
UpdateComboScriptNameDB()
EndIf
EndIf
EndIf
EndFunc
Local $temp1 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_0", "Copy to New Script File"), $temp2 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_1", "Copy"), $temp3 = GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_1", "to New Script Filename")
Local $temp1 = 0, $temp2 = 0, $temp3 = 0
Func DuplicateScriptDB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$DB] = $scriptname
Local $filenameScript = InputBox(GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_0", -1), GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_1", -1) & ": <" & $g_sAttackScrScriptName[$DB] & ">" & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_1", -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", -1))
Else
Local $hFileOpen = FileCopy($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$DB] & ".csv", $g_sCSVAttacksPath & "\" & $filenameScript & ".csv")
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$DB] = $filenameScript
UpdateComboScriptNameDB()
UpdateComboScriptNameAB()
EndIf
EndIf
EndIf
EndFunc
Func DuplicateScriptAB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$LB] = $scriptname
Local $filenameScript = InputBox(GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_0", -1), GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Copy_1", -1) & ": <" & $g_sAttackScrScriptName[$LB] & ">" & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_New_1", -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_File-exists", -1))
Else
Local $hFileOpen = FileCopy($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$LB] & ".csv", $g_sCSVAttacksPath & "\" & $filenameScript & ".csv")
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslatedFileIni("MBR Popups", "Func_AttackCSVAssignDefaultScriptName_Error", -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$LB] = $filenameScript
UpdateComboScriptNameAB()
UpdateComboScriptNameDB()
EndIf
EndIf
EndIf
EndFunc
Func ApplyScriptDB()
Local $iApply = 0
Local $aiCSVTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aiCSVSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aiCSVHeros[$eHeroCount][2] = [[0, 0], [0, 0], [0, 0]]
Local $iCSVRedlineRoutineItem = 0, $iCSVDroplineEdgeItem = 0
Local $sCSVCCReq = ""
Local $aTemp = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameDB)
Local $sFilename = $aTemp[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB) + 1]
SetLog("CSV settings apply starts: " & $sFilename, $COLOR_INFO)
$iApply = ParseAttackCSV_Settings_variables($aiCSVTroops, $aiCSVSpells, $aiCSVHeros, $iCSVRedlineRoutineItem, $iCSVDroplineEdgeItem, $sCSVCCReq, $sFilename)
If Not $iApply Then
SetLog("CSV settings apply failed", $COLOR_ERROR)
Return
EndIf
$iApply = 0
For $i = 0 To UBound($aiCSVTroops) - 1
If $aiCSVTroops[$i] > 0 Then $iApply += 1
Next
For $i = 0 To UBound($aiCSVSpells) - 1
If $aiCSVSpells[$i] > 0 Then $iApply += 1
Next
If $iApply > 0 Then
For $t = 0 To UBound($aiCSVTroops) - 1
If $aiCSVTroops[$t] > 0 And $g_aiTrainArmyTroopLevel[$t] = 0 Then $g_aiTrainArmyTroopLevel[$t] = 1
Next
$g_aiArmyCompTroops = $aiCSVTroops
For $s = 0 To UBound($aiCSVSpells) - 1
If $aiCSVSpells[$s] > 0 And $g_aiTrainArmySpellLevel[$s] = 0 Then $g_aiTrainArmySpellLevel[$s] = 1
Next
$g_aiArmyCompSpells = $aiCSVSpells
ApplyConfig_600_52_2("Read")
SetComboTroopComp()
lblTotalCountSpell2()
SetLog("CSV Train settings applied", $COLOR_SUCCESS)
EndIf
$iApply = 0
For $i = 0 To UBound($aiCSVHeros) - 1
If $aiCSVHeros[$i][0] > 0 Then $iApply += 1
Next
If $iApply > 0 Then
For $h = 0 To UBound($aiCSVHeros) - 1
If $aiCSVHeros[$h][0] > 0 Then
Switch $h
Case $eHeroBarbarianKing
$g_iActivateKing = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateKing = $aiCSVHeros[$h][1]
Case $eHeroArcherQueen
$g_iActivateQueen = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateQueen = $aiCSVHeros[$h][1]
Case $eHeroGrandWarden
$g_iActivateWarden = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateWarden = $aiCSVHeros[$h][1]
EndSwitch
EndIf
Next
radHerosApply()
SetLog("CSV Hero Ability settings applied", $COLOR_SUCCESS)
GUICtrlSetState($g_hChkDBKingAttack, $aiCSVHeros[$eHeroBarbarianKing][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkDBKingAttack))
GUICtrlSetState($g_hChkDBQueenAttack, $aiCSVHeros[$eHeroArcherQueen][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkDBQueenAttack))
GUICtrlSetState($g_hChkDBWardenAttack, $aiCSVHeros[$eHeroGrandWarden][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkDBWardenAttack))
SetLog("CSV 'Attack with' Hero settings applied", $COLOR_SUCCESS)
EndIf
If $sCSVCCReq <> "" Then
GUICtrlSetState($g_hChkDBDropCC, $GUI_CHECKED)
SetLog("CSV 'Attack with' CC settings applied", $COLOR_SUCCESS)
EndIf
$iApply = 0
Local $ahChkDBSpell = StringSplit($g_aGroupAttackDBSpell, "#", 2)
If IsArray($ahChkDBSpell) Then
For $i = 0 To UBound($ahChkDBSpell) - 1
GUICtrlSetState($ahChkDBSpell[$i], $aiCSVSpells[$i] > 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
If $aiCSVSpells[$i] > 0 Then $iApply += 1
Next
If $iApply > 0 Then SetLog("CSV 'Attack with' Spell settings applied", $COLOR_SUCCESS)
EndIf
If $iCSVRedlineRoutineItem > 0 And $iCSVRedlineRoutineItem <= _GUICtrlComboBox_GetCount($g_hCmbScriptRedlineImplDB) + 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplDB, $iCSVRedlineRoutineItem - 1)
cmbScriptRedlineImplDB()
SetLog("CSV Red Line settings applied", $COLOR_SUCCESS)
Else
If $iCSVRedlineRoutineItem <> 0 Then SetLog("CSV Red Line settings out of bounds", $COLOR_ERROR)
EndIf
If $iCSVDroplineEdgeItem > 0 And $iCSVDroplineEdgeItem <= _GUICtrlComboBox_GetCount($g_hCmbScriptDroplineDB) + 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineDB, $iCSVDroplineEdgeItem - 1)
cmbScriptDroplineDB()
SetLog("CSV Drop Line settings applied", $COLOR_SUCCESS)
Else
If $iCSVDroplineEdgeItem <> 0 Then SetLog("CSV Drop Line settings out of bounds", $COLOR_ERROR)
EndIf
If $sCSVCCReq <> "" Then
$g_bRequestTroopsEnable = True
$g_sRequestTroopsText = $sCSVCCReq
ApplyConfig_600_11("Read")
SetLog("CSV CC Request settings applied", $COLOR_SUCCESS)
EndIf
EndFunc
Func ApplyScriptAB()
Local $iApply = 0
Local $aiCSVTroops[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aiCSVSpells[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aiCSVHeros[$eHeroCount][2] = [[0, 0], [0, 0], [0, 0]]
Local $iCSVRedlineRoutineItem = 0, $iCSVDroplineEdgeItem = 0
Local $sCSVCCReq = ""
Local $aTemp = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameAB)
Local $sFilename = $aTemp[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB) + 1]
SetLog("CSV settings apply starts: " & $sFilename, $COLOR_INFO)
$iApply = ParseAttackCSV_Settings_variables($aiCSVTroops, $aiCSVSpells, $aiCSVHeros, $iCSVRedlineRoutineItem, $iCSVDroplineEdgeItem, $sCSVCCReq, $sFilename)
If Not $iApply Then
SetLog("CSV settings apply failed", $COLOR_ERROR)
Return
EndIf
$iApply = 0
For $i = 0 To UBound($aiCSVTroops) - 1
If $aiCSVTroops[$i] > 0 Then $iApply += 1
Next
For $i = 0 To UBound($aiCSVSpells) - 1
If $aiCSVSpells[$i] > 0 Then $iApply += 1
Next
If $iApply > 0 Then
For $t = 0 To UBound($aiCSVTroops) - 1
If $aiCSVTroops[$t] > 0 And $g_aiTrainArmyTroopLevel[$t] = 0 Then $g_aiTrainArmyTroopLevel[$t] = 1
Next
$g_aiArmyCompTroops = $aiCSVTroops
For $s = 0 To UBound($aiCSVSpells) - 1
If $aiCSVSpells[$s] > 0 And $g_aiTrainArmySpellLevel[$s] = 0 Then $g_aiTrainArmySpellLevel[$s] = 1
Next
$g_aiArmyCompSpells = $aiCSVSpells
ApplyConfig_600_52_2("Read")
SetComboTroopComp()
lblTotalCountSpell2()
SetLog("CSV Train settings applied", $COLOR_SUCCESS)
EndIf
$iApply = 0
For $i = 0 To UBound($aiCSVHeros) - 1
If $aiCSVHeros[$i][0] > 0 Then $iApply += 1
Next
If $iApply > 0 Then
For $h = 0 To UBound($aiCSVHeros) - 1
If $aiCSVHeros[$h][0] > 0 Then
Switch $h
Case $eHeroBarbarianKing
$g_iActivateKing = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateKing = $aiCSVHeros[$h][1]
Case $eHeroArcherQueen
$g_iActivateQueen = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateQueen = $aiCSVHeros[$h][1]
Case $eHeroGrandWarden
$g_iActivateWarden = $aiCSVHeros[$h][0] - 1
$g_iDelayActivateWarden = $aiCSVHeros[$h][1]
EndSwitch
EndIf
Next
radHerosApply()
SetLog("CSV Hero Ability settings applied", $COLOR_SUCCESS)
GUICtrlSetState($g_hChkABKingAttack, $aiCSVHeros[$eHeroBarbarianKing][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkABKingAttack))
GUICtrlSetState($g_hChkABQueenAttack, $aiCSVHeros[$eHeroArcherQueen][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkABQueenAttack))
GUICtrlSetState($g_hChkABWardenAttack, $aiCSVHeros[$eHeroGrandWarden][0] > 0 ? $GUI_CHECKED : GUICtrlGetState($g_hChkABWardenAttack))
SetLog("CSV 'Attack with' Hero settings applied", $COLOR_SUCCESS)
EndIf
If $sCSVCCReq <> "" Then
GUICtrlSetState($g_hChkABDropCC, $GUI_CHECKED)
SetLog("CSV 'Attack with' CC settings applied", $COLOR_SUCCESS)
EndIf
$iApply = 0
Local $ahChkABSpell = StringSplit($GroupAttackABSpell, "#", 2)
If IsArray($ahChkABSpell) Then
For $i = 0 To UBound($ahChkABSpell) - 1
GUICtrlSetState($ahChkABSpell[$i], $aiCSVSpells[$i] > 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
If $aiCSVSpells[$i] > 0 Then $iApply += 1
Next
If $iApply > 0 Then SetLog("CSV 'Attack with' Spell settings applied", $COLOR_SUCCESS)
EndIf
If $iCSVRedlineRoutineItem > 0 And $iCSVRedlineRoutineItem <= _GUICtrlComboBox_GetCount($g_hCmbScriptRedlineImplAB) + 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplAB, $iCSVRedlineRoutineItem - 1)
cmbScriptRedlineImplAB()
SetLog("CSV Red Line settings applied", $COLOR_SUCCESS)
Else
If $iCSVRedlineRoutineItem <> 0 Then SetLog("CSV Red Line settings out of bounds", $COLOR_ERROR)
EndIf
If $iCSVDroplineEdgeItem > 0 And $iCSVDroplineEdgeItem <= _GUICtrlComboBox_GetCount($g_hCmbScriptDroplineAB) + 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineAB, $iCSVDroplineEdgeItem - 1)
cmbScriptDroplineAB()
SetLog("CSV Drop Line settings applied", $COLOR_SUCCESS)
Else
If $iCSVDroplineEdgeItem <> 0 Then SetLog("CSV Drop Line settings out of bounds", $COLOR_ERROR)
EndIf
If $sCSVCCReq <> "" Then
$g_bRequestTroopsEnable = True
$g_sRequestTroopsText = $sCSVCCReq
ApplyConfig_600_11("Read")
SetLog("CSV CC Request settings applied", $COLOR_SUCCESS)
EndIf
EndFunc
Func cmbScriptRedlineImplDB()
$g_aiAttackScrRedlineRoutine[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplDB)
If $g_aiAttackScrRedlineRoutine[$DB] = 3 then
GUICtrlSetState($g_hCmbScriptDroplineDB, $GUI_HIDE)
$g_aiAttackScrDroplineEdge[$DB] = $DROPLINE_FULL_EDGE_FIXED
Else
GUICtrlSetState($g_hCmbScriptDroplineDB, $GUI_SHOW)
Endif
EndFunc
Func cmbScriptRedlineImplAB()
$g_aiAttackScrRedlineRoutine[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplAB)
If $g_aiAttackScrRedlineRoutine[$LB] = 3 then
GUICtrlSetState($g_hCmbScriptDroplineAB, $GUI_HIDE)
$g_aiAttackScrDroplineEdge[$LB] = $DROPLINE_FULL_EDGE_FIXED
Else
GUICtrlSetState($g_hCmbScriptDroplineAB, $GUI_SHOW)
EndIf
EndFunc
Func cmbScriptDroplineDB()
$g_aiAttackScrDroplineEdge[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineDB)
EndFunc
Func cmbScriptDroplineAB()
$g_aiAttackScrDroplineEdge[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineAB)
EndFunc
Func AttackNowAB()
Local $tempbRunState = $g_bRunState
Local $tempSieges = $g_aiCurrentSiegeMachines
$g_aiCurrentSiegeMachines[$eSiegeWallWrecker] = 1
$g_aiCurrentSiegeMachines[$eSiegeBattleBlimp] = 1
$g_aiCurrentSiegeMachines[$eSiegeStoneSlammer] = 1
$g_aiAttackAlgorithm[$LB] = 1
$g_sAttackScrScriptName[$LB] = GuiCtrlRead($g_hCmbScriptNameAB)
$g_iMatchMode = $LB
$g_bRunState = True
PrepareAttack($g_iMatchMode)
Attack()
$g_aiCurrentSiegeMachines = $tempSieges
$g_bRunState = $tempbRunState
EndFunc
Func AttackNowDB()
Local $tempbRunState = $g_bRunState
Local $tempSieges = $g_aiCurrentSiegeMachines
$g_aiCurrentSiegeMachines[$eSiegeWallWrecker] = 1
$g_aiCurrentSiegeMachines[$eSiegeBattleBlimp] = 1
$g_aiCurrentSiegeMachines[$eSiegeStoneSlammer] = 1
$g_aiAttackAlgorithm[$DB] = 1
$g_sAttackScrScriptName[$DB] = GuiCtrlRead($g_hCmbScriptNameDB)
$g_iMatchMode = $DB
$g_bRunState = True
PrepareAttack($g_iMatchMode)
Attack()
$g_aiCurrentSiegeMachines = $tempSieges
$g_bRunState = $tempbRunState
EndFunc
Func chkUnbreakable()
If GUICtrlRead($g_hChkUnbreakable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtUnbreakable, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinDark, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxDark, $GUI_ENABLE)
$g_iUnbrkMode = 1
ElseIf GUICtrlRead($g_hChkUnbreakable) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hTxtUnbreakable, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinDark, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxDark, $GUI_DISABLE)
$g_iUnbrkMode = 0
EndIf
EndFunc
Func chkPBTGenabled()
If GUICtrlRead($g_hChkNotifyTGEnable) = $GUI_CHECKED Then
$g_bNotifyTGEnable = True
GUICtrlSetState($g_hTxtNotifyTGToken, $GUI_ENABLE)
Else
$g_bNotifyTGEnable = False
GUICtrlSetState($g_hTxtNotifyTGToken, $GUI_DISABLE)
EndIf
If $g_bNotifyTGEnable = True Then
GUICtrlSetState($g_hChkNotifyRemote, $GUI_ENABLE)
GUICtrlSetState($g_hTxtNotifyOrigin, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertBAN, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertSmartWaitTime, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLaboratoryIdle, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkNotifyRemote, $GUI_DISABLE)
GUICtrlSetState($g_hTxtNotifyOrigin, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertBAN, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertSmartWaitTime, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLaboratoryIdle, $GUI_DISABLE)
EndIf
EndFunc
Func chkNotifyHours()
Local $b = GUICtrlRead($g_hChkNotifyOnlyHours) = $GUI_CHECKED
For $i = 0 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_ENABLE : $GUI_DISABLE)
Next
_GUI_Value_STATE($b ? "ENABLE" : "DISABLE", $g_hChkNotifyOnlyWeekDays&"#"&$g_hChkNotifyhoursE1&"#"&$g_hChkNotifyhoursE2)
If $b = False Then
GUICtrlSetState($g_hChkNotifyOnlyWeekDays, $GUI_UNCHECKED)
chkNotifyWeekDays()
EndIf
EndFunc
Func chkNotifyhoursE1()
Local $b = GUICtrlRead($g_hChkNotifyhoursE1) = $GUI_CHECKED And GUICtrlRead($g_hChkNotifyhours[0]) = $GUI_CHECKED
For $i = 0 To 11
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_hChkNotifyhoursE1, $GUI_UNCHECKED)
EndFunc
Func chkNotifyhoursE2()
Local $b = GUICtrlRead($g_hChkNotifyhoursE2) = $GUI_CHECKED And GUICtrlRead($g_hChkNotifyhours[12]) = $GUI_CHECKED
For $i = 12 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_hChkNotifyhoursE2, $GUI_UNCHECKED)
EndFunc
Func chkNotifyWeekDays()
Local $b = GUICtrlRead($g_hChkNotifyOnlyWeekDays) = $GUI_CHECKED
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $b ? $GUI_ENABLE : $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkNotifyWeekdaysE, $b ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func ChkNotifyWeekdaysE()
Local $b = BitOR(GUICtrlRead($g_hChkNotifyWeekdays[0]), GUICtrlRead($g_hChkNotifyWeekdays[1]), GUICtrlRead($g_hChkNotifyWeekdays[2]), GUICtrlRead($g_hChkNotifyWeekdays[3]), GUICtrlRead($g_hChkNotifyWeekdays[4]), GUICtrlRead($g_hChkNotifyWeekdays[5]), GUICtrlRead($g_hChkNotifyWeekdays[6])) = $GUI_CHECKED
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkNotifyWeekdaysE, $GUI_UNCHECKED)
EndFunc
Func InitTranslatedTextUpgradeTab()
GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Warning_Title", "Warning about your settings...")
GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Warning_Text", "Warning ! You selected 2 resources to ignore... That can be a problem,\r\n" & "and Auto Upgrade can be ineffective, by not launching any upgrade...\r\n" & "I recommend you to select only one resource, not more...")
GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Invalid_Title", "Invalid settings...")
GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Invalid_Text", "Warning ! You selected 3 resources to ignore... And you can't...\r\n" & "With your settings, Auto Upgrade will be completely ineffective\r\n" & "and will not launch any upgrade... You must deselect one or more\r\n" & "ignored resource.")
EndFunc
Func btnLocateUpgrades()
Local $wasRunState = $g_bRunState
$g_bRunState = True
LocateUpgrades()
$g_bRunState = $wasRunState
EndFunc
Func btnchkbxUpgrade()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgrade[$i]) = $GUI_CHECKED Then
$g_abBuildingUpgradeEnable[$i] = True
Else
$g_abBuildingUpgradeEnable[$i] = False
EndIf
Next
EndFunc
Func btnchkbxRepeat()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgradeRepeat[$i]) = $GUI_CHECKED Then
$g_abUpgradeRepeatEnable[$i] = True
Else
$g_abUpgradeRepeatEnable[$i] = False
EndIf
Next
EndFunc
Func picUpgradeTypeLocation()
Local $wasRunState = $g_bRunState
$g_bRunState = True
PureClick(1, 40, 1, 0, "#9999")
Sleep(100)
Zoomout()
Local $inum
For $inum = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If @GUI_CtrlId = $g_hPicUpgradeType[$inum] Then
Local $x = $g_avBuildingUpgrades[$inum][0]
Local $y = $g_avBuildingUpgrades[$inum][1]
Local $n = $g_avBuildingUpgrades[$inum][4]
SetDebugLog("Selecting #" & $inum + 1 & ": " & $n & ", " & $x & "/" & $y)
If isInsideDiamondXY($x, $y) Then
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#9999")
Sleep(100)
If StringInStr($n, "collect", $STR_NOCASESENSEBASIC) Or StringInStr($n, "mine", $STR_NOCASESENSEBASIC) Or StringInStr($n, "drill", $STR_NOCASESENSEBASIC) Then
Click(1, 40, 1, 0, "#0999")
Sleep(100)
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#9999")
EndIf
EndIf
ExitLoop
EndIf
Next
$g_bRunState = $wasRunState
EndFunc
Func btnResetUpgrade()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgradeRepeat[$i]) = $GUI_CHECKED Then ContinueLoop
$g_avBuildingUpgrades[$i][0] = -1
$g_avBuildingUpgrades[$i][1] = -1
$g_avBuildingUpgrades[$i][2] = -1
$g_avBuildingUpgrades[$i][3] = ""
$g_avBuildingUpgrades[$i][4] = ""
$g_avBuildingUpgrades[$i][5] = ""
$g_avBuildingUpgrades[$i][6] = ""
$g_avBuildingUpgrades[$i][7] = ""
GUICtrlSetData($g_hTxtUpgradeName[$i], "")
GUICtrlSetData($g_hTxtUpgradeLevel[$i], "")
GUICtrlSetData($g_hTxtUpgradeValue[$i], "")
GUICtrlSetData($g_hTxtUpgradeTime[$i], "")
_GUICtrlSetImage($g_hPicUpgradeType[$i], $g_sLibIconPath, $eIcnBlank)
$g_aiPicUpgradeStatus[$i] = $eIcnTroops
_GUICtrlSetImage($g_hPicUpgradeStatus[$i], $g_sLibIconPath, $g_aiPicUpgradeStatus[$i])
GUICtrlSetState($g_hChkUpgrade[$i], $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUpgradeEndTime[$i], "")
GUICtrlSetState($g_hChkUpgradeRepeat[$i], $GUI_UNCHECKED)
Next
EndFunc
Func chkLab()
If GUICtrlRead($g_hChkAutoLabUpgrades) = $GUI_CHECKED Then
$g_bAutoLabUpgradeEnable = True
GUICtrlSetState($g_hPicLabUpgrade, $GUI_SHOW)
GUICtrlSetState($g_hLblNextUpgrade, $GUI_ENABLE)
GUICtrlSetState($g_hCmbLaboratory, $GUI_ENABLE)
_GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $g_avLabTroops[$g_iCmbLaboratory][4])
Else
$g_bAutoLabUpgradeEnable = False
GUICtrlSetState($g_hPicLabUpgrade, $GUI_HIDE)
GUICtrlSetState($g_hLblNextUpgrade, $GUI_DISABLE)
GUICtrlSetState($g_hCmbLaboratory, $GUI_DISABLE)
_GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $g_avLabTroops[0][4])
EndIf
LabStatusGUIUpdate()
EndFunc
Func chkStarLab()
If GUICtrlRead($g_hChkAutoStarLabUpgrades) = $GUI_CHECKED Then
$g_bAutoStarLabUpgradeEnable = True
GUICtrlSetState($g_hPicStarLabUpgrade, $GUI_SHOW)
GUICtrlSetState($g_hLblNextSLUpgrade, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStarLaboratory, $GUI_ENABLE)
_GUICtrlSetImage($g_hPicStarLabUpgrade, $g_sLibIconPath, $g_avStarLabTroops[$g_iCmbStarLaboratory][4])
Else
$g_bAutoStarLabUpgradeEnable = False
GUICtrlSetState($g_hPicStarLabUpgrade, $GUI_HIDE)
GUICtrlSetState($g_hLblNextSLUpgrade, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStarLaboratory, $GUI_DISABLE)
_GUICtrlSetImage($g_hPicStarLabUpgrade, $g_sLibIconPath, $g_avStarLabTroops[0][4])
EndIf
StarLabStatusGUIUpdate()
EndFunc
Func LabStatusGUIUpdate()
If _DateIsValid($g_sLabUpgradeTime) Then
_GUICtrlSetTip($g_hBtnResetLabUpgradeTime, GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_04", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_05", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_06", "Troop Upgrade started") & ", " & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_07", "Will begin to check completion at:") & " " & $g_sLabUpgradeTime & @CRLF & " ")
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func StarLabStatusGUIUpdate()
If _DateIsValid($g_sStarLabUpgradeTime) Then
_GUICtrlSetTip($g_hBtnResetStarLabUpgradeTime, GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_04", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_05", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_06", -1) & ", " & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_07", -1) & " " & $g_sStarLabUpgradeTime & @CRLF & " ")
GUICtrlSetState($g_hBtnResetStarLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($g_hBtnResetStarLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnResetStarLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($g_hBtnResetStarLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func cmbLab()
$g_iCmbLaboratory = _GUICtrlComboBox_GetCurSel($g_hCmbLaboratory)
_GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $g_avLabTroops[$g_iCmbLaboratory][4])
EndFunc
Func cmbStarLab()
$g_iCmbStarLaboratory = _GUICtrlComboBox_GetCurSel($g_hCmbStarLaboratory)
_GUICtrlSetImage($g_hPicStarLabUpgrade, $g_sLibIconPath, $g_avStarLabTroops[$g_iCmbStarLaboratory][4])
EndFunc
Func ResetLabUpgradeTime()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_01", "Are you 100% sure you want to reset lab upgrade timer?") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_02", "Click OK to reset") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_03", "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_04", "Reset timer") & "|" & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_05", "Cancel and Return"), GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_06", "Reset laboratory upgrade timer?"), $stext, 120, $g_hFrmBot)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
$g_sLabUpgradeTime = ""
_GUICtrlSetTip($g_hBtnResetLabUpgradeTime, GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_01", "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_02", "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_03", "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_04", "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_05", "Caution - Unnecessary timer reset will force constant checks for lab status"))
EndIf
If _DateIsValid($g_sLabUpgradeTime) Then
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func ResetStarLabUpgradeTime()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_03", -1) & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_04", -1) & "|" & GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_05", -1), GetTranslatedFileIni("MBR Func_Village_Upgrade", "Lab_GUIUpdate_Info_06", -1), $stext, 120, $g_hFrmBot)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
$g_sStarLabUpgradeTime = ""
_GUICtrlSetTip($g_hBtnResetStarLabUpgradeTime, GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_01", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_02", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_03", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_04", -1) & @CRLF & GetTranslatedFileIni("MBR Func_Village_Upgrade", "BtnResetLabUpgradeTime_Info_05", -1))
EndIf
If _DateIsValid($g_sStarLabUpgradeTime) Then
GUICtrlSetState($g_hBtnResetStarLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($g_hBtnResetStarLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnResetStarLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($g_hBtnResetStarLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func chkUpgradeKing()
If $g_iTownHallLevel > 6 Or $g_iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeKing, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeKing) = $GUI_CHECKED Then
$g_bUpgradeKingEnable = True
_GUI_Value_STATE("SHOW", $groupKingSleeping)
Else
$g_bUpgradeKingEnable = False
_GUI_Value_STATE("HIDE", $groupKingSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostBarbarianKing) > 0 Then
GUICtrlSetState($g_hChkUpgradeKing, $GUI_DISABLE + $GUI_UNCHECKED)
$g_bUpgradeKingEnable = False
Else
GUICtrlSetState($g_hChkUpgradeKing, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeKing, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkUpgradeQueen()
If $g_iTownHallLevel > 8 Or $g_iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeQueen) = $GUI_CHECKED Then
$g_bUpgradeQueenEnable = True
_GUI_Value_STATE("SHOW", $groupQueenSleeping)
Else
$g_bUpgradeQueenEnable = False
_GUI_Value_STATE("HIDE", $groupQueenSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostArcherQueen) > 0 Then
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_DISABLE + $GUI_UNCHECKED)
$g_bUpgradeQueenEnable = False
Else
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeQueen, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkUpgradeWarden()
If $g_iTownHallLevel > 10 Or $g_iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeWarden) = $GUI_CHECKED Then
$g_bUpgradeWardenEnable = True
_GUI_Value_STATE("SHOW", $groupWardenSleeping)
Else
$g_bUpgradeWardenEnable = False
_GUI_Value_STATE("HIDE", $groupWardenSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostWarden) > 0 Then
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_DISABLE + $GUI_UNCHECKED)
$g_bUpgradeWardenEnable = False
Else
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeWarden, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func cmbHeroReservedBuilder()
$g_iHeroReservedBuilder = _GUICtrlComboBox_GetCurSel($g_hCmbHeroReservedBuilder)
If $g_iTownHallLevel > 6 Then
If $g_iTownHallLevel > 10 Then
GUICtrlSetData($g_hCmbHeroReservedBuilder, "|0|1|2|3", "0")
ElseIf $g_iTownHallLevel > 8 Then
GUICtrlSetData($g_hCmbHeroReservedBuilder, "|0|1|2", "0")
Else
GUICtrlSetData($g_hCmbHeroReservedBuilder, "|0|1", "0")
EndIf
GUICtrlSetState($g_hCmbHeroReservedBuilder, $GUI_ENABLE)
GUICtrlSetState($g_hLblHeroReservedBuilderTop, $GUI_ENABLE)
GUICtrlSetState($g_hLblHeroReservedBuilderBottom, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbHeroReservedBuilder, $GUI_DISABLE)
GUICtrlSetState($g_hLblHeroReservedBuilderTop, $GUI_DISABLE)
GUICtrlSetState($g_hLblHeroReservedBuilderBottom, $GUI_DISABLE)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbHeroReservedBuilder, $g_iHeroReservedBuilder)
EndFunc
Func chkWalls()
If GUICtrlRead($g_hChkWalls) = $GUI_CHECKED Then
$g_bAutoUpgradeWallsEnable = True
GUICtrlSetState($g_hRdoUseGold, $GUI_ENABLE)
GUICtrlSetState($g_hCmbWalls, $GUI_ENABLE)
GUICtrlSetState($g_hTxtWallMinGold, $GUI_ENABLE)
cmbWalls()
Else
$g_bAutoUpgradeWallsEnable = False
GUICtrlSetState($g_hRdoUseGold, $GUI_DISABLE)
GUICtrlSetState($g_hRdoUseElixir, $GUI_DISABLE)
GUICtrlSetState($g_hRdoUseElixirGold, $GUI_DISABLE)
GUICtrlSetState($g_hCmbWalls, $GUI_DISABLE)
GUICtrlSetState($g_hTxtWallMinGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtWallMinElixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkSaveWallBldr()
$g_bUpgradeWallSaveBuilder =(GUICtrlRead($g_hChkSaveWallBldr) = $GUI_CHECKED)
EndFunc
Func cmbWalls()
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
$g_iWallCost = $g_aiWallCost[$g_iCmbUpgradeWallsLevel]
GUICtrlSetData($g_hLblWallCost, _NumberFormat($g_iWallCost))
For $i = 4 To $g_iCmbUpgradeWallsLevel+5
GUICtrlSetState($g_ahWallsCurrentCount[$i], $GUI_SHOW)
GUICtrlSetState($g_ahPicWallsLevel[$i], $GUI_SHOW)
Next
For $i = $g_iCmbUpgradeWallsLevel+6 To 13
GUICtrlSetState($g_ahWallsCurrentCount[$i], $GUI_HIDE)
GUICtrlSetState($g_ahPicWallsLevel[$i], $GUI_HIDE)
Next
If $g_iCmbUpgradeWallsLevel <= 3 Then GUICtrlSetState($g_hRdoUseGold, $GUI_CHECKED)
GUICtrlSetState($g_hRdoUseElixir, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
GUICtrlSetState($g_hRdoUseElixirGold, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
GUICtrlSetState($g_hTxtWallMinElixir, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
EndFunc
Func btnWalls()
Local $wasRunState = $g_bRunState
$g_bRunState = True
Zoomout()
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
If imglocCheckWall() Then SetLog("Hei Chef! We found the Wall!")
$g_bRunState = $wasRunState
AndroidShield("btnWalls")
EndFunc
Func chkAutoUpgrade()
If GUICtrlRead($g_hChkAutoUpgrade) = $GUI_CHECKED Then
$g_bAutoUpgradeEnabled = True
For $i = $g_hLblAutoUpgrade To $g_hTxtAutoUpgradeLog
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
$g_bAutoUpgradeEnabled = False
For $i = $g_hLblAutoUpgrade To $g_hTxtAutoUpgradeLog
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkResourcesToIgnore()
For $i = 0 To 2
$g_iChkResourcesToIgnore[$i] = GUICtrlRead($g_hChkResourcesToIgnore[$i]) = $GUI_CHECKED ? 1 : 0
Next
Local $iIgnoredResources = 0
For $i = 0 To 2
If $g_iChkResourcesToIgnore[$i] = 1 Then $iIgnoredResources += 1
Next
Switch $iIgnoredResources
Case 2
MsgBox(0 + 16, GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Warning_Title", "-1"), GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Warning_Text", "-1"))
Case 3
MsgBox(0 + 16, GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Invalid_Title", "-1"), GetTranslatedFileIni("MBR GUI Design - AutoUpgrade", "MsgBox_Invalid_Text", "-1"))
EndSwitch
EndFunc
Func chkUpgradesToIgnore()
For $i = 0 To 13
$g_iChkUpgradesToIgnore[$i] = GUICtrlRead($g_hChkUpgradesToIgnore[$i]) = $GUI_CHECKED ? 1 : 0
Next
EndFunc
Global $g_aiDonIcons[$eTroopCount + 1] = [$eIcnDonBarbarian, $eIcnDonArcher, $eIcnDonGiant, $eIcnDonGoblin, $eIcnDonWallBreaker, $eIcnDonBalloon, $eIcnDonWizard, $eIcnDonHealer, $eIcnDonDragon, $eIcnDonPekka, $eIcnDonBabyDragon, $eIcnDonMiner, $eIcnElectroDragon, $eIcnDonMinion, $eIcnDonHogRider, $eIcnDonValkyrie, $eIcnDonGolem, $eIcnDonWitch, $eIcnDonLavaHound, $eIcnDonBowler, $eIcnIceGolem, $eIcnDonBlank]
Func btnDonateTroop()
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs + $eSiegeMachineCount
If @GUI_CtrlId = $g_ahBtnDonateTroop[$i] Then
If GUICtrlGetState($g_ahGrpDonateTroop[$i]) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_ahGrpDonateTroop[$i], $g_ahTxtBlacklistTroop[$i])
EndIf
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_HIDE)
If $i <= $eTroopCount - 1 + $g_iCustomDonateConfigs Then
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_SHOW)
If GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_CHECKED Or GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED Then
If GUICtrlRead($g_hChkClanHop) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_DISABLE + $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_DISABLE)
EndIf
Else
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_HIDE)
EndIf
ExitLoop
EndIf
Next
EndFunc
Func btnDonateSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahBtnDonateSpell[$i] Then
If GUICtrlGetState($g_ahGrpDonateSpell[$i]) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_ahGrpDonateSpell[$i], $g_ahTxtBlacklistSpell[$i])
EndIf
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_HIDE)
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_SHOW)
If GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_CHECKED Or GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED Then
If GUICtrlRead($g_hChkClanHop) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_DISABLE + $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_DISABLE)
EndIf
ExitLoop
EndIf
Next
EndFunc
Func btnDonateOptions()
If GUICtrlGetState($g_hGrpDonateOptions) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_hGrpDonateOptions, $g_hChkClanHop)
EndIf
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_HIDE)
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_HIDE)
EndFunc
Func btnDonateBlacklist()
If GUICtrlGetState($g_hGrpDonateGeneralBlacklist) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_hGrpDonateGeneralBlacklist, $g_hTxtGeneralBlacklist)
EndIf
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_HIDE)
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_HIDE)
GUICtrlSetState($g_hChkClanHop, $GUI_HIDE)
EndFunc
Func chkDonateTroop()
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs + $eSiegeMachineCount
If @GUI_CtrlId = $g_ahChkDonateTroop[$i] Then
If GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_CHECKED Then
_DonateControls($i)
If $i <= $eTroopCount - 1 + $g_iCustomDonateConfigs Then
If GUICtrlRead($g_hChkClanHop) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_DISABLE + $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_ENABLE)
EndIf
EndIf
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
If $i <= $eTroopCount - 1 + $g_iCustomDonateConfigs And GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_UNCHECKED Then GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_DISABLE)
EndIf
SetStateTxtGeneralBlacklist()
EndIf
Next
EndFunc
Func chkDonateAllTroop()
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs + $eSiegeMachineCount
If @GUI_CtrlId = $g_ahChkDonateAllTroop[$i] Then
If $i <= $eTroopCount - 1 + $g_iCustomDonateConfigs Then
If GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED Then
If GUICtrlRead($g_hChkClanHop) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_DISABLE + $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_ENABLE)
EndIf
Else
If GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_UNCHECKED Then GUICtrlSetState($g_hChkDonateQueueTroopOnly, $GUI_DISABLE)
EndIf
EndIf
_DonateAllControls($i, GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED ? True : False)
SetStateTxtGeneralBlacklist()
ExitLoop
EndIf
Next
EndFunc
Func chkDonateSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahChkDonateSpell[$i] Then
If GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_CHECKED Then
_DonateControlsSpell($i)
If GUICtrlRead($g_hChkClanHop) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_DISABLE + $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_ENABLE)
EndIf
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
If GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_UNCHECKED Then GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_DISABLE)
EndIf
SetStateTxtGeneralBlacklist()
EndIf
Next
EndFunc
Func chkDonateAllSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahChkDonateAllSpell[$i] Then
If GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED Then
If GUICtrlRead($g_hChkClanHop) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_DISABLE + $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_ENABLE)
EndIf
Else
If GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_UNCHECKED Then GUICtrlSetState($g_hChkDonateQueueSpellOnly, $GUI_DISABLE)
EndIf
_DonateAllControlsSpell($i, GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED ? True : False)
SetStateTxtGeneralBlacklist()
ExitLoop
EndIf
Next
EndFunc
Func cmbDonateCustomA()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[2])
_GUICtrlSetImage($g_ahPicDonateCustomA[0], $g_sLibIconPath, $g_aiDonIcons[$combo1])
_GUICtrlSetImage($g_ahPicDonateCustomA[1], $g_sLibIconPath, $g_aiDonIcons[$combo2])
_GUICtrlSetImage($g_ahPicDonateCustomA[2], $g_sLibIconPath, $g_aiDonIcons[$combo3])
EndFunc
Func cmbDonateCustomB()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[2])
_GUICtrlSetImage($g_ahPicDonateCustomB[0], $g_sLibIconPath, $g_aiDonIcons[$combo1])
_GUICtrlSetImage($g_ahPicDonateCustomB[1], $g_sLibIconPath, $g_aiDonIcons[$combo2])
_GUICtrlSetImage($g_ahPicDonateCustomB[2], $g_sLibIconPath, $g_aiDonIcons[$combo3])
EndFunc
Func cmbDonateCustomC()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomC[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomC[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomC[2])
_GUICtrlSetImage($g_ahPicDonateCustomC[0], $g_sLibIconPath, $g_aiDonIcons[$combo1])
_GUICtrlSetImage($g_ahPicDonateCustomC[1], $g_sLibIconPath, $g_aiDonIcons[$combo2])
_GUICtrlSetImage($g_ahPicDonateCustomC[2], $g_sLibIconPath, $g_aiDonIcons[$combo3])
EndFunc
Func cmbDonateCustomD()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomD[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomD[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomD[2])
_GUICtrlSetImage($g_ahPicDonateCustomD[0], $g_sLibIconPath, $g_aiDonIcons[$combo1])
_GUICtrlSetImage($g_ahPicDonateCustomD[1], $g_sLibIconPath, $g_aiDonIcons[$combo2])
_GUICtrlSetImage($g_ahPicDonateCustomD[2], $g_sLibIconPath, $g_aiDonIcons[$combo3])
EndFunc
Func _DonateBtn($hFirstControl, $hLastControl)
Static $hLastDonateBtn1 = -1, $hLastDonateBtn2 = -1
If $hLastDonateBtn1 = -1 Then
For $i = $g_ahGrpDonateTroop[$eTroopBarbarian] To $g_ahTxtBlacklistTroop[$eTroopBarbarian]
GUICtrlSetState($i, $GUI_HIDE)
Next
Else
For $i = $hLastDonateBtn1 To $hLastDonateBtn2
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
$hLastDonateBtn1 = $hFirstControl
$hLastDonateBtn2 = $hLastControl
For $i = $hFirstControl To $hLastControl
GUICtrlSetState($i, $GUI_SHOW)
Next
EndFunc
Func _DonateControls($iTroopIndex)
Local $iFirstTroop = 0, $iLastTroop = $eTroopCount - 1 + $g_iCustomDonateConfigs + $eSiegeMachineCount
If $iTroopIndex <= $eTroopCount - 1 + $g_iCustomDonateConfigs Then
$iLastTroop = $eTroopCount - 1 + $g_iCustomDonateConfigs
Else
$iFirstTroop = $eTroopCount + $g_iCustomDonateConfigs
EndIf
For $i = $iFirstTroop To $iLastTroop
If $i = $iTroopIndex Then
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $COLOR_ORANGE)
Else
If GUICtrlGetBkColor($g_ahLblDonateTroop[$i]) = $COLOR_NAVY Then GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED Then GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_ENABLE)
Next
EndFunc
Func _DonateAllControls($iTroopIndex, $Set)
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "_DonateAllControls")
Local $iFirstTroop = 0, $iLastTroop = $eTroopCount - 1 + $g_iCustomDonateConfigs + $eSiegeMachineCount
If $iTroopIndex <= $eTroopCount - 1 + $g_iCustomDonateConfigs Then
$iLastTroop = $eTroopCount - 1 + $g_iCustomDonateConfigs
Else
$iFirstTroop = $eTroopCount + $g_iCustomDonateConfigs
EndIf
If $Set = True Then
For $i = $iFirstTroop To $iLastTroop
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $i = $iTroopIndex ? $COLOR_NAVY : $GUI_BKCOLOR_TRANSPARENT)
If $i <> $iTroopIndex Then
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
EndIf
GUICtrlSetState($g_ahChkDonateTroop[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_DISABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_DISABLE)
Next
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$iTroopIndex], $GUI_BKCOLOR_TRANSPARENT)
For $i = $iFirstTroop To $iLastTroop
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_ENABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGUI_DONATE_TAB, "_DonateAllControls")
EndFunc
Func _DonateControlsSpell($iSpellIndex)
For $i = 0 To $eSpellCount - 1
If $i = $iSpellIndex Then
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $COLOR_ORANGE)
Else
If GUICtrlGetBkColor($g_ahLblDonateSpell[$i]) = $COLOR_NAVY Then GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED Then GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_ENABLE)
Next
EndFunc
Func _DonateAllControlsSpell($iSpellIndex, $Set)
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "_DonateAllControlsSpell")
If $Set = True Then
For $i = 0 To $eSpellCount - 1
If $i = $iSpellIndex Then
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $COLOR_NAVY)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $i <> $iSpellIndex Then GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkDonateSpell[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_DISABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_DISABLE)
Next
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$iSpellIndex], $GUI_BKCOLOR_TRANSPARENT)
For $i = 0 To $eSpellCount - 1
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_ENABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGUI_DONATE_TAB, "_DonateAllControlsSpell")
EndFunc
Func SetStateTxtGeneralBlacklist()
Local $bDonateToSpecificKeyWord = False, $bDonateToAll = False
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs + $eSiegeMachineCount
If $bDonateToSpecificKeyWord Then ExitLoop
If GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_CHECKED Then $bDonateToSpecificKeyWord = True
If GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED Then $bDonateToAll = True
If $i >= $eSpellCount - 1 Then ContinueLoop
If GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_CHECKED Then $bDonateToSpecificKeyWord = True
If GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED Then $bDonateToAll = True
Next
If $bDonateToSpecificKeyWord Or Not $bDonateToAll Then
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_ENABLE)
ElseIf $bDonateToAll Then
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_DISABLE)
EndIf
EndFunc
Func btnFilterDonationsCC()
SetLog("open folder " & $g_sProfileDonateCapturePath, $COLOR_AQUA)
ShellExecute("explorer", $g_sProfileDonateCapturePath)
EndFunc
Func chkskipDonateNearFulLTroopsEnable()
If GUICtrlRead($g_hChkSkipDonateNearFullTroopsEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSkipDonateNearFullTroopsPercentage, $GUI_ENABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText, $GUI_ENABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText1, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSkipDonateNearFullTroopsPercentage, $GUI_DISABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText, $GUI_DISABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText1, $GUI_DISABLE)
EndIf
EndFunc
Func chkBalanceDR()
If GUICtrlRead($g_hChkUseCCBalanced) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbCCDonated, $GUI_ENABLE)
GUICtrlSetState($g_hCmbCCReceived, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbCCDonated, $GUI_DISABLE)
GUICtrlSetState($g_hCmbCCReceived, $GUI_DISABLE)
EndIf
EndFunc
Func cmbBalanceDR()
If _GUICtrlComboBox_GetCurSel($g_hCmbCCDonated) = _GUICtrlComboBox_GetCurSel($g_hCmbCCReceived) Then
_GUICtrlComboBox_SetCurSel($g_hCmbCCDonated, 0)
_GUICtrlComboBox_SetCurSel($g_hCmbCCReceived, 0)
EndIf
EndFunc
Func Doncheck()
tabDONATE()
EndFunc
Global $aLanguageFile[1][2]
Global $hLangIcons = 0
Func LoadLanguagesComboBox()
Local $hFileSearch = FileFindFirstFile($g_sDirLanguages & "*.ini")
Local $sFilename, $sLangDisplayName = "", $iFileIndex = 0
If $hLangIcons Then _GUIImageList_Destroy($hLangIcons)
$hLangIcons = _GUIImageList_Create(16, 16, 5)
While 1
$sFilename = FileFindNextFile($hFileSearch)
If @error Then ExitLoop
ReDim $aLanguageFile[$iFileIndex + 1][3]
$aLanguageFile[$iFileIndex][0] = StringLeft($sFilename, StringLen($sFilename) - 4)
$aLanguageFile[$iFileIndex][2] = _GUIImageList_AddIcon($hLangIcons, @ScriptDir & "\lib\MBRBot.dll", Eval("e" & $aLanguageFile[$iFileIndex][0]) - 1)
$sLangDisplayName = IniRead($g_sDirLanguages & $sFilename, "Language", "DisplayName", "Unknown")
$aLanguageFile[$iFileIndex][1] = $sLangDisplayName
If $sLangDisplayName = "Unknown" Then
IniWrite($g_sDirLanguages & $sFilename, "Language", "DisplayName", StringLeft($sFilename, StringLen($sFilename) - 4))
$sLangDisplayName = IniRead($g_sDirLanguages & $sFilename, "Language", "DisplayName", "Unknown")
$aLanguageFile[$iFileIndex][1] = $sLangDisplayName
EndIf
$iFileIndex += 1
WEnd
FileClose($hFileSearch)
_GUICtrlComboBox_ResetContent($g_hCmbGUILanguage)
_GUICtrlComboBoxEx_SetImageList($g_hCmbGUILanguage, $hLangIcons)
For $i = 0 To UBound($aLanguageFile) - 1
If $aLanguageFile[$i][2] <> -1 Then
_GUICtrlComboBoxEx_AddString($g_hCmbGUILanguage, $aLanguageFile[$i][1], $aLanguageFile[$i][2], $aLanguageFile[$i][2])
Else
_GUICtrlComboBoxEx_AddString($g_hCmbGUILanguage, $aLanguageFile[$i][1], $eMissingLangIcon, $eMissingLangIcon)
EndIf
Next
_GUICtrlComboBoxEx_SetCurSel($g_hCmbGUILanguage, _GUICtrlComboBoxEx_FindStringExact($g_hCmbGUILanguage, $aLanguageFile[_ArraySearch($aLanguageFile, $g_sLanguage)][1]))
EndFunc
Func cmbLanguage()
Local $aLanguage = _GUICtrlComboBox_GetListArray($g_hCmbGUILanguage)
Local $g_sLanguageIndex = _ArraySearch($aLanguageFile, $aLanguage[_GUICtrlComboBox_GetCurSel($g_hCmbGUILanguage) + 1])
$g_sLanguage = $aLanguageFile[$g_sLanguageIndex][0]
MsgBox("", "", GetTranslatedFileIni("MBR Popups", "Func_cmbLanguage", "Restart Bot to load program with new language:") & " " & $aLanguageFile[$g_sLanguageIndex][1] & " (" & $g_sLanguage & ")")
IniWriteS($g_sProfileConfigPath, "other", "language", $g_sLanguage)
RestartBot(False, False)
EndFunc
Func chkBotCustomTitleBarClick()
Local $bChecked = GUICtrlRead($g_hChkBotCustomTitleBarClick) = $GUI_CHECKED
$g_iBotDesignFlags = BitOR(BitAND($g_iBotDesignFlags, BitNOT(1)),(($bChecked) ? 1 : 0))
GUICtrlSetState($g_hChkBotAutoSlideClick,($bChecked ? $GUI_ENABLE : $GUI_DISABLE))
EndFunc
Func chkBotAutoSlideClick()
Local $bChecked = GUICtrlRead($g_hChkBotAutoSlideClick) = $GUI_CHECKED
$g_iBotDesignFlags = BitOR(BitAND($g_iBotDesignFlags, BitNOT(2)),(($bChecked) ? 2 : 0))
EndFunc
Func chkDisableNotifications()
$g_bDisableNotifications =(GUICtrlRead($g_hChkDisableNotifications) = $GUI_CHECKED)
EndFunc
Func chkUseRandomClick()
$g_bUseRandomClick =(GUICtrlRead($g_hChkUseRandomClick) = $GUI_CHECKED)
EndFunc
Func chkHideWhenMinimized()
$g_bHideWhenMinimized =(GUICtrlRead($g_hChkHideWhenMinimized) = $GUI_CHECKED)
TrayItemSetState($g_hTiHide,($g_bHideWhenMinimized = 1 ? $TRAY_CHECKED : $TRAY_UNCHECKED))
EndFunc
Func chkScreenshotType()
$g_bScreenshotPNGFormat =(GUICtrlRead($g_hChkScreenshotType) = $GUI_CHECKED)
EndFunc
Func chkScreenshotHideName()
$g_bScreenshotHideName =(GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED)
EndFunc
Func chkDeleteLogs()
GUICtrlSetState($g_hTxtDeleteLogsDays, GUICtrlRead($g_hChkDeleteLogs) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDeleteTemp()
GUICtrlSetState($g_hTxtDeleteTempDays, GUICtrlRead($g_hChkDeleteTemp) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDeleteLoots()
GUICtrlSetState($g_hTxtDeleteLootsDays, GUICtrlRead($g_hChkDeleteLoots) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkAutoStart()
GUICtrlSetState($g_hTxtAutostartDelay, GUICtrlRead($g_hChkAutoStart) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDisposeWindows()
If GUICtrlRead($g_hChkAutoAlign) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAlignmentOptions, $GUI_ENABLE)
GUICtrlSetState($g_hTxtAlignOffsetX, $GUI_ENABLE)
GUICtrlSetState($g_hTxtAlignOffsetY, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbAlignmentOptions, $GUI_DISABLE)
GUICtrlSetState($g_hTxtAlignOffsetX, $GUI_DISABLE)
GUICtrlSetState($g_hTxtAlignOffsetY, $GUI_DISABLE)
EndIf
EndFunc
Func chkSinglePBTForced()
If GUICtrlRead($g_hChkSinglePBTForced) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSinglePBTimeForced, $GUI_ENABLE)
GUICtrlSetState($g_hTxtPBTimeForcedExit, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSinglePBTimeForced, $GUI_DISABLE)
GUICtrlSetState($g_hTxtPBTimeForcedExit, $GUI_DISABLE)
EndIf
txtSinglePBTimeForced()
EndFunc
Func txtSinglePBTimeForced()
Switch Int(GUICtrlRead($g_hTxtSinglePBTimeForced))
Case 0 To 15
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_ERROR)
Case 16
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_YELLOW)
Case 17 To 999
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_MONEYGREEN)
EndSwitch
Switch Int(GUICtrlRead($g_hTxtPBTimeForcedExit))
Case 0 To 11
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_ERROR)
Case 12 To 14
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_YELLOW)
Case 15 To 999
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_MONEYGREEN)
EndSwitch
EndFunc
Func chkAutoResume()
GUICtrlSetState($g_hTxtAutoResumeTime, GUICtrlRead($g_hChkAutoResume) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func txtGlobalActiveBotsAllowed()
Local $iValue = Int(GUICtrlRead($g_hTxtGlobalActiveBotsAllowed))
If $iValue < 1 Then
$iValue = 1
GUICtrlSetData($g_hTxtGlobalActiveBotsAllowed, $iValue)
EndIf
If $g_iGlobalActiveBotsAllowed <> $iValue Then
SetDebugLog("Maximum of " & $g_iGlobalActiveBotsAllowed & " bots running at same time changed to " & $iValue)
$g_iGlobalActiveBotsAllowed = $iValue
SaveProfileConfig(Default, True)
EndIf
EndFunc
Func txtGlobalThreads()
Local $iValue = Int(GUICtrlRead($g_hTxtGlobalThreads))
If $g_iGlobalThreads <> $iValue Then
SetDebugLog("Threading: Using " & $g_iGlobalThreads & " threads shared across all bot instances changed to " & $iValue)
$g_iGlobalThreads = $iValue
SaveProfileConfig(Default, True)
EndIf
EndFunc
Func txtThreads()
Local $iValue = Int(GUICtrlRead($g_hTxtThreads))
If $g_iThreads <> $iValue Then
SetDebugLog("Threading: Using " & $g_iThreads & " threads for parallelism changedd to " & $iValue)
$g_iThreads = $iValue
setMaxDegreeOfParallelism($g_iThreads)
EndIf
EndFunc
Func chkSwitchAcc()
If GUICtrlRead($g_hChkSwitchAcc) = $GUI_CHECKED And aquireSwitchAccountMutex($g_iCmbSwitchAcc, False, True) Then
For $i = $g_hCmbTotalAccount To $g_ahChkDonate[7]
GUICtrlSetState($i, $GUI_ENABLE)
Next
GUICtrlSetState($g_hChkOnlySCIDAccounts, $GUI_DISABLE + $GUI_UNCHECKED)
For $i = 0 To 7
GUICtrlSetState($g_ahChkSetFarm[$i], $GUI_ENABLE)
_chkSetFarmSchedule($i)
Next
Else
releaseSwitchAccountMutex()
For $i = $g_hCmbTotalAccount To $g_ahChkDonate[7]
GUICtrlSetState($i, $GUI_DISABLE)
Next
GUICtrlSetState($g_hChkOnlySCIDAccounts, $GUI_ENABLE)
For $i = 0 To 7
For $j = $g_ahChkSetFarm[$i] To $g_ahCmbTime2[$i]
GUICtrlSetState($j, $GUI_DISABLE)
Next
Next
EndIf
chkSwitchProfile()
OnlySCIDAccounts()
EndFunc
Func cmbSwitchAcc()
Return _cmbSwitchAcc()
EndFunc
Func _cmbSwitchAcc($bReadSaveConfig = True)
Static $s_bActive = False
If $s_bActive Then Return
$s_bActive = True
Local $iCmbSwitchAcc = _GUICtrlComboBox_GetCurSel($g_hCmbSwitchAcc)
Local $bAcquired = aquireSwitchAccountMutex($iCmbSwitchAcc, False, True)
Local $bEnable = False
If $iCmbSwitchAcc And $bAcquired Then
$bEnable = True
Else
If $g_iCmbSwitchAcc And $iCmbSwitchAcc = 0 Then
For $i = 0 To UBound($g_ahChkDonate) - 7
If GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED And GUICtrlRead($g_ahCmbProfile[$i]) = $g_sProfileCurrentName Then
SetLog("Disabled Profile " & $g_sProfileCurrentName & " in Group " & $g_iCmbSwitchAcc)
SetSwitchAccLog("Disabled Profile " & $g_sProfileCurrentName & " in Group " & $g_iCmbSwitchAcc)
GUICtrlSetState($g_ahChkAccount[$i], $GUI_UNCHECKED)
ExitLoop
EndIf
Next
EndIf
If $iCmbSwitchAcc And Not $bAcquired Then
$iCmbSwitchAcc = $g_iCmbSwitchAcc
_GUICtrlComboBox_SetCurSel($g_hCmbSwitchAcc, $iCmbSwitchAcc)
$bAcquired = aquireSwitchAccountMutex($iCmbSwitchAcc, False, True)
$bEnable = $bAcquired
EndIf
EndIf
If $bReadSaveConfig Then
If $g_iCmbSwitchAcc Then
SetLog("Save Switch Accounts Group " & $g_iCmbSwitchAcc)
SetSwitchAccLog("Save Group " & $g_iCmbSwitchAcc)
_GUICtrlComboBox_SetCurSel($g_hCmbSwitchAcc, $g_iCmbSwitchAcc)
SaveConfig_600_35_2()
_GUICtrlComboBox_SetCurSel($g_hCmbSwitchAcc, $iCmbSwitchAcc)
EndIf
$g_iCmbSwitchAcc = $iCmbSwitchAcc
If $g_iCmbSwitchAcc Then
SetLog("Read Switch Accounts Group " & $g_iCmbSwitchAcc)
SetSwitchAccLog("Read Group " & $g_iCmbSwitchAcc)
EndIf
ReadConfig_SwitchAccounts()
ApplyConfig_600_35_2("Read")
Else
$g_iCmbSwitchAcc = $iCmbSwitchAcc
EndIf
If $bEnable And GUICtrlRead($g_hChkSwitchAcc) = $GUI_UNCHECKED Then
$bEnable = False
EndIf
GUICtrlSetState($g_hChkSwitchAcc,(($bEnable Or($iCmbSwitchAcc And $bAcquired)) ? $GUI_ENABLE : $GUI_DISABLE))
For $i = $g_hCmbTotalAccount To $g_ahChkDonate[7]
GUICtrlSetState($i,(($bEnable) ? $GUI_ENABLE : $GUI_DISABLE))
Next
cmbTotalAcc()
For $i = 0 To 7
If $bEnable Then
GUICtrlSetState($g_ahChkSetFarm[$i], $GUI_ENABLE)
_chkSetFarmSchedule($i)
Else
For $j = $g_ahChkSetFarm[$i] To $g_ahCmbTime2[$i]
GUICtrlSetState($j, $GUI_DISABLE)
Next
EndIf
Next
$s_bActive = False
EndFunc
Func cmbTotalAcc()
Local $iCmbTotalAcc = _GUICtrlComboBox_GetCurSel($g_hCmbTotalAccount) + 1
For $i = 0 To 7
If $iCmbTotalAcc >= 0 And $i <= $iCmbTotalAcc Then
_GUI_Value_STATE("SHOW", $g_ahChkAccount[$i] & "#" & $g_ahCmbProfile[$i] & "#" & $g_ahChkDonate[$i])
For $j = $g_ahChkSetFarm[$i] To $g_ahCmbTime2[$i]
GUICtrlSetState($j, $GUI_SHOW)
Next
_chkSetFarmSchedule($i)
ElseIf $i > $iCmbTotalAcc Then
GUICtrlSetState($g_ahChkAccount[$i], $GUI_UNCHECKED)
_GUI_Value_STATE("HIDE", $g_ahChkAccount[$i] & "#" & $g_ahCmbProfile[$i] & "#" & $g_ahChkDonate[$i])
For $j = $g_ahChkSetFarm[$i] To $g_ahCmbTime2[$i]
GUICtrlSetState($j, $GUI_HIDE)
Next
EndIf
chkAccount($i)
Next
EndFunc
Func chkSmartSwitch()
If GUICtrlRead($g_hChkSmartSwitch) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkDonateLikeCrazy, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDonateLikeCrazy, $GUI_DISABLE + $GUI_UNCHECKED)
EndIf
EndFunc
Func chkAccount($i)
If GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_ahCmbProfile[$i] & "#" & $g_ahChkDonate[$i])
SwitchAccountCheckProfileInUse($g_asProfileName[$i])
Else
_GUI_Value_STATE("DISABLE", $g_ahCmbProfile[$i] & "#" & $g_ahChkDonate[$i])
EndIf
EndFunc
Func chkAccountX()
For $i = 0 To UBound($g_ahChkAccount) - 1
If @GUI_CtrlId = $g_ahChkAccount[$i] Then
Return chkAccount($i)
EndIf
Next
EndFunc
Func cmbSwitchAccProfile($i)
Local $sOldProfile = $g_asProfileName[$i]
Local $sNewProfile = GUICtrlRead($g_ahCmbProfile[$i])
SwitchAccountCheckProfileInUse($sNewProfile)
Local $sOthProfile
If $sNewProfile Then
For $j = 0 To UBound($g_ahCmbProfile) - 1
If $j <> $i Then
$sOthProfile = GUICtrlRead($g_ahCmbProfile[$j])
If $sOthProfile = $sNewProfile Then
$g_asProfileName[$j] = $sOldProfile
_GUICtrlComboBox_SetCurSel($g_ahCmbProfile[$j], _GUICtrlComboBox_FindStringExact($g_ahCmbProfile[$j], $sOldProfile))
ExitLoop
EndIf
EndIf
Next
EndIf
$g_asProfileName[$i] = $sNewProfile
EndFunc
Func cmbSwitchAccProfileX()
For $i = 0 To UBound($g_ahCmbProfile) - 1
If @GUI_CtrlId = $g_ahCmbProfile[$i] Then
Return cmbSwitchAccProfile($i)
EndIf
Next
EndFunc
Func chkAccSwitchMode()
If GUICtrlRead($g_hRadSwitchGooglePlay) = $GUI_CHECKED Then
$g_bChkGooglePlay = True
$g_bChkSuperCellID = False
$g_bChkSharedPrefs = False
ElseIf GUICtrlRead($g_hRadSwitchSuperCellID) = $GUI_CHECKED Then
$g_bChkGooglePlay = False
$g_bChkSuperCellID = True
$g_bChkSharedPrefs = False
ElseIf GUICtrlRead($g_hRadSwitchSharedPrefs) = $GUI_CHECKED Then
$g_bChkGooglePlay = False
$g_bChkSuperCellID = False
$g_bChkSharedPrefs = True
Else
$g_bChkGooglePlay = False
$g_bChkSuperCellID = False
$g_bChkSharedPrefs = False
EndIf
EndFunc
Func chkSwitchProfile()
For $i = 0 To 3
If GUICtrlRead($g_ahChk_SwitchMax[$i]) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_ahCmb_SwitchMax[$i] & "#" & $g_ahLbl_SwitchMax[$i] & "#" & $g_ahTxt_ConditionMax[$i])
If GUICtrlRead($g_hChkSwitchAcc) = $GUI_CHECKED Then
GUICtrlSetState($g_ahChk_BotTypeMax[$i], $GUI_ENABLE)
Else
GUICtrlSetState($g_ahChk_BotTypeMax[$i], $GUI_DISABLE + $GUI_UNCHECKED)
EndIf
Else
For $j = $g_ahCmb_SwitchMax[$i] To $g_ahTxt_ConditionMax[$i]
GUICtrlSetState($j, $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChk_BotTypeMax[$i], $GUI_UNCHECKED)
EndIf
If GUICtrlRead($g_ahChk_SwitchMin[$i]) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_ahCmb_SwitchMin[$i] & "#" & $g_ahLbl_SwitchMin[$i] & "#" & $g_ahTxt_ConditionMin[$i])
If GUICtrlRead($g_hChkSwitchAcc) = $GUI_CHECKED Then
GUICtrlSetState($g_ahChk_BotTypeMin[$i], $GUI_ENABLE)
Else
GUICtrlSetState($g_ahChk_BotTypeMin[$i], $GUI_DISABLE + $GUI_UNCHECKED)
EndIf
Else
For $j = $g_ahCmb_SwitchMin[$i] To $g_ahTxt_ConditionMin[$i]
GUICtrlSetState($j, $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChk_BotTypeMin[$i], $GUI_UNCHECKED)
EndIf
Next
chkSwitchBotType()
EndFunc
Func chkSwitchBotType()
For $i = 0 To 3
If GUICtrlRead($g_ahChk_BotTypeMax[$i]) = $GUI_CHECKED Then
GUICtrlSetState($g_ahCmb_BotTypeMax[$i], $GUI_ENABLE)
Else
GUICtrlSetState($g_ahCmb_BotTypeMax[$i], $GUI_DISABLE)
EndIf
If GUICtrlRead($g_ahChk_BotTypeMin[$i]) = $GUI_CHECKED Then
GUICtrlSetState($g_ahCmb_BotTypeMin[$i], $GUI_ENABLE)
Else
GUICtrlSetState($g_ahCmb_BotTypeMin[$i], $GUI_DISABLE)
EndIf
Next
EndFunc
Func chkSetFarmSchedule()
For $i = 0 To UBound($g_ahChkSetFarm) - 1
If @GUI_CtrlId = $g_ahChkSetFarm[$i] Then
Return _chkSetFarmSchedule($i)
EndIf
Next
EndFunc
Func _chkSetFarmSchedule($i)
If GUICtrlRead($g_ahChkSetFarm[$i]) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_ahCmbAction1[$i] & "#" & $g_ahCmbAction2[$i] & "#" & $g_ahCmbCriteria1[$i] & "#" & $g_ahCmbCriteria2[$i])
_cmbCriteria1($i)
_cmbCriteria2($i)
Else
_GUI_Value_STATE("DISABLE", $g_ahCmbAction1[$i] & "#" & $g_ahCmbCriteria1[$i] & "#" & $g_ahTxtResource1[$i] & "#" & $g_ahCmbTime1[$i] & "#" & $g_ahCmbAction2[$i] & "#" & $g_ahCmbCriteria2[$i] & "#" & $g_ahTxtResource2[$i] & "#" & $g_ahCmbTime2[$i])
EndIf
EndFunc
Func cmbCriteria1()
For $i = 0 To UBound($g_ahCmbCriteria1) - 1
If @GUI_CtrlId = $g_ahCmbCriteria1[$i] Then
Return _cmbCriteria1($i)
EndIf
Next
EndFunc
Func _cmbCriteria1($i)
Local $aiDefaultValue[4] = ["12000000", "12000000", "240000", "6000"]
Local $aiDefaultLimit[4] = [99999999, 99999999, 299999, 9999]
Local $iCmbCriteria = _GUICtrlComboBox_GetCurSel($g_ahCmbCriteria1[$i])
Switch $iCmbCriteria
Case 0
_GUI_Value_STATE("DISABLE", $g_ahCmbTime1[$i] & "#" & $g_ahTxtResource1[$i])
Case 1 To 4
GUICtrlSetState($g_ahCmbTime1[$i], $GUI_HIDE)
GUICtrlSetState($g_ahTxtResource1[$i], $GUI_SHOW + $GUI_ENABLE)
If GUICtrlRead($g_ahTxtResource1[$i]) = "" Or GUICtrlRead($g_ahTxtResource1[$i]) > $aiDefaultLimit[$iCmbCriteria - 1] Then GUICtrlSetData($g_ahTxtResource1[$i], $aiDefaultValue[$iCmbCriteria - 1])
GUICtrlSetLimit($g_ahTxtResource1[$i], StringLen($aiDefaultValue[$iCmbCriteria - 1]))
Case 5
GUICtrlSetState($g_ahTxtResource1[$i], $GUI_HIDE)
GUICtrlSetState($g_ahCmbTime1[$i], $GUI_SHOW + $GUI_ENABLE)
EndSwitch
EndFunc
Func cmbCriteria2()
For $i = 0 To UBound($g_ahCmbCriteria2) - 1
If @GUI_CtrlId = $g_ahCmbCriteria2[$i] Then
Return _cmbCriteria2($i)
EndIf
Next
EndFunc
Func _cmbCriteria2($i)
Local $aiDefaultValue[4] = ["1000000", "1000000", "020000", "3000"]
Local $aiDefaultLimit[4] = [9999999, 9999999, 199999, 9999]
Local $iCmbCriteria = _GUICtrlComboBox_GetCurSel($g_ahCmbCriteria2[$i])
Switch $iCmbCriteria
Case 0
_GUI_Value_STATE("DISABLE", $g_ahTxtResource2[$i] & "#" & $g_ahCmbTime2[$i])
Case 1 To 4
GUICtrlSetState($g_ahCmbTime2[$i], $GUI_HIDE)
GUICtrlSetState($g_ahTxtResource2[$i], $GUI_SHOW + $GUI_ENABLE)
If GUICtrlRead($g_ahTxtResource2[$i]) = "" Or GUICtrlRead($g_ahTxtResource2[$i]) > $aiDefaultLimit[$iCmbCriteria - 1] Then GUICtrlSetData($g_ahTxtResource2[$i], Number($aiDefaultValue[$iCmbCriteria - 1]))
GUICtrlSetLimit($g_ahTxtResource2[$i], StringLen($aiDefaultValue[$iCmbCriteria - 1]))
Case 5
GUICtrlSetState($g_ahTxtResource2[$i], $GUI_HIDE)
GUICtrlSetState($g_ahCmbTime2[$i], $GUI_SHOW + $GUI_ENABLE)
EndSwitch
EndFunc
Func chkDebugSetLog()
$g_bDebugSetlog =(GUICtrlRead($g_hChkDebugSetlog) = $GUI_CHECKED)
SetDebugLog("DebugSetlog " &($g_bDebugSetlog ? "enabled" : "disabled"))
EndFunc
Func chkDebugAndroid()
$g_bDebugAndroid =(GUICtrlRead($g_hChkDebugAndroid) = $GUI_CHECKED)
SetDebugLog("DebugAndroid " &($g_bDebugAndroid ? "enabled" : "disabled"))
EndFunc
Func chkDebugClick()
$g_bDebugClick =(GUICtrlRead($g_hChkDebugClick) = $GUI_CHECKED)
SetDebugLog("DebugClick " &($g_bDebugClick ? "enabled" : "disabled"))
EndFunc
Func chkDebugFunc()
Local $bDebugFunc =(GUICtrlRead($g_hChkDebugFunc) = $GUI_CHECKED)
$g_bDebugFuncTime = $bDebugFunc
$g_bDebugFuncCall = $bDebugFunc
SetDebugLog("DebugFunc " &($bDebugFunc ? "enabled" : "disabled"))
EndFunc
Func chkDebugDisableZoomout()
$g_bDebugDisableZoomout =(GUICtrlRead($g_hChkDebugDisableZoomout) = $GUI_CHECKED)
SetDebugLog("DebugDisableZoomout " &($g_bDebugDisableZoomout ? "enabled" : "disabled"))
EndFunc
Func chkDebugDisableVillageCentering()
$g_bDebugDisableVillageCentering =(GUICtrlRead($g_hChkDebugDisableVillageCentering) = $GUI_CHECKED)
SetDebugLog("DebugDisableVillageCentering " &($g_bDebugDisableVillageCentering ? "enabled" : "disabled"))
EndFunc
Func chkDebugDeadbaseImage()
$g_bDebugDeadBaseImage =(GUICtrlRead($g_hChkDebugDeadbaseImage) = $GUI_CHECKED)
SetDebugLog("DebugDeadbaseImage " &($g_bDebugDeadBaseImage ? "enabled" : "disabled"))
EndFunc
Func chkDebugOcr()
$g_bDebugOcr =(GUICtrlRead($g_hChkDebugOCR) = $GUI_CHECKED)
SetDebugLog("DebugOcr " &($g_bDebugOcr ? "enabled" : "disabled"))
EndFunc
Func chkDebugImageSave()
$g_bDebugImageSave =(GUICtrlRead($g_hChkDebugImageSave) = $GUI_CHECKED)
SetDebugLog("DebugImageSave " &($g_bDebugImageSave ? "enabled" : "disabled"))
EndFunc
Func chkDebugBuildingPos()
$g_bDebugBuildingPos =(GUICtrlRead($g_hChkdebugBuildingPos) = $GUI_CHECKED)
SetDebugLog("DebugBuildingPos " &($g_bDebugBuildingPos ? "enabled" : "disabled"))
EndFunc
Func chkDebugTrain()
$g_bDebugSetlogTrain =(GUICtrlRead($g_hChkdebugTrain) = $GUI_CHECKED)
SetDebugLog("DebugTrain " &($g_bDebugSetlogTrain ? "enabled" : "disabled"))
EndFunc
Func chkdebugOCRDonate()
$g_bDebugOCRdonate =(GUICtrlRead($g_hChkDebugOCRDonate) = $GUI_CHECKED)
SetDebugLog("DebugOCRDonate " &($g_bDebugOCRdonate ? "enabled" : "disabled"))
EndFunc
Func chkdebugAttackCSV()
$g_bDebugAttackCSV =(GUICtrlRead($g_hChkdebugAttackCSV) = $GUI_CHECKED)
SetDebugLog("DebugAttackCSV " &($g_bDebugAttackCSV ? "enabled" : "disabled"))
EndFunc
Func chkmakeIMGCSV()
$g_bDebugMakeIMGCSV =(GUICtrlRead($g_hChkMakeIMGCSV) = $GUI_CHECKED)
SetDebugLog("MakeIMGCSV " &($g_bDebugMakeIMGCSV ? "enabled" : "disabled"))
EndFunc
Func btnTestDonateCC()
Local $currentRunState = $g_bRunState
Local $currentSetlog = $g_bDebugSetlog
_GUICtrlTab_ClickTab($g_hTabMain, 0)
$g_bRunState = True
SetLog(_PadStringCenter(" Test DonateCC begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
PrepareDonateCC()
$g_iCurrentSpells = 11
$g_aiCurrentSiegeMachines[$eSiegeWallWrecker] = 1
$g_aiCurrentSiegeMachines[$eSiegeBattleBlimp] = 1
$g_aiCurrentSiegeMachines[$eSiegeStoneSlammer] = 1
DonateCC()
SetLog(_PadStringCenter(" Test DonateCC end ", 54, "="), $COLOR_INFO)
$g_bRunState = $currentRunState
$g_bDebugSetlog = $currentSetlog
EndFunc
Func btnTestRequestCC()
Local $currentRunState = $g_bRunState
$g_bRunState = True
$g_bCanRequestCC = True
SetLog(_PadStringCenter(" Test RequestCC begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
RequestCC()
SetLog(_PadStringCenter(" Test RequestCC end ", 54, "="), $COLOR_INFO)
$g_bRunState = $currentRunState
EndFunc
Func btnTestSendText()
Local $currentRunState = $g_bRunState
$g_bRunState = True
SetLog(_PadStringCenter(" Test SendText begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
Local $s = InputBox("Send characters to Android", "Text to send (please open a input box in Android):", "some text ;-)", "")
SendText($s)
SetLog(_PadStringCenter(" Test SendText end ", 54, "="), $COLOR_INFO)
$g_bRunState = $currentRunState
EndFunc
Func btnTestAttackBar()
Local $bCurrentOCR = $g_bDebugOcr, $bCurrentRunState = $g_bRunState, $bCurrentDebugImage = $g_bDebugImageSave
_GUICtrlTab_ClickTab($g_hTabMain, 0)
$g_bDebugOcr = True
$g_bDebugImageSave = True
$g_bRunState = True
If MsgBox($MB_YESNO, "Screenshot or Live Image", "Do you want to use a Screenshot instead of a Live Image?") = $IDYES Then
Local $sImageFile = BeginImageTest()
If $sImageFile = False Then $sImageFile = "Live Screenshot"
EndIf
SetLog(_PadStringCenter(" Begin AttackBar Detection", 54, "="), $COlOR_INFO)
Local $avAttackBar = GetAttackBar(False, $DB, True)
If IsArray($avAttackBar) And UBound($avAttackBar, 1) >= 1 Then
SetLog("Found " & UBound($avAttackBar, 1) & " Slots", $COlOR_SUCCESS)
For $i = 0 To UBound($avAttackBar, 1) - 1
SetLog("- Slot " & $avAttackBar[$i][1] & ": " & $avAttackBar[$i][2] & " " & GetTroopName($avAttackBar[$i][0], $avAttackBar[$i][2]) & " (X: " & $avAttackBar[$i][3] & "|Y: " & $avAttackBar[$i][4] & "|OCR X: " & $avAttackBar[$i][5] & "|OCR Y: " & $avAttackBar[$i][6] & ")", $COLOR_SUCCESS)
Next
EndIf
SetLog(_PadStringCenter(" End AttackBar Detection ", 54, "="), $COlOR_INFO)
EndImageTest()
$g_bDebugOcr = $bCurrentOCR
$g_bDebugImageSave = $bCurrentDebugImage
$g_bRunState = $bCurrentRunState
EndFunc
Func btnTestClickDrag()
Local $sUserInputCoor = InputBox("Coordinators", "x1,y1,x2,y2", "650,469,290,469")
Local $asCoor = StringSplit($sUserInputCoor, ",")
If @error Or $asCoor[0] <> 4 Then
SetLog("Please try again with the correct format...", $COLOR_ERROR)
Return
EndIf
SetLog("Testing Click drag functionality...", $COLOR_INFO)
SetLog("Drag from (" & $asCoor[1] & "," & $asCoor[2] & ") to (" & $asCoor[3] & "," & $asCoor[4] & ")", $COLOR_DEBUG)
ClickDrag(Int($asCoor[1]), Int($asCoor[2]), Int($asCoor[3]), Int($asCoor[4]))
SetLog("Sleep 3 seconds...", $COLOR_DEBUG)
_Sleep(3000, True, False)
SetLog("Save the image...", $COLOR_DEBUG)
DebugImageSave("TestClickDrag", Default, Default, Default, "_" & $asCoor[1] & "x." & $asCoor[2] & "y." & $asCoor[3] & "x." & $asCoor[4] & "y_")
SetLog("Sleep 1 seconds...", $COLOR_DEBUG)
_Sleep(1000, True, False)
SetLog("Drag back", $COLOR_DEBUG)
ClickDrag(Int($asCoor[3]), Int($asCoor[4]), Int($asCoor[1]), Int($asCoor[2]))
EndFunc
Func btnTestImage()
Local $sImageFile = BeginImageTest()
If $sImageFile = False Then $sImageFile = "Live Screenshot"
Local $i
Local $result
Local $currentRunState = $g_bRunState
$g_bRunState = True
For $i = 0 To 0
SetLog("Testing isProblemAffect...", $COLOR_SUCCESS)
$result = isProblemAffect(False)
SetLog("Testing isProblemAffect DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing checkObstacles...", $COLOR_SUCCESS)
$result = checkObstacles()
SetLog("Testing checkObstacles DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing waitMainScreen...", $COLOR_SUCCESS)
$result = waitMainScreen()
SetLog("Testing waitMainScreen DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing waitMainScreenMini...", $COLOR_SUCCESS)
$result = waitMainScreenMini()
SetLog("Testing waitMainScreenMini DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing WaitForClouds...", $COLOR_SUCCESS)
SetLog("$aNoCloudsAttack pixel check: " & _CheckPixel($aNoCloudsAttack, $g_bCapturePixel))
SetLog("Testing WaitForClouds DONE", $COLOR_SUCCESS)
Next
SetLog("Testing finished", $COLOR_INFO)
EndImageTest()
$g_bRunState = $currentRunState
EndFunc
Func btnTestVillageSize()
BeginImageTest()
Local $currentRunState = $g_bRunState
$g_bRunState = True
_CaptureRegion()
_CaptureRegion2Sync()
Local $a[2][2] = [["stone", "tree"], ["2stone", "2tree"]]
For $i = 0 To 1
SetLog("Testing GetVillageSize(True, """ & $a[$i][0] & """, """ & $a[$i][1] & """)", $COLOR_INFO)
Local $hTimer = __TimerInit()
Local $village = GetVillageSize(True, $a[$i][0], $a[$i][1])
Local $ms = __TimerDiff($hTimer)
If $village = 0 Then
SetLog("Village not found (" & Round($ms, 0) & " ms.)", $COLOR_WARNING)
Else
SetLog("Village found (" & Round($ms, 0) & " ms.)", $COLOR_WARNING)
SetLog("Village size: " & $village[0])
SetLog("Village zoom level: " & $village[1])
SetLog("Village offset x: " & $village[2])
SetLog("Village offset y: " & $village[3])
SetLog("Village stone " & $village[6] & ": " & $village[4] & ", " & $village[5])
SetLog("Village tree " & $village[9] & ": " & $village[7] & ", " & $village[8])
EndIf
Next
EndImageTest()
$g_bRunState = $currentRunState
EndFunc
Func btnTestDeadBase()
Local $hBMP = 0, $hHBMP = 0
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test, cancel to use live screenshot", $g_sProfileTempPath, "Image (*.png)", $FD_FILEMUSTEXIST, "", $g_hFrmBot)
If @error <> 0 Then
SetLog("Testing image cancelled, taking screenshot from " & $g_sAndroidEmulator, $COLOR_INFO)
_CaptureRegion()
$hHBMP = $g_hHBitmap
TestCapture($hHBMP)
Else
SetLog("Testing image " & $sImageFile, $COLOR_INFO)
$hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
$hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
EndIf
Local $currentRunState = $g_bRunState
$g_bRunState = True
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestDeadBase")
ResetTHsearch()
SetLog("Testing FindTownhall()", $COLOR_INFO)
SetLog("FindTownhall() = " & FindTownhall(True), $COLOR_INFO)
SetLog("$g_sImglocRedline = " & $g_sImglocRedline, $COLOR_INFO)
SetLog("Testing checkDeadBase()", $COLOR_INFO)
SetLog("Result checkDeadBase() = " & checkDeadBase(), $COLOR_INFO)
SetLog("Testing checkDeadBase() DONE", $COLOR_INFO)
If $hHBMP <> 0 Then
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
EndIf
$g_bRunState = $currentRunState
EndFunc
Func btnTestDeadBaseFolder()
Local $directory = FileSelectFolder("Select folder of CoC village screenshot to test for dead base", "", $FSF_NEWDIALOG, @ScriptDir, $g_hFrmBot)
If @error <> 0 Then
SetLog("btnTestDeadBaseFolder cancelled", $COLOR_INFO)
EndIf
Local $oldFill = 'checkDeadBaseSuperNew(False, "' & @ScriptDir & "\imgxml\deadbase\elix\fill\old\" & '")'
Local $newFill = 'checkDeadBaseSuperNew(False, "' & @ScriptDir & "\imgxml\deadbase\elix\fill\new\" & '")'
checkDeadBaseFolder($directory, $oldFill, $newFill)
EndFunc
Func btnTestAttackCSV()
BeginImageTest()
Local $currentRunState = $g_bRunState
Local $currentDebugAttackCSV = $g_bDebugAttackCSV
Local $currentMakeIMGCSV = $g_bDebugMakeIMGCSV
Local $currentiMatchMode = $g_iMatchMode
Local $currentdebugsetlog = $g_bDebugSetlog
Local $currentDebugBuildingPos = $g_bDebugBuildingPos
$g_bRunState = True
$g_bDebugAttackCSV = True
$g_bDebugMakeIMGCSV = True
$g_bDebugSetlog = True
$g_bDebugBuildingPos = True
$g_iMatchMode = $DB
setVillageOffset(0, 0, 1)
ConvertInternalExternArea()
If CheckZoomOut("btnTestAttackCSV", True, False) = False Then
SetLog("CheckZoomOut failed", $COLOR_INFO)
EndIf
ResetTHsearch()
SetLog("Testing FindTownhall()", $COLOR_INFO)
SetLog("FindTownhall() = " & FindTownhall(True), $COLOR_INFO)
SetLog("$g_sImglocRedline = " & $g_sImglocRedline, $COLOR_INFO)
SetLog("Testing PrepareAttack()", $COLOR_INFO)
PrepareAttack($g_iMatchMode)
SetLog("Testing Algorithm_AttackCSV()", $COLOR_INFO)
Algorithm_AttackCSV(True, False)
SetLog("Testing Algorithm_AttackCSV() DONE", $COLOR_INFO)
EndImageTest()
$g_bRunState = $currentRunState
$g_bDebugAttackCSV = $currentDebugAttackCSV
$g_bDebugMakeIMGCSV = $currentMakeIMGCSV
$g_iMatchMode = $currentiMatchMode
$g_bDebugSetlog = $currentdebugsetlog
$g_bDebugBuildingPos = $currentDebugBuildingPos
EndFunc
Func btnTestGetLocationBuilding()
Local $aResult, $iBdlgFindTime, $hTimer
BeginImageTest()
Local $currentRunState = $g_bRunState
Local $currentDebugBuildingPos = $g_bDebugBuildingPos
Local $currentdebugsetlog = $g_bDebugSetlog
$g_bRunState = True
$g_bDebugBuildingPos = True
$g_bDebugSetlog = True
setVillageOffset(0, 0, 1)
ConvertInternalExternArea()
If CheckZoomOut("btnTestGetLocationBuilding", True, False) = False Then
SetLog("CheckZoomOut failed", $COLOR_INFO)
EndIf
ResetTHsearch()
SetLog("Testing FindTownhall()", $COLOR_INFO)
SetLog("FindTownhall() = " & FindTownhall(True), $COLOR_INFO)
_LogObjList($g_oBldgAttackInfo)
SetLog("Testing GetLocationBuilding() with all buildings", $COLOR_INFO)
For $b = $eBldgGoldS To $eBldgAirDefense
If $b = $eBldgDarkS Then ContinueLoop
$aResult = GetLocationBuilding($b, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$b], $COLOR_ERROR)
Next
_LogObjList($g_oBldgAttackInfo)
btnTestGetLocationBuildingImage()
Local $string, $iFindBldgTotalTestTime
Local $iKeys = $g_oBldgAttackInfo.Keys
For $string In $iKeys
If StringInStr($string, "_FINDTIME", $STR_NOCASESENSEBASIC) > 0 Then $iFindBldgTotalTestTime += $g_oBldgAttackInfo.item($string)
Next
SetLog("GetLocationBuilding() Total Image search time= " & $iFindBldgTotalTestTime, $COLOR_SUCCESS)
$g_oBldgAttackInfo.RemoveAll
SetLog("Testing DONE", $COLOR_INFO)
EndImageTest()
$g_bRunState = $currentRunState
$g_bDebugBuildingPos = $currentDebugBuildingPos
$g_bDebugSetlog = $currentdebugsetlog
EndFunc
Func btnTestGetLocationBuildingImage()
Local $iTimer = __TimerInit()
_CaptureRegion2()
Local $EditedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $pixel
Local $hPenWhite = _GDIPlus_PenCreate(0xFFFFFFFF, 2)
Local $hPenMagenta = _GDIPlus_PenCreate(0xFFFF00F6, 2)
Local $hPenRed = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $hPenNavyBlue = _GDIPlus_PenCreate(0xFF000066, 2)
Local $hPenBlue = _GDIPlus_PenCreate(0xFF0000CC, 2)
Local $hPenSteelBlue = _GDIPlus_PenCreate(0xFF0066CC, 2)
Local $hPenLtBlue = _GDIPlus_PenCreate(0xFF0080FF, 2)
Local $hPenPaleBlue = _GDIPlus_PenCreate(0xFF66B2FF, 2)
Local $hPenCyan = _GDIPlus_PenCreate(0xFF00FFFF, 2)
If $g_oBldgAttackInfo.exists($eBldgGoldS & "_LOCATION") Then
$g_aiCSVGoldStoragePos = $g_oBldgAttackInfo.item($eBldgGoldS & "_LOCATION")
If IsArray($g_aiCSVGoldStoragePos) Then
For $i = 0 To UBound($g_aiCSVGoldStoragePos) - 1
$pixel = $g_aiCSVGoldStoragePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 20, 20, $hPenMagenta)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgElixirS & "_LOCATION") Then
$g_aiCSVElixirStoragePos = $g_oBldgAttackInfo.item($eBldgElixirS & "_LOCATION")
If IsArray($g_aiCSVElixirStoragePos) Then
For $i = 0 To UBound($g_aiCSVElixirStoragePos) - 1
$pixel = $g_aiCSVElixirStoragePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 20, 20, $hPenWhite)
Next
EndIf
EndIf
_GDIPlus_GraphicsDrawRect($hGraphic, $g_iTHx - 5, $g_iTHy - 10, 30, 30, $hPenRed)
If $g_oBldgAttackInfo.exists($eBldgEagle & "_LOCATION") Then
$g_aiCSVEagleArtilleryPos = $g_oBldgAttackInfo.item($eBldgEagle & "_LOCATION")
If IsArray($g_aiCSVEagleArtilleryPos[0]) Then
Local $sPixel = $g_aiCSVEagleArtilleryPos[0]
_GDIPlus_GraphicsDrawRect($hGraphic, $sPixel[0] - 15, $sPixel[1] - 15, 30, 30, $hPenBlue)
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgInferno & "_LOCATION") Then
$g_aiCSVInfernoPos = $g_oBldgAttackInfo.item($eBldgInferno & "_LOCATION")
If IsArray($g_aiCSVInfernoPos) Then
For $i = 0 To UBound($g_aiCSVInfernoPos) - 1
$pixel = $g_aiCSVInfernoPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenNavyBlue)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgXBow & "_LOCATION") Then
$g_aiCSVXBowPos = $g_oBldgAttackInfo.item($eBldgXBow & "_LOCATION")
If IsArray($g_aiCSVXBowPos) Then
For $i = 0 To UBound($g_aiCSVXBowPos) - 1
$pixel = $g_aiCSVXBowPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 25, 25, 25, $hPenBlue)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgWizTower & "_LOCATION") Then
$g_aiCSVWizTowerPos = $g_oBldgAttackInfo.item($eBldgWizTower & "_LOCATION")
If IsArray($g_aiCSVWizTowerPos) Then
For $i = 0 To UBound($g_aiCSVWizTowerPos) - 1
$pixel = $g_aiCSVWizTowerPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 5, $pixel[1] - 15, 25, 25, $hPenSteelBlue)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgMortar & "_LOCATION") Then
$g_aiCSVMortarPos = $g_oBldgAttackInfo.item($eBldgMortar & "_LOCATION")
If IsArray($g_aiCSVMortarPos) Then
For $i = 0 To UBound($g_aiCSVMortarPos) - 1
$pixel = $g_aiCSVMortarPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 25, 25, $hPenLtBlue)
Next
EndIf
EndIf
If $g_oBldgAttackInfo.exists($eBldgAirDefense & "_LOCATION") Then
$g_aiCSVAirDefensePos = $g_oBldgAttackInfo.item($eBldgAirDefense & "_LOCATION")
If IsArray($g_aiCSVAirDefensePos) Then
For $i = 0 To UBound($g_aiCSVAirDefensePos) - 1
$pixel = $g_aiCSVAirDefensePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 12, $pixel[1] - 10, 25, 25, $hPenPaleBlue)
Next
EndIf
EndIf
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $g_sProfileTempDebugPath & String("GetLocationBuilding_" & $Date & "_" & $Time) & ".jpg"
_GDIPlus_ImageSaveToFile($EditedImage, $filename)
SetLog("GetLocationBuilding image saved: " & $filename)
_GDIPlus_PenDispose($hPenWhite)
_GDIPlus_PenDispose($hPenMagenta)
_GDIPlus_PenDispose($hPenRed)
_GDIPlus_PenDispose($hPenBlue)
_GDIPlus_PenDispose($hPenNavyBlue)
_GDIPlus_PenDispose($hPenSteelBlue)
_GDIPlus_PenDispose($hPenLtBlue)
_GDIPlus_PenDispose($hPenPaleBlue)
_GDIPlus_PenDispose($hPenCyan)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($EditedImage)
If TestCapture() Then
ShellExecute($filename)
EndIf
SetLog("GetLocationBuilding DEBUG IMAGE Create Required: " & Round((__TimerDiff($iTimer) * 0.001), 1) & "Seconds", $COLOR_DEBUG)
EndFunc
Func btnTestFindButton()
BeginImageTest()
Local $result
Local $sButton = GUICtrlRead($g_hTxtTestFindButton)
SetLog("Testing findButton(""" & $sButton & """)", $COLOR_INFO)
$result = findButton($sButton)
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result findButton(""" & $sButton & """) = " & $result, $COLOR_INFO)
SetLog("Testing findButton(""" & $sButton & """) DONE", $COLOR_INFO)
EndImageTest()
EndFunc
Func btnTestCleanYard()
Local $currentRunState = $g_bRunState
Local $iCurrFreeBuilderCount = $g_iFreeBuilderCount
$g_iTestFreeBuilderCount = 5
$g_bRunState = True
BeginImageTest()
Local $result
SetLog("Testing CleanYard", $COLOR_INFO)
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestCleanYard")
$result = CleanYard()
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result CleanYard", $COLOR_INFO)
SetLog("Testing CheckTombs", $COLOR_INFO)
$result = CheckTombs()
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result CheckTombs", $COLOR_INFO)
SetLog("Testing CleanYard DONE", $COLOR_INFO)
EndImageTest()
$g_iTestFreeBuilderCount = -1
$g_iFreeBuilderCount = $iCurrFreeBuilderCount
$g_bRunState = $currentRunState
EndFunc
Func BeginImageTest($directory = $g_sProfileTempPath)
Local $hBMP = 0, $hHBMP = 0
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test, cancel to use live screenshot", $directory, "Image (*.png)", $FD_FILEMUSTEXIST, "", $g_hFrmBot)
If @error <> 0 Then
SetLog("Testing image cancelled, taking screenshot from " & $g_sAndroidEmulator, $COLOR_INFO)
_CaptureRegion()
$hHBMP = $g_hHBitmap
TestCapture($hHBMP)
Return False
EndIf
SetLog("Testing image " & $sImageFile, $COLOR_INFO)
$hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
$hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
Return $sImageFile
EndFunc
Func EndImageTest()
TestCapture(0)
EndFunc
Func btnTestOcrMemory()
_CaptureRegion2(162, 200, 162 + 120, 200 + 27)
For $i = 1 To 5000
DllCallMyBot("ocr", "ptr", $g_hHBitmap2, "str", "coc-DonTroops", "int", $g_bDebugOcr ? 1 : 0)
Next
EndFunc
Func btnTestWeakBase()
Local $currentRunState = $g_bRunState
$g_bRunState = True
BeginImageTest()
FindTownhall(True)
If($g_iSearchTH <> "-") Then
IsWeakBase($g_iImglocTHLevel, $g_sImglocRedline, False)
Else
IsWeakBase($g_iMaxTHLevel, "", False)
EndIf
EndImageTest()
$g_bRunState = $currentRunState
EndFunc
Func btnTestClickAway()
ClickP($aAway, 2, 0)
EndFunc
Func btnTestUpgradeWindow()
Local $currentRunState = $g_bRunState
Local $iCurrFreeBuilderCount = $g_iFreeBuilderCount
$g_iTestFreeBuilderCount = 5
$g_bRunState = True
BeginImageTest()
Local $result
SetLog("Testing LocateUpgrade", $COLOR_INFO)
SetLog("Result = " & $result, $COLOR_INFO)
EndImageTest()
$g_iTestFreeBuilderCount = -1
$g_iFreeBuilderCount = $iCurrFreeBuilderCount
$g_bRunState = $currentRunState
EndFunc
Func btnTestSmartWait()
Local $currentRunState = $g_bRunState
Local $bCloseWhileTrainingEnable = $g_bCloseWhileTrainingEnable
$g_bRunState = True
$g_bCloseWhileTrainingEnable = True
SmartWait4Train(20)
$g_bRunState = $currentRunState
$g_bCloseWhileTrainingEnable = $bCloseWhileTrainingEnable
EndFunc
Func btnConsoleWindow()
ConsoleWindow()
EndFunc
Func chkSQLite()
$g_bUseStatistics = GUICtrlRead($g_hChkSqlite) = $GUI_CHECKED
EndFunc
Func SQLiteExport()
If Not $g_bUseStatistics Then
Setlog("")
Return
EndIf
Setlog("Exporting data from SQlite, please wait!", $COLOR_ACTION)
ExportDataBase(False)
Setlog("Export successfully completed.", $COLOR_SUCCESS)
EndFunc
Func PopulatePresetComboBox()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sProfilePresetPath & "\*.ini")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbPresetList)
GUICtrlSetData($g_hCmbPresetList, $output)
EndFunc
Func PresetLoadConfigInfo()
Local $inputfilename = $g_sProfilePresetPath & "\" & GUICtrlRead($g_hCmbPresetList) & ".ini"
SetDebugLog("PresetLoadConfigInfo: " & $inputfilename)
Local $message = IniRead($inputfilename, "Preset", "info", "")
If StringInStr($message, "\n") > 0 Then
GUICtrlSetData($g_hTxtPresetMessage, StringReplace($message, "\n", @CRLF))
Else
GUICtrlSetData($g_hTxtPresetMessage, $message)
EndIf
GUICtrlSetState($g_hLblLoadPresetMessage, $GUI_HIDE)
GUICtrlSetState($g_hTxtPresetMessage, $GUI_SHOW)
GUICtrlSetState($g_hBtnGUIPresetLoadConf, $GUI_SHOW)
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_SHOW + $GUI_DISABLE)
GUICtrlSetState($g_hChkDeleteConf, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteConf, $GUI_SHOW)
EndFunc
Func PresetLoadConf()
Local $filename = GUICtrlRead($g_hCmbPresetList)
$g_sProfileSecondaryInputFileName = $g_sProfilePresetPath & "\" & $filename & ".ini"
SetDebugLog("PresetLoadConf: " & $g_sProfileSecondaryInputFileName)
SaveConfig()
readConfig()
applyConfig(False)
_GUICtrlTab_ClickTab($g_hTabMain, 0)
SetRedrawBotWindow(True, Default, Default, Default, "PresetLoadConf")
SetLog("Config " & $filename & " LOADED!", $COLOR_SUCCESS)
$g_sProfileSecondaryInputFileName = ""
EndFunc
Func PresetSaveConf()
Local $filename = GUICtrlRead($g_hTxtPresetSaveFilename)
If StringRight($filename, 4) = ".ini" Then
$filename = StringLeft($filename, StringLen($filename) - 4)
GUICtrlSetData($g_hTxtPresetSaveFilename, $filename)
EndIf
If StringRegExp($filename, '\\|/|:|\*|\?|\"|\<|\>|\|') Then GUICtrlSetData($g_hTxtPresetSaveFilename, StringRegExpReplace($filename, '\\|/|:|\*|\?|\"|\<|\>|\|', "_"))
If FileExists($g_sProfilePresetPath & "\" & $filename & ".ini") Then
Local $i = 2
While $i > 0
If FileExists($g_sProfilePresetPath & "\" & $filename & " (" & $i & ").ini") Then
$i += 1
Else
$filename = $filename & " (" & $i & ")"
GUICtrlSetData($g_hTxtPresetSaveFilename, $filename)
$i = 0
EndIf
WEnd
EndIf
Local $msg = StringReplace(GUICtrlRead($g_hTxtSavePresetMessage), @CRLF, "\n")
$g_sProfileSecondaryOutputFileName = $g_sProfilePresetPath & "\" & $filename & ".ini"
SetDebugLog("PresetSaveConf: " & $g_sProfileSecondaryInputFileName)
IniWrite($g_sProfileSecondaryOutputFileName, "preset", "info", $msg)
saveConfig()
readconfig()
applyConfig()
_GUICtrlTab_ClickTab($g_hTabMain, 0)
SetLog("Config " & $filename & " SAVED!", $COLOR_SUCCESS)
$g_sProfileSecondaryOutputFileName = ""
EndFunc
Func PresetDeleteConf()
Local $button = MsgBox($MB_ICONWARNING + $MB_OKCANCEL, GetTranslatedFileIni("MBR Popups", "Func_PresetDeleteConf_Info_01", "Delete Configuration"), GetTranslatedFileIni("MBR Popups", "Func_PresetDeleteConf_Info_02", 'Are you sure you want to delete the configuration ?') & GUICtrlRead($g_hCmbPresetList) & '"?' & @CRLF & "This cannot be undone.")
If $button = $IDOK Then
SetDebugLog("PresetDeleteConf: " & $g_sProfilePresetPath & "\" & GUICtrlRead($g_hCmbPresetList) & ".ini")
FileDelete($g_sProfilePresetPath & "\" & GUICtrlRead($g_hCmbPresetList) & ".ini")
saveconfig()
readconfig()
applyConfig()
EndIf
EndFunc
Func chkCheckDeleteConf()
If GUICtrlRead($g_hChkDeleteConf) = $GUI_CHECKED Then
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_DISABLE)
EndIf
EndFunc
Func MakeSavePresetMessage()
Local $message = ""
$message &= "NOTES:" & @CRLF & @CRLF
If $g_bDropTrophyEnable Then $message &= "TROPHIES RANGE: " & $g_iDropTrophyMin & " - " & $g_iDropTrophyMax & @CRLF & @CRLF
$message &= "TRAIN ARMY SETTINGS:" & @CRLF
$message &= "- Custom Train Troops:" & @CRLF
For $i = 0 To $eTroopCount - 1
If $g_aiArmyCompTroops[$i] > 0 Then
$message &= "  " & $g_asTroopShortNames[$i] & " " & $g_aiArmyCompTroops[$i] & "x"
If Mod($i + 1, 4) = 0 Then $message &= @CRLF
EndIf
Next
$message &= @CRLF
$message &= "SEARCH SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB search: "
Case $LB
$message &= "- AS search: "
Case $TS
$message &= "- TH search: "
EndSwitch
If $g_abSearchSearchesEnable[$i] Then $message &= " " & "s. " & $g_aiSearchSearchesMin[$i] & "-" & $g_aiSearchSearchesMax[$i]
If $g_abSearchTropiesEnable[$i] Then $message &= "  " & "t. " & $g_aiSearchTrophiesMin[$i] & "-" & $g_aiSearchTrophiesMax[$i]
If $g_abSearchCampsEnable[$i] Then $message &= " " & "c. >" & $g_aiSearchCampsPct[$i] & "%"
$message &= @CRLF
Switch $i
Case $DB
$message &= "- DB filter: "
Case $LB
$message &= "- AS filter: "
Case $TS
$message &= "- TH filter: "
EndSwitch
Switch $g_aiFilterMeetGE[$i]
Case 0
$message &= " G >= " & $g_aiFilterMinGold[$i]
$message &= " & "
$message &= " E >= " & $g_aiFilterMinElixir[$i] & "  "
Case 1
$message &= " G >= " & $g_aiFilterMinGold[$i]
$message &= " or "
$message &= " E >= " & $g_aiFilterMinElixir[$i] & "  "
Case 2
$message &= " G+E >= " & $g_aiFilterMinGoldPlusElixir[$i] & "  "
EndSwitch
If $g_abFilterMeetDEEnable[$i] Then $message &= " D >= " & $g_aiFilterMeetDEMin[$i] & "  "
If $g_abFilterMeetTrophyEnable[$i] Then $message &= " TR >= " & $g_aiFilterMeetTrophyMin[$i] & "  "
If $g_abFilterMeetTrophyEnable[$i] Then $message &= " TR <= " & $g_aiFilterMeetTrophyMax[$i] & "  "
If $g_abFilterMeetTH[$i] Then $message &= " TH >= " & $g_aiFilterMeetTHMin[$i] + 6 & "  "
If $g_abFilterMeetTHOutsideEnable[$i] Then $message &= " THO" & "  "
If IsWeakBaseActive($i) Then $message &= " WB" & "  "
If $g_abFilterMeetOneConditionEnable[$i] Then $message &= " MeetOne" & "  "
$message &= @CRLF
EndIf
Next
$message &= @CRLF & "ATTACK SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB: "
Case $LB
$message &= "- AS: "
Case $TS
$message &= "- TH: "
EndSwitch
If $i = $DB Or $i = $LB Then
Switch $g_aiAttackAlgorithm[$i]
Case "0"
$message &= "Standard Attack > "
Case "1"
$message &= "Scripted Attack > "
Case "2"
$message &= "Milking Attack   " & @CRLF
EndSwitch
EndIf
If $i = $TS Then $message &= $g_sAtkTSType & @CRLF
If($i = $DB Or $i = $LB) And $g_aiAttackAlgorithm[$i] = 0 Then
Local $tmp = StringSplit("one side|two sides|three sides|four sides|Four Finger Classic|DE side|TH side", "|", 2)
$message &= $tmp[$g_aiAttackStdDropSides[$i]] & @CRLF
EndIf
EndIf
Next
$message &= @CRLF & "END BATTLE SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB: "
Case $LB
$message &= "- AS: "
Case $TS
$message &= "- TH: "
EndSwitch
If $g_abStopAtkNoLoot1Enable[$i] Then $message &= "wait " & $g_aiStopAtkNoLoot1Time[$i] & "  "
If $g_abStopAtkNoLoot2Enable[$i] Then $message &= "wait " & $g_aiStopAtkNoLoot2Time[$i] & " ->(" & $g_aiStopAtkNoLoot2MinGold[$i] & "," & $g_aiStopAtkNoLoot2MinElixir[$i] & "," & $g_aiStopAtkNoLoot2MinDark[$i] & ")  "
If $g_abStopAtkNoResources[$i] Then $message &= "nores "
If $g_abStopAtkOneStar[$i] Then $message &= "1star  "
If $g_abStopAtkTwoStars[$i] Then $message &= "2stars  "
EndIf
$message &= @CRLF
Next
GUICtrlSetData($g_hTxtSavePresetMessage, $message)
EndFunc
Func btnStrategyFolder()
ShellExecute("explorer", $g_sProfilePresetPath)
EndFunc
Func cmbProfile()
If LoadProfile() Then
Return True
EndIf
_GUICtrlComboBox_SelectString($g_hCmbProfile, $g_sProfileCurrentName)
Return False
EndFunc
Func LoadProfile($bSaveCurrentProfile = True)
If $bSaveCurrentProfile Then
saveConfig()
EndIf
If setupProfile() Then
readConfig()
applyConfig()
saveConfig()
SetLog("Profile " & $g_sProfileCurrentName & " loaded from " & $g_sProfileConfigPath, $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func btnAddConfirm()
Switch @GUI_CtrlId
Case $g_hBtnAddProfile
GUICtrlSetState($g_hCmbProfile, $GUI_HIDE)
GUICtrlSetState($g_hTxtVillageName, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_HIDE)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_HIDE)
GUICtrlSetState($g_hBtnSaveprofile, $GUI_HIDE)
Case $g_hBtnConfirmAddProfile
Local $newProfileName = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
If FileExists($g_sProfilePath & "\" & $newProfileName) Then
MsgBox($MB_ICONWARNING, GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_01", "Profile Already Exists"), GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_02", "%s already exists.\r\nPlease choose another name for your profile.", $newProfileName))
Return
EndIf
saveConfig()
$g_sProfileCurrentName = $newProfileName
createProfile()
setupProfileComboBox()
selectProfile()
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnSaveprofile, $GUI_SHOW)
If GUICtrlGetState($g_hBtnDeleteProfile) <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnDeleteProfile, $GUI_ENABLE)
If GUICtrlGetState($g_hBtnRenameProfile) <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnRenameProfile, $GUI_ENABLE)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
EndFunc
Func btnDeleteCancel()
Switch @GUI_CtrlId
Case $g_hBtnDeleteProfile
Local $msgboxAnswer = MsgBox($MB_ICONWARNING + $MB_OKCANCEL, GetTranslatedFileIni("MBR Popups", "Delete_Profile_01", "Delete Profile"), GetTranslatedFileIni("MBR Popups", "Delete_Profile_02", "Are you sure you really want to delete the profile?\r\nThis action can not be undone."))
If $msgboxAnswer = $IDOK Then
If deleteProfile() Then
GUICtrlSetData($g_hTxtVillageName, GetTranslatedFileIni("MBR Popups", "MyVillage", "MyVillage"))
If _GUICtrlComboBox_GetCount($g_hCmbProfile) > 1 Then
setupProfileComboBox()
selectProfile()
Else
createProfile(True)
EndIf
EndIf
EndIf
Case $g_hBtnCancelProfileChange
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnSaveprofile, $GUI_SHOW)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
If GUICtrlRead($g_hCmbProfile) = "<No Profiles>" Then
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_DISABLE)
EndIf
EndFunc
Func btnRenameConfirm()
Switch @GUI_CtrlId
Case $g_hBtnRenameProfile
Local $sProfile = GUICtrlRead($g_hCmbProfile)
If aquireProfileMutex($sProfile, False, True) = 0 Then
Return
EndIf
GUICtrlSetData($g_hTxtVillageName, $sProfile)
GUICtrlSetState($g_hCmbProfile, $GUI_HIDE)
GUICtrlSetState($g_hTxtVillageName, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_SHOW)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_HIDE)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_HIDE)
GUICtrlSetState($g_hBtnSaveprofile, $GUI_HIDE)
Case $g_hBtnConfirmRenameProfile
Local $newProfileName = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
If FileExists($g_sProfilePath & "\" & $newProfileName) Then
MsgBox($MB_ICONWARNING, GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_01", "Profile Already Exists"), $newProfileName & " " & GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_03", "already exists.") & @CRLF & GetTranslatedFileIni("MBR Popups", "Profile_Already_Exists_04", "Please choose another name for your profile"))
Return
EndIf
$g_sProfileCurrentName = $newProfileName
renameProfile()
setupProfileComboBox()
selectProfile()
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnPullSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnPushSharedPrefs, $GUI_SHOW)
GUICtrlSetState($g_hBtnSaveprofile, $GUI_SHOW)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
EndFunc
Func btnPullSharedPrefs()
PullSharedPrefs()
EndFunc
Func btnPushSharedPrefs()
PushSharedPrefs()
EndFunc
Func BtnSaveprofile()
Setlog("Saving your setting...", $COLOR_INFO)
SaveConfig()
readConfig()
applyConfig()
Setlog("Done!", $COLOR_SUCCESS)
EndFunc
Func OnlySCIDAccounts()
If GUICtrlRead($g_hChkOnlySCIDAccounts) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbWhatSCIDAccount2Use, $GUI_ENABLE)
WhatSCIDAccount2Use()
$g_bOnlySCIDAccounts = True
Else
GUICtrlSetState($g_hCmbWhatSCIDAccount2Use, $GUI_DISABLE)
$g_bOnlySCIDAccounts = False
EndIf
EndFunc
Func WhatSCIDAccount2Use()
$g_iWhatSCIDAccount2Use = _GUICtrlComboBox_GetCurSel($g_hCmbWhatSCIDAccount2Use)
EndFunc
Func cmbBotCond()
If _GUICtrlComboBox_GetCurSel($g_hCmbBotCond) = 15 Then
If _GUICtrlComboBox_GetCurSel($g_hCmbHoursStop) = 0 Then _GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, 1)
GUICtrlSetState($g_hCmbHoursStop, $GUI_ENABLE)
Else
_GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, 0)
GUICtrlSetState($g_hCmbHoursStop, $GUI_DISABLE)
EndIf
EndFunc
Func chkBotStop()
If GUICtrlRead($g_hChkBotStop) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbBotCommand, $GUI_ENABLE)
GUICtrlSetState($g_hCmbBotCond, $GUI_ENABLE)
_GUI_Value_STATE("ENABLE", $g_hTxtRestartGold & "#" & $g_hTxtRestartElixir & "#" & $g_hTxtRestartDark)
Else
GUICtrlSetState($g_hCmbBotCommand, $GUI_DISABLE)
GUICtrlSetState($g_hCmbBotCond, $GUI_DISABLE)
_GUI_Value_STATE("DISABLE", $g_hTxtRestartGold & "#" & $g_hTxtRestartElixir & "#" & $g_hTxtRestartDark)
EndIf
EndFunc
Func btnLocateClanCastle()
Local $wasRunState = $g_bRunState
$g_bRunState = True
ZoomOut()
LocateClanCastle()
$g_bRunState = $wasRunState
AndroidShield("btnLocateClanCastle")
EndFunc
Func btnLocateKingAltar()
LocateKingAltar()
EndFunc
Func btnLocateQueenAltar()
LocateQueenAltar()
EndFunc
Func btnLocateWardenAltar()
LocateWardenAltar()
EndFunc
Func btnLocateTownHall()
Local $wasRunState = $g_bRunState
Local $g_iOldTownHallLevel = $g_iTownHallLevel
$g_bRunState = True
ZoomOut()
LocateTownHall()
If Not $g_iOldTownHallLevel = $g_iTownHallLevel Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Popups", "Locating_your_TH", "If you locating your TH because you upgraded,") & @CRLF & GetTranslatedFileIni("MBR Popups", "Must_restart_bot", "then you must restart bot!!!") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "OK_to_restart_bot", "Click OK to restart bot,") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Cancel_to_exit", "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Close_Bot", "Close Bot Please!"), $stext, 120)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
RestartBot(False, $wasRunState)
EndIf
EndIf
$g_bRunState = $wasRunState
AndroidShield("btnLocateTownHall")
EndFunc
Func btnResetBuilding()
Local $wasRunState = $g_bRunState
$g_bRunState = True
While 1
If _Sleep(500) Then Return
If FileExists($g_sProfileBuildingPath) Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Popups", "Delete_and_Reset_Building_info", "Click OK to Delete and Reset all Building info,") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Bot_will_exit", "NOTE =>> Bot will exit and need to be restarted when complete") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Cancel_to_exit", "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Delete_Building_Info", "Delete Building Infomation ?"), $stext, 120)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $stext = @CRLF & GetTranslatedFileIni("MBR Popups", "Sure_Delete_Building_Info", "Are you 100% sure you want to delete Building information ?") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Delete_then_restart_bot", "Click OK to Delete and then restart the bot (manually)") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Cancel_to_exit", -1) & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", -1), GetTranslatedFileIni("MBR Popups", "Delete_Building_Info", -1), $stext, 120)
If $g_bDebugSetlog Then SetDebugLog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $Result = FileDelete($g_sProfileBuildingPath)
If $Result = 0 Then
SetLog("Unable to remove building.ini file, please use manual method", $COLOR_ERROR)
Else
BotClose(False)
EndIf
EndIf
EndIf
Else
SetLog("Building.ini file does not exist", $COLOR_INFO)
EndIf
ExitLoop
WEnd
$g_bRunState = $wasRunState
AndroidShield("btnResetBuilding")
EndFunc
Func btnLab()
Local $wasRunState = $g_bRunState
$g_bRunState = True
ZoomOut()
LocateLab()
$g_bRunState = $wasRunState
AndroidShield("btnLab")
EndFunc
Func chkTrophyAtkDead()
If GUICtrlRead($g_hChkTrophyAtkDead) = $GUI_CHECKED Then
$g_bDropTrophyAtkDead = True
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_ENABLE)
Else
$g_bDropTrophyAtkDead = False
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_DISABLE)
EndIf
EndFunc
Func chkTrophyRange()
If GUICtrlRead($g_hChkTrophyRange) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDropTrophy, $GUI_ENABLE)
GUICtrlSetState($g_hTxtMaxTrophy, $GUI_ENABLE)
GUICtrlSetState($g_hChkTrophyHeroes, $GUI_ENABLE)
GUICtrlSetState($g_hChkTrophyAtkDead, $GUI_ENABLE)
chkTrophyAtkDead()
chkTrophyHeroes()
Else
GUICtrlSetState($g_hTxtDropTrophy, $GUI_DISABLE)
GUICtrlSetState($g_hTxtMaxTrophy, $GUI_DISABLE)
GUICtrlSetState($g_hChkTrophyHeroes, $GUI_DISABLE)
GUICtrlSetState($g_hChkTrophyAtkDead, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_DISABLE)
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_DISABLE)
EndIf
EndFunc
Func TxtDropTrophy()
If Number(GUICtrlRead($g_hTxtDropTrophy)) > Number(GUICtrlRead($g_hTxtMaxTrophy)) Then
GUICtrlSetData($g_hTxtMaxTrophy, GUICtrlRead($g_hTxtDropTrophy))
TxtMaxTrophy()
EndIf
_GUI_Value_STATE("HIDE", $g_aGroupListPicMinTrophy)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[21][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueLegend], $GUI_SHOW)
GUICtrlSetData($g_hLblMinTrophies, "")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[18][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueTitan], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[20][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[19][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[18][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[15][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueChampion], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[17][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[16][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[15][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[12][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueMaster], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[14][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[13][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[12][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[9][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueCrystal], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[11][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[10][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[9][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[6][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueGold], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[8][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[7][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[6][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[3][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueSilver], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[5][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[4][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[3][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[0][4]) Then
GUICtrlSetState($g_hPicMinTrophies[$eLeagueBronze], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[2][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[1][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtDropTrophy)) >= Number($g_asLeagueDetails[0][4]) Then
GUICtrlSetData($g_hLblMinTrophies, "3")
EndIf
Else
GUICtrlSetState($g_hPicMinTrophies[$eLeagueUnranked], $GUI_SHOW)
GUICtrlSetData($g_hLblMinTrophies, "")
EndIf
EndFunc
Func TxtMaxTrophy()
If Number(GUICtrlRead($g_hTxtDropTrophy)) > Number(GUICtrlRead($g_hTxtMaxTrophy)) Then
GUICtrlSetData($g_hTxtMaxTrophy, GUICtrlRead($g_hTxtDropTrophy))
EndIf
_GUI_Value_STATE("HIDE", $g_aGroupListPicMaxTrophy)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[21][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueLegend], $GUI_SHOW)
GUICtrlSetData($g_hLblMaxTrophies, "")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[18][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueTitan], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[20][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[19][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[18][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[15][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueChampion], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[17][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[16][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[15][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[12][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueMaster], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[14][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[13][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[12][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[9][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueCrystal], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[11][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[10][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[9][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[6][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueGold], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[8][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[7][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[6][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[3][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueSilver], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[5][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[4][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[3][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[0][4]) Then
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueBronze], $GUI_SHOW)
If Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[2][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "1")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[1][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "2")
ElseIf Number(GUICtrlRead($g_hTxtMaxTrophy)) >= Number($g_asLeagueDetails[0][4]) Then
GUICtrlSetData($g_hLblMaxTrophies, "3")
EndIf
Else
GUICtrlSetState($g_hPicMaxTrophies[$eLeagueUnranked], $GUI_SHOW)
GUICtrlSetData($g_hLblMaxTrophies, "")
EndIf
EndFunc
Func chkTrophyHeroes()
If GUICtrlRead($g_hChkTrophyHeroes) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_DISABLE)
EndIf
EndFunc
Func ChkCollect()
If GUICtrlRead($g_hChkCollect) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCollectCartFirst, $GUI_ENABLE)
GUICtrlSetState($g_hChkTreasuryCollect, $GUI_ENABLE)
GUICtrlSetState($g_hTxtCollectGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtCollectElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtCollectDark, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkCollectCartFirst, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCollectCartFirst, $GUI_DISABLE)
GUICtrlSetState($g_hChkTreasuryCollect, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTreasuryCollect, $GUI_DISABLE)
GUICtrlSetState($g_hTxtCollectGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtCollectElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtCollectDark, $GUI_DISABLE)
EndIf
ChkTreasuryCollect()
EndFunc
Func ChkTreasuryCollect()
If GUICtrlRead($g_hChkTreasuryCollect) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtTreasuryGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTreasuryElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTreasuryDark, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtTreasuryGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTreasuryElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTreasuryDark, $GUI_DISABLE)
EndIf
EndFunc
Func chkStartClockTowerBoost()
If GUICtrlRead($g_hChkStartClockTowerBoost) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCTBoostBlderBz, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkCTBoostBlderBz, $GUI_DISABLE)
EndIf
EndFunc
Func chkActivateClangames()
If GUICtrlRead($g_hChkClanGamesEnabled) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkClanGames60, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesAir, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesGround, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesMisc, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesLoot, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesBattle, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesDestruction, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesAirTroop, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesGroundTroop, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesMiscellaneous, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesPurge, $GUI_ENABLE)
If GUICtrlRead($g_hChkClanGamesPurge) = $GUI_CHECKED then GUICtrlSetState($g_hcmbPurgeLimit, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesStopBeforeReachAndPurge, $GUI_ENABLE)
GUICtrlSetState($g_hChkClanGamesDebug, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkClanGames60, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesAir, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesGround, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesMisc, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesLoot, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesBattle, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesDestruction, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesAirTroop, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesGroundTroop, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesMiscellaneous, $GUI_DISABLE)
GUICtrlSetState($g_hcmbPurgeLimit, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesStopBeforeReachAndPurge, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesPurge, $GUI_DISABLE)
GUICtrlSetState($g_hChkClanGamesDebug, $GUI_DISABLE)
EndIf
EndFunc
Func chkPurgeLimits()
If GUICtrlRead($g_hChkClanGamesPurge) = $GUI_CHECKED AND GUICtrlRead($g_hChkClanGamesEnabled) = $GUI_CHECKED Then
GUICtrlSetState($g_hcmbPurgeLimit, $GUI_ENABLE)
Else
GUICtrlSetState($g_hcmbPurgeLimit, $GUI_DISABLE)
EndIf
EndFunc
Func LoadCOCDistributorsComboBox()
Local $sDistributors = $g_sNO_COC
Local $aDistributorsData = GetCOCDistributors()
If @error = 2 Then
$sDistributors = $g_sUNKNOWN_COC
ElseIf IsArray($aDistributorsData) Then
$sDistributors = _ArrayToString($aDistributorsData, "|")
EndIf
GUICtrlSetData($g_hCmbCOCDistributors, "", "")
GUICtrlSetData($g_hCmbCOCDistributors, $sDistributors)
EndFunc
Func SetCurSelCmbCOCDistributors()
Local $sIniDistributor
Local $iIndex
If _GUICtrlComboBox_GetCount($g_hCmbCOCDistributors) = 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, 0)
GUICtrlSetState($g_hCmbCOCDistributors, $GUI_DISABLE)
Else
$sIniDistributor = GetCOCTranslated($g_sAndroidGameDistributor)
$iIndex = _GUICtrlComboBox_FindStringExact($g_hCmbCOCDistributors, $sIniDistributor)
If $iIndex = -1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, 0)
Else
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, $iIndex)
EndIf
GUICtrlSetState($g_hCmbCOCDistributors, $GUI_ENABLE)
EndIf
EndFunc
Func cmbCOCDistributors()
Local $sDistributor
_GUICtrlComboBox_GetLBText($g_hCmbCOCDistributors, _GUICtrlComboBox_GetCurSel($g_hCmbCOCDistributors), $sDistributor)
If $sDistributor = $g_sUserGameDistributor Then
$g_sAndroidGameDistributor = $g_sUserGameDistributor
$g_sAndroidGamePackage = $g_sUserGamePackage
$g_sAndroidGameClass = $g_sUserGameClass
Else
GetCOCUnTranslated($sDistributor)
If Not @error Then
$g_sAndroidGameDistributor = GetCOCUnTranslated($sDistributor)
$g_sAndroidGamePackage = GetCOCPackage($sDistributor)
$g_sAndroidGameClass = GetCOCClass($sDistributor)
EndIf
EndIf
EndFunc
Func DistributorsUpdateGUI()
LoadCOCDistributorsComboBox()
SetCurSelCmbCOCDistributors()
EndFunc
Func AndroidSuspendFlagsToIndex($iFlags)
Local $idx = 0
If BitAND($iFlags, 2) > 0 Then
$idx = 2
ElseIf BitAND($iFlags, 1) > 0 Then
$idx = 1
EndIf
If $idx > 0 And BitAND($iFlags, 4) > 0 Then $idx += 2
Return $idx
EndFunc
Func AndroidSuspendIndexToFlags($idx)
Local $iFlags = 0
Switch $idx
Case 1
$iFlags = 1
Case 2
$iFlags = 2
Case 3
$iFlags = 1 + 4
Case 4
$iFlags = 2 + 4
EndSwitch
Return $iFlags
EndFunc
Func cmbSuspendAndroid()
$g_iAndroidSuspendModeFlags = AndroidSuspendIndexToFlags(_GUICtrlComboBox_GetCurSel($g_hCmbSuspendAndroid))
EndFunc
Func cmbAndroidBackgroundMode()
$g_iAndroidBackgroundMode = _GUICtrlComboBox_GetCurSel($g_hCmbAndroidBackgroundMode)
UpdateAndroidBackgroundMode()
EndFunc
func EnableShowTouchs()
AndroidAdbSendShellCommand("content insert --uri content://settings/system --bind name:s:show_touches --bind value:i:1")
SetDebugLog("EnableShowTouchs ON")
EndFunc
func DisableShowTouchs()
AndroidAdbSendShellCommand("content insert --uri content://settings/system --bind name:s:show_touches --bind value:i:0")
SetDebugLog("EnableShowTouchs OFF")
EndFunc
Func BotStart($bAutostartDelay = 0)
FuncEnter(BotStart)
If Not $g_bSearchMode Then
If $g_hLogFile = 0 Then CreateLogFile()
CreateAttackLogFile()
If $g_iFirstRun = -1 Then $g_iFirstRun = 1
EndIf
SetLogCentered(" BOT LOG ", Default, Default, True)
If Not ForumAuthentication() Then
EnableControls($g_hFrmBotBottom, Default, $g_aFrmBotBottomCtrlState)
SetRedrawBotWindow(True, Default, Default, Default, "BotStart")
Return FuncReturn()
EndIf
ResumeAndroid()
CleanSecureFiles()
CalCostCamp()
CalCostSpell()
CalCostSiege()
$g_bRunState = True
$g_bTogglePauseAllowed = True
$g_bSkipFirstZoomout = False
$g_bIsSearchLimit = False
$g_bIsClientSyncError = False
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
$g_bTrainEnabled = True
$g_bDonationEnabled = True
$g_bMeetCondStop = False
$g_bIsClientSyncError = False
$g_bDisableBreakCheck = False
SaveConfig()
readConfig()
applyConfig(False)
CreaTableDB()
__ObjEventIni()
If BitAND($g_iAndroidSupportFeature, 1 + 2) = 0 And $g_bChkBackgroundMode = True Then
GUICtrlSetState($g_hChkBackgroundMode, $GUI_UNCHECKED)
UpdateChkBackground()
SetLog("Background Mode not supported for " & $g_sAndroidEmulator & " and has been disabled", $COLOR_ERROR)
EndIf
GUICtrlSetState($g_hBtnStart, $GUI_HIDE)
GUICtrlSetState($g_hBtnStop, $GUI_SHOW)
GUICtrlSetState($g_hBtnPause, $GUI_SHOW)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
GUICtrlSetState($g_hBtnSearchMode, $GUI_HIDE)
GUICtrlSetState($g_hChkBackgroundMode, $GUI_DISABLE)
TrayItemSetText($g_hTiStartStop, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Stop", "Stop bot"))
TrayItemSetState($g_hTiPause, $TRAY_ENABLE)
TrayItemSetText($g_hTiPause, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Pause", "Pause bot"))
EnableControls($g_hFrmBotBottom, Default, $g_aFrmBotBottomCtrlState)
DisableGuiControls()
SetRedrawBotWindow(True, Default, Default, Default, "BotStart")
If $bAutostartDelay Then
SetLog("Bot Auto Starting in " & Round($bAutostartDelay / 1000, 0) & " seconds", $COLOR_ERROR)
_SleepStatus($bAutostartDelay)
EndIf
LockBotSlot(True)
If $g_bRunState = False Then Return FuncReturn()
Local $Result = False
If WinGetAndroidHandle() = 0 Then
$Result = OpenAndroid(False)
EndIf
SetDebugLog("Android Window Handle: " & WinGetAndroidHandle())
If $g_hAndroidWindow <> 0 Then
If Not $g_bRunState Then Return FuncReturn()
If $g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable() Then
If Not $Result Then
$Result = InitiateLayout()
EndIf
Else
SetLog("Current " & $g_sAndroidEmulator & " Window not supported by MyBot", $COLOR_ERROR)
$Result = RebootAndroid(False)
EndIf
If Not $g_bRunState Then Return FuncReturn()
Local $hWndActive = $g_hAndroidWindow
If $g_bNoFocusTampering = False And $g_bAndroidBackgroundLaunched = False And $g_bAndroidEmbedded = False Then
Local $hTimer = __TimerInit()
$hWndActive = -1
Local $activeHWnD = WinGetHandle("")
While __TimerDiff($hTimer) < 1000 And $hWndActive <> $g_hAndroidWindow And Not _Sleep(100)
$hWndActive = WinActivate($g_hAndroidWindow)
WEnd
WinActivate($activeHWnD)
EndIf
If Not $g_bRunState Then Return FuncReturn()
If $hWndActive = $g_hAndroidWindow And($g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable()) Then
If $g_bChkAutoDock Then
If Not $g_bAndroidEmbedded Then
SetLog("Auto use Dock Android Window", $COLOR_INFO)
btnEmbed()
EndIf
If _Sleep($DELAYRUNBOT5) Then Return
ElseIf $g_bChkAutoHideEmulator Then
If Not $g_bIsHidden Then
SetLog("Auto hidden the Emulator", $COLOR_INFO)
btnHide()
$g_bIsHidden = True
EndIf
If _Sleep($DELAYRUNBOT5) Then Return
EndIf
If $g_bChkAutoMinimizeBot Then
SetLog("Auto Minimize the Bot", $COLOR_INFO)
If $g_bUpdatingWhenMinimized Then
If $g_bHideWhenMinimized Then
WinMove2($g_hFrmBot, "", -32000, -32000, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then WinSetState($g_hFrmBot, "", @SW_RESTORE)
If _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
WinMove2($g_hFrmBot, "", -32000, -32000, -1, -1, 0, BitOR($SWP_SHOWWINDOW, $SWP_NOACTIVATE), False)
Else
If $g_bHideWhenMinimized Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
WinSetState($g_hFrmBot, "", @SW_MINIMIZE)
EndIf
If _Sleep($DELAYRUNBOT5) Then Return
EndIf
Initiate()
Else
SetLog("Cannot use " & $g_sAndroidEmulator & ", please check log", $COLOR_ERROR)
btnStop()
EndIf
Else
SetLog("Cannot start " & $g_sAndroidEmulator & ", please check log", $COLOR_ERROR)
btnStop()
EndIf
FuncReturn()
EndFunc
Func BotStop()
FuncEnter(BotStop)
LockBotSlot(False)
releaseProfilesMutex()
ResumeAndroid()
$g_bRunState = False
$g_bBotPaused = False
$g_bTogglePauseAllowed = True
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
EnableGuiControls()
AndroidBotStopEvent()
If $g_bTerminateAdbShellOnStop Then
AndroidAdbTerminateShellInstance()
EndIf
AndroidShield("btnStop", Default)
EnableControls($g_hFrmBotBottom, Default, $g_aFrmBotBottomCtrlState)
GUICtrlSetState($g_hChkBackgroundMode, $GUI_ENABLE)
GUICtrlSetState($g_hBtnStart, $GUI_SHOW)
GUICtrlSetState($g_hBtnStop, $GUI_HIDE)
GUICtrlSetState($g_hBtnPause, $GUI_HIDE)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
If $g_iTownHallLevel > 2 Then GUICtrlSetState($g_hBtnSearchMode, $GUI_ENABLE)
GUICtrlSetState($g_hBtnSearchMode, $GUI_SHOW)
GUICtrlSetState($g_hBtnEnableGUI, $GUI_HIDE)
GUICtrlSetState($g_hBtnDisableGUI, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_HIDE)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_SHOW)
GUICtrlSetState($g_hLblVersion, $GUI_SHOW)
GUICtrlSetState($g_hLblMod, $GUI_SHOW)
TrayItemSetText($g_hTiStartStop, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Start", "Start bot"))
TrayItemSetState($g_hTiPause, $TRAY_DISABLE)
SetLogCentered(" Bot Stop ", Default, $COLOR_ACTION)
If Not $g_bSearchMode Then
If Not $g_bBotPaused Then $g_iTimePassed += Int(__TimerDiff($g_hTimerSinceStarted))
If ProfileSwitchAccountEnabled() And Not $g_bBotPaused Then $g_aiRunTime[$g_iCurAccount] += Int(__TimerDiff($g_ahTimerSinceSwitched[$g_iCurAccount]))
$g_bRestart = True
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
Else
$g_bSearchMode = False
EndIf
__ObjEventEnds()
ReduceBotMemory()
FuncReturn()
EndFunc
Func BotSearchMode()
FuncEnter(BotSearchMode)
$g_bSearchMode = True
$g_bRestart = False
$g_bIsClientSyncError = False
If $g_iFirstRun = 1 Then $g_iFirstRun = -1
btnStart()
checkMainScreen(False)
If _Sleep(100) Then Return FuncReturn()
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If _Sleep(100) Then Return FuncReturn()
CheckIfArmyIsReady()
ClickP($aAway, 2, 0, "")
If _Sleep(100) Then Return FuncReturn()
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If _Sleep(100) Then Return FuncReturn()
PrepareSearch()
If _Sleep(1000) Then Return FuncReturn()
VillageSearch()
If _Sleep(100) Then Return FuncReturn()
Else
SetLog("Your Army is not prepared, check the Attack/train options")
EndIf
btnStop()
FuncReturn()
EndFunc
Func chkRequestCCDefense()
If GUICtrlRead($g_hChkRequestCCDefense) = $GUI_CHECKED Then
For $i = $g_hTxtRequestCCDefense To $g_ahCmbCCTroopDefense[2]
GUICtrlSetState($i, $GUI_ENABLE)
Next
chkSaveCCTroopForDefense()
GUIToggle_RequestOnlyDuringHours(True)
Else
For $i = $g_hTxtRequestCCDefense To $g_ahCmbCCTroopDefense[2]
GUICtrlSetState($i, $GUI_DISABLE)
Next
If GUICtrlRead($g_hChkRequestTroopsEnable) = $GUI_UNCHECKED Then GUIToggle_RequestOnlyDuringHours(False)
EndIf
EndFunc
Func chkSaveCCTroopForDefense()
If GUICtrlRead($g_hChkSaveCCTroopForDefense) = $GUI_CHECKED Then
For $i = $g_ahTxtCCTroopDefense[0] To $g_ahCmbCCTroopDefense[2]
GUICtrlSetState($i, $GUI_ENABLE)
Next
cmbCCTroopDefense()
Else
For $i = $g_ahTxtCCTroopDefense[0] To $g_ahCmbCCTroopDefense[2]
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func cmbCCTroopDefense()
For $i = 0 To UBound($g_ahCmbCCTroopDefense) - 1
If _GUICtrlComboBox_GetCurSel($g_ahCmbCCTroopDefense[$i]) < $eTroopCount Then
GUICtrlSetState($g_ahTxtCCTroopDefense[$i], $GUI_ENABLE)
Else
GUICtrlSetState($g_ahTxtCCTroopDefense[$i], $GUI_DISABLE)
EndIf
Next
EndFunc
Func chkEnableAuto()
If GUICtrlRead($g_hChkEnableAuto) = $GUI_CHECKED Then
$g_bEnableAuto = True
_GUI_Value_STATE("ENABLE", $g_hChkAutoDock & "#" & $g_hChkAutoHideEmulator)
Else
$g_bEnableAuto = False
_GUI_Value_STATE("DISABLE", $g_hChkAutoDock & "#" & $g_hChkAutoHideEmulator)
EndIf
EndFunc
Func btnEnableAuto()
If $g_bEnableAuto = True Then
If GUICtrlRead($g_hChkAutoDock) = $GUI_CHECKED Then
$g_bChkAutoDock = True
$g_bChkAutoHideEmulator = False
ElseIf GUICtrlRead($g_hChkAutoHideEmulator) = $GUI_CHECKED Then
$g_bChkAutoDock = False
$g_bChkAutoHideEmulator = True
EndIf
Else
$g_bChkAutoDock = False
$g_bChkAutoHideEmulator = False
EndIf
EndFunc
Func chkSearchTimeout()
If GUICtrlRead($g_hChkSearchTimeout) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_hLblSearchTimeout & "#" & $g_hTxtSearchTimeout & "#" & $g_hLblSearchTimeoutminutes)
Else
_GUI_Value_STATE("DISABLE", $g_hLblSearchTimeout & "#" & $g_hTxtSearchTimeout & "#" & $g_hLblSearchTimeoutminutes)
EndIf
EndFunc
Func cmbStandardDropSidesAB()
If _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesAB) = 4 Then
GUICtrlSetState($g_hChkSmartAttackRedAreaAB, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartAttackRedAreaAB, $GUI_DISABLE)
Else
GUICtrlSetState($g_hChkSmartAttackRedAreaAB, $GUI_ENABLE)
EndIf
chkSmartAttackRedAreaAB()
EndFunc
Func cmbStandardDropSidesDB()
If _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesDB) = 4 Then
GUICtrlSetState($g_hChkSmartAttackRedAreaDB, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartAttackRedAreaDB, $GUI_DISABLE)
Else
GUICtrlSetState($g_hChkSmartAttackRedAreaDB, $GUI_ENABLE)
EndIf
chkSmartAttackRedAreaDB()
EndFunc
Func InitializeMainGUI($bGuiModeUpdate = False)
InitializeControlVariables()
If Not $bGuiModeUpdate Then AtkLogHead()
tabMain()
If FileExists($g_sProfileConfigPath) = 0 And $g_asCmdLine[0] > 0 Then
createProfile()
saveConfig()
setupProfileComboBox()
ElseIf $g_iGuiMode <> 1 Then
setupProfileComboBox()
EndIf
selectProfile()
If FileExists($g_sProfileConfigPath) Or FileExists($g_sProfileBuildingPath) Then
readConfig()
applyConfig()
EndIf
If $g_bDevMode Then
GUICtrlSetState($g_hChkDebugFunc, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableZoomout, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableVillageCentering, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDeadbaseImage, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCR, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugImageSave, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugBuildingPos, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugTrain, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCRDonate, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkMakeIMGCSV, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugAttackCSV, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugSmartZap, $GUI_SHOW + $GUI_ENABLE)
EndIf
GUISetOnEvent($GUI_EVENT_CLOSE, "GUIEvents", $g_hFrmBot)
GUISetOnEvent($GUI_EVENT_MINIMIZE, "GUIEvents", $g_hFrmBot)
GUISetOnEvent($GUI_EVENT_RESTORE, "GUIEvents", $g_hFrmBot)
GUIRegisterMsg($WM_COMMAND, "GUIControl_WM_COMMAND")
GUIRegisterMsg($WM_NOTIFY, "GUIControl_WM_NOTIFY")
For $i = $WM_MOUSEMOVE To $WM_MOUSEWHEEL
GUIRegisterMsg($i, "GUIControl_WM_MOUSE")
Next
GUIRegisterMsg($WM_CLOSE, "GUIControl_WM_CLOSE")
GUIRegisterMsg($WM_NCACTIVATE, "GUIControl_WM_NCACTIVATE")
GUIRegisterMsg($WM_SETFOCUS, "GUIControl_WM_FOCUS")
GUIRegisterMsg($WM_KILLFOCUS, "GUIControl_WM_FOCUS")
GUIRegisterMsg($WM_ACTIVATEAPP, "GUIControl_WM_ACTIVATEAPP")
GUIRegisterMsg($WM_MOVE, "GUIControl_WM_MOVE")
GUIRegisterMsg(_WinAPI_RegisterWindowMessage('SHELLHOOK'), 'GUIControl_WM_SHELLHOOK')
_WinAPI_RegisterShellHookWindow($g_hFrmBot)
$g_hFrmBot_WNDPROC_ptr = DllCallbackGetPtr(DllCallbackRegister("frmBot_WNDPROC", "ptr", "hwnd;uint;long;ptr"))
cmbDBAlgorithm()
cmbABAlgorithm()
SetAccelerators()
EndFunc
Func SetCriticalMessageProcessing($bEnterCritical = Default)
If $bEnterCritical = Default Then Return $g_bCriticalMessageProcessing
Local $wasCritical = $g_bCriticalMessageProcessing
$g_bCriticalMessageProcessing = $bEnterCritical
Return $wasCritical
EndFunc
Func UpdateFrmBotStyle()
If $g_iGuiMode = 0 Then Return False
Local $bChanged = False
Local $ShowMinimize = $g_bAndroidBackgroundLaunched = True Or $g_bAndroidEmbedded = False Or($g_bAndroidEmbedded = True And $g_bChkBackgroundMode = True)
Local $lStyle = $WS_MINIMIZEBOX
Local $lNewStyle =($ShowMinimize ? $lStyle : 0)
Local $lCurStyle = _WinAPI_GetWindowLong($g_hFrmBot, $GWL_STYLE)
If BitAND($lCurStyle, $lStyle) <> $lNewStyle Then
$bChanged = True
If $ShowMinimize Then
$lNewStyle = BitOR($lCurStyle, $lStyle)
SetDebugLog("Show Bot Minimize Button")
Else
$lNewStyle = BitAND($lCurStyle, BitNOT($lStyle))
SetDebugLog("Hide Bot Minimize Button")
EndIf
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_STYLE, $lNewStyle)
EndIf
If CheckBotShrinkExpandButton() Then $bChanged = True
Return $bChanged
EndFunc
Func IsAlwaysEnabledControl($controlID)
Local $bAlwaysEnabled =(($oAlwaysEnabledControls.Item($controlID)) ?(True) :(False))
Return $bAlwaysEnabled
EndFunc
Func SetAccelerators($bDockedUnshieledFocus = False)
If $g_iGuiMode = 0 Then Return
Local $aAccelKeys[2][2] = [["{ESC}", $g_hBtnStop], ["{PAUSE}", $g_hBtnPause]]
Local $aAccelKeys_DockedUnshieldedFocus[3][2] = [["{ESC}", $g_hFrmBotEmbeddedShieldInput], ["{ENTER}", $g_hFrmBotEmbeddedShieldInput], ["{PAUSE}", $g_hBtnPause]]
GUISetAccelerators(0, $g_hFrmBot)
If $bDockedUnshieledFocus = False Then
GUISetAccelerators($aAccelKeys, $g_hFrmBot)
Else
GUISetAccelerators($aAccelKeys_DockedUnshieldedFocus, $g_hFrmBot)
EndIf
EndFunc
Func DisableProcessWindowsGhosting()
DllCall($g_hLibUser32DLL, "none", "DisableProcessWindowsGhosting")
EndFunc
Func GUIControl_WM_SHELLHOOK($hWin, $iMsg, $wParam, $lParam)
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_SHELLHOOK: $hWin=" & $hWin & ", $wParam=" & $wParam & ", $lParam=" & $lParam & ", Active=" & _WinAPI_GetActiveWindow(), Default, True)
If $hWin = $g_hFrmBot And $lParam And BitAND($wParam, $HSHELL_WINDOWACTIVATED) And Not AndroidEmbedded() Then
Select
Case $lParam = $g_hAndroidWindow
BotMinimizeRestore(False, "GUIControl_WM_SHELLHOOK", False, 0, $g_hAndroidWindow)
EndSelect
EndIf
EndFunc
Func GUIControl_WM_ACTIVATEAPP($hWin, $iMsg, $wParam, $lParam)
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_ACTIVATEAPP: $hWin=" & $hWin & ", $wParam=" & $wParam & ", $lParam=" & $lParam & ", Active=" & _WinAPI_GetActiveWindow(), Default, True)
If $wParam Then
If Not $g_bFlushGuiLogActive And Not $g_bIsHidden And Not AndroidEmbedded() And $g_bChkBackgroundMode Then ShowAndroidWindow($g_hFrmBot, False, Default, "GUIControl_WM_ACTIVATEAPP")
Else
If BitAND($g_iBotDesignFlags, 2) And $g_bAndroidEmbedded And Not $g_bBotDockedShrinked Then BotShrinkExpandToggle()
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_NCACTIVATE($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NCACTIVATE: $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg, 8) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $iActive = BitAND($wParam, 0x0000FFFF)
If $hWin = $g_hFrmBot Then
If $g_bAndroidEmbedded And AndroidShieldActiveDelay() = False Then
If $iActive = 0 Then
AndroidShield("GUIControl_WM_NCACTIVATE not active", Default, False, 0, False, False)
Else
AndroidShield("GUIControl_WM_NCACTIVATE active", Default, False)
EndIf
EndIf
If $iActive = 0 Then
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NCACTIVATE: Deactivate Bot", Default, True)
_WinAPI_SetFocus(0)
Else
If $g_bHideWhenMinimized = False Then BotRestore("GUIControl_WM_NCACTIVATE")
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NCACTIVATE: Activate Bot", Default, True)
If BitAND($g_iBotDesignFlags, 2) And $g_bAndroidEmbedded And $g_bBotDockedShrinked Then BotShrinkExpandToggle()
EndIf
If $g_bAndroidEmbedded And $g_iAndroidEmbedMode = 1 And AndroidShieldActiveDelay() = False Then
AndroidEmbedCheck(False, $iActive <> 0, 1)
AndroidShield("GUIControl_WM_NCACTIVATE", Default, False)
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_FOCUS($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_FOCUS: $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg, 8) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $iActive = BitAND($wParam, 0x0000FFFF)
Switch $hWin
Case $g_hFrmBot
If $g_bAndroidEmbedded And AndroidShieldActiveDelay() = False Then
AndroidShield("GUIControl_WM_FOCUS", Default, False)
If $g_iAndroidEmbedMode = 1 Then
AndroidEmbedCheck(False, Default, 1)
EndIf
EndIf
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GetPixelFromWindow($x, $y, $hWin)
Local $hDC = _WinAPI_GetWindowDC($hWin)
Local $Result = DllCall("gdi32.dll", "int", "GetPixel", "int", $hDC, "int", $x, "int", $y)
_WinAPI_ReleaseDC($hWin, $hDC)
If UBound($Result) > 0 Then Return Hex($Result[0], 6)
Return ""
EndFunc
Func GUIControl_WM_MOUSE($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $hWinMouse = $g_hFrmBotEmbeddedMouse
If $g_hFrmBotEmbeddedMouse = 0 Then $hWinMouse =(($g_iAndroidEmbedMode = 0) ? $g_hFrmBotEmbeddedShield : $g_hFrmBot)
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_MOUSE Received message: $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ",$hWinMouse=" & $hWinMouse, Default, True)
CheckBotZOrder()
If $hWin <> $hWinMouse Or $g_bAndroidEmbedded = False Or $g_avAndroidShieldStatus[0] = True Then
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_MOUSE block message: $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ",$hWinMouse=" & $hWinMouse, Default, True)
If $g_avAndroidShieldStatus[0] = True And $iMsg = $WM_LBUTTONDOWN And $hWin <> $g_hFrmBotButtons Then BotMoveRequest()
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
Switch $iMsg
Case $WM_LBUTTONDOWN, $WM_LBUTTONUP, $WM_RBUTTONDOWN, $WM_RBUTTONUP, $WM_LBUTTONDBLCLK
Local $hInput = GUICtrlGetHandle($g_hFrmBotEmbeddedShieldInput)
_WinAPI_SetFocus($hInput)
EndSwitch
Local $x = BitAND($lParam, 0xFFFF)
Local $y = BitAND($lParam, 0xFFFF0000) / 0x10000
Switch $iMsg
Case $WM_MOUSEMOVE
If $g_bDebugClick And AndroidShieldHasFocus() Then
Local $c = GetPixelFromWindow($x, $y, $g_hAndroidControl)
_GUICtrlStatusBar_SetText($g_hStatusBar, StringFormat("Mouse %03i,%03i Color %s", $x, $y, $c))
EndIf
Case $WM_LBUTTONDOWN
If $g_bDebugClick And AndroidShieldHasFocus() Then
Local $c = GetPixelFromWindow($x, $y, $g_hAndroidControl)
SetLog(StringFormat("Mouse LBUTTONDOWN %03i,%03i Color %s", $x, $y, $c), $COLOR_DEBUG)
EndIf
Case $WM_LBUTTONDBLCLK
If $g_bDebugClick And AndroidShieldHasFocus() Then
Local $c = GetPixelFromWindow($x, $y, $g_hAndroidControl)
SetLog(StringFormat("Mouse LBUTTONDBLCLK %03i,%03i Color %s", $x, $y, $c), $COLOR_DEBUG)
EndIf
Case $WM_LBUTTONUP, $WM_RBUTTONUP
If $g_iDebugWindowMessages Then
SetDebugLog("GUIControl_WM_MOUSE: " &($iMsg = $WM_LBUTTONUP ? "$WM_LBUTTONUP" : "$WM_RBUTTONUP") & " $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ", X=" & $x & ", Y=" & $y, Default, True)
EndIf
If AndroidShieldHasFocus() = False Then
Local $hInput = GUICtrlGetHandle($g_hFrmBotEmbeddedShieldInput)
_WinAPI_SetFocus($hInput)
AndroidShield("GUIControl_WM_MOUSE", Default, False, 0, True)
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
EndSwitch
If AndroidShieldHasFocus() = False Then
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
Local $bMinitouch = True
If $bMinitouch Then
Static $s_x, $s_y
Local $iBytesSent = 0
Switch $iMsg
Case $WM_MOUSEMOVE
If $s_x <> $x Or $s_y <> $y Then
$iBytesSent = Minitouch($x, $y, 0)
EndIf
Case $WM_LBUTTONDOWN, $WM_LBUTTONDBLCLK
$iBytesSent = Minitouch($x, $y, 1)
Case $WM_LBUTTONUP
$iBytesSent = Minitouch($x, $y, 2)
EndSwitch
$bMinitouch =($iBytesSent > 0)
$s_x = $x
$s_y = $y
EndIf
If Not $bMinitouch And($iMsg <> $WM_MOUSEMOVE Or $g_iAndroidEmbedMode <> 0) Then
$lParam = $y * 0x10000 + $x
Local $useHWnD = $g_iAndroidControlClickWindow = 1 And $g_bAndroidEmbedded = False
Local $hCtrlTarget =(($useHWnD) ?($g_hAndroidWindow) :($g_hAndroidControl))
Local $Result = _SendMessage($hCtrlTarget, $iMsg, $wParam, $lParam)
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_AndroidEmbedded($hWin, $iMsg, $wParam, $lParam)
Static $GUIControl_AndroidEmbedded_Call = [0, 0, 0, 0]
If $g_bAndroidEmbedded = False Or $g_avAndroidShieldStatus[0] = True Then
Return $GUI_RUNDEFMSG
EndIf
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Switch $iMsg
Case $WM_KEYDOWN, $WM_KEYUP, $WM_SYSKEYDOWN, $WM_SYSKEYUP, $WM_MOUSEWHEEL
If $iMsg = $WM_KEYUP And $wParam = 27 Then
Local $wasSilentSetLog = $g_bSilentSetLog
$g_bSilentSetLog = True
AndroidBackButton(False)
$g_bSilentSetLog = $wasSilentSetLog
Else
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
If $GUIControl_AndroidEmbedded_Call[0] <> $hCtrlTarget Or $GUIControl_AndroidEmbedded_Call[1] <> $iMsg Or $GUIControl_AndroidEmbedded_Call[2] <> $wParam Or $GUIControl_AndroidEmbedded_Call[3] <> $lParam Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("GUIControl_AndroidEmbedded: FORWARD $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg) & ", $wParam=" & $wParam & ", $lParam=" & $lParam & ", $hCtrlTarget=" & $hCtrlTarget, Default, True)
_WinAPI_PostMessage($hCtrlTarget, $iMsg, $wParam, $lParam)
$GUIControl_AndroidEmbedded_Call[0] = $hCtrlTarget
$GUIControl_AndroidEmbedded_Call[1] = $iMsg
$GUIControl_AndroidEmbedded_Call[2] = $wParam
$GUIControl_AndroidEmbedded_Call[3] = $lParam
EndIf
EndIf
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_COMMAND($hWind, $iMsg, $wParam, $lParam)
If $g_bGUIControlDisabled = True Then Return $GUI_RUNDEFMSG
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_COMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
Local $nNotifyCode = BitShift($wParam, 16)
Local $nID = BitAND($wParam, 0x0000FFFF)
If $hWind <> $g_hFrmBotEmbeddedShield And $hWind <> $g_hFrmBotEmbeddedGraphics And $hWind <> $g_hFrmBotEmbeddedMouse And $nID <> $g_hFrmBotEmbeddedShieldInput And $hWind <> $g_hFrmBotButtons Then
If AndroidShieldHasFocus() = True Then
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_COMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
AndroidShield("GUIControl_WM_COMMAND", Default, False, 150, False)
EndIf
EndIf
CheckRedrawBotWindow(Default, Default, "GUIControl_WM_COMMAND")
Switch $nID
Case $g_hDivider
$g_bMoveDivider = True
SetDebugLog("MoveDivider active", Default, True)
Case $g_hLblBotShrink, $g_hLblBotExpand
BotShrinkExpandToggle()
Case $g_hLblBotMinimize
BotMinimizeRequest()
Case $GUI_EVENT_CLOSE, $g_hLblBotClose
BotCloseRequest()
Case $g_hLblBotMiniGUI, $g_hLblBotNormalGUI
BotGuiModeToggleRequest()
Case $g_hLblCreditsBckGrnd
Local $CursorInfo = GUIGetCursorInfo($g_hFrmBot)
If IsArray($CursorInfo) = 1 Then
Switch $CursorInfo[4]
Case $g_hLblMyBotURL, $g_hLblForumURL
OpenURL_Label($CursorInfo[4])
EndSwitch
EndIf
Case $g_hLblMyBotURL, $g_hLblForumURL, $g_hLblUnbreakableLink
OpenURL_Label($nID)
Case $g_hFrmBot_URL_PIC, $g_hFrmBot_URL_PIC2
OpenURL_Label($g_hLblMyBotURL)
Case $g_hLblDonate
ShellExecute("https://mybot.run/forums/index.php?/donate/make-donation/")
Case $g_hBtnStop
btnStop()
Case $g_hBtnPause
btnPause()
Case $g_hBtnResume
btnResume()
Case $g_hBtnHide
btnHide()
Case $btnResetStats
btnResetStats()
Case $g_hBtnAttackNowDB
btnAttackNowDB()
Case $g_hBtnAttackNowLB
btnAttackNowLB()
Case $g_hBtnAttackNowTS
btnAttackNowTS()
Case $g_hBtnMakeScreenshot
If $g_bRunState Then
btnMakeScreenshot()
Else
If $g_bScreenshotPNGFormat = False Then
MakeScreenshot($g_sProfileTempPath, "jpg")
Else
MakeScreenshot($g_sProfileTempPath, "png")
EndIf
EndIf
Case $g_hPicTwoArrowShield
btnVillageStat()
Case $g_hPicArrowLeft, $g_hPicArrowRight
btnVillageStat()
Case $g_hChkDebugSetlog
chkDebugSetlog()
Case $g_hChkDebugAndroid
chkDebugAndroid()
Case $g_hChkDebugClick
chkDebugClick()
Case $g_hChkDebugFunc
chkDebugFunc()
Case $g_hChkDebugDisableZoomout
chkDebugDisableZoomout()
Case $g_hChkDebugDisableVillageCentering
chkDebugDisableVillageCentering()
Case $g_hChkDebugDeadbaseImage
chkDebugDeadbaseImage()
Case $g_hChkDebugOCR
chkDebugOcr()
Case $g_hChkDebugImageSave
chkDebugImageSave()
Case $g_hChkdebugBuildingPos
chkDebugBuildingPos()
Case $g_hChkdebugTrain
chkDebugTrain()
Case $g_hChkDebugOCRDonate
chkdebugOCRDonate()
Case $g_hChkdebugAttackCSV
chkdebugAttackCSV()
Case $g_hChkMakeIMGCSV
chkmakeIMGCSV()
Case $g_hBtnTestTrain
TestSmartFarm()
Case $g_hBtnTestDonateCC
btnTestDonateCC()
Case $g_hBtnTestRequestCC
btnTestRequestCC()
Case $g_hBtnTestSendText
btnTestSendText()
Case $g_hBtnTestAttackBar
btnTestAttackBar()
Case $g_hBtnTestClickDrag
btnTestClickDrag()
Case $g_hBtnTestImage
btnTestImage()
Case $g_hBtnTestVillageSize
btnTestVillageSize()
Case $g_hBtnTestDeadBase
btnTestDeadBase()
Case $g_hBtnTestDeadBaseFolder
btnTestDeadBaseFolder()
Case $g_hBtnTestTHimgloc
imglocTHSearch()
Case $g_hBtnTestAttackCSV
btnTestAttackCSV()
Case $g_hBtnTestArmyWindow
Local $RuntimeA = $g_bRunState
$g_bRunState = True
Setlog("Army Window Test")
_checkArmyCamp(False,False,False, True)
$g_bRunState = $RuntimeA
Case $g_hBtnTestBuildingLocation
btnTestGetLocationBuilding()
Case $g_hBtnTestFindButton
btnTestFindButton()
Case $g_hBtnTestCleanYard
btnTestCleanYard()
Case $g_hBtnTestOcrMemory
btnTestOcrMemory()
Case $g_hBtnTestConfigSave
saveConfig()
Case $g_hBtnTestConfigRead
readConfig()
Case $g_hBtnTestConfigApply
applyConfig()
Case $g_hBtnTestWeakBase
btnTestWeakBase()
Case $g_hBtnTestClickAway
btnTestClickAway()
Case $g_hBtnTestAutoUpgrade
AutoUpgrade(True)
Case $g_hBtnTestUpgradeWindow
btnTestUpgradeWindow()
Case $g_hBtnTestSmartWait
btnTestSmartWait()
Case $g_hBtnConsoleWindow
btnConsoleWindow()
Case $g_hBtnTestTrainsimgloc
Local $RuntimeA = $g_bRunState
$g_bRunState = True
Setlog("Queued Spells Test")
CheckQueueSpells()
$g_bRunState = $RuntimeA
Case $g_hBtnTestQuickTrainsimgloc
Local $RuntimeA = $g_bRunState
$g_bRunState = True
Setlog("Queued Troops Test")
CheckQueueTroops()
$g_bRunState = $RuntimeA
EndSwitch
If $lParam = $g_hCmbGUILanguage Then
If $nNotifyCode = $CBN_SELCHANGE Then cmbLanguage()
EndIf
$g_bTogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_MOVE($hWind, $iMsg, $wParam, $lParam)
If $g_bBotShrinkExpandToggleRequested Then Return $GUI_RUNDEFMSG
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_MOVE: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
If $g_bUpdatingWhenMinimized And BotWindowCheck() = False And _WinAPI_IsIconic($g_hFrmBot) Then
BotMinimize("GUIControl_WM_MOVE")
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
If $g_bAndroidEmbedded And $g_bAndroidEmbeddedWindowZeroPosition Then
_SendMessage($g_hAndroidWindow, $iMsg, $wParam, $lParam)
EndIf
Local $g_iFrmBotPos = WinGetPos($g_hFrmBot)
If $g_bAndroidEmbedded = False Then
$g_iFrmBotPosX =($g_iFrmBotPos[0] > -30000 ? $g_iFrmBotPos[0] : $g_iFrmBotPosX)
$g_iFrmBotPosY =($g_iFrmBotPos[1] > -30000 ? $g_iFrmBotPos[1] : $g_iFrmBotPosY)
Else
$g_iFrmBotDockedPosX =($g_iFrmBotPos[0] > -30000 ? $g_iFrmBotPos[0] : $g_iFrmBotDockedPosX)
$g_iFrmBotDockedPosY =($g_iFrmBotPos[1] > -30000 ? $g_iFrmBotPos[1] : $g_iFrmBotDockedPosY)
EndIf
If $g_bAndroidEmbedded And AndroidEmbedArrangeActive() = False Then
CheckBotShrinkExpandButton()
Local $iAction = AndroidEmbedCheck(True)
If $iAction > 0 Then
AndroidEmbedCheck(False, Default, $iAction)
EndIf
If $g_iDebugWindowMessages Then
Local $a = $g_iFrmBotPos
SetDebugLog("Bot Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
$a = WinGetPos($g_hAndroidWindow)
SetDebugLog("Android Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
If $g_hFrmBotEmbeddedMouse <> 0 Then
$a = WinGetPos($g_hFrmBotEmbeddedMouse)
SetDebugLog("Mouse Window Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
EndIf
EndIf
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_SYSCOMMAND($hWind, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_SYSCOMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
Switch $wParam
Case $SC_MINIMIZE
BotMinimize("GUIControl_WM_SYSCOMMAND")
Case $SC_RESTORE
BotRestore("GUIControl_WM_SYSCOMMAND")
Case $SC_CLOSE
BotCloseRequest()
EndSwitch
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_NOTIFY($hWind, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_NOTIFY: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
Local $nNotifyCode = BitShift($wParam, 16)
Local $nID = BitAND($wParam, 0x0000FFFF)
Local $bCheckEmbeddedShield = True
Switch $nID
Case $g_hTabMain
tabMain()
Case $g_hGUI_VILLAGE_TAB
tabVillage()
Case $g_hGUI_DONATE_TAB
tabDONATE()
Case $g_hGUI_ATTACK_TAB
tabAttack()
Case $g_hGUI_SEARCH_TAB
tabSEARCH()
Case $g_hGUI_DEADBASE_TAB
tabDeadbase()
Case $g_hGUI_ACTIVEBASE_TAB
tabActivebase()
Case $g_hGUI_THSNIPE_TAB
tabTHSnipe()
Case $g_hGUI_MOD_TAB
tabMod()
Case $g_hGUI_BOT_TAB
tabBot()
Case $g_hGUI_SWITCH_OPTIONS_TAB
tabSwitchOptions()
Case Else
$bCheckEmbeddedShield = False
EndSwitch
If $bCheckEmbeddedShield Then
If $hWind <> $g_hFrmBotEmbeddedShield And $hWind <> $g_hFrmBotEmbeddedGraphics And $hWind <> $g_hFrmBotEmbeddedMouse Then
If AndroidShieldHasFocus() = True Then
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NOTIFY: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
AndroidShield("GUIControl_WM_NOTIFY", Default, False, 150, False)
EndIf
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_CLOSE($hWind, $iMsg, $wParam, $lParam)
If $g_iDebugWindowMessages > 0 Then SetDebugLog("GUIControl_WM_CLOSE: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
BotCloseRequest()
EndIf
EndFunc
Func GUIEvents()
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $GUI_CtrlId = @GUI_CtrlId
If $g_bFrmBotMinimized And $GUI_CtrlId = $GUI_EVENT_MINIMIZE Then
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_MINIMIZE changed to $GUI_EVENT_RESTORE", Default, True)
$GUI_CtrlId = $GUI_EVENT_RESTORE
EndIf
Switch $GUI_CtrlId
Case $GUI_EVENT_CLOSE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_CLOSE", Default, True)
BotCloseRequest()
Case $GUI_EVENT_MINIMIZE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_MINIMIZE", Default, True)
BotMinimize("GUIEvents")
Case $GUI_EVENT_RESTORE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_RESTORE", Default, True)
BotRestore("GUIEvents")
Case Else
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT: " & @GUI_CtrlId, Default, True)
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
EndFunc
Func OpenURL_Label($LabelCtrlID)
Local $url = GUICtrlRead($LabelCtrlID)
If StringInStr($url, "http") <> 1 Then
$url = _GUIToolTip_GetText($g_hToolTip, 0, GUICtrlGetHandle($LabelCtrlID))
EndIf
If StringInStr($url, "http") = 1 Then
SetDebugLog("Open URL: " & $url)
ShellExecute($url)
Else
SetDebugLog("Cannot open URL for Control ID " & $LabelCtrlID, $COLOR_ERROR)
EndIf
EndFunc
Func BotMinimizeRequest()
BotMinimize("MinimizeButton", False, 500)
EndFunc
Func BotToFront($hHWndAfter = $HWND_TOPMOST)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Or $hHWndAfter = $HWND_TOP Then WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndFunc
Func CheckBotZOrder($bCheckOnly = False, $bForceZOrder = False)
If $g_bAndroidEmbedded And $g_iAndroidEmbedMode = 0 Then
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
Local $targetIsHWnD = $hCtrlTarget = $g_hAndroidWindow
If Not $targetIsHWnD Then
Local $bCheck =($bForceZOrder Or _WinAPI_GetWindow($hCtrlTarget, $GW_HWNDNEXT) <> $g_hAndroidWindow)
If $bCheckOnly Then Return $bCheck
If $bCheck Then
SetDebugLog("CheckBotZOrder: Ajust docked Android Window")
WinMove2($g_hAndroidWindow, "", -1, -1, -1, -1, $hCtrlTarget, 0, False)
EndIf
Return $bCheck
EndIf
EndIf
If $g_iAndroidEmbedMode = 1 And $g_bBotDockedShrinked Then
Local $hWinBehindButtons =($g_hFrmBotEmbeddedGraphics ? $g_hFrmBotEmbeddedGraphics :($g_hFrmBotEmbeddedShield ? $g_hFrmBotEmbeddedShield : $g_hFrmBot))
Local $bCheck = $hWinBehindButtons And($bForceZOrder Or _WinAPI_GetWindow($g_hFrmBotLogoUrlSmall, $GW_HWNDNEXT) <> $g_hFrmBotButtons Or _WinAPI_GetWindow($g_hFrmBotButtons, $GW_HWNDNEXT) <> $hWinBehindButtons)
If $bCheckOnly Then Return $bCheck
If $bCheck Then
SetDebugLog("CheckBotZOrder: Ajust windows Z Order for custom window")
If $bForceZOrder Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
If $g_hFrmBotEmbeddedShield Then WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
EndIf
WinMove2($g_hFrmBotLogoUrlSmall, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $g_hFrmBotLogoUrlSmall, 0, False)
WinMove2($g_hFrmBotButtons, "", -1, -1, -1, -1, $g_hFrmBotLogoUrlSmall, 0, False)
If $hWinBehindButtons <> $g_hFrmBot Then WinMove2($hWinBehindButtons, "", -1, -1, -1, -1, $g_hFrmBotButtons, 0, False)
If $g_hFrmBotEmbeddedShield And $g_hFrmBotEmbeddedShield <> $hWinBehindButtons Then WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $hWinBehindButtons, 0, False)
EndIf
Return $bCheck
EndIf
If($g_iAndroidEmbedMode = 1 And $g_bCustomTitleBarActive = False) Or $g_avAndroidShieldStatus[4] Then
Local $hTopWin =($g_hFrmBotEmbeddedGraphics ? $g_hFrmBotEmbeddedGraphics :($g_hFrmBotEmbeddedShield ? $g_hFrmBotEmbeddedShield : 0))
Local $bCheck = $hTopWin And($bForceZOrder Or _WinAPI_GetWindow($hTopWin, $GW_HWNDNEXT) <> $g_hFrmBot)
If $bCheckOnly Then Return $bCheck
If $bCheck Then
SetDebugLog("CheckBotZOrder: Ajust windows Z Order for standard window")
If $bForceZOrder Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
EndIf
WinMove2($hTopWin, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $hTopWin, 0, False)
If $g_hFrmBotEmbeddedShield And $g_hFrmBotEmbeddedShield <> $hTopWin Then WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $hTopWin, 0, False)
EndIf
Return $bCheck
EndIf
Return False
EndFunc
Func CheckBotShrinkExpandButton($bCheckOnlyParent = False)
If $g_hFrmBotButtons = 0 Then Return False
Local $bInconsistent = False
If $g_bAndroidEmbedded = False And $g_bBotDockedShrinked Then
SetDebugLog("Bot Buttons inconsistent state", $COLOR_ERROR)
$bInconsistent = True
$bCheckOnlyParent = False
$g_bBotDockedShrinked = False
EndIf
Local $bChanged = False
Local $aBtnSize = $_GUI_MAIN_BUTTON_SIZE
Local $aPos = ControlGetPos($g_hFrmBot, "", $g_hFrmBotButtons)
Local $bDetached = False
Local $bBottonsHidden = False
If UBound($aPos) > 3 Then
Local $x = $_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT
Local $y = 0
Local $iStyle = _WinAPI_GetWindowLong($g_hFrmBotButtons, $GWL_STYLE)
If $g_bAndroidEmbedded = True Then
Local $a = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $iAndroidWidth = $a[2]
$x = $iAndroidWidth + 2 +(($g_bBotDockedShrinked) ?(-$aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT) :($_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT))
If $g_iAndroidEmbedMode = 1 Then
If $g_bBotDockedShrinked Then
$bDetached = True
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $x)
DllStructSetData($tPoint, "Y", $y)
_WinAPI_ClientToScreen($g_hFrmBot, $tPoint)
Local $abs_x = DllStructGetData($tPoint, "X")
Local $abs_y = DllStructGetData($tPoint, "Y")
$x = $abs_x
$y = $abs_y
If BitAND($iStyle, $WS_POPUP) <> $WS_POPUP Then
SetDebugLog("Detach Bot Buttons")
$bBottonsHidden = True
GUISetState(@SW_HIDE, $g_hFrmBotButtons)
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_EXSTYLE, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_STYLE, BitOR(BitAND($iStyle, BitNOT($WS_CHILD)), $WS_POPUP))
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_HWNDPARENT, 0)
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, $HWND_NOTOPMOST, 0, False)
$aPos[0] = $x
$aPos[1] = $y
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_EXSTYLE, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_STYLE, BitOR(BitAND($iStyle, BitNOT($WS_CHILD)), $WS_POPUP))
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_HWNDPARENT, 0)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, $HWND_NOTOPMOST, 0, False)
If $bCheckOnlyParent Then Return True
EndIf
If $bCheckOnlyParent Then Return False
$aPos = WinGetPos($g_hFrmBotButtons)
$bChanged = True
EndIf
EndIf
EndIf
If(Not $g_bAndroidEmbedded Or Not $g_bBotDockedShrinked) And BitAND($iStyle, $WS_POPUP) = $WS_POPUP Then
SetDebugLog("Integrate Bot Buttons")
$bBottonsHidden = True
If Not $bInconsistent Then GUISetState(@SW_HIDE, $g_hFrmBotButtons)
_WinAPI_SetParent($g_hFrmBotButtons, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_EXSTYLE, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE,($g_bAndroidShieldPreWin8 ? 0 : $WS_EX_LAYERED)))
_WinAPI_SetWindowLong($g_hFrmBotButtons, $GWL_STYLE, BitOR(BitAND($iStyle, BitNOT($WS_POPUP)), $WS_CHILD))
If $bInconsistent Then
_WinAPI_SetParent($g_hFrmBotButtons, $g_hFrmBot)
EndIf
_WinAPI_SetParent($g_hFrmBotLogoUrlSmall, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_EXSTYLE, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE,($g_bAndroidShieldPreWin8 ? 0 : $WS_EX_LAYERED)))
_WinAPI_SetWindowLong($g_hFrmBotLogoUrlSmall, $GWL_STYLE, BitOR(BitAND($iStyle, BitNOT($WS_POPUP)), $WS_CHILD))
If $bInconsistent Then
_WinAPI_SetParent($g_hFrmBotLogoUrlSmall, $g_hFrmBot)
EndIf
If $bCheckOnlyParent Then Return True
$aPos = ControlGetPos($g_hFrmBot, "", $g_hFrmBotButtons)
$bChanged = True
EndIf
If $bCheckOnlyParent Then Return False
If $x <> $aPos[0] Or $y <> $aPos[1] Or $bInconsistent Then
SetDebugLog("Move Bot Buttons: " & $x & ", " & $y)
If $bDetached Then
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, $HWND_NOTOPMOST, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, $HWND_NOTOPMOST, 0, False)
Else
WinMove2($g_hFrmBotButtons, "", $x, $y, -1, -1, 0, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, 0, 0, False)
WinMove2($g_hFrmBotLogoUrlSmall, "", $x - 290, $y, -1, -1, 0, 0, False)
EndIf
$bChanged = True
EndIf
EndIf
If $bBottonsHidden = True Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotButtons)
If $g_bBotDockedShrinked Then GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotLogoUrlSmall)
EndIf
If $bInconsistent Then
GUICtrlSetState($g_hLblBotShrink,(($g_bBotDockedShrinked) ?($GUI_HIDE) :($GUI_SHOW)))
GUICtrlSetState($g_hLblBotExpand,(($g_bBotDockedShrinked) ?($GUI_SHOW) :($GUI_HIDE)))
WinSetTrans($g_hFrmBotButtons, "",(($g_bBotDockedShrinked) ?(210) :(254)))
EndIf
Return $bChanged
EndFunc
Func BotShrinkExpandToggle()
$g_bBotShrinkExpandToggleRequested = True
EndFunc
Func BotShrinkExpandToggleExecute()
If $g_hFrmBotButtons = 0 Then Return False
If $g_iBotAction = $eBotClose Then Return False
If $g_bAndroidEmbedded = False Then
SetDebugLog("BotShrinkExpandToggle: Android not docked")
$g_bBotShrinkExpandToggleRequested = False
Return False
EndIf
Local $aPos = WinGetPos($g_hFrmBot)
If UBound($aPos) < 4 Then
SetDebugLog("BotShrinkExpandToggle: Bot Window not accessible")
$g_bBotShrinkExpandToggleRequested = False
Return False
EndIf
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
$aPos[2] =(($g_bBotDockedShrinked) ?($aPosCtl[2] + 2) :($g_aFrmBotPosInit[2] + $aPosCtl[2] + 2))
$aPos[3] = $g_aFrmBotPosInit[3] + $g_iFrmBotAddH + $g_aFrmBotPosInit[7]
Local $bAndroidShieldEnabled = $g_bAndroidShieldEnabled
$g_bAndroidShieldEnabled = False
$g_bBotDockedShrinked = Not $g_bBotDockedShrinked
If Not $g_bBotDockedShrinked Then GUISetState(@SW_HIDE, $g_hFrmBotLogoUrlSmall)
Local $aBtnSize = $_GUI_MAIN_BUTTON_SIZE
Local $a = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $iAndroidWidth = $a[2]
If Not $g_bBotDockedShrinked And CheckBotShrinkExpandButton(True) Then
Local $bStillShrinked = True
WinMove2($g_hFrmBotButtons, "", $iAndroidWidth + 2 +(($bStillShrinked) ?(-$aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT) :($_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT)), 0, -1, -1, 0, 0, False)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotButtons)
EndIf
Local $iMode =(($g_bBotDockedShrinked) ?(1) :(-1))
Local $aPosBtn = ControlGetPos($g_hFrmBot, "", $g_hFrmBotButtons)
Local $bAnimate = $bAndroidShieldEnabled And Not $g_bAndroidShieldPreWin8 And $g_bChkBackgroundMode
GUISetState(@SW_HIDE, $g_hFrmBotEx)
GUISetState(@SW_HIDE, $g_hFrmBotBottom)
Local $iSteps = 10
Local $fStep = $_GUI_MAIN_WIDTH / $iSteps
Local $bGetAnimationSpeed = True
Local $iAnimationDelay = 0
If $bAnimate Then
For $i = 1 To $iSteps
Local $iWidth = Round($aPos[2] - $i * $fStep * $iMode, 0)
Local $iChange = $iWidth - $aPos[2]
If $bGetAnimationSpeed Then Local $hTimer = __TimerInit()
WinMove2($g_hFrmBot, "", -1, -1, $iWidth, $aPos[3], 0, 0, False)
WinMove2($g_hFrmBotButtons, "", $iAndroidWidth + 2 - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT + $iChange +(($g_bBotDockedShrinked) ?($_GUI_MAIN_WIDTH) :(0)), $aPosBtn[1], -1, -1, 0, 0, False)
If $bGetAnimationSpeed Then
$iAnimationDelay = 100 / $iSteps - __TimerDiff($hTimer)
EndIf
If $iAnimationDelay > 0 Then _SleepMilli($iAnimationDelay)
Next
EndIf
GUICtrlSetState($g_hLblBotShrink,(($g_bBotDockedShrinked) ?($GUI_HIDE) :($GUI_SHOW)))
GUICtrlSetState($g_hLblBotExpand,(($g_bBotDockedShrinked) ?($GUI_SHOW) :($GUI_HIDE)))
WinSetTrans($g_hFrmBotButtons, "",(($g_bBotDockedShrinked) ?(210) :(254)))
WinMove2($g_hFrmBot, "", -1, -1, $aPos[2] - $_GUI_MAIN_WIDTH * $iMode, $aPos[3], 0, 0, False)
WinMove2($g_hFrmBotButtons, "", $iAndroidWidth + 2 +(($g_bBotDockedShrinked) ?(-$aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT) :($_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT)), $aPosBtn[1], -1, -1, 0, 0, False)
If $g_bBotDockedShrinked Then
WinMove2($g_hFrmBotLogoUrlSmall, "", $iAndroidWidth + 2 +(($g_bBotDockedShrinked) ?(-$aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT) :($_GUI_MAIN_WIDTH - $aBtnSize[0] * $_GUI_MAIN_BUTTON_COUNT)) - 290, $aPosBtn[1], -1, -1, 0, 0, False)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotLogoUrlSmall)
EndIf
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotEx)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotBottom)
If $g_bBotDockedShrinked Then CheckBotShrinkExpandButton()
SetDebugLog("BotShrinkExpandToggle: Bot " &(($g_bBotDockedShrinked) ?("collapsed") :("expanded")))
$g_bAndroidShieldEnabled = $bAndroidShieldEnabled
$g_bBotShrinkExpandToggleRequested = False
Return True
EndFunc
Func BotGuiModeToggleRequest()
If Not $g_bRunState And Not IsConfigActive() And Not DllCallMyBotIsActive() Then
BotGuiModeToggle()
Return False
EndIf
$g_bBotGuiModeToggleRequested = True
Return True
EndFunc
Func BotGuiModeToggle()
Static $bIsActive = False
If $g_iBotAction = $eBotClose Or $g_iGuiMode = 0 Or $bIsActive Or IsConfigActive() Or DllCallMyBotIsActive() Then Return False
$bIsActive = True
$g_bBotGuiModeToggleRequested = False
If $g_bAndroidEmbedded Then AndroidEmbed(False)
Local $_GUI_MAIN_WIDTH_OLD = $_GUI_MAIN_WIDTH
Local $_GUI_MAIN_HEIGHT_OLD = $_GUI_MAIN_HEIGHT
Switch $g_iGuiMode
Case 1
SetLog("Switch to Mini GUI Mode")
applyConfig(False, "Save")
saveConfig()
$g_iGuiMode = 2
SetRedrawBotWindow(False, Default, Default, Default, "BotGuiModeToggle")
$_GUI_MAIN_WIDTH = $_MINIGUI_MAIN_WIDTH
$_GUI_MAIN_HEIGHT = $_MINIGUI_MAIN_HEIGHT
_WinAPI_SetParent($g_hTxtLog, $g_hFrmBotEx)
_WinAPI_SetParent($g_hTxtAtkLog, $g_hFrmBotEx)
_WinAPI_SetWindowLong($g_hTxtLog, $GWL_HWNDPARENT, $g_hFrmBotEx)
_WinAPI_SetWindowLong($g_hTxtAtkLog, $GWL_HWNDPARENT, $g_hFrmBotEx)
WinSetState($g_hTxtLog, "", @SW_MINIMIZE)
WinSetState($g_hTxtAtkLog, "", @SW_MINIMIZE)
GUICtrlDelete($g_hTabMain)
GUICtrlDelete($g_hTabLog)
GUICtrlDelete($g_hTabVillage)
GUICtrlDelete($g_hTabAttack)
GUICtrlDelete($g_hTabMOD)
GUICtrlDelete($g_hTabBot)
GUICtrlDelete($g_hTabAbout)
GUICtrlDelete($g_hGUI_VILLAGE_TAB)
GUICtrlDelete($g_hGUI_MISC_TAB)
GUICtrlDelete($g_hGUI_DONATE_TAB)
GUICtrlDelete($g_hGUI_UPGRADE_TAB)
GUICtrlDelete($g_hGUI_NOTIFY_TAB)
GUICtrlDelete($g_hGUI_ATTACK_TAB)
GUICtrlDelete($g_hGUI_TRAINARMY_TAB)
GUICtrlDelete($g_hGUI_SEARCH_TAB)
GUICtrlDelete($g_hGUI_DEADBASE_TAB)
GUICtrlDelete($g_hGUI_ACTIVEBASE_TAB)
GUICtrlDelete($g_hGUI_THSNIPE_TAB)
GUICtrlDelete($g_hGUI_ATTACKOPTION_TAB)
GUICtrlDelete($g_hGUI_STRATEGIES_TAB)
GUICtrlDelete($g_hGUI_MOD_TAB)
GUICtrlDelete($g_hGUI_BOT_TAB)
GUICtrlDelete($g_hGUI_LOG_SA)
GUICtrlDelete($g_hGUI_SWITCH_OPTIONS_TAB)
GUICtrlDelete($g_hGUI_STATS_TAB)
For $i = $g_hFirstControlToHide To $g_hLastControlToHide
GUICtrlDelete($i)
Next
$g_hFirstControlToHide = 0
$g_hLastControlToHide = 0
For $hGUI In $g_oGuiNotInMini
SetDebugLog("GUIDelete: " & $hGUI)
GUIDelete($hGUI)
Next
$g_oGuiNotInMini.RemoveAll
$oAlwaysEnabledControls.RemoveAll
__GDIPlus_Shutdown()
__GDIPlus_Startup()
Case 2
SetLog("Switch to Normal GUI Mode")
$g_iGuiMode = 1
$_GUI_MAIN_WIDTH = $_NORMALGUI_MAIN_WIDTH
$_GUI_MAIN_HEIGHT = $_NORMALGUI_MAIN_HEIGHT
CreateSplashScreen(6)
CreateMainGUIControls(True)
tabMod()
tabBot()
tabDONATE()
tabSEARCH()
tabAttack()
tabVillage()
tabSwitchOptions()
InitializeMainGUI(True)
UpdateStats(True)
UpdateMultiStats()
DistributorsUpdateGUI()
DestroySplashScreen()
applyConfig(False)
If Not $g_bGuiControlsEnabled Then DisableGuiControls()
SetRedrawBotWindow(False, Default, Default, Default, "BotGuiModeToggle")
_GUICtrlRichEdit_SetSel($g_hTxtLog, 0, 0)
_GUICtrlRichEdit_SetSel($g_hTxtLog, -1, -1)
_GUICtrlRichEdit_SetSel($g_hTxtAtkLog, 0, 0)
_GUICtrlRichEdit_SetSel($g_hTxtAtkLog, -1, -1)
GUICtrlSetState($g_hTabMain, $GUI_FOCUS)
EndSwitch
WinMove2($g_hFrmBotBottom, "", 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, -1, -1, 0, 0, False)
Local $xComp = $g_aFrmBotPosInit[2] - $_GUI_MAIN_WIDTH_OLD
Local $yComp = $g_aFrmBotPosInit[3] + $g_aFrmBotPosInit[7] - $_GUI_MAIN_HEIGHT_OLD
WinMove2($g_hFrmBotEx, "", -1, -1, $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, 0, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, $_GUI_MAIN_WIDTH + $xComp, $_GUI_MAIN_HEIGHT + $yComp, 0, 0, False)
GUICtrlSetState($g_hLblBotNormalGUI,(($g_iGuiMode = 1) ?($GUI_HIDE) :($GUI_SHOW)))
GUICtrlSetState($g_hLblBotMiniGUI,(($g_iGuiMode = 2) ?($GUI_HIDE) :($GUI_SHOW)))
updateBtnEmbed()
SetRedrawBotWindow(True, Default, Default, Default, "BotGuiModeToggle")
ShowMainGUI()
$bIsActive = False
Return True
EndFunc
Func BotMoveRequest()
$g_bBotMoveRequested = True
EndFunc
Func CheckBotRequests()
CheckBotZOrder()
If $g_bBotMoveRequested = True Then
$g_bBotMoveRequested = False
_WinAPI_PostMessage($g_hFrmBot, $WM_SYSCOMMAND, 0xF012, 0)
Else
If $g_bBotShrinkExpandToggleRequested Then BotShrinkExpandToggleExecute()
If $g_bBotGuiModeToggleRequested Then BotGuiModeToggle()
EndIf
EndFunc
Func BotCloseRequest()
If $g_iBotAction = $eBotClose Then
BotClose()
Else
SetLog("Closing " & $g_sBotTitle & ", please wait ...")
EndIf
$g_bRunState = False
$g_bBotPaused = False
$g_iBotAction = $eBotClose
EndFunc
Func BotCloseRequestProcessed()
Return False
EndFunc
Func BotClose($SaveConfig = Default, $bExit = True)
If $SaveConfig = Default Then $SaveConfig = IsBotLaunched()
$g_bRunState = False
$g_bBotPaused = False
ResumeAndroid()
SetLog("Closing " & $g_sBotTitle & " now ...")
LockBotSlot(False)
If $SaveConfig = True Then
setupProfile()
SaveConfig()
EndIf
$g_bChkBackgroundMode = True
AndroidEmbed(False)
AndroidShieldDestroy()
If $g_bAndroidCloseWithBot And $g_hAndroidWindow Then
$g_bRunState = True
CloseAndroid("BotClose")
$g_bRunState = False
Else
AndroidBotStopEvent()
AndroidToFront(Default, "BotClose")
AndroidAdbTerminateShellInstance()
EndIf
If $g_hMutex_BotTitle <> 0 Then ReleaseMutex($g_hMutex_BotTitle)
ReleaseProfilesMutex(True)
If $g_hMutex_MyBot <> 0 Then ReleaseMutex($g_hMutex_MyBot)
__GDIPlus_Shutdown()
_Crypt_Shutdown()
_GUICtrlRichEdit_Destroy($g_hTxtLog)
_GUICtrlRichEdit_Destroy($g_hTxtAtkLog)
TCPShutdown()
_WinAPI_DeregisterShellHookWindow($g_hFrmBot)
If $g_hAndroidWindow <> 0 Then ControlFocus($g_hAndroidWindow, "", $g_hAndroidWindow)
GUIDelete($g_hFrmBot)
$g_aiAndroidAdbScreencapBuffer = 0
$g_hStruct_SleepMicro = 0
UnregisterManagedMyBotHost()
If $bExit = True Then Exit
EndFunc
Func BotMinimizeRestore($bMinimize, $sCaller, $iForceUpdatingWhenMinimized = False, $iStayMinimizedMillis = 0, $hHWndAfter = $HWND_TOP)
Static $siStayMinimizedMillis = 0
Static $shStayMinimizedTimer = 0
If $bMinimize Then
If $iStayMinimizedMillis > 0 Then
$siStayMinimizedMillis = $iStayMinimizedMillis
$shStayMinimizedTimer = __TimerInit()
EndIf
If $g_bAndroidEmbedded = True And $g_bChkBackgroundMode = False Then
Return False
EndIf
SetDebugLog("Minimize bot window, caller: " & $sCaller, Default, True)
$g_bFrmBotMinimized = True
If $g_bUpdatingWhenMinimized Or $iForceUpdatingWhenMinimized = True Then
If $g_bHideWhenMinimized Then
WinMove2($g_hFrmBot, "", -32000, -32000, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then WinSetState($g_hFrmBot, "", @SW_RESTORE)
If _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
WinMove2($g_hFrmBot, "", -32000, -32000, -1, -1, 0, BitOR($SWP_SHOWWINDOW, $SWP_NOACTIVATE), False)
Else
If $g_bHideWhenMinimized Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
WinSetState($g_hFrmBot, "", @SW_MINIMIZE)
EndIf
If $g_bChkBackgroundMode And Not $g_bIsHidden Then HideAndroidWindow(True, False, Default, "BotMinimizeRestore")
Return True
EndIf
If $siStayMinimizedMillis > 0 And __TimerDiff($shStayMinimizedTimer) < $siStayMinimizedMillis Then
SetDebugLog("Prevent Bot Window Restore")
Return False
Else
$siStayMinimizedMillis = 0
$shStayMinimizedTimer = 0
EndIf
$g_bFrmBotMinimized = False
Local $botPosX =($g_bAndroidEmbedded = False ? $g_iFrmBotPosX : $g_iFrmBotDockedPosX)
Local $botPosY =($g_bAndroidEmbedded = False ? $g_iFrmBotPosY : $g_iFrmBotDockedPosY)
Local $aPos = [$botPosX, $botPosY]
SetDebugLog("Restore bot window to " & $botPosX & ", " & $botPosY & ", caller: " & $sCaller, Default, True)
Local $iExStyle = _WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE)
If BitAND($iExStyle, $WS_EX_TOOLWINDOW) Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitAND($iExStyle, BitNOT($WS_EX_TOOLWINDOW)))
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then WinSetState($g_hFrmBot, "", @SW_RESTORE)
If $g_bAndroidAdbScreencap = False And $g_bRunState = True And $g_bBotPaused = False And _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
WinMove2($g_hFrmBot, "", $botPosX, $botPosY, -1, -1, $hHWndAfter, BitOR($SWP_SHOWWINDOW, $SWP_NOACTIVATE))
If _CheckWindowVisibility($g_hFrmBot, $aPos) Then
SetDebugLog("Bot Window '" & $g_sAndroidTitle & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove2($g_hFrmBot, "", $aPos[0], $aPos[1])
EndIf
WinSetTrans($g_hFrmBot, "", 255)
BotToFront($hHWndAfter)
If $g_bChkBackgroundMode And Not $g_bIsHidden And $hHWndAfter <> $g_hAndroidWindow Then HideAndroidWindow(False, False, Default, "BotMinimizeRestore", $g_hFrmBot)
Return True
EndFunc
Func BotMinimize($sCaller, $iForceUpdatingWhenMinimized = False, $iStayMinimizedMillis = 0)
Return BotMinimizeRestore(True, $sCaller, $iForceUpdatingWhenMinimized, $iStayMinimizedMillis)
EndFunc
Func BotRestore($sCaller)
Return BotMinimizeRestore(False, $sCaller)
EndFunc
Func BotWindowCheck()
If $g_bFrmBotMinimized Then
Local $aPos = WinGetPos($g_hFrmBot)
If IsArray($aPos) And $aPos[0] > -30000 Or $aPos[0] > -30000 Then
BotMinimize("BotWindowCheck")
Return True
EndIf
EndIf
Return False
EndFunc
Func tiStartStop()
If $g_bRunState Then
btnStop()
Else
btnStart()
EndIf
EndFunc
Func tiShow()
BotRestore("tiShow")
EndFunc
Func tiHide()
$g_bHideWhenMinimized = Not $g_bHideWhenMinimized
TrayItemSetState($g_hTiHide,($g_bHideWhenMinimized ? $TRAY_CHECKED : $TRAY_UNCHECKED))
GUICtrlSetState($g_hChkHideWhenMinimized,($g_bHideWhenMinimized ? $GUI_CHECKED : $GUI_UNCHECKED))
If $g_bFrmBotMinimized = True Then
If $g_bHideWhenMinimized = False Then
BotRestore("tiHide")
Else
BotMinimize("tiHide")
EndIf
EndIf
EndFunc
Func tiAbout()
Local $sMsg = "Clash of Clans Bot" & @CRLF & @CRLF & "Version: " & $g_sBotVersion & @CRLF & "Released under the GNU GPLv3 license." & @CRLF & "Visit www.MyBot.run"
MsgBox(64 + $MB_APPLMODAL + $MB_TOPMOST, $g_sBotTitle, $sMsg, 0, $g_hFrmBot)
EndFunc
Func tiDonate()
ShellExecute("https://mybot.run/forums/index.php?/donate/make-donation/")
EndFunc
Func tiExit()
BotCloseRequest()
EndFunc
Func SetRedrawBotWindow($bEnableRedraw, $bCheckRedrawBotWindow = Default, $bForceRedraw = Default, $RedrawControlIDs = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $g_iRedrawBotWindowMode = 1 Then $RedrawControlIDs = Default
If $bCheckRedrawBotWindow = Default Then $bCheckRedrawBotWindow = True
If $bForceRedraw = Default Then $bForceRedraw = False
Local $bWasRedraw = $g_bRedrawBotWindow[0]
If $g_bRedrawBotWindow[0] = $bEnableRedraw Then
Return $bWasRedraw
EndIf
_SendMessage($g_hFrmBotEx, $WM_SETREDRAW, $bEnableRedraw, 0)
$g_bRedrawBotWindow[0] = $bEnableRedraw
If $bEnableRedraw Then
If $bCheckRedrawBotWindow Then
CheckRedrawBotWindow($bForceRedraw, $RedrawControlIDs, $sSource)
EndIf
Else
SetDebugLog("Disable MyBot Window Redraw" &(($sSource <> "") ?(": " & $sSource) :("")))
$g_bRedrawBotWindow[1] = True
EndIf
Return $bWasRedraw
EndFunc
Func SetRedrawBotWindowControls($bEnableRedraw, $RedrawControlIDs, $sSource = "")
Return SetRedrawBotWindow($bEnableRedraw, True, False, $RedrawControlIDs, $sSource)
EndFunc
Func CheckRedrawBotWindow($bForceRedraw = Default, $RedrawControlIDs = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $bForceRedraw = Default Then $bForceRedraw = False
If $g_iRedrawBotWindowMode = 1 Then $RedrawControlIDs = Default
If Not $g_bRedrawBotWindow[0] Then Return False
If $g_bRedrawBotWindow[1] Or $bForceRedraw Then
$g_bRedrawBotWindow[1] = False
$g_bRedrawBotWindow[2] = False
If $RedrawControlIDs = Default Then
SetDebugLog("Redraw MyBot Window" &($bForceRedraw ? " (forced)" : "") &(($sSource <> "") ?(": " & $sSource) :("")))
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
Else
If IsArray($RedrawControlIDs) Then
SetDebugLog("Redraw MyBot ControlIds" &($bForceRedraw ? " (forced)" : "") & ": " & _ArrayToString($RedrawControlIDs, ", "))
Local $c
For $c In $RedrawControlIDs
If ControlRedraw($g_hFrmBot, $c) = 0 Then
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
ExitLoop
EndIf
Next
Else
SetDebugLog("Redraw MyBot ControlId" &($bForceRedraw ? " (forced)" : "") & ": " & $RedrawControlIDs)
If ControlRedraw($g_hFrmBot, $RedrawControlIDs) = 0 Then
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
EndIf
EndIf
EndIf
_WinAPI_UpdateWindow($g_hFrmBotEx)
Return True
Else
Return CheckRedrawControls(Default, $sSource)
EndIf
Return False
EndFunc
Func CheckRedrawControls($ForceCheck = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $ForceCheck = Default Then $ForceCheck = False
If Not $g_bRedrawBotWindow[2] And Not $ForceCheck Then Return False
If GUICtrlRead($g_hTabMain, 1) = $g_hTabLog Then
Local $a = [$g_hTxtLog, $g_hTxtAtkLog]
Return CheckRedrawBotWindow(True, $a, $sSource)
EndIf
$g_bRedrawBotWindow[2] = False
Return False
EndFunc
Func RedrawBotWindowNow()
SetDebugLog("Redraw MyBot Window Now")
_WinAPI_RedrawWindow($g_hFrmBot, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
_WinAPI_UpdateWindow($g_hFrmBot)
EndFunc
Func ControlRedraw($hWin, $ConrolId)
Local $a = ControlGetPos($hWin, "", $ConrolId)
If IsArray($a) = 0 Then
SetDebugLog("ControlRedraw: Invalid ControlId: " & $ConrolId)
Return 0
EndIf
Local $hCtrl =(IsHWnd($ConrolId) ? $ConrolId : GUICtrlGetHandle($ConrolId))
Local $hWinParent = _WinAPI_GetParent($hCtrl)
SetDebugLog("Control ID " & $ConrolId & " handle: " & $hCtrl & " parent: " & $hWinParent & " $g_hFrmBot: " & $g_hFrmBot & " $g_hFrmBotEx: " & $g_hFrmBotEx & " Pos: " & $a[0] & ", " & $a[1] & ", " & $a[2] & ", " & $a[3], Default, True)
Local $left = $a[0]
Local $top = $a[1]
Local $width = $a[2]
Local $height = $a[3]
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $left)
DllStructSetData($tRECT, "Top", $top)
DllStructSetData($tRECT, "Right", $left + $width)
DllStructSetData($tRECT, "Bottom", $top + $height)
SetDebugLog("Control ID " & $ConrolId & " RedrawWindow Pos: " & $left & ", " & $top & ", " & $left + $width & ", " & $top + $height, Default, True)
_WinAPI_RedrawWindow($hWin, $tRECT, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN))
$tRECT = 0
Return 1
EndFunc
Func SetTime($bForceUpdate = False)
If $g_hTimerSinceStarted = 0 Then Return
Local $day = 0, $hour = 0, $min = 0, $sec = 0
If(GUICtrlRead($g_hGUI_STATS_TAB, 1) = $g_hGUI_STATS_TAB_ITEM2 And GUICtrlRead($g_hGUI_BOT_TAB, 1) = $g_hGUI_BOT_TAB_ITEM5 And GUICtrlRead($g_hTabMain, 1) = $g_hTabBot) Or $bForceUpdate = True Then
_TicksToDay(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed), $day, $hour, $min, $sec)
GUICtrlSetData($g_hLblResultRuntime, $day > 0 ? StringFormat("%2u Day(s) %02i:%02i:%02i", $day, $hour, $min, $sec) : StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
EndIf
If GUICtrlGetState($g_hLblResultGoldNow) <> $GUI_ENABLE + $GUI_SHOW Or $bForceUpdate = True Then
_TicksToTime(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed), $hour, $min, $sec)
GUICtrlSetData($g_hLblResultRuntimeNow, StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
EndIf
If _DateIsValid($g_sLabUpgradeTime) Then
Local $iLabTime = _DateDiff("s", _NowCalc(), $g_sLabUpgradeTime) * 1000
If $iLabTime > 0 Then
_TicksToDay($iLabTime, $day, $hour, $min, $sec)
GUICtrlSetData($g_hLbLLabTime, $day > 0 ? StringFormat("%2ud %02i:%02i", $day, $hour, $min, $sec) :($hour > 0 ? StringFormat("%02i:%02i:%02i", $hour, $min, $sec) : StringFormat("%02i:%02i", $min, $sec)))
GUICtrlSetColor($g_hLbLLabTime, $day > 0 ? $COLOR_GREEN : $COLOR_ORANGE)
Else
GUICtrlSetData($g_hLbLLabTime, "00:00:00")
$g_sLabUpgradeTime = ""
EndIf
EndIf
If ProfileSwitchAccountEnabled() Then
If GUICtrlRead($g_hGUI_STATS_TAB, 1) = $g_hGUI_STATS_TAB_ITEM5 And GUICtrlRead($g_hGUI_BOT_TAB, 1) = $g_hGUI_BOT_TAB_ITEM5 And GUICtrlRead($g_hTabMain, 1) = $g_hTabBot Then SwitchAccountVariablesReload("SetTime")
EndIf
Static $DisplayLoop = 0, $bCurrentDisplayStatus = True
If $DisplayLoop > 5 Then
$DisplayLoop = 0
If _DateIsValid($g_sNextBuilderReadyTime) Then
_TicksToDay(Int(_DateDiff("s", _NowCalc(), $g_sNextBuilderReadyTime) * 1000), $day, $hour, $min, $sec)
Local $sBuilderTime = $day > 0 ? StringFormat("%id %ih", $day, $hour) :($hour > 0 ? StringFormat("%ih %i'", $hour, $min) : StringFormat("%im %i""", $min, $sec))
If $bCurrentDisplayStatus Then
GUICtrlSetData($g_hLblResultBuilderNow, $g_iFreeBuilderCount & "/" & $g_iTotalBuilderCount)
GUICtrlSetColor($g_hLblResultBuilderNow, $COLOR_BLACK)
$bCurrentDisplayStatus = False
Else
GUICtrlSetData($g_hLblResultBuilderNow, $sBuilderTime)
GUICtrlSetColor($g_hLblResultBuilderNow, $g_iFreeBuilderCount > 0 ? $COLOR_GREEN : $COLOR_BLACK)
$bCurrentDisplayStatus = True
EndIf
EndIf
EndIf
$DisplayLoop += 1
EndFunc
Func tabMain()
If $g_iGuiMode = 0 Then Return
Local $tabidx = GUICtrlRead($g_hTabMain)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_LOG)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_VILLAGE)
tabVillage()
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ATTACK)
tabAttack()
Case $tabidx = 3
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_BOT)
tabBot()
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ABOUT)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
EndSelect
EndFunc
Func tabVillage()
Local $tabidx = GUICtrlRead($g_hGUI_VILLAGE_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_MISC)
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_MISC)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
Case $tabidx = 2
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_MISC)
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_MISC)
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_NOTIFY)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_MISC)
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
EndSelect
EndFunc
Func tabAttack()
Local $tabidx = GUICtrlRead($g_hGUI_ATTACK_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_STRATEGIES)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_TRAINARMY)
GUISetState(@SW_HIDE, $g_hGUI_SEARCH)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_STRATEGIES)
GUISetState(@SW_HIDE, $g_hGUI_TRAINARMY)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_SEARCH)
tabSEARCH()
Case $tabidx = 2
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_STRATEGIES)
GUISetState(@SW_HIDE, $g_hGUI_TRAINARMY)
GUISetState(@SW_HIDE, $g_hGUI_SEARCH)
EndSelect
EndFunc
Func tabSEARCH()
Local $tabidx = GUICtrlRead($g_hGUI_SEARCH_TAB)
Local $tabdbx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 0)
Local $tababx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 1)
Local $tabtsx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 2)
Local $tabblx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 3)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE)
GUICtrlSetState($g_hLblDeadbaseDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUICtrlSetState($g_hLblDeadbaseDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 17)
tabDeadbase()
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE)
GUICtrlSetState($g_hLblActivebaseDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUICtrlSetState($g_hLblActivebaseDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 17)
tabActivebase()
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_THSNIPE)
GUICtrlSetState($g_hLblTHSnipeDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUICtrlSetState($g_hLblTHSnipeDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 17)
tabTHSnipe()
Case $tabidx = 3
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkBully) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_BULLY)
GUICtrlSetState($g_hLblBullyDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUICtrlSetState($g_hLblBullyDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 17)
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ATTACKOPTION)
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
EndSelect
EndFunc
Func tabDONATE()
Local $tabidx = GUICtrlRead($g_hGUI_DONATE_TAB)
Local $tabdonx = _GUICtrlTab_GetItemRect($g_hGUI_DONATE_TAB, 1)
Select
Case $tabidx = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
If GUICtrlRead($g_hChkDonate) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DONATECC)
GUICtrlSetState($g_hLblDonateDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
GUICtrlSetState($g_hLblDonateDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
If GUICtrlRead($g_hChkDonate) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ScheduleCC)
GUICtrlSetState($g_hLblScheduleDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
GUICtrlSetState($g_hLblScheduleDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
EndSelect
EndFunc
Func tabMod()
Local $tabidx = GUICtrlRead($g_hGUI_MOD_TAB)
Select
Case $tabidx = 0
Case $tabidx = 1
Case $tabidx = 2
Case $tabidx = 3
EndSelect
EndFunc
Func tabBot()
Local $tabidx = GUICtrlRead($g_hGUI_BOT_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_STATS)
GUISetState(@SW_HIDE, $g_hGUI_SWITCH_OPTIONS)
ControlShow("", "", $g_hCmbGUILanguage)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_STATS)
GUISetState(@SW_HIDE, $g_hGUI_SWITCH_OPTIONS)
ControlHide("", "", $g_hCmbGUILanguage)
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_STATS)
GUISetState(@SW_HIDE, $g_hGUI_SWITCH_OPTIONS)
ControlHide("", "", $g_hCmbGUILanguage)
Case $tabidx = 3
GUISetState(@SW_HIDE, $g_hGUI_STATS)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_SWITCH_OPTIONS)
ControlHide("", "", $g_hCmbGUILanguage)
tabSwitchOptions()
Case $tabidx = 4
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_STATS)
GUISetState(@SW_HIDE, $g_hGUI_SWITCH_OPTIONS)
If Not $g_bRunState Then UpdateMultiStats()
ControlHide("", "", $g_hCmbGUILanguage)
EndSelect
EndFunc
Func tabSwitchOptions()
Local $tabidx = GUICtrlRead($g_hGUI_SWITCH_OPTIONS_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_LOG_SA)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_LOG_SA)
EndSelect
EndFunc
Func tabDeadbase()
Local $tabidx = GUICtrlRead($g_hGUI_DEADBASE_TAB)
Select
Case $tabidx = 1
cmbDBAlgorithm()
Case Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SMARTFARM)
EndSelect
EndFunc
Func tabActivebase()
Local $tabidx = GUICtrlRead($g_hGUI_ACTIVEBASE_TAB)
Select
Case $tabidx = 1
cmbABAlgorithm()
Case Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
EndSelect
EndFunc
Func tabTHSnipe()
Local $tabidx = GUICtrlRead($g_hGUI_THSNIPE_TAB)
Select
Case $tabidx = 1
Case Else
EndSelect
EndFunc
Func Bind_ImageList($nCtrl, ByRef $hImageList)
Local $aIconIndex = 0
If $hImageList = 0 Then
$hImageList = _GUIImageList_Create(16, 16, 5, 1)
EndIf
GUICtrlSendMsg($nCtrl, $TCM_SETIMAGELIST, 0, $hImageList)
Local $tTcItem = DllStructCreate("uint;dword;dword;ptr;int;int;int")
DllStructSetData($tTcItem, 1, 0x0002)
Switch $nCtrl
Case $g_hTabMain
Local $aIconIndex = [$eIcnHourGlass, $eIcnTH12, $eIcnAttack, $eIcnGUI, $eIcnInfo]
Case $g_hGUI_VILLAGE_TAB
Local $aIconIndex = [$eIcnTH1, $eIcnCC, $eIcnLaboratory, $eIcnAchievements, $eIcnTelegram]
Case $g_hGUI_TRAINARMY_TAB
Local $aIconIndex = [$eIcnTrain, $eIcnGem, $eIcnReOrder, $eIcnOptions]
Case $g_hGUI_MISC_TAB
Local $aIconIndex = [$eIcnTH1, $eIcnBuilderHall, $eIcnClanGames]
Case $g_hGUI_DONATE_TAB
Local $aIconIndex = [$eIcnCCRequest, $eIcnCCDonate, $eIcnHourGlass]
Case $g_hGUI_UPGRADE_TAB
Local $aIconIndex = [$eIcnLaboratory, $eIcnHeroes, $eIcnMortar, $eIcnBuilder, $eIcnWall]
Case $g_hGUI_NOTIFY_TAB
Local $aIconIndex = [$eIcnTelegram]
Case $g_hGUI_ATTACK_TAB
Local $aIconIndex = [$eIcnTrain, $eIcnMagnifier, $eIcnStrategies]
Case $g_hGUI_SEARCH_TAB
Local $aIconIndex = [$eIcnCollector, $eIcnCC, $eIcnTH10, $eIcnTH1, $eIcnOptions]
Case $g_hGUI_DEADBASE_TAB
Local $aIconIndex = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar, $eIcnCollector]
Case $g_hGUI_ACTIVEBASE_TAB
Local $aIconIndex = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar]
Case $g_hGUI_THSNIPE_TAB
Local $aIconIndex = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar]
Case $g_hGUI_ATTACKOPTION_TAB
Local $aIconIndex = [$eIcnMagnifier, $eIcnCamp, $eIcnLightSpell, $eIcnSilverStar, $eIcnTrophy]
Case $g_hGUI_MOD_TAB
Local $aIconIndex = [$eIcnMiscMod, $eIcnHumanization, $eIcnGoblinXP, $eIcnWarPreparation]
Case $g_hGUI_BOT_TAB
Local $aIconIndex = [$eIcnOptions, $eIcnAndroid, $eIcnDebug, $eIcnProfile, $eIcnGold]
Case $g_hGUI_SWITCH_OPTIONS_TAB
Local $aIconIndex = [$eIcnSwitchAcc, $eIcnSwitchProfiles, $eIcnFarmingSchedule]
Case $g_hGUI_STRATEGIES_TAB
Local $aIconIndex = [$eIcnReload, $eIcnCopy]
Case $g_hGUI_STATS_TAB
Local $aIconIndex = [$eIcnGoldElixir, $eIcnOptions, $eIcnCamp, $eIcnCCRequest, $eIcnGoldElixir]
Case Else
EndSwitch
If IsArray($aIconIndex) Then
For $i = 0 To UBound($aIconIndex) - 1
DllStructSetData($tTcItem, 6, $i)
AddImageToTab($nCtrl, $hImageList, $i, $tTcItem, $g_sLibIconPath, $aIconIndex[$i] - 1)
Next
$aIconIndex = 0
EndIf
EndFunc
Func AddImageToTab($nCtrl, ByRef $hImageList, $nTabIndex, $nItem, $g_sLibIconPath, $nIconID)
Local $hIcon = DllStructCreate("int")
Local $Result = DllCall("shell32.dll", "int", "ExtractIconEx", "str", $g_sLibIconPath, "int", $nIconID, "hwnd", 0, "ptr", DllStructGetPtr($hIcon), "int", 1)
If UBound($Result) > 0 Then
$Result = $Result[0]
If $Result > 0 Then
DllCall("comctl32.dll", "int", "ImageList_AddIcon", "hwnd", $hImageList, "hwnd", DllStructGetData($hIcon, 1))
DllCall("user32.dll", "int", "SendMessage", "hwnd", ControlGetHandle($g_hFrmBot, "", $nCtrl), "int", $TCM_SETITEM, "int", $nTabIndex, "ptr", DllStructGetPtr($nItem))
DllCall("user32.dll", "int", "DestroyIcon", "hwnd", DllStructGetData($hIcon, 1))
EndIf
EndIf
EndFunc
Func _GUICtrlListView_SetItemHeightByFont($hListView, $iHeight)
Local $hDC = _WinAPI_GetDC($hListView), $hFont = _SendMessage($hListView, $WM_GETFONT)
Local $hObject = _WinAPI_SelectObject($hDC, $hFont), $lvLOGFONT = DllStructCreate($tagLOGFONT)
_WinAPI_GetObject($hFont, DllStructGetSize($lvLOGFONT), DllStructGetPtr($lvLOGFONT))
Local $hLVfont = _WinAPI_CreateFontIndirect($lvLOGFONT)
_WinAPI_SelectObject($hDC, $hObject)
_WinAPI_ReleaseDC($hListView, $hDC)
_WinAPI_DeleteObject($hFont)
$hFont = _WinAPI_CreateFont($iHeight, 0)
_WinAPI_SetFont($hListView, $hFont)
_WinAPI_DeleteObject($hFont)
Local $hHeader = _GUICtrlListView_GetHeader($hListView)
If $hHeader Then _WinAPI_SetFont($hHeader, $hLVfont)
$lvLOGFONT = 0
Return $hLVfont
EndFunc
Func _GUICtrlListView_GetHeightToFitRows($hListView, $iRows)
Local $tRECT = _WinAPI_GetClientRect($hListView)
Local $hHeader = _GUICtrlListView_GetHeader($hListView)
Local $tWindowPos = _GUICtrlHeader_Layout($hHeader, $tRECT)
Local $iHdrHeight = DllStructGetData($tWindowPos, "CY")
Local $aItemRect = _GUICtrlListView_GetItemRect($hListView, 0, 0)
Return($aItemRect[3] - $aItemRect[1]) * $iRows + $iHdrHeight + 8
EndFunc
Func EnableControls($hWin, $Enable, ByRef $avArr, $bGUIControl_Disabled = True, $i = 0)
If $hWin = 0 Or $hWin = -1 Then Return 0
Local $initalCall = $i = 0
If UBound($avArr, 0) <> 2 Then
Local $avTmp[1][2] = [[0]]
$avArr = $avTmp
EndIf
If $initalCall And $bGUIControl_Disabled Then
_SendMessage($hWin, $WM_SETREDRAW, False, 0)
Local $g_bGUIControlDisabled_ = $g_bGUIControlDisabled
$g_bGUIControlDisabled = True
EndIf
Local $hChild = _WinAPI_GetWindow($hWin, $GW_CHILD)
While $hChild
$i += 1
If $avArr[0][0] + 1 > UBound($avArr, 1) - 1 Then
ReDim $avArr[$avArr[0][0] + 2][2]
$avArr[$avArr[0][0] + 1][0] = $hChild
$avArr[$avArr[0][0] + 1][1] = BitAND(WinGetState($hChild), 4) > 0
EndIf
If $Enable = Default Then
WinSetState($hChild, "",($avArr[$i][1] = True ? @SW_ENABLE : @SW_DISABLE))
Else
WinSetState($hChild, "",($Enable ? @SW_ENABLE : @SW_DISABLE))
EndIf
$avArr[0][0] += 1
$i = EnableControls($hChild, $Enable, $avArr, $bGUIControl_Disabled, $i)
$hChild = _WinAPI_GetWindow($hChild, $GW_HWNDNEXT)
WEnd
If $initalCall And $Enable = Default Then $avArr = 0
If $initalCall And $bGUIControl_Disabled Then
_SendMessage($hWin, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($hWin, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN))
$g_bGUIControlDisabled = $g_bGUIControlDisabled_
EndIf
Return $i
EndFunc
Func frmBot_WNDPROC($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
If $g_iDebugWindowMessages > 0 Then SetDebugLog("frmBot_WNDPROC: FORWARD $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg) & ", $wParam=" & Hex($wParam) & ", $lParam=" & $lParam, Default, True)
Switch $iMsg
Case $WM_KEYDOWN, $WM_KEYUP, $WM_SYSKEYDOWN, $WM_SYSKEYUP, $WM_MOUSEHWHEEL
GUIControl_AndroidEmbedded($hWin, $iMsg, $wParam, $lParam)
EndSwitch
Local $wndproc = $g_hFrmBot_WNDPROC
Local $Return = 1
If $wndproc <> 0 Then
_WinAPI_CallWindowProc($wndproc, $hWin, $iMsg, $wParam, $lParam)
$Return = 0
EndIf
SetCriticalMessageProcessing($wasCritical)
Return $Return
EndFunc
Func HandleWndProc($Enable = True)
If $g_hFrmBot_WNDPROC = 0 And $Enable = True Then
$g_hFrmBot_WNDPROC = _WinAPI_SetWindowLong(ControlGetHandle($g_hFrmBot, "", $g_hFrmBotEmbeddedShieldInput), $GWL_WNDPROC, $g_hFrmBot_WNDPROC_ptr)
ElseIf $g_hFrmBot_WNDPROC <> 0 And $Enable = False Then
_WinAPI_SetWindowLong(ControlGetHandle($g_hFrmBot, "", $g_hFrmBotEmbeddedShieldInput), $GWL_WNDPROC, $g_hFrmBot_WNDPROC)
$g_hFrmBot_WNDPROC = 0
EndIf
EndFunc
Func IsGUICtrlHidden($hGUICtrl)
If BitAND(WinGetState(GUICtrlGetHandle($hGUICtrl), ""), 2) = 0 Then Return True
Return False
EndFunc
Func IsConfigActive()
Return $g_bReadConfigIsActive Or $g_bSaveConfigIsActive Or $g_bApplyConfigIsActive
EndFunc
Func IsBotLaunched()
Return $g_iBotLaunchTime > 0
EndFunc
Func ConsoleWindow($bShow = Default)
Static $bConsoleAllocated = False
If $bShow = Default Then $bShow = Not $bConsoleAllocated
If $bShow Then
_WinAPI_AllocConsole()
_WinAPI_SetConsoleIcon($g_sLibIconPath, $eIcnGUI)
$bConsoleAllocated = True
SetDebugLog("Allocate Console Window")
Else
SetDebugLog("Free Console Window")
_WinAPI_FreeConsole()
$bConsoleAllocated = False
EndIf
EndFunc
Global $_B64E_CodeBuffer, $_B64E_CodeBufferMemory, $_B64E_Init, $_B64E_EncodeData, $_B64E_EncodeEnd
Func _B64E_Exit()
$_B64E_CodeBuffer = 0
_MemVirtualFree($_B64E_CodeBufferMemory, 0, $MEM_RELEASE)
EndFunc
Func _Base64EncodeInit($LineBreak = 76)
If Not IsDllStruct($_B64E_CodeBuffer) Then
If @AutoItX64 Then
Local $Opcode = '0x89C08D42034883EC0885D2C70100000000C64104000F49C2C7410800000000C1F80283E20389410C740683C00189410C4883C408C389C94883EC3848895C242848897424304889CB8B0A83F901742083F9024889D87444C6000A4883C001488B74243029D8488B5C24284883C438C30FB67204E803020000BA3D0000004080FE3F7F08480FBEF60FB614308813C643013D488D4303C643023DEBBC0FB67204E8D7010000BA3D0000004080FE3F7F08480FBEF60FB614308813C643013D488D4302EB9489DB4883EC68418B014863D248895C242848897424304C89C348897C24384C896424484C89CE83F80148896C24404C896C24504C897424584C897C24604C8D2411410FB6790474434D89C64989CD0F82F700000083F8024C89C5747B31C0488B5C2428488B742430488B7C2438488B6C24404C8B6424484C8B6C24504C8B7424584C8B7C24604883C468C34C89C54989CF4D39E70F840B010000450FBE374D8D6F014489F025F0000000C1F80409C7E8040100004080FF3FBA3D0000007F08480FBEFF0FB614384489F78855004883C50183E70FC1E7024D39E50F84B2000000450FB675004983C5014489F025C0000000C1F80609C7E8BD0000004080FF3FBA3D0000007F08480FBEFF0FB61438BF3F0000008855004421F74C8D7502E896000000480FBED70FB604108845018B460883C0013B460C89460875104C8D7503C645020AC7460800000000904D39E5742E410FBE7D004D8D7D01498D6E01E8560000004889FA83E70348C1EA02C1E70483E23F0FB60410418806E913FFFFFF4489F040887E04C7060000000029D8E9CCFEFFFF89E840887E04C7060200000029D8E9B9FEFFFF89E840887E04C7060100000029D8E9A6FEFFFFE8400000004142434445464748494A4B4C4D4E4F505152535455565758595A6162636465666768696A6B6C6D6E6F707172737475767778797A303132333435363738392B2F58C3'
Else
Local $Opcode = '0x89C08B4C24088B44240489CAC1FA1FC1EA1E01CAC1FA0283E103C70000000000C6400400C740080000000089500C740683C20189500CC2100089C983EC0C8B4C2414895C24048B5C2410897424088B1183FA01741D83FA0289D87443C6000A83C0018B74240829D88B5C240483C40CC210000FB67104E80C020000BA3D00000089F180F93F7F0989F20FBEF20FB6143088138D4303C643013DC643023DEBBD0FB67104E8DF010000BA3D00000089F180F93F7F0989F20FBEF20FB6143088138D4302C643013DEB9489DB83EC3C895C242C8B5C244C896C24388B542440897424308B6C2444897C24348B030FB6730401D583F801742D8B4C24488954241C0F820101000083F80289CF747D31C08B5C242C8B7424308B7C24348B6C243883C43CC210008B4C244889D739EF0F84400100008D57010FBE3F89542418894C241489F825F0000000C1F80409C6897C241CE8330100008B542418C644240C3D8B4C241489C789F03C3F7F0B0FBEF00FB604378844240C0FB644240C8D790188018B74241C83E60FC1E60239EA0F84CB0000000FB60A83C2018954241C89C825C0000000C1F80609C6884C2414E8D8000000BA3D0000000FB64C24148944240C89F03C3F7F0B0FBEF08B44240C0FB6143083E13F881789CEE8AD00000089F10FBED18D4F020FB604108847018B430883C0013B430C894308750EC647020A8D4F03C7430800000000396C241C743A8B44241C8B7C241C0FBE30894C241483C701E8650000008B4C241489F283E60381E2FC000000C1EA02C1E6040FB60410880183C101E9E4FEFFFF89F088430489C8C703000000002B442448E9B2FEFFFF89F189F8884B04C703020000002B442448E99CFEFFFF89F088430489C8C703010000002B442448E986FEFFFFE8400000004142434445464748494A4B4C4D4E4F505152535455565758595A6162636465666768696A6B6C6D6E6F707172737475767778797A303132333435363738392B2F58C3'
EndIf
$_B64E_Init =(StringInStr($Opcode, "89C0") - 3) / 2
$_B64E_EncodeData =(StringInStr($Opcode, "89DB") - 3) / 2
$_B64E_EncodeEnd =(StringInStr($Opcode, "89C9") - 3) / 2
$Opcode = Binary($Opcode)
$_B64E_CodeBufferMemory = _MemVirtualAlloc(0, BinaryLen($Opcode), $MEM_COMMIT, $PAGE_EXECUTE_READWRITE)
$_B64E_CodeBuffer = DllStructCreate("byte[" & BinaryLen($Opcode) & "]", $_B64E_CodeBufferMemory)
DllStructSetData($_B64E_CodeBuffer, 1, $Opcode)
OnAutoItExitRegister("_B64E_Exit")
EndIf
Local $State = DllStructCreate("byte[16]")
DllCall("user32.dll", "none", "CallWindowProc", "ptr", DllStructGetPtr($_B64E_CodeBuffer) + $_B64E_Init, "ptr", DllStructGetPtr($State), "uint", $LineBreak, "int", 0, "int", 0)
Return $State
EndFunc
Func _Base64EncodeData(ByRef $State, $Data)
If Not IsDllStruct($_B64E_CodeBuffer) Or Not IsDllStruct($State) Then Return SetError(1, 0, "")
$Data = Binary($Data)
Local $InputLen = BinaryLen($Data)
Local $Input = DllStructCreate("byte[" & $InputLen & "]")
DllStructSetData($Input, 1, $Data)
Local $OputputLen = Ceiling(BinaryLen($Data) * 1.4) + 3
Local $Output = DllStructCreate("char[" & $OputputLen & "]")
DllCall("user32.dll", "int", "CallWindowProc", "ptr", DllStructGetPtr($_B64E_CodeBuffer) + $_B64E_EncodeData, "ptr", DllStructGetPtr($Input), "uint", $InputLen, "ptr", DllStructGetPtr($Output), "ptr", DllStructGetPtr($State))
Return DllStructGetData($Output, 1)
EndFunc
Func _Base64EncodeEnd(ByRef $State)
If Not IsDllStruct($_B64E_CodeBuffer) Or Not IsDllStruct($State) Then Return SetError(1, 0, "")
Local $Output = DllStructCreate("char[5]")
DllCall("user32.dll", "int", "CallWindowProc", "ptr", DllStructGetPtr($_B64E_CodeBuffer) + $_B64E_EncodeEnd, "ptr", DllStructGetPtr($Output), "ptr", DllStructGetPtr($State), "int", 0, "int", 0)
Return DllStructGetData($Output, 1)
EndFunc
Func _Base64Encode($Data, $LineBreak = 76)
Local $State = _Base64EncodeInit($LineBreak)
Return _Base64EncodeData($State, $Data) & _Base64EncodeEnd($State)
EndFunc
Global $g_oTxtLogInitText = ObjCreate("Scripting.Dictionary")
Global $g_oTxtAtkLogInitText = ObjCreate("Scripting.Dictionary")
Global $g_oTxtSALogInitText = ObjCreate("Scripting.Dictionary")
Global $g_bSilentSetDebugLog = False
Global $g_aLastStatusBar
Func SetLog($sLogMessage, $iColor = Default, $sFont = Default, $iFontSize = Default, $iStatusbar = Default, $bConsoleWrite = Default)
If $sLogMessage <> "" Then Return _SetLog($sLogMessage, $iColor, $sFont, $iFontSize, $iStatusbar, $bConsoleWrite)
EndFunc
Func _SetLog($sLogMessage, $Color = Default, $Font = Default, $FontSize = Default, $statusbar = Default, $time = Default, $bConsoleWrite = Default, $LogPrefix = Default, $bPostponed = Default, $bSilentSetLog = Default, $bWriteToLogFile = Default)
Local Static $bActive = False
Local Static $hLogCheckFreeSpaceTimer = 0
If $Color = Default Then $Color = $COLOR_BLACK
If $Font = Default Then $Font = "Verdana"
If $FontSize = Default Then $FontSize = 7.5
If $statusbar = Default Then $statusbar = 1
If $time = Default Then $time = Time()
Local $debugTime = TimeDebug()
If $bConsoleWrite = Default Then $bConsoleWrite = True
If $LogPrefix = Default Then $LogPrefix = "L "
If $bPostponed = Default Then $bPostponed = $g_bCriticalMessageProcessing
If $bSilentSetLog = Default Then $bSilentSetLog = $g_bSilentSetLog
If $bWriteToLogFile = Default Then $bWriteToLogFile = True
Local $log = $LogPrefix & $debugTime & $sLogMessage
If $bConsoleWrite = True And $sLogMessage <> "" Then
Local $sLevel = GetLogLevel($Color)
_ConsoleWrite($sLevel & $log & @CRLF)
EndIf
If $g_hLogFile = 0 And $g_sProfileLogsPath Then
CreateLogFile()
EndIf
If $bWriteToLogFile Then __FileWriteLog($g_hLogFile, $log)
If $bSilentSetLog = True And($bWriteToLogFile = False Or $g_hLogFile) Then
Return
EndIf
Local $a[6]
$a[0] = $sLogMessage
$a[1] = $Color
$a[2] = $Font
$a[3] = $FontSize
$a[4] = $statusbar
$a[5] = $time
If $statusbar Then $g_aLastStatusBar = $a
If $g_hLogFile = 0 Then
ReDim $a[8]
$a[6] =(($bSilentSetLog) ?(1) :(2))
$a[7] = $LogPrefix & $debugTime
EndIf
$g_oTxtLogInitText($g_oTxtLogInitText.Count + 1) = $a
If $bActive Then Return
$bActive = True
If(($g_hTxtLog <> 0 Or $g_iGuiMode <> 1) And $g_bRunState = False) Or($bPostponed = False And __TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout) Then
CheckPostponedLog()
If $g_iLogCheckFreeSpaceMB And $g_bRunState Then
If $hLogCheckFreeSpaceTimer = 0 Or __TimerDiff($hLogCheckFreeSpaceTimer) > 600000 Then
Local $fFree = DriveSpaceFree($g_sProfilePath & "\" & $g_sProfileCurrentName)
If $hLogCheckFreeSpaceTimer = 0 Then SetDebugLog("Free disk space is " & $fFree & " MB")
$hLogCheckFreeSpaceTimer = __TimerInit()
If @error = 0 And $fFree < $g_iLogCheckFreeSpaceMB Then
$hLogCheckFreeSpaceTimer = 0
SetLog("Less than " & $g_iLogCheckFreeSpaceMB & " MB free disk space, bot is stopping!", $COLOR_ERROR)
If $g_bRunState Then btnStop()
EndIf
EndIf
EndIf
EndIf
$bActive = False
EndFunc
Func GetLogLevel($Color)
Local $sLevel = ""
Switch $Color
Case $COLOR_ERROR
$sLevel = "ERROR    "
Case $COLOR_WARNING
$sLevel = "WARN     "
Case $COLOR_SUCCESS
$sLevel = "SUCCESS  "
Case $COLOR_SUCCESS1
$sLevel = "SUCCESS1 "
Case $COLOR_INFO
$sLevel = "INFO     "
Case $COLOR_DEBUG
$sLevel = "DEBUG    "
Case $COLOR_DEBUG1
$sLevel = "DEBUG1   "
Case $COLOR_DEBUG2
$sLevel = "DEBUG2   "
Case $COLOR_DEBUGS
$sLevel = "DEBUGS   "
Case $COLOR_ACTION
$sLevel = "ACTION   "
Case $COLOR_ACTION1
$sLevel = "ACTION1  "
Case $COLOR_ORANGE
$sLevel = "ORANGE   "
Case $COLOR_BLACK
$sLevel = "NORMAL   "
Case Else
$sLevel = Hex($Color, 6) & "   "
EndSwitch
Return $sLevel
EndFunc
Func SetLogText(ByRef $hTxtLog, ByRef $sLogMessage, ByRef $Color, ByRef $Font, ByRef $FontSize, ByRef $time)
If $time Then
_GUICtrlRichEdit_SetFont($hTxtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($hTxtLog, $time, 0x000000, False)
EndIf
_GUICtrlRichEdit_SetFont($hTxtLog, $FontSize, $Font)
_GUICtrlRichEdit_AppendTextColor($hTxtLog, $sLogMessage & @CRLF, _ColorConvert($Color), False)
EndFunc
Func SetDebugLog($sLogMessage, $sColor = $COLOR_DEBUG, $bSilentSetLog = Default, $Font = Default, $FontSize = Default, $statusbar = 0)
Local $sLogPrefix = "D "
Local $sLog = $sLogPrefix & TimeDebug() & $sLogMessage
If $bSilentSetLog = Default Then $bSilentSetLog = $g_bSilentSetDebugLog
If $g_bDebugSetlog And $bSilentSetLog = False Then
_SetLog($sLogMessage, $sColor, $Font, $FontSize, $statusbar, Default, True, $sLogPrefix)
Else
If $sLogMessage <> "" Then _ConsoleWrite(GetLogLevel($sColor) & $sLog & @CRLF)
If $g_hLogFile = 0 And $g_sProfileLogsPath Then CreateLogFile()
If $g_hLogFile Then
__FileWriteLog($g_hLogFile, $sLog)
Else
_SetLog($sLogMessage, $sColor, $Font, $FontSize, $statusbar, Default, False, $sLogPrefix, Default, True)
EndIf
EndIf
EndFunc
Func SetGuiLog($sLogMessage, $Color = Default, $bGuiLog = Default)
If $bGuiLog = Default Then $bGuiLog = True
If $bGuiLog = True Then
Return _SetLog($sLogMessage, $Color)
EndIf
Return SetDebugLog($sLogMessage, $Color)
EndFunc
Func FlushGuiLog(ByRef $hTxtLog, ByRef $oTxtLog, $bUpdateStatus = False, $sLogMutexName = "txtLog")
$g_bFlushGuiLogActive = True
Local $wasLock = AndroidShieldLock(True)
If $hTxtLog Then
Local $activeBot = _WinAPI_GetForegroundWindow() = $g_hFrmBot
Local $hCtrl = _WinAPI_GetFocus()
_SendMessage($hTxtLog, $WM_SETREDRAW, False, 0)
_WinAPI_EnableWindow($hTxtLog, False)
_GUICtrlRichEdit_SetSel($hTxtLog, -1, -1)
EndIf
Local $sLastStatus = ""
For $i = 1 To $oTxtLog.Count
Local $a = $oTxtLog($i)
Local $iSize = UBound($a)
If $hTxtLog Then
If $iSize = 0 And $a = 0 Then
_GUICtrlEdit_SetText($hTxtLog, "")
ContinueLoop
EndIf
If $iSize = 6 Or($iSize > 6 And $a[6] = 2) Then
SetLogText($hTxtLog, $a[0], $a[1], $a[2], $a[3], $a[5])
EndIf
EndIf
If $iSize > 7 And $a[6] > 0 Then
__FileWriteLog($g_hLogFile, $a[7] & $a[0])
If $a[6] = 1 Then
ContinueLoop
EndIf
EndIf
If $bUpdateStatus = True And($g_hStatusBar Or $g_iGuiMode <> 1) And $iSize > 4 And $a[4] = 1 Then
$sLastStatus = $a[0]
EndIf
Next
If $sLastStatus Then
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, "Status : " & $sLastStatus)
EndIf
Local $iLogs = $oTxtLog.Count
$oTxtLog.RemoveAll
If $hTxtLog Then
_WinAPI_EnableWindow($hTxtLog, True)
_GUICtrlRichEdit_SetSel($hTxtLog, -1, -1)
_SendMessage($hTxtLog, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($hTxtLog, 0, 0, $RDW_INVALIDATE)
If $activeBot And $hCtrl <> $hTxtLog Then _WinAPI_SetFocus($hCtrl)
EndIf
AndroidShieldLock($wasLock)
$g_bFlushGuiLogActive = False
Return $iLogs
EndFunc
Func UpdateStatusBar($sText)
Local $iPosCr = StringInStr($sText, Chr(13))
Local $iPosLf = StringInStr($sText, Chr(10))
Local $iPos = $iPosCr
If $iPosLf > 0 And $iPosLf < $iPosCr Then $iPos = $iPosLf
If $iPos > 0 Then $sText = StringLeft($sText, $iPos - 1)
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, "Status : " & $sText)
EndFunc
Func CheckPostponedLog($bNow = False)
Local $iLogs = 0
If $g_bCriticalMessageProcessing Or($bNow = False And __TimerDiff($g_hTxtLogTimer) < $g_iTxtLogTimerTimeout) Then Return 0
If $g_oTxtLogInitText.Count > 0 And($g_iGuiMode <> 1 Or $g_hTxtLog) Then
If $g_hTxtLog And UBound($g_aLastStatusBar) > 0 And BitAND(WinGetState($g_hGUI_LOG), 2) = 0 Then
UpdateStatusBar($g_aLastStatusBar[0])
$g_aLastStatusBar = 0
Else
$iLogs += FlushGuiLog($g_hTxtLog, $g_oTxtLogInitText, True, "txtLog")
EndIf
EndIf
If $g_oTxtAtkLogInitText.Count > 0 And($g_iGuiMode <> 1 Or($g_hTxtAtkLog And BitAND(WinGetState($g_hGUI_LOG), 2))) Then
$iLogs += FlushGuiLog($g_hTxtAtkLog, $g_oTxtAtkLogInitText, False, "txtAtkLog")
EndIf
If $g_oTxtSALogInitText.Count > 0 And($g_iGuiMode <> 1 Or($g_hTxtSALog And BitAND(WinGetState($g_hGUI_LOG_SA), 2))) Then
$iLogs += FlushGuiLog($g_hTxtSALog, $g_oTxtSALogInitText, False, "txtSALog")
EndIf
$g_hTxtLogTimer = __TimerInit()
Return $iLogs
EndFunc
Func _GUICtrlRichEdit_AppendTextColor($hWnd, $sText, $iColor, $bGotoEnd = True)
If $bGotoEnd Then _GUICtrlRichEdit_SetSel($hWnd, -1, -1)
_GUICtrlRichEdit_SetCharColor($hWnd, $iColor)
_GUICtrlRichEdit_AppendText($hWnd, $sText)
EndFunc
Func _ColorConvert($nColor)
Return BitOR(BitShift(BitAND($nColor, 0x000000FF), -16), BitAND($nColor, 0x0000FF00), BitShift(BitAND($nColor, 0x00FF0000), 16))
EndFunc
Func SetAtkLog($String1, $String2 = "", $Color = $COLOR_BLACK, $Font = "Lucida Console", $FontSize = 7.5)
If $g_hAttackLogFile = 0 Then CreateAttackLogFile()
_FileWriteLog($g_hAttackLogFile, $String1 & $String2)
Dim $a[6]
$a[0] = $String1
$a[1] = $Color
$a[2] = $Font
$a[3] = $FontSize
$a[4] = 0
$a[5] = 0
$g_oTxtAtkLogInitText($g_oTxtAtkLogInitText.Count + 1) = $a
EndFunc
Func SetSwitchAccLog($String, $Color = $COLOR_BLACK, $Font = "Verdana", $FontSize = 7.5, $time = True)
If $time = True Then
$time = Time()
Else
$time = 0
EndIf
If $g_hSwitchLogFile = 0 Then CreateSwitchLogFile()
_FileWriteLog($g_hSwitchLogFile, $String)
Dim $a[6]
$a[0] = $String
$a[1] = $Color
$a[2] = $Font
$a[3] = $FontSize
$a[4] = 0
$a[5] = $time
$g_oTxtSALogInitText($g_oTxtSALogInitText.Count + 1) = $a
EndFunc
Func AtkLogHead()
SetAtkLog(_PadStringCenter(" " & GetTranslatedFileIni("MBR Func_AtkLogHead", "AtkLogHead_Text_01", "ATTACK LOG") & " ", 71, "="), "", $COLOR_BLACK, "MS Shell Dlg", 8.5)
SetAtkLog(GetTranslatedFileIni("MBR Func_AtkLogHead", "AtkLogHead_Text_02", '|                      -------  LOOT ------           ------ BONUS ------'), "")
SetAtkLog(GetTranslatedFileIni("MBR Func_AtkLogHead", "AtkLogHead_Text_03", '|AC|TIME.|TROP.|SRC|DS|   GOLD| ELIXIR|  DE|TR.|S|  %|  GOLD|ELIXIR|  DE|L.'), "")
EndFunc
Func __FileWriteLog($handle, $text)
Return FileWriteLine($handle, BitAND(WinGetState($g_hFrmBot), 2) & ": " & $text)
EndFunc
Func ClearLog($hRichEditCtrl = $g_hTxtLog)
Switch $hRichEditCtrl
Case $g_hTxtLog
$g_oTxtLogInitText($g_oTxtLogInitText.Count + 1) = 0
Case $g_hTxtAtkLog
$g_oTxtAtkLogInitText($g_oTxtAtkLogInitText.Count + 1) = 0
EndSwitch
EndFunc
Func SetLogCentered($String, $sPad = Default, $Color = Default, $bClearLog = False)
If $sPad = Default Then $sPad = "="
If $bClearLog = True Then ClearLog($g_hTxtLog)
_SetLog(_PadStringCenter($String, 53, $sPad), $Color, "Lucida Console", 8)
EndFunc
Func SetDebugLogSilent($bSilent = Default)
If $bSilent = Default Then $bSilent = True
Local $bWasSilent = $g_bSilentSetDebugLog
$g_bSilentSetDebugLog = $bSilent
Return $bWasSilent
EndFunc
Global $g_oStopWatches = ObjCreate("Scripting.Dictionary")
Global $g_oFuncCall = ObjCreate("Scripting.Dictionary")
If Not IsDeclared("g_bDebugFuncTime") Then Global $g_bDebugFuncTime = False
If Not IsDeclared("g_bDebugFuncCall") Then Global $g_bDebugFuncCall = False
Func FuncEnter($fFunc, $bLog = $g_bDebugFuncCall)
Local $sFunc = FuncName($fFunc)
Local $iLevel = FuncCallLevel()
$g_oFuncCall("__CURRENT_FUNC__" & $iLevel) = $sFunc
$g_oFuncCall("__CURRENT_FUNC_LEVEL__") = $iLevel + 1
If $bLog Then
SetDebugLog(">>> Enter Func: " & $sFunc & ", call-hierarchy: " & FuncCallHierarchy(False), $COLOR_WARNING)
EndIf
Return $iLevel
EndFunc
Func FuncCallHierarchy($bIncludeCurrent = True)
Local $iLevel = FuncCallLevel() - 1
If Not $bIncludeCurrent Then $iLevel -= 1
Local $sHierarchy = ""
For $i = 0 To $iLevel
If $sHierarchy = "" Then
$sHierarchy = $g_oFuncCall("__CURRENT_FUNC__" & $i)
Else
$sHierarchy &= " -> " & $g_oFuncCall("__CURRENT_FUNC__" & $i)
EndIf
Next
Return $sHierarchy
EndFunc
Func FuncCallLevel()
Local $iLevel = $g_oFuncCall("__CURRENT_FUNC_LEVEL__")
If IsNumber($iLevel) = 0 Then $iLevel = 0
Return $iLevel
EndFunc
Func FuncReturn($Result = "__No_Result", $bLog = $g_bDebugFuncCall)
Local $bNoResult =(IsString($Result) And $Result = "__No_Result")
Local $iLevel = FuncCallLevel() - 1
If $iLevel < 0 Then
SetDebugLog("FuncReturn improper use", $COLOR_ERROR)
Else
$g_oFuncCall("__CURRENT_FUNC_LEVEL__") = $iLevel
Local $sTag = "__CURRENT_FUNC__" & $iLevel
Local $sFunc = $g_oFuncCall($sTag)
$g_oFuncCall.remove($sTag)
If $bLog Then
SetDebugLog("<<< Return Func: " & $sFunc &(($bNoResult) ?(", no result") :(", Result: " & $Result)) & ", call-hierarchy: " & FuncCallHierarchy(True), $COLOR_WARNING)
EndIf
EndIf
If $bNoResult Then Return
Return $Result
EndFunc
Func StopWatchStart($sTag)
StopWatchStopPushTag($sTag)
$g_oStopWatches($sTag) = __TimerInit()
EndFunc
Func StopWatchLevel()
Local $iLevel = $g_oStopWatches("__CURRENT_TAG_LEVEL__")
If IsNumber($iLevel) = 0 Then $iLevel = 0
Return $iLevel
EndFunc
Func StopWatchStopPushTag($sTag)
Local $iLevel = StopWatchLevel()
$g_oStopWatches("__CURRENT_TAG__" & $iLevel) = $sTag
$g_oStopWatches("__CURRENT_TAG_LEVEL__") = $iLevel + 1
Return $iLevel
EndFunc
Func StopWatchStopPopTag($iNewLevel = Default)
Local $iLevel = StopWatchLevel() - 1
$g_oStopWatches("__CURRENT_TAG_LEVEL__") = $iLevel
Return $g_oStopWatches("__CURRENT_TAG__" & $iLevel)
EndFunc
Func StopWatchStopLog($sTag = Default, $iNewLevel = Default, $bLog = True)
Local $sTagLevel = StopWatchStopPopTag()
If $sTag = Default Then
$sTag = $sTagLevel
ElseIf $sTag <> $sTagLevel Then
SetLog("StopWatch Level mismatch: " & $sTag & " <> " & $sTagLevel, $COLOR_ERROR)
EndIf
Local $hTimer = $g_oStopWatches($sTag)
$g_oStopWatches.Remove($sTag)
SetLog($sTag & " Execution-time: " & __TimerDiff($hTimer))
If $iNewLevel <> Default Then
While StopWatchLevel() > $iNewLevel
StopWatchStopLog(Default, Default, $bLog)
WEnd
EndIf
EndFunc
Func StopWatchReturn($iNewLevel, $bLog = $g_bDebugFuncTime)
Local $iCurLevel = StopWatchLevel()
If $iNewLevel <> $iCurLevel Then StopWatchStopLog(Default, $iNewLevel, $bLog)
EndFunc
Global Enum $iOAER_bSet_ErrLine, $iOAER_bIn_Proc, $iOAER_bUse_StdOut, $iOAER_iPID, $iOAER_hErr_Callback, $iOAER_hErr_WinHook, $iOAER_sUserFunc, $iOAER_vUserParams, $iOAER_iCOMErrorNumber, $iOAER_sCOMErrorDesc, $iOAER_Total
Global $aOAER_DATA[$iOAER_Total]
Func _OnAutoItErrorRegister()
If $aOAER_DATA[$iOAER_hErr_WinHook] Then
Return
EndIf
$aOAER_DATA[$iOAER_hErr_CallBack] = DllCallbackRegister('__OAER_OnErrorCallback', 'int', 'int;int;int')
$aOAER_DATA[$iOAER_hErr_WinHook] = _WinAPI_SetWindowsHookEx($WH_CBT, DllCallbackGetPtr($aOAER_DATA[$iOAER_hErr_CallBack]), 0, _WinAPI_GetCurrentThreadId())
If Not $aOAER_DATA[$iOAER_hErr_WinHook] Then
DllCallbackFree($aOAER_DATA[$iOAER_hErr_CallBack])
Return 0
Else
Return 1
EndIf
EndFunc
Func _OnAutoItErrorUnRegister()
__OAER_OnExit()
EndFunc
Func __OAER_OnExit()
If $aOAER_DATA[$iOAER_hErr_WinHook] Then
_WinAPI_UnhookWindowsHookEx($aOAER_DATA[$iOAER_hErr_WinHook])
$aOAER_DATA[$iOAER_hErr_WinHook] = 0
EndIf
If $aOAER_DATA[$iOAER_hErr_CallBack] Then
DllCallbackFree($aOAER_DATA[$iOAER_hErr_CallBack])
$aOAER_DATA[$iOAER_hErr_CallBack] = 0
EndIf
EndFunc
Func __OAER_OnErrorCallback($nCode, $wParam, $lParam)
If $nCode < 0 Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
Switch $nCode
Case 5
If Not _WinAPI_FindWindow('#32770', 'AutoIt Error') Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
Local $hError_Wnd = HWnd($wParam)
Local $sError_Msg = StringRegExpReplace(ControlGetText($hError_Wnd, '', 'Static2'), '(?<!\r)\n', @CRLF)
If(_WinAPI_GetClassName($hError_Wnd) <> '#32770' And WinGetTitle($hError_Wnd) <> 'AutoIt Error') Or Not StringRegExp($sError_Msg, '(?is)^.*Line \d+\s+\(File "(.*?)"\):\s+.*Error: .*') Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
SetDebugLog($g_sBotTitle & " AutoIt Error: " & $sError_Msg, Default, True)
BotClose(Default, False)
_WinAPI_FatalAppExit($sError_Msg)
EndSwitch
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndFunc
Global $__BinaryCall_Kernel32dll = DllOpen('kernel32.dll')
Global $__BinaryCall_Msvcrtdll = DllOpen('msvcrt.dll')
Func AttackReport()
Static $iBonusLast = 0
Local $g_asLeagueDetailsShort = ""
Local $iCount
$iCount = 0
While _CheckPixel($aEndFightSceneAvl, True) = False
$iCount += 1
If _Sleep($DELAYATTACKREPORT1) Then Return
If $g_bDebugSetlog Then SetDebugLog("Waiting Attack Report Ready, " &($iCount / 2) & " Seconds.", $COLOR_DEBUG)
If $iCount > 30 Then ExitLoop
WEnd
If $iCount > 30 Then SetLog("End of Attack scene slow to appear, attack values my not be correct", $COLOR_INFO)
$iCount = 0
While getResourcesLoot(290, 289 + $g_iMidOffsetY) = ""
$iCount += 1
If _Sleep($DELAYATTACKREPORT1) Then Return
If $g_bDebugSetlog Then SetDebugLog("Waiting Attack Report Ready, " &($iCount / 2) & " Seconds.", $COLOR_DEBUG)
If $iCount > 20 Then ExitLoop
WEnd
If $iCount > 20 Then SetLog("End of Attack scene read gold error, attack values my not be correct", $COLOR_INFO)
If _ColorCheck(_GetPixelColor($aAtkRprtDECheck[0], $aAtkRprtDECheck[1], True), Hex($aAtkRprtDECheck[2], 6), $aAtkRprtDECheck[3]) Then
$g_iStatsLastAttack[$eLootGold] = getResourcesLoot(290, 289 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootElixir] = getResourcesLoot(290, 328 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootDarkElixir] = getResourcesLootDE(365, 365 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootTrophy] = getResourcesLootT(403, 402 + $g_iMidOffsetY)
If _ColorCheck(_GetPixelColor($aAtkRprtTrophyCheck[0], $aAtkRprtTrophyCheck[1], True), Hex($aAtkRprtTrophyCheck[2], 6), $aAtkRprtTrophyCheck[3]) Then
$g_iStatsLastAttack[$eLootTrophy] = -$g_iStatsLastAttack[$eLootTrophy]
EndIf
SetLog("Loot: [G]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [DE]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [T]: " & $g_iStatsLastAttack[$eLootTrophy], $COLOR_SUCCESS)
Else
$g_iStatsLastAttack[$eLootGold] = getResourcesLoot(290, 289 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootElixir] = getResourcesLoot(290, 328 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsLastAttack[$eLootTrophy] = getResourcesLootT(403, 365 + $g_iMidOffsetY)
If _ColorCheck(_GetPixelColor($aAtkRprtTrophyCheck[0], $aAtkRprtTrophyCheck[1], True), Hex($aAtkRprtTrophyCheck[2], 6), $aAtkRprtTrophyCheck[3]) Then
$g_iStatsLastAttack[$eLootTrophy] = -$g_iStatsLastAttack[$eLootTrophy]
EndIf
$g_iStatsLastAttack[$eLootDarkElixir] = ""
SetLog("Loot: [G]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [T]: " & $g_iStatsLastAttack[$eLootTrophy], $COLOR_SUCCESS)
EndIf
If $g_iStatsLastAttack[$eLootTrophy] >= 0 Then
$iBonusLast = Number(getResourcesBonusPerc(570, 309 + $g_iMidOffsetY))
If $iBonusLast > 0 Then
SetLog("Bonus Percentage: " & $iBonusLast & "%")
Local $iCalcMaxBonus = 0, $iCalcMaxBonusDark = 0
If _ColorCheck(_GetPixelColor($aAtkRprtDECheck2[0], $aAtkRprtDECheck2[1], True), Hex($aAtkRprtDECheck2[2], 6), $aAtkRprtDECheck2[3]) Then
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootGold] = getResourcesBonus(590, 340 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootGold] = StringReplace($g_iStatsBonusLast[$eLootGold], "+", "")
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootElixir] = getResourcesBonus(590, 371 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootElixir] = StringReplace($g_iStatsBonusLast[$eLootElixir], "+", "")
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootDarkElixir] = getResourcesBonus(621, 402 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootDarkElixir] = StringReplace($g_iStatsBonusLast[$eLootDarkElixir], "+", "")
If $iBonusLast = 100 Then
$iCalcMaxBonus = $g_iStatsBonusLast[$eLootGold]
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$eLootElixir]) & " [DE]: " & _NumberFormat($g_iStatsBonusLast[$eLootDarkElixir]), $COLOR_SUCCESS)
Else
$iCalcMaxBonus = Ceiling($g_iStatsBonusLast[$eLootGold] /($iBonusLast / 100))
$iCalcMaxBonusDark = Ceiling($g_iStatsBonusLast[$eLootDarkElixir] /($iBonusLast / 100))
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$eLootGold]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$eLootElixir]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [DE]: " & _NumberFormat($g_iStatsBonusLast[$eLootDarkElixir]) & " out of " & _NumberFormat($iCalcMaxBonusDark), $COLOR_SUCCESS)
EndIf
Else
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootGold] = getResourcesBonus(590, 340 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootGold] = StringReplace($g_iStatsBonusLast[$eLootGold], "+", "")
If _Sleep($DELAYATTACKREPORT2) Then Return
$g_iStatsBonusLast[$eLootElixir] = getResourcesBonus(590, 371 + $g_iMidOffsetY)
$g_iStatsBonusLast[$eLootElixir] = StringReplace($g_iStatsBonusLast[$eLootElixir], "+", "")
$g_iStatsBonusLast[$eLootDarkElixir] = 0
If $iBonusLast = 100 Then
$iCalcMaxBonus = $g_iStatsBonusLast[$eLootGold]
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$eLootElixir]), $COLOR_SUCCESS)
Else
$iCalcMaxBonus = Number($g_iStatsBonusLast[$eLootGold] /($iBonusLast / 100))
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$eLootGold]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$eLootElixir]) & " out of " & _NumberFormat($iCalcMaxBonus), $COLOR_SUCCESS)
EndIf
EndIf
$g_asLeagueDetailsShort = "--"
For $i = 1 To 21
If _Sleep($DELAYATTACKREPORT2) Then Return
If $g_asLeagueDetails[$i][0] = $iCalcMaxBonus Then
SetLog("Your league level is: " & $g_asLeagueDetails[$i][1])
$g_asLeagueDetailsShort = $g_asLeagueDetails[$i][3]
ExitLoop
EndIf
Next
Else
SetLog("No Bonus")
$g_asLeagueDetailsShort = "--"
If $g_aiCurrentLoot[$eLootTrophy] + $g_iStatsLastAttack[$eLootTrophy] >= 400 And $g_aiCurrentLoot[$eLootTrophy] + $g_iStatsLastAttack[$eLootTrophy] < 500 Then
SetLog("Your league level is: " & $g_asLeagueDetails[0][1])
$g_asLeagueDetailsShort = $g_asLeagueDetails[0][3]
EndIf
EndIf
GUICtrlSetData($g_hLblLeague, "")
If StringInStr($g_asLeagueDetailsShort, "1") > 1 Then
GUICtrlSetData($g_hLblLeague, "1")
ElseIf StringInStr($g_asLeagueDetailsShort, "2") > 1 Then
GUICtrlSetData($g_hLblLeague, "2")
ElseIf StringInStr($g_asLeagueDetailsShort, "3") > 1 Then
GUICtrlSetData($g_hLblLeague, "3")
EndIf
_GUI_Value_STATE("HIDE", $g_aGroupLeague)
If StringInStr($g_asLeagueDetailsShort, "B") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueBronze], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "S") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueSilver], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "G") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueGold], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "c", $STR_CASESENSE) > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueCrystal], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "M") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueMaster], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "C", $STR_CASESENSE) > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueChampion], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "T") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueTitan], $GUI_SHOW)
ElseIf StringInStr($g_asLeagueDetailsShort, "LE") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueLegend], $GUI_SHOW)
Else
GUICtrlSetState($g_ahPicLeague[$eLeagueUnranked], $GUI_SHOW)
EndIf
Else
$g_iStatsBonusLast[$eLootGold] = 0
$g_iStatsBonusLast[$eLootElixir] = 0
$g_iStatsBonusLast[$eLootDarkElixir] = 0
$g_asLeagueDetailsShort = "--"
EndIf
Local $starsearned = 0
If _ColorCheck(_GetPixelColor($aWonOneStarAtkRprt[0], $aWonOneStarAtkRprt[1], True), Hex($aWonOneStarAtkRprt[2], 6), $aWonOneStarAtkRprt[3]) Then $starsearned += 1
If _ColorCheck(_GetPixelColor($aWonTwoStarAtkRprt[0], $aWonTwoStarAtkRprt[1], True), Hex($aWonTwoStarAtkRprt[2], 6), $aWonTwoStarAtkRprt[3]) Then $starsearned += 1
If _ColorCheck(_GetPixelColor($aWonThreeStarAtkRprt[0], $aWonThreeStarAtkRprt[1], True), Hex($aWonThreeStarAtkRprt[2], 6), $aWonThreeStarAtkRprt[3]) Then $starsearned += 1
SetLog("Stars earned: " & $starsearned)
Local $AtkLogTxt
$AtkLogTxt = "  " & String($g_iCurAccount + 1) & "|" & _NowTime(4) & "|"
$AtkLogTxt &= StringFormat("%5d", $g_aiCurrentLoot[$eLootTrophy]) & "|"
$AtkLogTxt &= StringFormat("%3d", $g_iSearchCount) & "|"
$AtkLogTxt &= StringFormat("%2d", $g_iSidesAttack) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$eLootGold]) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$eLootElixir]) & "|"
$AtkLogTxt &= StringFormat("%4d", $g_iStatsLastAttack[$eLootDarkElixir]) & "|"
$AtkLogTxt &= StringFormat("%3d", $g_iStatsLastAttack[$eLootTrophy]) & "|"
$AtkLogTxt &= StringFormat("%1d", $starsearned) & "|"
$AtkLogTxt &= StringFormat("%3d", $g_iPercentageDamage) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iStatsBonusLast[$eLootGold]) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iStatsBonusLast[$eLootElixir]) & "|"
$AtkLogTxt &= StringFormat("%4d", $g_iStatsBonusLast[$eLootDarkElixir]) & "|"
$AtkLogTxt &= $g_asLeagueDetailsShort & "|"
$g_sTotalDamage = $g_iPercentageDamage
$g_sAttacksides = $g_iSidesAttack
$g_sLootGold = $g_iStatsLastAttack[$eLootGold]
$g_sLootElixir = $g_iStatsLastAttack[$eLootElixir]
$g_sLootDE = $g_iStatsLastAttack[$eLootDarkElixir]
$g_sLeague = $g_asLeagueDetailsShort
$g_sBonusGold = $g_iStatsBonusLast[$eLootGold]
$g_sBonusElixir = $g_iStatsBonusLast[$eLootElixir]
$g_sBonusDE = $g_iStatsBonusLast[$eLootDarkElixir]
$g_sStarsEarned = $starsearned
Local $AtkLogTxtExtend
$AtkLogTxtExtend = "|"
$AtkLogTxtExtend &= $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace & "|"
If Int($g_iStatsLastAttack[$eLootTrophy]) >= 0 Then
SetAtkLog($AtkLogTxt, $AtkLogTxtExtend, $COLOR_BLACK)
Else
SetAtkLog($AtkLogTxt, $AtkLogTxtExtend, $COLOR_ERROR)
EndIf
If $g_bDebugDeadBaseImage Then
setZombie($g_iStatsLastAttack[$eLootElixir])
EndIf
If $g_bShareAttackEnable Then
If(Number($g_iStatsLastAttack[$eLootGold]) >= Number($g_iShareMinGold)) And(Number($g_iStatsLastAttack[$eLootElixir]) >= Number($g_iShareMinElixir)) And(Number($g_iStatsLastAttack[$eLootDarkElixir]) >= Number($g_iShareMinDark)) Then
SetLog("Reached miminum Loot values... Share Replay")
$g_bShareAttackEnableNow = True
Else
SetLog("Below miminum Loot values... No Share Replay")
$g_bShareAttackEnableNow = False
EndIf
EndIf
If $g_iFirstAttack = 0 Then $g_iFirstAttack = 1
$g_iStatsTotalGain[$eLootGold] += $g_iStatsLastAttack[$eLootGold] + $g_iStatsBonusLast[$eLootGold]
$g_aiTotalGoldGain[$g_iMatchMode] += $g_iStatsLastAttack[$eLootGold] + $g_iStatsBonusLast[$eLootGold]
$g_iStatsTotalGain[$eLootElixir] += $g_iStatsLastAttack[$eLootElixir] + $g_iStatsBonusLast[$eLootElixir]
$g_aiTotalElixirGain[$g_iMatchMode] += $g_iStatsLastAttack[$eLootElixir] + $g_iStatsBonusLast[$eLootElixir]
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
$g_iStatsTotalGain[$eLootDarkElixir] += $g_iStatsLastAttack[$eLootDarkElixir] + $g_iStatsBonusLast[$eLootDarkElixir]
$g_aiTotalDarkGain[$g_iMatchMode] += $g_iStatsLastAttack[$eLootDarkElixir] + $g_iStatsBonusLast[$eLootDarkElixir]
EndIf
$g_iStatsTotalGain[$eLootTrophy] += $g_iStatsLastAttack[$eLootTrophy]
$g_aiTotalTrophyGain[$g_iMatchMode] += $g_iStatsLastAttack[$eLootTrophy]
If $g_iMatchMode = $TS Then
If $starsearned > 0 Then
$g_iNbrOfTHSnipeSuccess += 1
Else
$g_iNbrOfTHSnipeFails += 1
EndIf
EndIf
$g_aiAttackedVillageCount[$g_iMatchMode] += 1
UpdateStats()
UpdateSDataBase()
If ProfileSwitchAccountEnabled() Then
SetSwitchAccLog(" - Acc. " & $g_iCurAccount + 1 & ", Attack: " & $g_aiAttackedCount)
EndIf
$g_iActualTrainSkip = 0
$g_iPercentageDamage = 0
$g_iSidesAttack = 0
EndFunc
#ignorefunc __SQLite_Inline_Version, __SQLite_Inline_Modified
Global $__g_hDll_SQLite = 0
Global $__g_hDB_SQLite = 0
Global $__g_bUTF8ErrorMsg_SQLite = False
Global $__g_hPrintCallback_SQLite = __SQLite_ConsoleWrite
Global $__g_bSafeModeState_SQLite = True
Global $__g_ahDBs_SQLite[1] = ['']
Global $__g_ahQuerys_SQLite[1] = ['']
Global $__g_hMsvcrtDll_SQLite = 0
Global Const $SQLITE_OK = 0
Global Const $SQLITE_ERROR = 1
Global Const $SQLITE_ABORT = 4
Global Const $SQLITE_INTERRUPT = 9
Global Const $SQLITE_CORRUPT = 11
Global Const $SQLITE_MISMATCH = 20
Global Const $SQLITE_MISUSE = 21
Global Const $SQLITE_ROW = 100
Global Const $SQLITE_DONE = 101
Global Const $SQLITE_OPEN_READWRITE = 0x02
Global Const $SQLITE_OPEN_CREATE = 0x04
Global Const $SQLITE_ENCODING_UTF8 = 0
Global Const $SQLITE_TYPE_BLOB = 4
Global Const $SQLITE_TYPE_NULL = 5
Func _SQLite_Startup($sDll_Filename = "", $bUTF8ErrorMsg = False, $iForceLocal = 0, $hPrintCallback = $__g_hPrintCallback_SQLite)
If $sDll_Filename = Default Or $sDll_Filename = -1 Then $sDll_Filename = ""
If $hPrintCallback = Default Then $hPrintCallback = __SQLite_ConsoleWrite
$__g_hPrintCallback_SQLite = $hPrintCallback
If $bUTF8ErrorMsg = Default Then $bUTF8ErrorMsg = False
$__g_bUTF8ErrorMsg_SQLite = $bUTF8ErrorMsg
Local $sDll_Dirname = ""
If $sDll_Filename = "" Then $sDll_Filename = "sqlite3.dll"
If @AutoItX64 And(StringInStr($sDll_Filename, "_x64") = 0) Then $sDll_Filename = StringReplace($sDll_Filename, ".dll", "_x64.dll")
Local $iExt = 0
If $iForceLocal < 1 Then
Local $bDownloadDLL = True
Local $vInlineVersion = null
If @error Then $bDownloadDLL = False
If $iForceLocal = 0 Then
If __SQLite_VersCmp(@ScriptDir & "\" & $sDll_Filename, $vInlineVersion) = $SQLITE_OK Then
$sDll_Dirname = @ScriptDir & "\"
$bDownloadDLL = False
ElseIf __SQLite_VersCmp(@SystemDir & "\" & $sDll_Filename, $vInlineVersion) = $SQLITE_OK Then
$sDll_Dirname = @SystemDir & "\"
$bDownloadDLL = False
ElseIf __SQLite_VersCmp(@WindowsDir & "\" & $sDll_Filename, $vInlineVersion) = $SQLITE_OK Then
$sDll_Dirname = @WindowsDir & "\"
$bDownloadDLL = False
ElseIf __SQLite_VersCmp(@WorkingDir & "\" & $sDll_Filename, $vInlineVersion) = $SQLITE_OK Then
$sDll_Dirname = @WorkingDir & "\"
$bDownloadDLL = False
EndIf
EndIf
If $bDownloadDLL Then
If Not FileExists($sDll_Dirname & $sDll_Filename) Then
$sDll_Dirname = @LocalAppDataDir & "\AutoIt v3\SQLite"
EndIf
If $iForceLocal Then
$vInlineVersion = ""
Else
$vInlineVersion = "_" & $vInlineVersion
$iExt = 1
EndIf
$sDll_Filename = $sDll_Dirname & "\" & StringReplace($sDll_Filename, ".dll", "") & $vInlineVersion & ".dll"
EndIf
EndIf
Local $hDll = DllOpen($sDll_Filename)
If $hDll = -1 Then
$__g_hDll_SQLite = 0
Return SetError(1, $iExt, "")
Else
$__g_hDll_SQLite = $hDll
Return SetExtended($iExt, $sDll_Filename)
EndIf
EndFunc
Func _SQLite_Shutdown()
If $__g_hDll_SQLite > 0 Then DllClose($__g_hDll_SQLite)
$__g_hDll_SQLite = 0
If $__g_hMsvcrtDll_SQLite > 0 Then DllClose($__g_hMsvcrtDll_SQLite)
$__g_hMsvcrtDll_SQLite = 0
EndFunc
Func _SQLite_Open($sDatabase_Filename = Default, $iAccessMode = Default, $iEncoding = Default)
If Not $__g_hDll_SQLite Then Return SetError(3, $SQLITE_MISUSE, 0)
If $sDatabase_Filename = Default Or Not IsString($sDatabase_Filename) Then $sDatabase_Filename = ":memory:"
Local $tFilename = __SQLite_StringToUtf8Struct($sDatabase_Filename)
If @error Then Return SetError(2, @error, 0)
If $iAccessMode = Default Then $iAccessMode = BitOR($SQLITE_OPEN_READWRITE, $SQLITE_OPEN_CREATE)
Local $bOldBase = FileExists($sDatabase_Filename)
If $iEncoding = Default Then
$iEncoding = $SQLITE_ENCODING_UTF8
EndIf
Local $avRval = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_open_v2", "struct*", $tFilename, "ptr*", 0, "int", $iAccessMode, "ptr", 0)
If @error Then Return SetError(1, @error, 0)
If $avRval[0] <> $SQLITE_OK Then
__SQLite_ReportError($avRval[2], "_SQLite_Open")
_SQLite_Close($avRval[2])
Return SetError(-1, $avRval[0], 0)
EndIf
$__g_hDB_SQLite = $avRval[2]
__SQLite_hAdd($__g_ahDBs_SQLite, $avRval[2])
If Not $bOldBase Then
Local $aEncoding[3] = ["8", "16", "16be"]
_SQLite_Exec($avRval[2], 'PRAGMA encoding="UTF-' & $aEncoding[$iEncoding] & '";')
EndIf
Return SetExtended($avRval[0], $avRval[2])
EndFunc
Func _SQLite_Exec($hDB, $sSQL, $sCallBack = "")
If __SQLite_hChk($hDB, 2) Then Return SetError(@error, 0, $SQLITE_MISUSE)
If $sCallBack <> "" Then
Local $iRows, $iColumns
Local $aResult = "SQLITE_CALLBACK:" & $sCallBack
Local $iRval = _SQLite_GetTable2d($hDB, $sSQL, $aResult, $iRows, $iColumns)
If @error Then Return SetError(3, @error, $iRval)
Return $iRval
EndIf
Local $tSQL8 = __SQLite_StringToUtf8Struct($sSQL)
If @error Then Return SetError(4, @error, 0)
Local $avRval = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_exec", "ptr", $hDB, "struct*", $tSQL8, "ptr", 0, "ptr", 0, "ptr*", 0)
If @error Then Return SetError(1, @error, $SQLITE_MISUSE)
__SQLite_szFree($avRval[5])
If $avRval[0] <> $SQLITE_OK Then
__SQLite_ReportError($hDB, "_SQLite_Exec", $sSQL)
SetError(-1)
EndIf
Return $avRval[0]
EndFunc
Func _SQLite_ErrMsg($hDB = -1)
If __SQLite_hChk($hDB, 2) Then Return SetError(@error, @extended, "Library used incorrectly")
Local $r = DllCall($__g_hDll_SQLite, "wstr:cdecl", "sqlite3_errmsg16", "ptr", $hDB)
If @error Then
__SQLite_ReportError($hDB, "_SQLite_ErrMsg", Default, "Call Failed")
Return SetError(1, @error, "Library used incorrectly")
EndIf
Return $r[0]
EndFunc
Func _SQLite_GetTable2d($hDB, $sSQL, ByRef $aResult, ByRef $iRows, ByRef $iColumns, $iCharSize = -1, $bSwichDimensions = False)
If __SQLite_hChk($hDB, 1) Then Return SetError(@error, 0, $SQLITE_MISUSE)
If $iCharSize = "" Or $iCharSize < 1 Or $iCharSize = Default Then $iCharSize = -1
Local $sCallBack = "", $bCallBack = False
If IsString($aResult) Then
If StringLeft($aResult, 16) = "SQLITE_CALLBACK:" Then
$sCallBack = StringTrimLeft($aResult, 16)
$bCallBack = True
EndIf
EndIf
$aResult = ''
If $bSwichDimensions = Default Then $bSwichDimensions = False
Local $hQuery
Local $r = _SQLite_Query($hDB, $sSQL, $hQuery)
If @error Then Return SetError(2, @error, $r)
If $r <> $SQLITE_OK Then
__SQLite_ReportError($hDB, "_SQLite_GetTable2d", $sSQL)
_SQLite_QueryFinalize($hQuery)
Return SetError(-1, 0, $r)
EndIf
$iRows = 0
Local $iRval_Step, $iError
While True
$iRval_Step = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_step", "ptr", $hQuery)
If @error Then
$iError = @error
_SQLite_QueryFinalize($hQuery)
Return SetError(3, $iError, $SQLITE_MISUSE)
EndIf
Switch $iRval_Step[0]
Case $SQLITE_ROW
$iRows += 1
Case $SQLITE_DONE
ExitLoop
Case Else
_SQLite_QueryFinalize($hQuery)
Return SetError(3, $iError, $iRval_Step[0])
EndSwitch
WEnd
Local $iRet = _SQLite_QueryReset($hQuery)
If @error Then
$iError = @error
_SQLite_QueryFinalize($hQuery)
Return SetError(4, $iError, $iRet)
EndIf
Local $aDataRow
$r = _SQLite_FetchNames($hQuery, $aDataRow)
If @error Then
$iError = @error
_SQLite_QueryFinalize($hQuery)
Return SetError(5, $iError, $r)
EndIf
$iColumns = UBound($aDataRow)
If $iColumns <= 0 Then
_SQLite_QueryFinalize($hQuery)
Return SetError(-1, 0, $SQLITE_DONE)
EndIf
If Not $bCallBack Then
If $bSwichDimensions Then
Dim $aResult[$iColumns][$iRows + 1]
For $i = 0 To $iColumns - 1
If $iCharSize > 0 Then
$aDataRow[$i] = StringLeft($aDataRow[$i], $iCharSize)
EndIf
$aResult[$i][0] = $aDataRow[$i]
Next
Else
Dim $aResult[$iRows + 1][$iColumns]
For $i = 0 To $iColumns - 1
If $iCharSize > 0 Then
$aDataRow[$i] = StringLeft($aDataRow[$i], $iCharSize)
EndIf
$aResult[0][$i] = $aDataRow[$i]
Next
EndIf
Else
Local $iCbRval
#Au3Stripper_Off
$iCbRval = Call($sCallBack, $aDataRow)
#Au3Stripper_On
If $iCbRval = $SQLITE_ABORT Or $iCbRval = $SQLITE_INTERRUPT Or @error Then
$iError = @error
_SQLite_QueryFinalize($hQuery)
Return SetError(7, $iError, $iCbRval)
EndIf
EndIf
If $iRows > 0 Then
For $i = 1 To $iRows
$r = _SQLite_FetchData($hQuery, $aDataRow, 0, 0, $iColumns)
If @error Then
$iError = @error
_SQLite_QueryFinalize($hQuery)
Return SetError(6, $iError, $r)
EndIf
If $bCallBack Then
#Au3Stripper_Off
$iCbRval = Call($sCallBack, $aDataRow)
#Au3Stripper_On
If $iCbRval = $SQLITE_ABORT Or $iCbRval = $SQLITE_INTERRUPT Or @error Then
$iError = @error
_SQLite_QueryFinalize($hQuery)
Return SetError(7, $iError, $iCbRval)
EndIf
Else
For $j = 0 To $iColumns - 1
If $iCharSize > 0 Then
$aDataRow[$j] = StringLeft($aDataRow[$j], $iCharSize)
EndIf
If $bSwichDimensions Then
$aResult[$j][$i] = $aDataRow[$j]
Else
$aResult[$i][$j] = $aDataRow[$j]
EndIf
Next
EndIf
Next
EndIf
Return(_SQLite_QueryFinalize($hQuery))
EndFunc
Func _SQLite_Query($hDB, $sSQL, ByRef $hQuery)
If __SQLite_hChk($hDB, 2) Then Return SetError(@error, 0, $SQLITE_MISUSE)
Local $iRval = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_prepare16_v2", "ptr", $hDB, "wstr", $sSQL, "int", -1, "ptr*", 0, "ptr*", 0)
If @error Then Return SetError(1, @error, $SQLITE_MISUSE)
If $iRval[0] <> $SQLITE_OK Then
__SQLite_ReportError($hDB, "_SQLite_Query", $sSQL)
Return SetError(-1, 0, $iRval[0])
EndIf
$hQuery = $iRval[4]
__SQLite_hAdd($__g_ahQuerys_SQLite, $iRval[4])
Return $iRval[0]
EndFunc
Func _SQLite_FetchData($hQuery, ByRef $aRow, $bBinary = False, $bDoNotFinalize = False, $iColumns = 0)
Dim $aRow[1]
If __SQLite_hChk($hQuery, 7, False) Then Return SetError(@error, 0, $SQLITE_MISUSE)
If $bBinary = Default Then $bBinary = False
If $bDoNotFinalize = Default Then $bDoNotFinalize = False
Local $iRval_Step = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_step", "ptr", $hQuery)
If @error Then Return SetError(1, @error, $SQLITE_MISUSE)
If $iRval_Step[0] <> $SQLITE_ROW Then
If $bDoNotFinalize = False And $iRval_Step[0] = $SQLITE_DONE Then
_SQLite_QueryFinalize($hQuery)
EndIf
Return SetError(-1, 0, $iRval_Step[0])
EndIf
If Not $iColumns Then
Local $iRval_ColCnt = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_data_count", "ptr", $hQuery)
If @error Then Return SetError(2, @error, $SQLITE_MISUSE)
If $iRval_ColCnt[0] <= 0 Then Return SetError(-1, 0, $SQLITE_DONE)
$iColumns = $iRval_ColCnt[0]
EndIf
ReDim $aRow[$iColumns]
For $i = 0 To $iColumns - 1
Local $iRval_coltype = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_column_type", "ptr", $hQuery, "int", $i)
If @error Then Return SetError(4, @error, $SQLITE_MISUSE)
If $iRval_coltype[0] = $SQLITE_TYPE_NULL Then
$aRow[$i] = ""
ContinueLoop
EndIf
If(Not $bBinary) And($iRval_coltype[0] <> $SQLITE_TYPE_BLOB) Then
Local $sRval = DllCall($__g_hDll_SQLite, "wstr:cdecl", "sqlite3_column_text16", "ptr", $hQuery, "int", $i)
If @error Then Return SetError(3, @error, $SQLITE_MISUSE)
$aRow[$i] = $sRval[0]
Else
Local $vResult = DllCall($__g_hDll_SQLite, "ptr:cdecl", "sqlite3_column_blob", "ptr", $hQuery, "int", $i)
If @error Then Return SetError(6, @error, $SQLITE_MISUSE)
Local $iColBytes = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_column_bytes", "ptr", $hQuery, "int", $i)
If @error Then Return SetError(5, @error, $SQLITE_MISUSE)
Local $tResultStruct = DllStructCreate("byte[" & $iColBytes[0] & "]", $vResult[0])
$aRow[$i] = Binary(DllStructGetData($tResultStruct, 1))
EndIf
Next
Return $SQLITE_OK
EndFunc
Func _SQLite_Close($hDB = -1)
If __SQLite_hChk($hDB, 2) Then Return SetError(@error, 0, $SQLITE_MISUSE)
Local $iRval = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_close", "ptr", $hDB)
If @error Then Return SetError(1, @error, $SQLITE_MISUSE)
If $iRval[0] <> $SQLITE_OK Then
__SQLite_ReportError($hDB, "_SQLite_Close")
Return SetError(-1, 0, $iRval[0])
EndIf
$__g_hDB_SQLite = 0
__SQLite_hDel($__g_ahDBs_SQLite, $hDB)
Return $iRval[0]
EndFunc
Func _SQLite_QueryFinalize($hQuery)
If __SQLite_hChk($hQuery, 2, False) Then Return SetError(@error, 0, $SQLITE_MISUSE)
Local $avRval = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_finalize", "ptr", $hQuery)
If @error Then Return SetError(1, @error, $SQLITE_MISUSE)
__SQLite_hDel($__g_ahQuerys_SQLite, $hQuery)
If $avRval[0] <> $SQLITE_OK Then SetError(-1)
Return $avRval[0]
EndFunc
Func _SQLite_QueryReset($hQuery)
If __SQLite_hChk($hQuery, 2, False) Then Return SetError(@error, 0, $SQLITE_MISUSE)
Local $avRval = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_reset", "ptr", $hQuery)
If @error Then Return SetError(1, @error, $SQLITE_MISUSE)
If $avRval[0] <> $SQLITE_OK Then SetError(-1)
Return $avRval[0]
EndFunc
Func _SQLite_FetchNames($hQuery, ByRef $aNames)
Dim $aNames[1]
If __SQLite_hChk($hQuery, 3, False) Then Return SetError(@error, 0, $SQLITE_MISUSE)
Local $avDataCnt = DllCall($__g_hDll_SQLite, "int:cdecl", "sqlite3_column_count", "ptr", $hQuery)
If @error Then Return SetError(1, @error, $SQLITE_MISUSE)
If $avDataCnt[0] <= 0 Then Return SetError(-1, 0, $SQLITE_DONE)
ReDim $aNames[$avDataCnt[0]]
Local $avColName
For $iCnt = 0 To $avDataCnt[0] - 1
$avColName = DllCall($__g_hDll_SQLite, "wstr:cdecl", "sqlite3_column_name16", "ptr", $hQuery, "int", $iCnt)
If @error Then Return SetError(2, @error, $SQLITE_MISUSE)
$aNames[$iCnt] = $avColName[0]
Next
Return $SQLITE_OK
EndFunc
Func __SQLite_hChk(ByRef $hGeneric, $nError, $bDB = True)
If $__g_hDll_SQLite = 0 Then Return SetError(1, $SQLITE_MISUSE, $SQLITE_MISUSE)
If $hGeneric = -1 Or $hGeneric = "" Or $hGeneric = Default Then
If Not $bDB Then Return SetError($nError, 0, $SQLITE_ERROR)
$hGeneric = $__g_hDB_SQLite
EndIf
If Not $__g_bSafeModeState_SQLite Then Return $SQLITE_OK
If $bDB Then
If _ArraySearch($__g_ahDBs_SQLite, $hGeneric) > 0 Then Return $SQLITE_OK
Else
If _ArraySearch($__g_ahQuerys_SQLite, $hGeneric) > 0 Then Return $SQLITE_OK
EndIf
Return SetError($nError, 0, $SQLITE_ERROR)
EndFunc
Func __SQLite_hAdd(ByRef $ahLists, $hGeneric)
_ArrayAdd($ahLists, $hGeneric)
EndFunc
Func __SQLite_hDel(ByRef $ahLists, $hGeneric)
Local $iElement = _ArraySearch($ahLists, $hGeneric)
If $iElement > 0 Then _ArrayDelete($ahLists, $iElement)
EndFunc
Func __SQLite_VersCmp($sFile, $sVersion)
Local $avRval = DllCall($sFile, "str:cdecl", "sqlite3_libversion")
If @error Then Return $SQLITE_CORRUPT
Local $sFileVersion = StringSplit($avRval[0], ".")
Local $iMaintVersion = 0
If $sFileVersion[0] = 4 Then $iMaintVersion = $sFileVersion[4]
$sFileVersion =(($sFileVersion[1] * 1000 + $sFileVersion[2]) * 1000 + $sFileVersion[3]) * 100 + $iMaintVersion
If $sVersion < 10000000 Then $sVersion = $sVersion * 100
If $sFileVersion >= $sVersion Then Return $SQLITE_OK
Return $SQLITE_MISMATCH
EndFunc
Func __SQLite_ReportError($hDB, $sFunction, $sQuery = Default, $sError = Default, $vReturnValue = Default, $iCurErr = @error, $iCurExt = @extended)
If @Compiled Then Return SetError($iCurErr, $iCurExt)
If $sError = Default Then $sError = _SQLite_ErrMsg($hDB)
If $sQuery = Default Then $sQuery = ""
Local $sOut = "!   SQLite.au3 Error" & @CRLF
$sOut &= "--> Function: " & $sFunction & @CRLF
If $sQuery <> "" Then $sOut &= "--> Query:    " & $sQuery & @CRLF
$sOut &= "--> Error:    " & $sError & @CRLF
__SQLite_Print($sOut & @CRLF)
If Not($vReturnValue = Default) Then Return SetError($iCurErr, $iCurExt, $vReturnValue)
Return SetError($iCurErr, $iCurExt)
EndFunc
Func __SQLite_szFree($pPtr, $iCurErr = @error)
If $pPtr <> 0 Then DllCall($__g_hDll_SQLite, "none:cdecl", "sqlite3_free", "ptr", $pPtr)
SetError($iCurErr)
EndFunc
Func __SQLite_StringToUtf8Struct($sString)
Local $aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", 65001, "dword", 0, "wstr", $sString, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
If @error Then Return SetError(1, @error, "")
Local $tText = DllStructCreate("char[" & $aResult[0] & "]")
$aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", 65001, "dword", 0, "wstr", $sString, "int", -1, "struct*", $tText, "int", $aResult[0], "ptr", 0, "ptr", 0)
If @error Then Return SetError(2, @error, "")
Return $tText
EndFunc
Func __SQLite_ConsoleWrite($sText)
ConsoleWrite($sText)
EndFunc
Func __SQLite_Print($sText)
If IsFunc($__g_hPrintCallback_SQLite) Then
If $__g_bUTF8ErrorMsg_SQLite Then
Local $tStr8 = __SQLite_StringToUtf8Struct($sText)
$__g_hPrintCallback_SQLite(DllStructGetData($tStr8, 1))
Else
$__g_hPrintCallback_SQLite($sText)
EndIf
EndIf
EndFunc
Func OpenSqlite()
If Not $g_bUseStatistics Then Return
Local $sLocalSQLiteDll = @ScriptDir & "\lib\sqlite3.dll"
Local $sSQLite = _SQLite_Startup($sLocalSQLiteDll, False, 1)
If @error Then
MsgBox($MB_SYSTEMMODAL, "SQLite Error", "SQLite3.dll Can't be Loaded!", 10)
Return False
EndIf
$g_hSQLiteDB = _SQLite_Open(@ScriptDir & "\AttackStats.sqlite3")
If @error Then
MsgBox($MB_SYSTEMMODAL, "SQLite DB", "Can't open or create a Database!", 10)
Return False
EndIf
Return True
EndFunc
Func CloseSqlite()
_SQLite_Close($g_hSQLiteDB)
_SQLite_Shutdown()
EndFunc
Func CreaTableDB()
If Not $g_bUseStatistics Then Return
If OpenSqlite() Then
Local $sTableCreation = "CREATE TABLE IF NOT EXISTS `" & $g_sTabletName & "` (`Attack` INTEGER PRIMARY KEY AUTOINCREMENT, " & "'Date' TEXT NOT NULL, " & "'Profilename' TEXT NOT NULL, " & "'SearchCount' TEXT NOT NULL, " & "'Attacksides' TEXT NOT NULL, " & "'ResIN' TEXT NOT NULL, " & "'ResOUT' TEXT NOT NULL, " & "'ResBySide' TEXT NOT NULL, " & "'OppThlevel' TEXT NOT NULL, " & "'OppGold' TEXT NOT NULL, " & "'OppElixir' TEXT NOT NULL, " & "'OppDE' TEXT NOT NULL, " & "'OppTrophies' TEXT NOT NULL, " & "'PerDamage' TEXT NOT NULL, " & "'PerResources' TEXT NOT NULL, " & "'LootGold' TEXT NOT NULL, " & "'LootElixir' TEXT NOT NULL, " & "'LootDE' TEXT NOT NULL, " & "'League' TEXT NOT NULL, " & "'BonusGold' TEXT NOT NULL, " & "'BonusElixir' TEXT NOT NULL, " & "'BonusDE' TEXT NOT NULL)"
_SQLite_Exec($g_hSQLiteDB, $sTableCreation)
Else
Return
EndIf
CloseSqlite()
EndFunc
Func UpdateSDataBase()
If Not $g_bUseStatistics Then Return
If OpenSqlite() Then
UpdateVarStats()
Local $sInsereRow = "INSERT INTO " & $g_sTabletName & " (Date,Profilename,SearchCount,Attacksides,ResIN,ResOUT,ResBySide,OppThlevel,OppGold,OppElixir,OppDE,OppTrophies,PerDamage,PerResources,LootGold,LootElixir,LootDE,League,BonusGold,BonusElixir,BonusDE)" & " VALUES ('" & $g_sDate & "','" & $g_sProfilename & "','" & $g_sSearchCount & "','" & $g_sAttacksides & "','" & $g_sResourcesIN & "','" & $g_sResourcesOUT & "','" & $g_sResBySide & "','" & $g_sOppThlevel & "','" & $g_sOppGold & "','" & $g_sOppElixir & "','" & $g_sOppDE & "','" & $g_sOppTrophies & "','" & $g_sTotalDamage & "','" & $g_sPercentagesResources & "','" & $g_sLootGold & "','" & $g_sLootElixir & "','" & $g_sLootDE & "','" & $g_sLeague & "','" & $g_sBonusGold & "','" & $g_sBonusElixir & "','" & $g_sBonusDE & "');"
_SQLite_Exec($g_hSQLiteDB, $sInsereRow)
Else
Return
EndIf
CloseSqlite()
EndFunc
Func ExportDataBase($bLog = True)
If Not $g_bUseStatistics Then Return
If OpenSqlite() Then
Local $iColumns, $aResult, $iRows
Local $StrinForm[22] = ["%6s", "%20s", "%12s", "%12s", "%12s", "%7s", "%7s", "%10s", "%11s", "%8s", "%11s", "%7s", "%12s", "%10s", "%13s", "%9s", "%11s", "%7s", "%7s", "%10s", "%12s", "%8s"]
Local $filePath = @ScriptDir & "\SQLite_exportedData.csv"
Local $iRval = _SQLite_GetTable2d($g_hSQLiteDB, "Select * From " & $g_sTabletName, $aResult, $iRows, $iColumns)
If FileExists($filePath) Then FileDelete($filePath)
ConsoleWrite("Rows: " & $iRows & " Columns: " & $iColumns & @CRLF)
Local $header = "Attack;Date;Profilename;SearchCount;Attacksides;ResIN;ResOUT;ResBySide;OppThlevel;OppGold;OppElixir;OppDE;OppTrophies;PerDamage;PerResources;LootGold;LootElixir;LootDE;League;BonusGold;BonusElixir;BonusDE"
local $aHeader = StringSplit($header , ";", $STR_NOCOUNT)
$header = ""
For $i = 0 to Ubound($header) - 1
$header &= StringFormat($StrinForm[$i], $aHeader[$i]) & ";"
Next
StringTrimRight($header, 1)
FileWriteLine($filePath, $header)
For $iR = 0 To $iRows
Local $sText = ""
For $iC = 0 To $iColumns - 1
$sText &= StringFormat($StrinForm[$iC], $aResult[$iR][$iC])& ";"
Next
StringTrimRight($sText, 1)
FileWriteLine($filePath, $sText)
If $bLog Then ConsoleWrite($sText & @CRLF)
Next
Else
Return
EndIf
CloseSqlite()
EndFunc
Func UpdateVarStats()
$g_sDate = _Date_Time_GetLocalTime()
$g_sDate = _Date_Time_SystemTimeToDateTimeStr($g_sDate)
$g_sProfilename = $g_sProfileCurrentName = "" ? $g_asProfileName[$g_iNextAccount] : $g_sProfileCurrentName
$g_sOppThlevel = "TH" & $g_iSearchTH
$g_sTotalDamage = $g_sTotalDamage & "%"
Local $totalresources = Int($g_sOppGold) + Int($g_sOppElixir) + Int($g_sOppDE)
Local $totalgrab = Int($g_sLootGold) + Int($g_sLootElixir) + Int($g_sLootDE)
$g_sPercentagesResources = StringFormat("%.2f",(($totalgrab / $totalresources) * 100)) & "%"
EndFunc
Global $g_abSaveiChkTimeStopAtk[$g_iModeCount], $g_abSaveiChkTimeStopAtk2[$g_iModeCount], $g_abSaveichkEndOneStar[$g_iModeCount], $g_abSaveichkEndTwoStars[$g_iModeCount]
Global $g_iBuildingLoc = 0, $g_iBuildingLocX = 0, $g_iBuildingLocY = 0
Func GetBuildingEdge($TypeBuilding = $eSideBuildingDES)
Local $TypeBuildingName
BuildingXY($TypeBuilding)
Switch $TypeBuilding
Case $eSideBuildingDES
$TypeBuildingName = "DE Storage"
Case $eSideBuildingTH
$TypeBuildingName = "TownHall"
EndSwitch
If $g_iBuildingLoc = 1 Then
If($g_iBuildingLocX = 430) And($g_iBuildingLocY = 313) Then
SetLog($TypeBuildingName & " Located in Middle... Attacking Random Side", $COLOR_INFO)
$g_iBuildingEdge =(Random(Round(0, 3)))
ElseIf($g_iBuildingLocX >= 430) And($g_iBuildingLocY >= 313) Then
SetLog($TypeBuildingName & " Located Bottom Right... Attacking Bottom Right", $COLOR_INFO)
$g_iBuildingEdge = 0
ElseIf($g_iBuildingLocX > 430) And($g_iBuildingLocY < 313) Then
SetLog($TypeBuildingName & " Located Top Right... Attacking Top Right", $COLOR_INFO)
$g_iBuildingEdge = 3
ElseIf($g_iBuildingLocX <= 430) And($g_iBuildingLocY <= 313) Then
SetLog($TypeBuildingName & " Located Top Left... Attacking Top Left", $COLOR_INFO)
$g_iBuildingEdge = 1
ElseIf($g_iBuildingLocX < 430) And($g_iBuildingLocY > 313) Then
SetLog($TypeBuildingName & " Located Bottom Left... Attacking Bottom Left", $COLOR_INFO)
$g_iBuildingEdge = 2
EndIf
ElseIf $g_iBuildingLoc = 0 Then
SetLog($TypeBuildingName & " Not Located... Attacking Random Side", $COLOR_INFO)
$g_iBuildingEdge =(Random(Round(0, 3)))
EndIf
EndFunc
Func BuildingXY($TypeBuilding = $eSideBuildingDES)
Local $TypeBuildingName
_CaptureRegion2(230, 170, 630, 440)
Switch $TypeBuilding
Case $eSideBuildingDES
$TypeBuildingName = "DE Storage"
$g_iBuildingToLoc = GetLocationDarkElixirStorage()
Case $eSideBuildingTH
$TypeBuildingName = "TownHall"
$g_iBuildingToLoc = GetLocationTownHall()
EndSwitch
Local $pixel
If(UBound($g_iBuildingToLoc) > 1) Then
Local $centerPixel[2] = [430, 313]
Local $arrPixelCloser = _FindPixelCloser($g_iBuildingToLoc, $centerPixel, 1)
$pixel = $arrPixelCloser[0]
ElseIf(UBound($g_iBuildingToLoc) > 0) Then
$pixel = $g_iBuildingToLoc[0]
Else
$pixel = -1
EndIf
If $pixel = -1 Then
$g_iBuildingLoc = 0
SetLog(" == " & $TypeBuildingName & " Not Found ==")
Else
$pixel[0] += 230
$pixel[1] += 170
SetLog("== " & $TypeBuildingName & " : [" & $pixel[0] & "," & $pixel[1] & "] ==", $COLOR_INFO)
If _Sleep(1000) Then Return False
$g_iBuildingLocX = $pixel[0]
$g_iBuildingLocY = $pixel[1]
$g_iBuildingLoc = 1
EndIf
EndFunc
Func DELow()
Local $DarkE = ""
Local $Dchk = 0
While $DarkE = ""
$DarkE = getDarkElixirVillageSearch(48, 126)
$Dchk += 1
If _Sleep(50) Then Return
If $Dchk >= 10 Then
SetLog("Can't find De", $COLOR_ERROR)
Return False
EndIf
WEnd
If Number($DarkE) <(Number($g_iSearchDark) *(Number($g_iDESideEndMin) / 100)) Then
If _Sleep(50) Then Return
$DarkE = getDarkElixirVillageSearch(48, 126)
If _Sleep(50) Then Return
If Number($DarkE) <(Number($g_iSearchDark) *(Number($g_iDESideEndMin) / 100)) Then
If $g_bDESideEndAQWeak And $g_bDropQueen And Not $g_bCheckQueenPower Then
If $g_iActivateQueen = 0 Then
$g_iDarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and AQ health Low. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
ElseIf Not _ColorCheck(_GetPixelColor(68 +(72 * $g_iQueenSlot), 572, True), Hex(0x72F50B, 6), 120, "Heroes") Then
$g_iDarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and AQ health Low. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
If $g_bDESideEndBKWeak And $g_bDropKing And Not $g_bCheckKingPower Then
If $g_iActivateKing = 0 Then
$g_iDarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and BK health Low. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
ElseIf Not _ColorCheck(_GetPixelColor(68 +(72 * $g_iKingSlot), 572, True), Hex(0x4FD404, 6), 120, "Heroes") Then
$g_iDarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and BK health Low. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
If $g_bDESideEndOneStar Then
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) Then
SetLog("Low De. De = ( " & $DarkE & " ) and 1 star achieved. Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
$g_iDarkLow = 1
Return False
Else
SetLog("Low De. ( " & $DarkE & " ) Waiting for 1 star", $COLOR_SUCCESS)
$g_iDarkLow = 2
Return False
EndIf
EndIf
If Not $g_bDESideEndAQWeak And Not $g_bDESideEndBKWeak And Not $g_bDESideEndOneStar Then
SetLog("Low De. De = ( " & $DarkE & " ). Return to protect Heroes.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
Else
$g_iDarkLow = 0
EndIf
EndFunc
Func SaveandDisableEBO()
$g_abSaveichkEndOneStar[$g_iMatchMode] = $g_abStopAtkOneStar[$g_iMatchMode]
$g_abSaveichkEndTwoStars[$g_iMatchMode] = $g_abStopAtkTwoStars[$g_iMatchMode]
$g_abSaveiChkTimeStopAtk[$g_iMatchMode] = $g_abStopAtkNoLoot1Enable[$g_iMatchMode]
$g_abSaveiChkTimeStopAtk2[$g_iMatchMode] = $g_abStopAtkNoLoot2Enable[$g_iMatchMode]
$g_abStopAtkOneStar[$g_iMatchMode] = 0
$g_abStopAtkTwoStars[$g_iMatchMode] = 0
$g_abStopAtkNoLoot1Enable[$g_iMatchMode] = 0
$g_abStopAtkNoLoot2Enable[$g_iMatchMode] = 0
EndFunc
Func RevertEBO()
$g_abStopAtkOneStar[$g_iMatchMode] = $g_abSaveichkEndOneStar
$g_abStopAtkTwoStars[$g_iMatchMode] = $g_abSaveichkEndTwoStars
$g_abStopAtkNoLoot1Enable[$g_iMatchMode] = $g_abSaveiChkTimeStopAtk
$g_abStopAtkNoLoot2Enable[$g_iMatchMode] = $g_abSaveiChkTimeStopAtk2
EndFunc
Func GoldElixirChangeThSnipes($x)
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
SetLog("Checking if the Gold6Elixir are changing...", $COLOR_INFO)
For $y = 0 To $x
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
Local $iBegin = __TimerInit()
While __TimerDiff($iBegin) < 2000
CheckHeroesHealth()
If $g_bCheckKingPower Or $g_bCheckQueenPower Then
If _Sleep($DELAYGOLDELIXIRCHANGE1) Then Return
Else
If _Sleep($DELAYGOLDELIXIRCHANGE2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($DELAYGOLDELIXIRCHANGE1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
If $Gold2 <> "" Or $Elixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
EndIf
If($Gold2 = "" And $Elixir2 = "") Then
If _Sleep($DELAYGOLDELIXIRCHANGE1) Then Return
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" Then
SetLog("Battle has finished", $COLOR_SUCCESS)
Return True
ExitLoop
EndIf
EndIf
WEnd
If($Gold1 = $Gold2 And $Elixir1 = $Elixir2) Or($Gold2 = "" And $Elixir2 = "") Then
ExitLoop
Else
SetLog("Gold & Elixir change detected, waiting...", $COLOR_SUCCESS)
ContinueLoop
EndIf
$x += 1
If Sleep(1000) Then Return
Return False
Next
EndFunc
Func GoldElixirChangeEBO()
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
Local $DarkElixir1, $DarkElixir2
Local $DarkElixirChange
Local $Trophies
Local $txtDiff
Local $exitOneStar = 0, $exitTwoStars = 0
Local $Damage, $CurDamage
$g_iDarkLow = 0
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
$Trophies = getTrophyVillageSearch(48, 69 + 99)
$Damage = getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)
If Number($Damage) > Number($g_iPercentageDamage) Then $g_iPercentageDamage = Number($Damage)
If $Trophies <> "" Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO1) Then Return
$DarkElixir1 = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir1 = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
Local $x = $g_aiStopAtkNoLoot1Time[$g_iMatchMode] * 1000, $y = $g_aiStopAtkNoLoot2Time[$g_iMatchMode] * 1000, $z, $w = $g_aiStopAtkPctNoChangeTime[$g_iMatchMode] * 1000
If Number($Gold1) < $g_aiStopAtkNoLoot2MinGold[$g_iMatchMode] And Number($Elixir1) < $g_aiStopAtkNoLoot2MinElixir[$g_iMatchMode] And Number($DarkElixir1) < $g_aiStopAtkNoLoot2MinDark[$g_iMatchMode] And $g_abStopAtkNoLoot2Enable[$g_iMatchMode] Then
$z = $y
ElseIf $Damage <> "" And $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] Then
$z = $w
Else
If $g_abStopAtkNoLoot1Enable[$g_iMatchMode] Then
$z = $x
Else
$z = AttackRemainingTime()
EndIf
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And _CheckPixel($aWonTwoStar, True) Then
SetLog("Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
$z = 0
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And _CheckPixel($aWonOneStar, True) Then
SetLog("One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
$z = 0
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
SetLog("Overall Damage above " & Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]), $COLOR_SUCCESS)
$g_iPercentageDamage = Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY))
$z = 0
EndIf
Local $NoResourceOCR = False
Local $iBegin = __TimerInit()
Local $iSuspendAndroidTimeOffset = SuspendAndroidTime()
SetDebugLog("GoldElixirChangeEBO: Start waiting for battle end, Wait: " & $z & ", Offset: " & $iSuspendAndroidTimeOffset)
Local $iTime = 0
Local $bOneLoop = True
While $bOneLoop Or($iTime < $z And $z > 0 And $iTime >= 0)
$bOneLoop = False
CheckHeroesHealth()
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 And $g_bDESideEndEnable Then
If $g_bDropQueen Or $g_bDropKing Then DELow()
If $g_iDarkLow = 1 Then ExitLoop
EndIf
If $g_bCheckKingPower Or $g_bCheckQueenPower Or $g_iDarkLow = 2 Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO1) Then Return
Else
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
$Trophies = getTrophyVillageSearch(48, 69 + 99)
CheckHeroesHealth()
If $Trophies <> "" Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO1) Then Return
$DarkElixir2 = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir2 = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
$CurDamage = getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)
CheckHeroesHealth()
$txtDiff = Round(($z -(__TimerDiff($iBegin) - SuspendAndroidTime() + $iSuspendAndroidTimeOffset)) / 1000, 0)
If Number($txtDiff) < 0 Then
$txtDiff = "0s"
Else
Local $m = Int($txtDiff / 60)
Local $s = $txtDiff - $m * 60
$txtDiff = ""
If $m > 0 Then $txtDiff = $m & "m "
$txtDiff &= $s & "s"
EndIf
$NoResourceOCR = StringLen($Gold2) = 0 And StringLen($Elixir2) = 0 And StringLen($DarkElixir2) = 0
If $NoResourceOCR Then
SetLog("Exit now, [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " [%]: " & $CurDamage, $COLOR_INFO)
Else
If $g_bDebugSetlog Then
SetDebugLog("Exit in " & $txtDiff & ", [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " [%]: " & $CurDamage & ", Suspend-Time: " & $g_iSuspendAndroidTime & ", Suspend-Count: " & $g_iSuspendAndroidTimeCount & ", Offset: " & $iSuspendAndroidTimeOffset, $COLOR_INFO)
Else
SetLog("Exit in " & $txtDiff & ", [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " [%]: " & $CurDamage, $COLOR_INFO)
EndIf
EndIf
If Number($CurDamage) > Number($g_iPercentageDamage) Then $g_iPercentageDamage = Number($CurDamage)
If Number($CurDamage) >= 92 Then
If($g_bCheckKingPower Or $g_bCheckQueenPower Or $g_bCheckWardenPower) Then
If $g_bCheckKingPower And $g_iActivateKing = 0 Then
SetLog("Activating King's ability to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iKingSlot)
$g_bCheckKingPower = False
EndIf
If $g_bCheckQueenPower And $g_iActivateQueen = 0 Then
SetLog("Activating Queen's ability to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iQueenSlot)
$g_bCheckQueenPower = False
EndIf
If $g_bCheckWardenPower And $g_iActivateWarden = 0 Then
SetLog("Activating Warden's ability to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iWardenSlot)
$g_bCheckWardenPower = False
EndIf
EndIf
EndIf
If $Gold2 <> "" Or $Elixir2 <> "" Or $DarkElixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
$DarkElixirChange = $DarkElixir2
EndIf
If $g_abStopAtkNoResources[$g_iMatchMode] And Number($Gold2) = 0 And Number($Elixir2) = 0 And Number($DarkElixir2) = 0 Then
SetLog("Gold & Elixir & DE = 0, end battle ", $COLOR_SUCCESS)
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
ExitLoop
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And _CheckPixel($aWonTwoStar, True) Then
SetLog("Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
ExitLoop
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And _CheckPixel($aWonOneStar, True) Then
SetLog("One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
ExitLoop
EndIf
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" And $DarkElixir2 = "" Then
ExitLoop
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
SetLog("Overall Damage above " & Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) & ", exit", $COLOR_SUCCESS)
$g_iPercentageDamage = Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY))
ExitLoop
EndIf
If($g_abStopAtkNoLoot1Enable[$g_iMatchMode] Or $g_abStopAtkNoLoot2Enable[$g_iMatchMode]) And($Gold1 <> $Gold2 Or $Elixir1 <> $Elixir2 Or $DarkElixir1 <> $DarkElixir2) Then
SetLog("Gold & Elixir & DE change detected, waiting...", $COLOR_SUCCESS)
Return True
EndIf
If $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] And(Number($Damage) <> Number($CurDamage)) Then
SetLog("Overall Damage Percentage change detected, waiting...", $COLOR_SUCCESS)
$g_iPercentageDamage = Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY))
Return True
EndIf
$iTime = __TimerDiff($iBegin) - SuspendAndroidTime() + $iSuspendAndroidTimeOffset
WEnd
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 And $g_bDESideEndEnable And $g_iDarkLow = 1 Then
SetLog("Returning Now -DE-", $COLOR_SUCCESS)
Return False
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And $exitOneStar = 1 Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
Return False
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And $exitTwoStars = 1 Then
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
Return False
EndIf
If($NoResourceOCR = True) Then
SetLog("Battle has finished", $COLOR_SUCCESS)
Return False
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
$g_iPercentageDamage = Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY))
Return False
EndIf
If $g_abStopAtkNoResources[$g_iMatchMode] And $NoResourceOCR = False And Number($Gold2) = 0 And Number($Elixir2) = 0 And Number($DarkElixir2) = 0 Then
SetLog("Gold & Elixir & DE = 0, end battle ", $COLOR_SUCCESS)
If _Sleep($DELAYGOLDELIXIRCHANGEEBO2) Then Return
Return False
EndIf
If $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] And Number($Damage) = Number($CurDamage) Then
SetLog("No Overall Damage Percentage change detected, exit", $COLOR_SUCCESS)
Return False
EndIf
If(Number($Gold1) = Number($Gold2) And Number($Elixir1) = Number($Elixir2) And Number($DarkElixir1) = Number($DarkElixir2)) Then
If $g_abStopAtkNoLoot1Enable[$g_iMatchMode] Or $g_abStopAtkNoLoot2Enable[$g_iMatchMode] Then
SetLog("Gold & Elixir & DE no change detected, exit", $COLOR_SUCCESS)
Return False
Else
SetLog("Gold & Elixir & DE no change detected, waiting...", $COLOR_SUCCESS)
EndIf
Else
If $g_bDebugSetlog Then
SetDebugLog("Gold1: " & Number($Gold1) & "  Gold2: " & Number($Gold2), $COLOR_DEBUG)
SetDebugLog("Elixir1: " & Number($Elixir1) & "  Elixir2: " & Number($Elixir2), $COLOR_DEBUG)
SetDebugLog("Dark Elixir1: " & Number($DarkElixir1) & "  Dark Elixir2: " & Number($DarkElixir2), $COLOR_DEBUG)
EndIf
EndIf
Return True
EndFunc
Func PrepareAttack($pMatchMode, $bRemaining = False)
If($pMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 1) Or($pMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 1) Then
If $g_bDebugMakeIMGCSV And $bRemaining = False And TestCapture() = 0 Then
If $g_iSearchTH = "-" Then
imglocTHSearch(True, False, False)
EndIf
DebugImageSave("clean", False, Default, Default, "TH" & $g_iSearchTH & "-")
EndIf
EndIf
If Not $bRemaining Then
$g_bDropKing = False
$g_bDropQueen = False
$g_bDropWarden = False
If $g_iActivateKing = 1 Or $g_iActivateKing = 2 Then $g_aHeroesTimerActivation[$eHeroBarbarianKing] = 0
If $g_iActivateQueen = 1 Or $g_iActivateQueen = 2 Then $g_aHeroesTimerActivation[$eHeroArcherQueen] = 0
If $g_iActivateWarden = 1 Or $g_iActivateWarden = 2 Then $g_aHeroesTimerActivation[$eHeroGrandWarden] = 0
$g_iTotalAttackSlot = 10
$g_bDraggedAttackBar = False
EndIf
If $g_bDebugSetlog Then SetDebugLog("PrepareAttack for " & $pMatchMode & " " & $g_asModeText[$pMatchMode], $COLOR_DEBUG)
If $bRemaining Then
SetLog("Checking remaining unused troops for: " & $g_asModeText[$pMatchMode], $COLOR_INFO)
Else
SetLog("Initiating attack for: " & $g_asModeText[$pMatchMode], $COLOR_ERROR)
EndIf
If _Sleep($DELAYPREPAREATTACK1) Then Return
Local $iTroopNumber = 0
Local $avAttackBar = GetAttackBar($bRemaining, $pMatchMode)
For $i = 0 To UBound($g_avAttackTroops, 1) - 1
Local $bClearSlot = True
If $bRemaining Then
Local $bDropped = Default
Local $iTroopIndex = $g_avAttackTroops[$i][0]
Switch $iTroopIndex
Case $eKing
$bDropped = $g_bDropKing
Case $eQueen
$bDropped = $g_bDropQueen
Case $eWarden
$bDropped = $g_bDropWarden
EndSwitch
If $bDropped = False Then
SetDebugLog("Discard updating hero " & GetTroopName($g_avAttackTroops[$i][0]) & " because not dropped yet")
$iTroopNumber += $g_avAttackTroops[$i][2]
ContinueLoop
EndIf
If $bDropped = True Then
SetDebugLog("Discard updating hero " & GetTroopName($g_avAttackTroops[$i][0]) & " because already dropped")
$iTroopNumber += $g_avAttackTroops[$i][2]
ContinueLoop
EndIf
EndIf
If UBound($avAttackBar, 1) > 0 Then
For $j = 0 To UBound($avAttackBar, 1) - 1
If $avAttackBar[$j][1] = $i Then
If IsUnitUsed($pMatchMode, $avAttackBar[$j][0]) Then
$bClearSlot = False
Local $sLogExtension = ""
If Not $bRemaining Then
Local $iTroopIndex = Number($avAttackBar[$j][0])
$g_avAttackTroops[$i][0] = $iTroopIndex
$g_avAttackTroops[$i][1] = Number($avAttackBar[$j][2])
$g_avAttackTroops[$i][2] = Number($avAttackBar[$j][3])
$g_avAttackTroops[$i][3] = Number($avAttackBar[$j][4])
$g_avAttackTroops[$i][4] = Number($avAttackBar[$j][5])
$g_avAttackTroops[$i][5] = Number($avAttackBar[$j][6])
If $pMatchMode = $DB Or $pMatchMode = $LB Then
Switch $iTroopIndex
Case $eCastle, $eWallW, $eBattleB, $eStoneS
If $g_aiAttackUseSiege[$pMatchMode] <= 4 Then
SelectCastleOrSiege($iTroopIndex, Number($avAttackBar[$j][5]), $g_aiAttackUseSiege[$pMatchMode])
If $iTroopIndex <> $eCastle Then $sLogExtension = " (level " & $g_iSiegeLevel & ")"
EndIf
Case $eWarden
If $g_aiAttackUseWardenMode[$pMatchMode] <= 1 Then $sLogExtension = SelectWardenMode($g_aiAttackUseWardenMode[$pMatchMode], Number($avAttackBar[$j][5]))
EndSwitch
EndIf
Else
$g_avAttackTroops[$i][1] = Number($avAttackBar[$j][2])
EndIf
$iTroopNumber += $avAttackBar[$j][2]
Local $sDebugText = $g_bDebugSetlog ? " (X:" & $avAttackBar[$j][3] & "|Y:" & $avAttackBar[$j][4] & "|OCR-X:" & $avAttackBar[$j][5] & "|OCR-Y:" & $avAttackBar[$j][6] & ")" : ""
SetLog($avAttackBar[$j][1] & ": " & $avAttackBar[$j][2] & " " & GetTroopName($avAttackBar[$j][0], $avAttackBar[$j][2]) & $sLogExtension & $sDebugText, $COLOR_SUCCESS)
Else
SetDebugLog("Discard use of " & GetTroopName($avAttackBar[$j][0]) & " (" & $avAttackBar[$j][0] & ")", $COLOR_ERROR)
EndIf
ExitLoop
EndIf
Next
EndIf
If $bClearSlot Then
$g_avAttackTroops[$i][0] = -1
$g_avAttackTroops[$i][1] = 0
$g_avAttackTroops[$i][2] = 0
$g_avAttackTroops[$i][3] = 0
$g_avAttackTroops[$i][4] = 0
$g_avAttackTroops[$i][5] = 0
EndIf
Next
If Not $bRemaining Then SetSlotSpecialTroops()
Return $iTroopNumber
EndFunc
Func SelectCastleOrSiege(ByRef $iTroopIndex, $XCoord, $iCmbSiege)
Local $hStarttime = _Timer_Init()
Local $aSiegeTypes[5] = [$eCastle, $eWallW, $eBattleB, $eStoneS, "Any"]
Local $ToUse = $aSiegeTypes[$iCmbSiege]
Local $bNeedSwitch = False, $bAnySiege = False
Local $sLog = GetTroopName($iTroopIndex)
Switch $ToUse
Case $iTroopIndex
If $iTroopIndex <> $eCastle And $g_iSiegeLevel < 3 Then
$bNeedSwitch = True
SetLog(GetTroopName($iTroopIndex) & " level " & $g_iSiegeLevel & " detected. Try looking for higher level.")
EndIf
Case $eCastle, $eWallW, $eBattleB, $eStoneS
$bNeedSwitch = True
SetLog(GetTroopName($iTroopIndex) &($ToUse <> $eCastle ? " level " & $g_iSiegeLevel & " detected. Try looking for " : " detected. Switching to ") & GetTroopName($ToUse))
Case "Any"
If $iTroopIndex = $eCastle Or($iTroopIndex <> $eCastle And $g_iSiegeLevel < 3) Then
$bNeedSwitch = True
$bAnySiege = True
SetLog(GetTroopName($iTroopIndex) &($iTroopIndex = $eCastle ? " detected. Try looking for any siege machine" : " level " & $g_iSiegeLevel & " detected. Try looking for any higher siege machine"))
EndIf
EndSwitch
If $bNeedSwitch Then
If QuickMIS("BC1", $g_sImgSwitchSiegeMachine, $XCoord - 30, 700, $XCoord + 35, 720, True, False) Then
Click($g_iQuickMISX + $XCoord - 30, $g_iQuickMISY + 700, 1)
Local $lastX = $g_iQuickMISX + $XCoord - 30, $lastY = $g_iQuickMISY + 700
If _Sleep(1250) Then Return
Local $sSearchArea = GetDiamondFromRect(_Min($XCoord - 50, 470) & ",530(390,30)")
Local $aSearchResult = findMultiple($g_sImgSwitchSiegeMachine, $sSearchArea, $sSearchArea, 0, 1000, 5, "objectname,objectpoints", True)
If $g_bDebugSetlog Then SetDebugLog("Benchmark Switch Siege imgloc: " & StringFormat("%.2f", _Timer_Diff($hStarttime)) & "'ms")
$hStarttime = _Timer_Init()
If $aSearchResult <> "" And IsArray($aSearchResult) Then
Local $aFinalCoords, $iFinalLevel = 0, $iFinalSiege
For $i = 0 To UBound($aSearchResult) - 1
Local $aAvailable = $aSearchResult[$i]
SetDebugLog("SelectCastleOrSiege() $aSearchResult[" & $i & "]: " & _ArrayToString($aAvailable))
Local $iSiegeIndex = TroopIndexLookup($aAvailable[0], "SelectCastleOrSiege()")
Local $sAllCoordsString = _ArrayToString($aAvailable, "|", 1)
Local $aAllCoords = decodeMultipleCoords($sAllCoordsString, 50)
If $iSiegeIndex = $ToUse And $iSiegeIndex = $eCastle Then
$aFinalCoords = $aAllCoords[0]
$iFinalSiege = $iSiegeIndex
ExitLoop
EndIf
If $iSiegeIndex >= $eWallW And $iSiegeIndex <= $eStoneS And($bAnySiege Or $iSiegeIndex = $ToUse) Then
For $j = 0 To UBound($aAllCoords) - 1
Local $aCoords = $aAllCoords[$j]
Local $SiegeLevel = getTroopsSpellsLevel(Number($aCoords[0]) - 30, 587)
If $SiegeLevel = "" Then $SiegeLevel = 1
If $iFinalLevel < Number($SiegeLevel) Then
$iFinalLevel = Number($SiegeLevel)
$aFinalCoords = $aCoords
$iFinalSiege = $iSiegeIndex
EndIf
SetDebugLog($i & "." & $j & ". Name: " & $aAvailable[0] & ", Level: " & $SiegeLevel & ", Coords: " & _ArrayToString($aCoords))
If $iFinalLevel = 3 Then ExitLoop 2
Next
EndIf
Next
If $g_bDebugSetlog Then SetDebugLog("Benchmark Switch Siege Levels: " & StringFormat("%.2f", _Timer_Diff($hStarttime)) & "'ms")
$hStarttime = _Timer_Init()
If($iTroopIndex = $ToUse Or $bAnySiege) And $g_iSiegeLevel >= $iFinalLevel Then
SetLog($bAnySiege ? "No higher level siege machine found" : "No higher level of " & GetTroopName($iTroopIndex) & " found")
Click($lastX, $lastY, 1)
ElseIf IsArray($aFinalCoords) Then
ClickP($aFinalCoords, 1, 0)
$g_iSiegeLevel = $iFinalLevel
$iTroopIndex = $iFinalSiege
Else
If Not $bAnySiege Then SetLog("No " & GetTroopName($ToUse) & " found")
Click($lastX, $lastY, 1)
EndIf
Else
If $g_bDebugImageSave Then DebugImageSave("PrepareAttack_SwitchSiege")
Setlog("Undetected " &($bAnySiege ? "any siege machine " : GetTroopName($ToUse)) & " after click on switch btn!", $COLOR_DEBUG)
Click($lastX, $lastY, 1)
EndIf
If _Sleep(750) Then Return
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog("Benchmark Switch Siege Detection: " & StringFormat("%.2f", _Timer_Diff($hStarttime)) & "'ms")
EndFunc
Func SelectWardenMode($iMode, $XCoord)
Local $hStarttime = _Timer_Init()
Local $aSelectMode[2] = ["Ground", "Air"], $aSelectSymbol[2] = ["Foot", "Wing"]
Local $sLogText = ""
Local $sArrow = GetDiamondFromRect($XCoord - 20 & ",700(68,20)")
Local $aCurrentMode = findMultiple($g_sImgSwitchWardenMode, $sArrow, $sArrow, 0, 1000, 1, "objectname,objectpoints", True)
If $aCurrentMode <> "" And IsArray($aCurrentMode) Then
Local $aCurrentModeArray = $aCurrentMode[0]
If Not IsArray($aCurrentModeArray) Or UBound($aCurrentModeArray) < 2 Then Return $sLogText
SetDebugLog("SelectWardenMode() $aCurrentMode[0]: " & _ArrayToString($aCurrentModeArray))
If $g_bDebugSetlog Then SetLog("Benchmark G. Warden mode detection: " & StringFormat("%.2f", _Timer_Diff($hStarttime)) & "'ms", $COLOR_DEBUG)
If $aCurrentModeArray[0] = $aSelectMode[$iMode] Then
$sLogText = " (" & $aCurrentModeArray[0] & " mode)"
Else
Local $aArrowCoords = StringSplit($aCurrentModeArray[1], ",", $STR_NOCOUNT)
ClickP($aArrowCoords, 1, 0)
If _Sleep(1200) Then Return
Local $sSymbol = GetDiamondFromRect(_Min($XCoord - 30, 696) & ",582(162,18)")
Local $aAvailableMode = findMultiple($g_sImgSwitchWardenMode, $sSymbol, $sSymbol, 0, 1000, 2, "objectname,objectpoints", True)
If $aAvailableMode <> "" And IsArray($aAvailableMode) Then
For $i = 0 To UBound($aAvailableMode, $UBOUND_ROWS) - 1
Local $aAvailableModeArray = $aAvailableMode[$i]
SetDebugLog("SelectWardenMode() $aAvailableMode[" & $i & "]: " & _ArrayToString($aAvailableModeArray))
If $aAvailableModeArray[0] = $aSelectSymbol[$iMode] Then
Local $aSymbolCoords = StringSplit($aAvailableModeArray[1], ",", $STR_NOCOUNT)
ClickP($aSymbolCoords, 1, 0)
$sLogText = " (" & $aSelectMode[$iMode] & " mode)"
ExitLoop
EndIf
Next
If $sLogText = "" Then ClickP($aArrowCoords, 1, 0)
If $g_bDebugSetlog Then SetLog("Benchmark G. Warden mode selection: " & StringFormat("%.2f", _Timer_Diff($hStarttime)) & "'ms", $COLOR_DEBUG)
EndIf
EndIf
EndIf
Return $sLogText
EndFunc
Func IsUnitUsed($iMatchMode, $iTroopIndex)
Local $iTempMode =($iMatchMode = $MA ? $DB : $iMatchMode)
If $iTroopIndex < $eKing Then
If $iMatchMode = $DT Or $iMatchMode = $TB Then Return True
Local $aTempArray = $g_aaiTroopsToBeUsed[$g_aiAttackTroopSelection[$iTempMode]]
Local $iFoundAt = _ArraySearch($aTempArray, $iTroopIndex)
If $iFoundAt <> -1 Then
If $iMatchMode = $MA And $iTroopIndex = $eGobl Then
Return False
Else
Return True
EndIf
EndIf
Return False
Else
Local $iTempMode =($iMatchMode = $MA ? $DB : $iMatchMode)
If $iMatchMode <> $DB And $iMatchMode <> $LB And $iMatchMode <> $TS And $iMatchMode <> $MA Then
Return True
Else
Switch $iTroopIndex
Case $eKing
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroKing) = $eHeroKing) Then Return True
Case $eQueen
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroQueen) = $eHeroQueen) Then Return True
Case $eWarden
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroWarden) = $eHeroWarden) Then Return True
Case $eCastle, $eWallW, $eBattleB, $eStoneS
If $g_abAttackDropCC[$iTempMode] Then Return True
Case $eLSpell
If $g_abAttackUseLightSpell[$iTempMode] Or $g_bSmartZapEnable Then Return True
Case $eHSpell
If $g_abAttackUseHealSpell[$iTempMode] Then Return True
Case $eRSpell
If $g_abAttackUseRageSpell[$iTempMode] Then Return True
Case $eJSpell
If $g_abAttackUseJumpSpell[$iTempMode] Then Return True
Case $eFSpell
If $g_abAttackUseFreezeSpell[$iTempMode] Then Return True
Case $ePSpell
If $g_abAttackUsePoisonSpell[$iTempMode] Then Return True
Case $eESpell
If $g_abAttackUseEarthquakeSpell[$iTempMode] = 1 Or $g_bSmartZapEnable Then Return True
Case $eHaSpell
If $g_abAttackUseHasteSpell[$iTempMode] Then Return True
Case $eCSpell
If $g_abAttackUseCloneSpell[$iTempMode] Then Return True
Case $eSkSpell
If $g_abAttackUseSkeletonSpell[$iTempMode] Then Return True
Case $eBtSpell
If $g_abAttackUseBatSpell[$iTempMode] Then Return True
Case Else
Return False
EndSwitch
Return False
EndIf
Return False
EndIf
Return False
EndFunc
Func AttackRemainingTime($bInitialze = Default)
If $bInitialze Then
$g_hAttackTimer = __TimerInit()
$g_iAttackTimerOffset = Default
SuspendAndroidTime(True)
Return
EndIf
Local $iPrepareTime = 29 * 1000
If $g_iAttackTimerOffset = Default Then
$g_iAttackTimerOffset = __TimerDiff($g_hAttackTimer) - SuspendAndroidTime()
If $g_iAttackTimerOffset > $iPrepareTime Then
$g_iAttackTimerOffset = $iPrepareTime - $g_iAttackTimerOffset
EndIf
EndIf
If Not $bInitialze Then Return
Local $iAttackTime = 3 * 60 * 1000
Local $iRemaining = $iAttackTime -(__TimerDiff($g_hAttackTimer) - SuspendAndroidTime() - $g_iAttackTimerOffset)
If $iRemaining < 0 Then Return 0
Return $iRemaining
EndFunc
Func ReturnHome($TakeSS = 1, $GoldChangeCheck = True)
If $g_bDebugSetlog Then SetDebugLog("ReturnHome function... (from matchmode=" & $g_iMatchMode & " - " & $g_asModeText[$g_iMatchMode] & ")", $COLOR_DEBUG)
Local $counter = 0
Local $hBitmap_Scaled
Local $i, $j
If $g_bDESideDisableOther And $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 And $g_bDESideEndEnable And($g_bDropQueen Or $g_bDropKing) Then
SaveandDisableEBO()
SetLog("Disabling Normal End Battle Options", $COLOR_SUCCESS)
EndIf
If $GoldChangeCheck Then
If Not(IsReturnHomeBattlePage(True, False)) Then
SetLog("Checking if the battle has finished", $COLOR_INFO)
While GoldElixirChangeEBO()
If _Sleep($DELAYRETURNHOME1) Then Return
WEnd
If IsAttackPage() Then smartZap()
If($g_bCheckKingPower Or $g_bCheckQueenPower Or $g_bCheckWardenPower) Then
If _ColorCheck(_GetPixelColor($aRtnHomeCheck1[0], $aRtnHomeCheck1[1], True), Hex($aRtnHomeCheck1[2], 6), $aRtnHomeCheck1[3]) = False And _ColorCheck(_GetPixelColor($aRtnHomeCheck2[0], $aRtnHomeCheck2[1], True), Hex($aRtnHomeCheck2[2], 6), $aRtnHomeCheck2[3]) = False Then
If $g_bCheckKingPower Then
SetLog("Activating King's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iKingSlot)
EndIf
If $g_bCheckQueenPower Then
SetLog("Activating Queen's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iQueenSlot)
EndIf
If $g_bCheckWardenPower Then
SetLog("Activating Warden's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($g_iWardenSlot)
EndIf
EndIf
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Battle already over", $COLOR_DEBUG)
EndIf
EndIf
If $g_bDESideDisableOther And $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 And $g_bDESideEndEnable And($g_bDropQueen Or $g_bDropKing) Then
RevertEBO()
EndIf
$g_bCheckKingPower = False
$g_bCheckQueenPower = False
$g_bCheckWardenPower = False
$g_bDropKing = False
$g_bDropQueen = False
$g_bDropWarden = False
$g_aHeroesTimerActivation[$eHeroBarbarianKing] = 0
$g_aHeroesTimerActivation[$eHeroArcherQueen] = 0
$g_aHeroesTimerActivation[$eHeroGrandWarden] = 0
_ObjDeleteKey($g_oBldgAttackInfo, "")
If $g_abAttackTypeEnable[$TS] = 1 And $g_iMatchMode = $TS Then $g_bFirstStart = True
SetLog("Returning Home", $COLOR_INFO)
If $g_bRunState = False Then Return
If Not(IsReturnHomeBattlePage(True, False)) Then
For $i = 0 To 5
If $g_bDebugSetlog Then SetDebugLog("Wait for surrender button to appear #" & $i)
If _CheckPixel($aSurrenderButton, $g_bCapturePixel) Then
If IsAttackPage() Then
ClickP($aSurrenderButton, 1, 0, "#0099")
$j = 0
While 1
If $g_bDebugSetlog Then SetDebugLog("Wait for OK button to appear #" & $j)
If IsEndBattlePage(False) Then
ClickOkay("SurrenderOkay")
ExitLoop 2
Else
$j += 1
EndIf
If ReturnHomeMainPage() Then Return
If $j > 10 Then ExitLoop
If _Sleep($DELAYRETURNHOME5) Then Return
WEnd
EndIf
EndIf
If ReturnHomeMainPage() Then Return
If _Sleep($DELAYRETURNHOME5) Then Return
Next
Else
If $g_bDebugSetlog Then SetDebugLog("Battle already over.", $COLOR_DEBUG)
EndIf
If _Sleep($DELAYRETURNHOME2) Then Return
TrayTip($g_sBotTitle, "", BitOR($TIP_ICONASTERISK, $TIP_NOSOUND))
If CheckAndroidReboot() Then Return
If $GoldChangeCheck Then
If IsAttackPage() Then
$counter = 0
While _ColorCheck(_GetPixelColor($aRtnHomeCheck1[0], $aRtnHomeCheck1[1], True), Hex($aRtnHomeCheck1[2], 6), $aRtnHomeCheck1[3]) = False And _ColorCheck(_GetPixelColor($aRtnHomeCheck2[0], $aRtnHomeCheck2[1], True), Hex($aRtnHomeCheck2[2], 6), $aRtnHomeCheck2[3]) = False
If $g_bDebugSetlog Then SetDebugLog("Wait for Return Home Button to appear #" & $counter)
If _Sleep($DELAYRETURNHOME2) Then ExitLoop
$counter += 1
If $counter > 40 Then ExitLoop
WEnd
EndIf
If _Sleep($DELAYRETURNHOME3) Then Return
_CaptureRegion()
AttackReport()
EndIf
If $TakeSS = 1 And $GoldChangeCheck Then
SetLog("Taking snapshot of your loot", $COLOR_SUCCESS)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion()
$hBitmap_Scaled = _GDIPlus_ImageResize($g_hBitmap, _GDIPlus_ImageGetWidth($g_hBitmap) / 2, _GDIPlus_ImageGetHeight($g_hBitmap) / 2)
If $g_bScreenshotLootInfo Then
$g_sLootFileName = $Date & "_" & $Time & " G" & $g_iStatsLastAttack[$eLootGold] & " E" & $g_iStatsLastAttack[$eLootElixir] & " DE" & $g_iStatsLastAttack[$eLootDarkElixir] & " T" & $g_iStatsLastAttack[$eLootTrophy] & " S" & StringFormat("%3s", $g_iSearchCount) & ".jpg"
Else
$g_sLootFileName = $Date & "_" & $Time & ".jpg"
EndIf
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileLootsPath & $g_sLootFileName)
_GDIPlus_ImageDispose($hBitmap_Scaled)
EndIf
If $GoldChangeCheck Then PushMsg("LastRaid")
$i = 0
Local $iExitLoop = -1
While 1
If $g_bDebugSetlog Then SetDebugLog("Wait for End Fight Scene to appear #" & $i)
If _CheckPixel($aEndFightSceneAvl, $g_bCapturePixel) Then
If IsReturnHomeBattlePage(True) Then
ClickP($aReturnHomeButton, 1, 0, "#0101")
$iExitLoop = $i
EndIf
EndIf
If $i > 25 Or($iExitLoop > -1 And $i > $iExitLoop) Then ExitLoop
If _Sleep($DELAYRETURNHOME5) Then Return
$i += 1
WEnd
If _Sleep($DELAYRETURNHOME2) Then Return
$counter = 0
While 1
If $g_bDebugSetlog Then SetDebugLog("Wait for Star Bonus window to appear #" & $counter)
If _Sleep($DELAYRETURNHOME4) Then Return
If StarBonus() Then SetLog("Star Bonus window closed chief!", $COLOR_INFO)
$g_bFullArmy = False
$g_bIsFullArmywithHeroesAndSpells = False
If ReturnHomeMainPage() Then Return
$counter += 1
If $counter >= 50 Or isProblemAffect(True) Then
SetLog("Cannot return home.", $COLOR_ERROR)
checkMainScreen()
Return
EndIf
WEnd
EndFunc
Func ReturnHomeMainPage()
If IsMainPage(1) Then
SetLogCentered(" BOT LOG ", Default, Default, True)
Return True
EndIf
Return False
EndFunc
Func ReturnfromDropTrophies()
If $g_bDebugSetlog Then SetDebugLog(" -- ReturnfromDropTrophies -- ")
For $i = 0 To 5
If $g_bDebugSetlog Then SetDebugLog("Wait for surrender button to appear #" & $i)
ClickP($aSurrenderButton, 1, 0, "#0099")
Local $j = 0
While 1
If $g_bDebugSetlog Then SetDebugLog("Wait for OK button to appear #" & $j)
If IsEndBattlePage(True) Then
ClickOkay("SurrenderOkay")
ExitLoop 2
Else
$j += 1
EndIf
If $j > 10 Then ExitLoop
If _Sleep(100) Then Return
If _CheckPixel($aSurrenderButton, $g_bCapturePixel) Then
ClickP($aSurrenderButton, 1, 0, "#0099")
EndIf
WEnd
If _Sleep(100) Then Return
Next
$i = 0
Local $iExitLoop = -1
While 1
If $g_bDebugSetlog Then SetDebugLog("Wait for End Fight Scene to appear #" & $i)
If _CheckPixel($aEndFightSceneAvl, $g_bCapturePixel) Then
If IsReturnHomeBattlePage(True) Then
ClickP($aReturnHomeButton, 1, 0, "#0101")
$iExitLoop = $i
EndIf
Else
$i += 1
EndIf
If $i > 25 Or($iExitLoop > -1 And $i > $iExitLoop) Then ExitLoop
If _Sleep($DELAYRETURNHOME5) Then Return
WEnd
If _Sleep($DELAYRETURNHOME2) Then Return
$g_bFullArmy = False
$g_bIsFullArmywithHeroesAndSpells = False
If ReturnHomeMainPage() Then Return
checkMainScreen()
EndFunc
Func Unbreakable()
Local $x, $y, $i, $iTime, $iCount
Switch $g_iUnbrkMode
Case 2
If(Number($g_aiCurrentLoot[$eLootGold]) > Number($g_iUnbrkMaxGold)) And(Number($g_aiCurrentLoot[$eLootElixir]) > Number($g_iUnbrkMaxElixir)) And(Number($g_aiCurrentLoot[$eLootDarkElixir]) > Number($g_iUnbrkMaxDark)) Then
SetLog(" ====== Unbreakable Mode restarted! ====== ", $COLOR_SUCCESS)
$g_iUnbrkMode = 1
Else
SetLog(" = Unbreakable Mode Paused, Farming to Refill Storages =", $COLOR_INFO)
Return False
EndIf
Case 1
SetLog(" ====== Unbreakable Mode enabled! ====== ", $COLOR_SUCCESS)
Case Else
SetLog(">>> Programmer Humor, You shouldn't ever see this message, RUN! <<<", $COLOR_DEBUG)
EndSwitch
If $g_bDropTrophyAtkDead Then
If($g_CurrentCampUtilization <=($g_iTotalCampSpace * 70 / 100)) Then
SetLog("Oops, wait for 70% troops due attack dead base checked", $COLOR_ERROR)
Return True
EndIf
Else
If($g_CurrentCampUtilization <=($g_iTotalCampSpace * 20 / 100)) Then
SetLog("Oops, wait for 20% troops for use in trophy drop", $COLOR_ERROR)
Return True
EndIf
EndIf
Local $sMissingLoot = ""
If((Number($g_aiCurrentLoot[$eLootGold]) - Number($g_iUnbrkMinGold)) < 0) Then
$sMissingLoot &= "Gold, "
EndIf
If((Number($g_aiCurrentLoot[$eLootElixir]) - Number($g_iUnbrkMinElixir)) < 0) Then
$sMissingLoot &= "Elixir, "
EndIf
If((Number($g_aiCurrentLoot[$eLootDarkElixir]) - Number($g_iUnbrkMinDark)) < 0) Then
$sMissingLoot &= "Dark Elixir"
EndIf
If $sMissingLoot <> "" Then
SetLog("Oops, Out of " & $sMissingLoot & " - back to farming", $COLOR_ERROR)
$g_iUnbrkMode = 2
Return False
EndIf
DropTrophy()
If _Sleep($DELAYUNBREAKABLE2) Then Return True
ClickP($aAway, 1, $DELAYUNBREAKABLE7, "#0112")
If _Sleep($DELAYUNBREAKABLE1) Then Return True
If $g_bRestart = True Then Return True
$iCount = 0
Local $iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If $g_bDebugSetlog Then SetDebugLog("Trophy Count Read = " & $iTrophyCurrent, $COLOR_DEBUG)
While Number($iTrophyCurrent) > Number($g_iDropTrophyMax)
If $g_bDebugSetlog Then SetDebugLog("Drop Trophy Loop #" & $iCount + 1, $COLOR_DEBUG)
DropTrophy()
If _Sleep($DELAYUNBREAKABLE2) Then Return True
ClickP($aAway, 1, 0, "#0395")
If _Sleep($DELAYUNBREAKABLE1) Then Return True
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If($iCount > 2) And(Number($iTrophyCurrent) > Number($g_iDropTrophyMax)) Then
SetLog("Unable to drop trophy, trying again", $COLOR_ERROR)
If _Sleep(500) Then Return True
Return True
EndIf
$iCount += 1
WEnd
If $g_bRestart = True Then Return True
BreakPersonalShield()
If @error Then
If @extended <> "" Then SetLog("PersonalShield button problem: " & @extended, $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0395")
Return True
EndIf
ClickP($aAway, 2, $DELAYUNBREAKABLE8, "#0115")
If _Sleep($DELAYUNBREAKABLE1) Then Return True
If CheckObstacles() = True Then SetLog("Window clean required, but no problem for MyBot!", $COLOR_INFO)
SetLog("Closing Clash Of Clans", $COLOR_INFO)
$i = 0
While 1
AndroidBackButton()
If _Sleep($DELAYUNBREAKABLE1) Then Return True
Local $offColors[3][3] = [[0x000000, 144, 0], [0xFFFFFF, 54, 17], [0xCBE870, 54, 10]]
Local $ButtonPixel = _MultiPixelSearch(438, 372 + $g_iMidOffsetY, 590, 404 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog("Exit btn chk-#1: " & _GetPixelColor(441, 374, True) & ", #2: " & _GetPixelColor(441 + 144, 374, True) & ", #3: " & _GetPixelColor(441 + 54, 374 + 17, True) & ", #4: " & _GetPixelColor(441 + 54, 374 + 10, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
ExitLoop
EndIf
If $i > 15 Then ExitLoop
$i += 1
WEnd
$iTime = Number($g_iUnbrkWait)
If $iTime < 1 Then $iTime = 1
Local Const $iGracePeriodTime = 5
$iTime =($iTime + $iGracePeriodTime) * 60 * 1000
WaitnOpenCoC($iTime, False)
$iCount = 0
While 1
If $g_bDebugSetlog Then SetDebugLog("Under Attack Pixels = " & _GetPixelColor(841, 342 + $g_iMidOffsetY, True) & "/" & _GetPixelColor(842, 348 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(841, 342 + $g_iMidOffsetY, True), Hex(0x711C0A, 6), 20) And _ColorCheck(_GetPixelColor(842, 348 + $g_iMidOffsetY, True), Hex(0x721C0E, 6), 20) Then
SetLog("Base is under attack, waiting 30 seocnds for end", $COLOR_INFO)
Else
ExitLoop
EndIf
If _SleepStatus($DELAYUNBREAKABLE6) Then Return True
If $iCount > 7 Then ExitLoop
$iCount += 1
WEnd
If _Sleep($DELAYUNBREAKABLE4) Then Return True
Local $Message = _PixelSearch(20, 624, 105, 627, Hex(0xE1E3CB, 6), 15)
If IsArray($Message) Then
If $g_bDebugSetlog Then SetDebugLog("Return Home Pixel = " & _GetPixelColor($Message[0], $Message[1], True) & ", Pos: " & $Message[0] & "/" & $Message[1], $COLOR_DEBUG)
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($DELAYUNBREAKABLE3) Then Return True
EndIf
If _ColorCheck(_GetPixelColor(235, 209 + $g_iMidOffsetY, True), Hex(0x9E3826, 6), 20) And _ColorCheck(_GetPixelColor(242, 140 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20) Then
If $g_bDebugSetlog Then SetDebugLog("Village Attacked Pixels = " & _GetPixelColor(235, 209 + $g_iMidOffsetY, True) & "/" & _GetPixelColor(242, 140 + $g_iMidOffsetY, True), $COLOR_DEBUG)
PureClick(429, 493 + $g_iMidOffsetY, 1, 0, "#0132")
If _Sleep($DELAYUNBREAKABLE3) Then Return True
EndIf
If CheckObstacles() = True Then
If _Sleep($DELAYUNBREAKABLE3) Then Return
If CheckObstacles() = True Then CheckMainScreen(False)
Return
EndIf
ZoomOut()
If _Sleep($DELAYUNBREAKABLE1) Then Return True
Return True
EndFunc
Func GetAttackBar($bRemaining = False, $pMatchMode = $DB, $bDebug = False)
Local Static $aAttackBar[0][8]
Local Static $bDoubleRow = False, $bCheckSlot12 = False
Local $sSearchDiamond = GetDiamondFromRect("0,635,835,698")
Local $iYBelowRowOne = 630, $aiOCRLocation[2] = [-1, -1], $aSlotAmountX[0][3]
If $g_bDraggedAttackBar Then DragAttackBar($g_iTotalAttackSlot, True)
If Not $bRemaining Then
$bCheckSlot12 = False
$bDoubleRow = False
Local $aDummyArray[0][8]
$aAttackBar = $aDummyArray
$g_iLSpellLevel = 1
$g_iESpellLevel = 1
$g_iSiegeLevel = 1
If _CheckPixel($aDoubRowAttackBar, True) Then
$bDoubleRow = True
$sSearchDiamond = GetDiamondFromRect("0,535,835,698")
ElseIf _CheckPixel($a12OrMoreSlots, True) Then
$bCheckSlot12 = True
EndIf
SetDebugLog("AttackBarCheck: DoubleRow= " & $bDoubleRow)
EndIf
If Not $g_bRunState Then Return
If UBound($aAttackBar) = 0 Or Not $bRemaining Then
Local $iAttackbarStart = __TimerInit()
Local $aTempArray, $aTempCoords, $aTempMultiCoords, $iRow = 1
Local $aAttackBarResult = findMultiple($g_sImgAttackBarDir, $sSearchDiamond, $sSearchDiamond, 0, 1000, 0, "objectname,objectpoints", True)
If UBound($aAttackBarResult) = 0 Then
SetLog("Error in AttackBarCheck(): Search did not return any results!", $COLOR_ERROR)
DebugImageSave("ErrorAttackBarCheck", False, Default, Default, "#1")
Return ""
EndIf
For $i = 0 To UBound($aAttackBarResult, 1) - 1
$aTempArray = $aAttackBarResult[$i]
$aTempMultiCoords = decodeMultipleCoords($aTempArray[1], 40, 40, -1)
For $j = 0 To UBound($aTempMultiCoords, 1) - 1
$aTempCoords = $aTempMultiCoords[$j]
If UBound($aTempCoords) < 2 Then ContinueLoop
If $bDoubleRow And $aTempCoords[1] >= $iYBelowRowOne Then $iRow = 2
If StringRegExp($aTempArray[0], "(AmountX)", 0) Then
_ArrayAdd($aSlotAmountX, $aTempCoords[0] & "|" & $aTempCoords[1] & "|" & $iRow, 0, "|", @CRLF, $ARRAYFILL_FORCE_NUMBER)
$aiOCRLocation[$iRow - 1] = $aTempCoords[1]
Else
If StringRegExp($aTempArray[0], "(King)|(Queen)|(Warden)", 0) Then _ArrayAdd($aSlotAmountX, $aTempCoords[0] & "|" & $aTempCoords[1] & "|" & $iRow, 0, "|", @CRLF, $ARRAYFILL_FORCE_NUMBER)
Local $aTempElement[1][8] = [[$aTempArray[0], $aTempCoords[0], $aTempCoords[1], -1, -1, -1, -1, $iRow]]
_ArrayAdd($aAttackBar, $aTempElement)
EndIf
$iRow = 1
Next
Next
If UBound($aAttackBar, 1) = 0 Then
SetLog("Error in AttackBarCheck(): $aAttackBar has no results in it", $COLOR_ERROR)
Return ""
EndIf
_ArraySort($aAttackBar, 0, 0, 0, 1)
_ArraySort($aSlotAmountX)
If $bDoubleRow Then $aSlotAmountX = SortDoubleRowXElements($aSlotAmountX)
SetDebugLog("AttackBarCheck(): Finished Image Search in: " & StringFormat("%.2f", __TimerDiff($iAttackbarStart)) & " ms")
$iAttackbarStart = __TimerInit()
EndIf
Local $aFinalAttackBar[0][7]
Local $aiOCRY = [-1, -1]
If Not $bRemaining Then $aiOCRY = GetOCRYLocation($aSlotAmountX)
Local $sKeepRemainTroops = "(King)|(Queen)|(Warden)|(WallW)|(BattleB)|(StoneS)"
For $i = 0 To UBound($aAttackBar, 1) - 1
If $aAttackBar[$i][1] > 0 Then
Local $bRemoved = False
If Not $g_bRunState Then Return
If _Sleep(20) Then Return
If $bRemaining Then
$aTroopIsDeployed[0] = $aAttackBar[$i][5] - 15
$aTroopIsDeployed[1] = $aAttackBar[$i][6]
If _CheckPixel($aTroopIsDeployed, True) Then
$bRemoved = True
$aAttackBar[$i][4] = 0
If StringRegExp($aAttackBar[$i][0], $sKeepRemainTroops, 0) = 0 Then
SetDebugLog("AttackBarCheck(): Troop " & $aAttackBar[$i][0] & " already deployed, now removed")
ContinueLoop
Else
SetDebugLog("AttackBarCheck(): Troop " & $aAttackBar[$i][0] & " already deployed, but stays")
EndIf
EndIf
Else
Local $aTempSlot = AttackSlot(Number($aAttackBar[$i][1]), Number($aAttackBar[$i][7]), $aSlotAmountX)
$aAttackBar[$i][5] = Number($aTempSlot[0])
$aAttackBar[$i][6] = Number($aTempSlot[1])
$aAttackBar[$i][3] = Number($aTempSlot[2])
If StringRegExp($aAttackBar[$i][0], "(King)|(Queen)|(Warden)", 0) And $aiOCRY[$aAttackBar[$i][7] - 1] <> -1 Then $aAttackBar[$i][6] =($aiOCRY[$aAttackBar[$i][7] - 1] - 7)
EndIf
If StringRegExp($aAttackBar[$i][0], "(King)|(Queen)|(Warden)|(Castle)|(WallW)|(BattleB)|(StoneS)", 0) Then
If Not $bRemoved Then $aAttackBar[$i][4] = 1
If($pMatchMode = $DB Or $pMatchMode = $LB) And StringRegExp($aAttackBar[$i][0], "(WallW)|(BattleB)|(StoneS)", 0) And $g_abAttackDropCC[$pMatchMode] And $g_aiAttackUseSiege[$pMatchMode] > 0 And $g_aiAttackUseSiege[$pMatchMode] <= 4 Then
$g_iSiegeLevel = Number(getTroopsSpellsLevel(Number($aAttackBar[$i][5]) - 30, 704))
If $g_iSiegeLevel = "" Then $g_iSiegeLevel = 1
SetDebugLog($aAttackBar[$i][0] & " level: " & $g_iSiegeLevel)
EndIf
Else
If Not $bRemoved Then
$aAttackBar[$i][4] = Number(getTroopCountSmall(Number($aAttackBar[$i][5]), Number($aAttackBar[$i][6])))
If $aAttackBar[$i][4] = 0 Then $aAttackBar[$i][4] = Number(getTroopCountBig(Number($aAttackBar[$i][5]), Number($aAttackBar[$i][6] - 2)))
EndIf
If StringRegExp($aAttackBar[$i][0], "(LSpell)|(ESpell)", 0) And $g_bSmartZapEnable Then
Local $iSpellLevel = Number(getTroopsSpellsLevel(Number($aAttackBar[$i][5]) - 20, 704))
If StringInStr($aAttackBar[$i][0], "LSpell") <> 0 And $iSpellLevel > 0 Then $g_iLSpellLevel = $iSpellLevel
If StringInStr($aAttackBar[$i][0], "ESpell") <> 0 And $iSpellLevel > 0 Then $g_iESpellLevel = $iSpellLevel
EndIf
EndIf
Local $aTempFinalArray[1][7] = [[TroopIndexLookup($aAttackBar[$i][0]), $aAttackBar[$i][3], $aAttackBar[$i][4], $aAttackBar[$i][1], $aAttackBar[$i][2], $aAttackBar[$i][5], $aAttackBar[$i][6]]]
_ArrayAdd($aFinalAttackBar, $aTempFinalArray)
EndIf
Next
If($pMatchMode <= $LB And $bCheckSlot12 And Not $bDoubleRow And UBound($aAttackBar) > 1 And $g_aiAttackAlgorithm[$pMatchMode] <> 3) Or($bDebug And $bCheckSlot12) Then
DragAttackBar()
Local $aExtendedArray = ExtendedAttackBarCheck($aAttackBar, $bRemaining, $sSearchDiamond)
_ArrayAdd($aFinalAttackBar, $aExtendedArray)
If Not $bRemaining Then
$g_iTotalAttackSlot = UBound($aFinalAttackBar, 1) - 1
DragAttackBar($g_iTotalAttackSlot, True)
EndIf
EndIf
_ArraySort($aFinalAttackBar, 0, 0, 0, 1)
Return $aFinalAttackBar
EndFunc
Func ExtendedAttackBarCheck($aAttackBarFirstSearch, $bRemaining, $sSearchDiamond)
Local Static $aAttackBar[0][8]
Local $iLastSlotNumber = _ArrayMax($aAttackBarFirstSearch, 0, -1, -1, 3)
Local $sLastTroopName = $aAttackBarFirstSearch[_ArrayMaxIndex($aAttackBarFirstSearch, 0, -1, -1, 1)][0], $aiOCRLocation[2] = [-1, -1]
Local $aSlotAmountX[0][3]
If Not $bRemaining Then
Local $aDummyArray[0][8]
$aAttackBar = $aDummyArray
$g_iTotalAttackSlot = 11
EndIf
If Not $g_bRunState Then Return
If UBound($aAttackBar) = 0 Or Not $bRemaining Then
Local $iAttackbarStart = __TimerInit()
Local $aTempArray, $aTempCoords, $aTempMultiCoords, $iRow = 1
Local $aAttackBarResult = findMultiple($g_sImgAttackBarDir, $sSearchDiamond, $sSearchDiamond, 0, 1000, 0, "objectname,objectpoints", True)
If UBound($aAttackBarResult) = 0 Then
SetLog("Error in AttackBarCheck(): Search did not return any results!", $COLOR_ERROR)
DebugImageSave("ErrorAttackBarCheck", False, Default, Default, "#2")
Return ""
EndIf
For $i = 0 To UBound($aAttackBarResult, 1) - 1
$aTempArray = $aAttackBarResult[$i]
$aTempMultiCoords = decodeMultipleCoords($aTempArray[1], 60, 60, -1)
For $j = 0 To UBound($aTempMultiCoords, 1) - 1
$aTempCoords = $aTempMultiCoords[$j]
If UBound($aTempCoords) < 2 Then ContinueLoop
If StringRegExp($aTempArray[0], "(AmountX)", 0) Then
_ArrayAdd($aSlotAmountX, $aTempCoords[0] & "|" & $aTempCoords[1] & "|" & $iRow, 0, "|", @CRLF, $ARRAYFILL_FORCE_NUMBER)
$aiOCRLocation[$iRow - 1] = $aTempCoords[1]
Else
If StringRegExp($aTempArray[0], "(King)|(Queen)|(Warden)", 0) Then _ArrayAdd($aSlotAmountX, $aTempCoords[0] & "|" & $aTempCoords[1] & "|" & $iRow, 0, "|", @CRLF, $ARRAYFILL_FORCE_NUMBER)
Local $aTempElement[1][8] = [[$aTempArray[0], $aTempCoords[0], $aTempCoords[1], -1, -1, -1, -1, $iRow]]
_ArrayAdd($aAttackBar, $aTempElement)
EndIf
Next
Next
If UBound($aAttackBar, 1) = 0 Then
SetLog("Error in AttackBarCheck(): $aAttackBar has no results in it", $COLOR_ERROR)
Return ""
EndIf
_ArraySort($aAttackBar, 0, 0, 0, 1)
_ArraySort($aSlotAmountX)
SetDebugLog("AttackBarCheck(): Finished Image Search in: " & StringFormat("%.2f", __TimerDiff($iAttackbarStart)) & " ms")
$iAttackbarStart = __TimerInit()
EndIf
Local $aFinalAttackBar[0][7]
Local $aiOCRY = [-1, -1]
Local $sKeepRemainTroops = "(King)|(Queen)|(Warden)|(WallW)|(BattleB)|(StoneS)"
If Not $bRemaining Then
$aiOCRY = GetOCRYLocation($aSlotAmountX)
Local $iLastTroopIndex = _ArraySearch($aAttackBar, $sLastTroopName, 0, 0, 0, 0, 1, 0) + 1
$aAttackBar = _ArrayExtract($aAttackBar, $iLastTroopIndex)
$aSlotAmountX = _ArrayExtract($aSlotAmountX, $iLastTroopIndex)
EndIf
For $i = 0 To UBound($aAttackBar, 1) - 1
If $aAttackBar[$i][1] > 0 Then
Local $bRemoved = False
If Not $g_bRunState Then Return
If _Sleep(20) Then Return
If $bRemaining Then
$aTroopIsDeployed[0] = $aAttackBar[$i][5] - 15
$aTroopIsDeployed[1] = $aAttackBar[$i][6]
If _CheckPixel($aTroopIsDeployed, True) Then
$bRemoved = True
$aAttackBar[$i][4] = 0
If StringRegExp($aAttackBar[$i][0], $sKeepRemainTroops, 0) = 0 Then
SetDebugLog("AttackBarCheck(): Troop " & $aAttackBar[$i][0] & " already deployed, now removed")
ContinueLoop
Else
SetDebugLog("AttackBarCheck(): Troop " & $aAttackBar[$i][0] & " already deployed, but stays")
EndIf
EndIf
Else
Local $aTempSlot = AttackSlot(Number($aAttackBar[$i][1]), Number($aAttackBar[$i][7]), $aSlotAmountX)
$aAttackBar[$i][5] = Number($aTempSlot[0])
$aAttackBar[$i][6] = Number($aTempSlot[1])
$aAttackBar[$i][3] = Number($aTempSlot[2] + $iLastSlotNumber + 1)
If StringRegExp($aAttackBar[$i][0], "(King)|(Queen)|(Warden)", 0) And $aiOCRY[$aAttackBar[$i][7] - 1] <> -1 Then $aAttackBar[$i][6] =($aiOCRY[$aAttackBar[$i][7] - 1] - 7)
EndIf
If StringRegExp($aAttackBar[$i][0], "(King)|(Queen)|(Warden)|(Castle)|(WallW)|(BattleB)|(StoneS)", 0) Then
If Not $bRemoved Then $aAttackBar[$i][4] = 1
Else
If Not $bRemoved Then
$aAttackBar[$i][4] = Number(getTroopCountSmall(Number($aAttackBar[$i][5]), Number($aAttackBar[$i][6])))
If $aAttackBar[$i][4] = 0 Then $aAttackBar[$i][4] = Number(getTroopCountBig(Number($aAttackBar[$i][5]), Number($aAttackBar[$i][6] - 2)))
EndIf
If StringRegExp($aAttackBar[$i][0], "(LSpell)|(ESpell)", 0) And $g_bSmartZapEnable Then
Local $iSpellLevel = Number(getTroopsSpellsLevel(Number($aAttackBar[$i][5]) - 20, 704))
If StringInStr($aAttackBar[$i][0], "LSpell") <> 0 And $iSpellLevel > 0 Then $g_iLSpellLevel = $iSpellLevel
If StringInStr($aAttackBar[$i][0], "ESpell") <> 0 And $iSpellLevel > 0 Then $g_iESpellLevel = $iSpellLevel
EndIf
EndIf
Local $aTempFinalArray[1][7] = [[TroopIndexLookup($aAttackBar[$i][0]), $aAttackBar[$i][3], $aAttackBar[$i][4], $aAttackBar[$i][1], $aAttackBar[$i][2], $aAttackBar[$i][5], $aAttackBar[$i][6]]]
_ArrayAdd($aFinalAttackBar, $aTempFinalArray)
EndIf
Next
_ArraySort($aFinalAttackBar, 0, 0, 0, 1)
Return $aFinalAttackBar
EndFunc
Func GetOCRYLocation($aArray)
Local $aiReturn[2] = [-1, -1], $aTempArray[0], $aTempArray2[0]
For $i = 0 To UBound($aArray, 1) - 1
If $aArray[$i][2] = 1 Then
_ArrayAdd($aTempArray, $aArray[$i][1])
Else
_ArrayAdd($aTempArray2, $aArray[$i][1])
EndIf
Next
$aiReturn[0] = _ArrayMin($aTempArray)
$aiReturn[1] = _ArrayMin($aTempArray2)
Return $aiReturn
EndFunc
Func SearchNearest($aArray, $iNumber, $iRow)
Local $iVal, $iValOld = _ArrayMax($aArray), $iReturn
For $i = 0 To UBound($aArray) - 1
$iVal = Abs($aArray[$i][0] - $iNumber)
If $iValOld >= $iVal And $iRow = Number($aArray[$i][2]) Then
$iValOld = $iVal
$iReturn = $i
EndIf
Next
Return $iReturn
EndFunc
Func SortDoubleRowXElements($aArray)
Local $aSecondRow[0][3]
Local $aNewSlotAmountX[0][3]
For $i = 0 To UBound($aArray) - 1
If $aArray[$i][2] = 2 Then
_ArrayAdd($aSecondRow, _ArrayExtract($aArray, $i, $i))
Else
_ArrayAdd($aNewSlotAmountX, _ArrayExtract($aArray, $i, $i))
EndIf
Next
_ArraySort($aNewSlotAmountX)
_ArraySort($aSecondRow)
_ArrayAdd($aNewSlotAmountX, $aSecondRow)
Return $aNewSlotAmountX
EndFunc
Func DragAttackBar($iTotalSlot = 20, $bBack = False)
If $g_iTotalAttackSlot > 10 Then $iTotalSlot = $g_iTotalAttackSlot
Local $bAlreadyDrag = False
If Not $bBack Then
SetDebugLog("Dragging attack troop bar to 2nd page. Distance = " & $iTotalSlot - 9 & " slots")
ClickDrag(25 + 73 *($iTotalSlot - 9), 660, 25, 660, 1000)
If _Sleep(1000 + $iTotalSlot * 25) Then Return
$bAlreadyDrag = True
Else
SetDebugLog("Dragging attack troop bar back to 1st page. Distance = " & $iTotalSlot - 9 & " slots")
ClickDrag(25, 660, 25 + 73 *($iTotalSlot - 9), 660, 1000)
If _Sleep(800 + $iTotalSlot * 25) Then Return
$bAlreadyDrag = False
EndIf
$g_bDraggedAttackBar = $bAlreadyDrag
$g_iCSVLastTroopPositionDropTroopFromINI = -1
Return $bAlreadyDrag
EndFunc
Func AttackSlot($iPosX, $iRow, $aSlots)
Local $aTempSlot[3] = [0, 0, 0]
Local $iClosest = SearchNearest($aSlots, $iPosX, $iRow)
Local $bLast = False
If $iClosest = _ArrayMaxIndex($aSlots, 0) And $aSlots[$iClosest][0] >=($g_iGAME_WIDTH - 60) Then $bLast = True
If $iClosest >= 0 And $iClosest < UBound($aSlots) Then
$aTempSlot[0] = $bLast ? $g_iGAME_WIDTH - 53 : $aSlots[$iClosest][0] - 15
$aTempSlot[1] = $aSlots[$iClosest][1] - 7
$aTempSlot[2] = $iClosest
EndIf
Return $aTempSlot
EndFunc
Func algorithm_AllTroops()
If $g_bDebugSetlog Then SetDebugLog("algorithm_AllTroops()", $COLOR_DEBUG)
SetSlotSpecialTroops()
If _Sleep($DELAYALGORITHM_ALLTROOPS1) Then Return
If $g_aiAttackStdDropSides[$g_iMatchMode] <> 4 Then SmartAttackStrategy($g_iMatchMode)
If($g_iSearchTH = "-" And($g_iMatchMode = $DB And $g_bTHSnipeBeforeEnable[$DB])) Or($g_iSearchTH = "-" And($g_iMatchMode = $LB And $g_bTHSnipeBeforeEnable[$LB])) Then
FindTownHall(True)
EndIf
Local $bTHSearchTemp = SearchTownHallLoc()
If $g_iMatchMode = $TS Or($g_iMatchMode = $DB And $g_bTHSnipeBeforeEnable[$DB] And $bTHSearchTemp = True) Or($g_iMatchMode = $LB And $g_bTHSnipeBeforeEnable[$LB] And $bTHSearchTemp = True) Then
SwitchAttackTHType()
EndIf
If $g_iMatchMode = $TS Then
If($g_bTHSnipeUsedKing = True Or $g_bTHSnipeUsedQueen = True) And($g_bSmartZapEnable = True And $g_bSmartZapSaveHeroes = True) Then
SetLog("King and/or Queen dropped, close attack")
If $g_bSmartZapEnable = True Then SetLog("Skipping SmartZap to protect your royals!", $COLOR_FUCHSIA)
ElseIf IsAttackPage() And Not SmartZap() And $g_bTHSnipeUsedKing = False And $g_bTHSnipeUsedQueen = False Then
SetLog("Wait few sec before close attack")
If _Sleep(Random(0, 2, 1) * 1000) Then Return
EndIf
If CompareResources($DB) And $g_aiAttackAlgorithm[$DB] = 0 And $g_bEndTSCampsEnable And Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) >= Int($g_iEndTSCampsPct) Then
$g_iMatchMode = $DB
Else
CloseBattle()
Return
EndIf
EndIf
Local $nbSides = 0
Switch $g_aiAttackStdDropSides[$g_iMatchMode]
Case 0
SetLog("Attacking on a single side", $COLOR_INFO)
$nbSides = 1
Case 1
SetLog("Attacking on two sides", $COLOR_INFO)
$nbSides = 2
Case 2
SetLog("Attacking on three sides", $COLOR_INFO)
$nbSides = 3
Case 3
SetLog("Attacking on all sides", $COLOR_INFO)
$nbSides = 4
Case 4
SetLog("Attacking four finger fight style", $COLOR_INFO)
$nbSides = 5
Case 5
SetLog("Attacking on Dark Elixir Side.", $COLOR_INFO)
$nbSides = 1
If Not($g_abAttackStdSmartAttack[$g_iMatchMode]) Then GetBuildingEdge($eSideBuildingDES)
Case 6
SetLog("Attacking on Town Hall Side.", $COLOR_INFO)
$nbSides = 1
If Not($g_abAttackStdSmartAttack[$g_iMatchMode]) Then GetBuildingEdge($eSideBuildingTH)
EndSwitch
If($nbSides = 0) Then Return
If _Sleep($DELAYALGORITHM_ALLTROOPS2) Then Return
$g_iSidesAttack = $nbSides
$g_iSlotsGiants = 0
Local $GiantComp = 0
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eGiant Then
$GiantComp = $g_avAttackTroops[$i][1]
EndIf
Next
Switch $GiantComp
Case 0 To 10
$g_iSlotsGiants = 2
Case Else
Switch $nbSides
Case 1 To 2
$g_iSlotsGiants = 4
Case Else
$g_iSlotsGiants = 0
EndSwitch
EndSwitch
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Switch $g_aiAttackStdDropOrder[$g_iMatchMode]
Case 0
If $g_bCustomDropOrderEnable Then
Local $listInfoDeploy[23][5] = [[MatchTroopDropName(0), MatchSidesDrop(0), MatchTroopWaveNb(0), 1, MatchSlotsPerEdge(0)], [MatchTroopDropName(1), MatchSidesDrop(1), MatchTroopWaveNb(1), 1, MatchSlotsPerEdge(1)], [MatchTroopDropName(2), MatchSidesDrop(2), MatchTroopWaveNb(2), 1, MatchSlotsPerEdge(2)], [MatchTroopDropName(3), MatchSidesDrop(3), MatchTroopWaveNb(3), 1, MatchSlotsPerEdge(3)], [MatchTroopDropName(4), MatchSidesDrop(4), MatchTroopWaveNb(4), 1, MatchSlotsPerEdge(4)], [MatchTroopDropName(5), MatchSidesDrop(5), MatchTroopWaveNb(5), 1, MatchSlotsPerEdge(5)], [MatchTroopDropName(6), MatchSidesDrop(6), MatchTroopWaveNb(6), 1, MatchSlotsPerEdge(6)], [MatchTroopDropName(7), MatchSidesDrop(7), MatchTroopWaveNb(7), 1, MatchSlotsPerEdge(7)], [MatchTroopDropName(8), MatchSidesDrop(8), MatchTroopWaveNb(8), 1, MatchSlotsPerEdge(8)], [MatchTroopDropName(9), MatchSidesDrop(9), MatchTroopWaveNb(9), 1, MatchSlotsPerEdge(9)], [MatchTroopDropName(10), MatchSidesDrop(10), MatchTroopWaveNb(10), 1, MatchSlotsPerEdge(10)], [MatchTroopDropName(11), MatchSidesDrop(11), MatchTroopWaveNb(11), 1, MatchSlotsPerEdge(11)], [MatchTroopDropName(12), MatchSidesDrop(12), MatchTroopWaveNb(12), 1, MatchSlotsPerEdge(12)], [MatchTroopDropName(13), MatchSidesDrop(13), MatchTroopWaveNb(13), 1, MatchSlotsPerEdge(13)], [MatchTroopDropName(14), MatchSidesDrop(14), MatchTroopWaveNb(14), 1, MatchSlotsPerEdge(14)], [MatchTroopDropName(15), MatchSidesDrop(15), MatchTroopWaveNb(15), 1, MatchSlotsPerEdge(15)], [MatchTroopDropName(16), MatchSidesDrop(16), MatchTroopWaveNb(16), 1, MatchSlotsPerEdge(16)], [MatchTroopDropName(17), MatchSidesDrop(17), MatchTroopWaveNb(17), 1, MatchSlotsPerEdge(17)], [MatchTroopDropName(18), MatchSidesDrop(18), MatchTroopWaveNb(18), 1, MatchSlotsPerEdge(18)], [MatchTroopDropName(19), MatchSidesDrop(19), MatchTroopWaveNb(19), 1, MatchSlotsPerEdge(19)], [MatchTroopDropName(20), MatchSidesDrop(20), MatchTroopWaveNb(20), 1, MatchSlotsPerEdge(20)], [MatchTroopDropName(21), MatchSidesDrop(21), MatchTroopWaveNb(21), 1, MatchSlotsPerEdge(21)], [MatchTroopDropName(22), MatchSidesDrop(22), MatchTroopWaveNb(22), 1, MatchSlotsPerEdge(22)]]
Else
Local $listInfoDeploy[23][5] = [[$eGole, $nbSides, 1, 1, 2] , [$eLava, $nbSides, 1, 1, 2] , [$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , [$eDrag, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , [$eBall, $nbSides, 1, 1, 0] , [$eBabyD, $nbSides, 1, 1, 1] , [$eHogs, $nbSides, 1, 1, 1] , [$eValk, $nbSides, 1, 1, 0] , [$eBowl, $nbSides, 1, 1, 0] , [$eMine, $nbSides, 1, 1, 0] , [$eEDrag, $nbSides, 1, 1, 0] , [$eBarb, $nbSides, 1, 1, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 1, 0] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eWitc, $nbSides, 1, 1, 1] , [$eGobl, $nbSides, 1, 1, 0] , [$eHeal, $nbSides, 1, 1, 1] , [$ePekk, $nbSides, 1, 1, 1] , [$eIceG, $nbSides, 1, 1, 0] , ["HEROES", 1, 2, 1, 1] ]
EndIf
Case 1
Local $listInfoDeploy[6][5] = [[$eBarb, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 1, 1, 0] , [$eGobl, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
Case 2
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , ["CC", 1, 1, 1, 1] , [$eWall, $nbSides, 1, 1, 2] , [$eBarb, $nbSides, 1, 2, 2] , [$eArch, $nbSides, 1, 3, 3] , [$eBarb, $nbSides, 2, 2, 2] , [$eArch, $nbSides, 2, 3, 3] , ["HEROES", 1, 2, 1, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 3, 3, 2] , [$eGobl, $nbSides, 1, 1, 1] ]
EndSwitch
ElseIf $nbSides = 5 Then
If $g_bCustomDropOrderEnable Then
Local $listInfoDeploy[23][5] = [[MatchTroopDropName(0), MatchSidesDrop(0), MatchTroopWaveNb(0), 1, MatchSlotsPerEdge(0)], [MatchTroopDropName(1), MatchSidesDrop(1), MatchTroopWaveNb(1), 1, MatchSlotsPerEdge(1)], [MatchTroopDropName(2), MatchSidesDrop(2), MatchTroopWaveNb(2), 1, MatchSlotsPerEdge(2)], [MatchTroopDropName(3), MatchSidesDrop(3), MatchTroopWaveNb(3), 1, MatchSlotsPerEdge(3)], [MatchTroopDropName(4), MatchSidesDrop(4), MatchTroopWaveNb(4), 1, MatchSlotsPerEdge(4)], [MatchTroopDropName(5), MatchSidesDrop(5), MatchTroopWaveNb(5), 1, MatchSlotsPerEdge(5)], [MatchTroopDropName(6), MatchSidesDrop(6), MatchTroopWaveNb(6), 1, MatchSlotsPerEdge(6)], [MatchTroopDropName(7), MatchSidesDrop(7), MatchTroopWaveNb(7), 1, MatchSlotsPerEdge(7)], [MatchTroopDropName(8), MatchSidesDrop(8), MatchTroopWaveNb(8), 1, MatchSlotsPerEdge(8)], [MatchTroopDropName(9), MatchSidesDrop(9), MatchTroopWaveNb(9), 1, MatchSlotsPerEdge(9)], [MatchTroopDropName(10), MatchSidesDrop(10), MatchTroopWaveNb(10), 1, MatchSlotsPerEdge(10)], [MatchTroopDropName(11), MatchSidesDrop(11), MatchTroopWaveNb(11), 1, MatchSlotsPerEdge(11)], [MatchTroopDropName(12), MatchSidesDrop(12), MatchTroopWaveNb(12), 1, MatchSlotsPerEdge(12)], [MatchTroopDropName(13), MatchSidesDrop(13), MatchTroopWaveNb(13), 1, MatchSlotsPerEdge(13)], [MatchTroopDropName(14), MatchSidesDrop(14), MatchTroopWaveNb(14), 1, MatchSlotsPerEdge(14)], [MatchTroopDropName(15), MatchSidesDrop(15), MatchTroopWaveNb(15), 1, MatchSlotsPerEdge(15)], [MatchTroopDropName(16), MatchSidesDrop(16), MatchTroopWaveNb(16), 1, MatchSlotsPerEdge(16)], [MatchTroopDropName(17), MatchSidesDrop(17), MatchTroopWaveNb(17), 1, MatchSlotsPerEdge(17)], [MatchTroopDropName(18), MatchSidesDrop(18), MatchTroopWaveNb(18), 1, MatchSlotsPerEdge(18)], [MatchTroopDropName(19), MatchSidesDrop(19), MatchTroopWaveNb(19), 1, MatchSlotsPerEdge(19)], [MatchTroopDropName(20), MatchSidesDrop(20), MatchTroopWaveNb(20), 1, MatchSlotsPerEdge(20)], [MatchTroopDropName(21), MatchSidesDrop(21), MatchTroopWaveNb(21), 1, MatchSlotsPerEdge(21)], [MatchTroopDropName(22), MatchSidesDrop(22), MatchTroopWaveNb(22), 1, MatchSlotsPerEdge(22)]]
Else
Local $listInfoDeploy[23][5] = [[$eGole, $nbSides, 1, 1, 2], [$eLava, $nbSides, 1, 1, 2], [$eGiant, $nbSides, 1, 1, $g_iSlotsGiants], [$eDrag, $nbSides, 1, 1, 2], ["CC", 1, 1, 1, 1], [$eBall, $nbSides, 1, 1, 2], [$eBabyD, $nbSides, 1, 1, 0], [$eHogs, $nbSides, 1, 1, 2], [$eValk, $nbSides, 1, 1, 2], [$eBowl, $nbSides, 1, 1, 0], [$eIceG, $nbSides, 1, 1, 2], [$eMine, $nbSides, 1, 1, 0], [$eEDrag, $nbSides, 1, 1, 2], [$eBarb, $nbSides, 1, 1, 0], [$eWall, $nbSides, 1, 1, 2], [$eArch, $nbSides, 1, 1, 0], [$eWiza, $nbSides, 1, 1, 2], [$eMini, $nbSides, 1, 1, 0], [$eWitc, $nbSides, 1, 1, 2], [$eGobl, $nbSides, 1, 1, 0], [$eHeal, $nbSides, 1, 1, 2], [$ePekk, $nbSides, 1, 1, 2], ["HEROES", 1, 2, 1, 1]]
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("listdeploy standard for attack", $COLOR_DEBUG)
Switch $g_aiAttackStdDropOrder[$g_iMatchMode]
Case 0
If $g_bCustomDropOrderEnable Then
Local $listInfoDeploy[23][5] = [[MatchTroopDropName(0), MatchSidesDrop(0), MatchTroopWaveNb(0), 1, MatchSlotsPerEdge(0)], [MatchTroopDropName(1), MatchSidesDrop(1), MatchTroopWaveNb(1), 1, MatchSlotsPerEdge(1)], [MatchTroopDropName(2), MatchSidesDrop(2), MatchTroopWaveNb(2), 1, MatchSlotsPerEdge(2)], [MatchTroopDropName(3), MatchSidesDrop(3), MatchTroopWaveNb(3), 1, MatchSlotsPerEdge(3)], [MatchTroopDropName(4), MatchSidesDrop(4), MatchTroopWaveNb(4), 1, MatchSlotsPerEdge(4)], [MatchTroopDropName(5), MatchSidesDrop(5), MatchTroopWaveNb(5), 1, MatchSlotsPerEdge(5)], [MatchTroopDropName(6), MatchSidesDrop(6), MatchTroopWaveNb(6), 1, MatchSlotsPerEdge(6)], [MatchTroopDropName(7), MatchSidesDrop(7), MatchTroopWaveNb(7), 1, MatchSlotsPerEdge(7)], [MatchTroopDropName(8), MatchSidesDrop(8), MatchTroopWaveNb(8), 1, MatchSlotsPerEdge(8)], [MatchTroopDropName(9), MatchSidesDrop(9), MatchTroopWaveNb(9), 1, MatchSlotsPerEdge(9)], [MatchTroopDropName(10), MatchSidesDrop(10), MatchTroopWaveNb(10), 1, MatchSlotsPerEdge(10)], [MatchTroopDropName(11), MatchSidesDrop(11), MatchTroopWaveNb(11), 1, MatchSlotsPerEdge(11)], [MatchTroopDropName(12), MatchSidesDrop(12), MatchTroopWaveNb(12), 1, MatchSlotsPerEdge(12)], [MatchTroopDropName(13), MatchSidesDrop(13), MatchTroopWaveNb(13), 1, MatchSlotsPerEdge(13)], [MatchTroopDropName(14), MatchSidesDrop(14), MatchTroopWaveNb(14), 1, MatchSlotsPerEdge(14)], [MatchTroopDropName(15), MatchSidesDrop(15), MatchTroopWaveNb(15), 1, MatchSlotsPerEdge(15)], [MatchTroopDropName(16), MatchSidesDrop(16), MatchTroopWaveNb(16), 1, MatchSlotsPerEdge(16)], [MatchTroopDropName(17), MatchSidesDrop(17), MatchTroopWaveNb(17), 1, MatchSlotsPerEdge(17)], [MatchTroopDropName(18), MatchSidesDrop(18), MatchTroopWaveNb(18), 1, MatchSlotsPerEdge(18)], [MatchTroopDropName(19), MatchSidesDrop(19), MatchTroopWaveNb(19), 1, MatchSlotsPerEdge(19)], [MatchTroopDropName(20), MatchSidesDrop(20), MatchTroopWaveNb(20), 1, MatchSlotsPerEdge(20)], [MatchTroopDropName(21), MatchSidesDrop(21), MatchTroopWaveNb(21), 1, MatchSlotsPerEdge(21)], [MatchTroopDropName(22), MatchSidesDrop(22), MatchTroopWaveNb(22), 1, MatchSlotsPerEdge(22)]]
Else
Local $listInfoDeploy[23][5] = [[$eGole, $nbSides, 1, 1, 2] , [$eLava, $nbSides, 1, 1, 2] , [$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , [$eDrag, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , [$eBall, $nbSides, 1, 1, 0] , [$eBabyD, $nbSides, 1, 1, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eValk, $nbSides, 1, 1, 0] , [$eBowl, $nbSides, 1, 1, 0] , [$eIceG, $nbSides, 1, 1, 0] , [$eMine, $nbSides, 1, 1, 0] , [$eEDrag, $nbSides, 1, 1, 0] , [$eBarb, $nbSides, 1, 1, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 1, 0] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eWitc, $nbSides, 1, 1, 1] , [$eGobl, $nbSides, 1, 1, 0] , [$eHeal, $nbSides, 1, 1, 1] , [$ePekk, $nbSides, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
EndIf
Case 1
Local $listInfoDeploy[6][5] = [[$eBarb, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 1, 1, 0] , [$eGobl, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
Case 2
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , ["CC", 1, 1, 1, 1] , [$eBarb, $nbSides, 1, 2, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 2, 0] , [$eBarb, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 1, 2, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 2, 2, 0] , ["HEROES", 1, 2, 1, 1] ]
Case Else
SetLog("Algorithm type unavailable, defaulting to regular", $COLOR_ERROR)
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , ["CC", 1, 1, 1, 1] , [$eBarb, $nbSides, 1, 2, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 2, 0] , [$eBarb, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 1, 2, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 2, 2, 0] , ["HEROES", 1, 2, 1, 1] ]
EndSwitch
EndIf
$g_bIsCCDropped = False
$g_aiDeployCCPosition[0] = -1
$g_aiDeployCCPosition[1] = -1
$g_bIsHeroesDropped = False
$g_aiDeployHeroesPosition[0] = -1
$g_aiDeployHeroesPosition[1] = -1
LaunchTroop2($listInfoDeploy, $g_iClanCastleSlot, $g_iKingSlot, $g_iQueenSlot, $g_iWardenSlot)
CheckHeroesHealth()
If _Sleep($DELAYALGORITHM_ALLTROOPS4) Then Return
SetLog("Dropping left over troops", $COLOR_INFO)
For $x = 0 To 1
If PrepareAttack($g_iMatchMode, True) = 0 Then
If $g_bDebugSetlog Then SetDebugLog("No Wast time... exit, no troops usable left", $COLOR_DEBUG)
ExitLoop
EndIf
For $i = $eBarb To $eIceG
If LaunchTroop($i, $nbSides, 1, 1, 1) Then
CheckHeroesHealth()
If _Sleep($DELAYALGORITHM_ALLTROOPS5) Then Return
EndIf
Next
Next
CheckHeroesHealth()
SetLog("Finished Attacking, waiting for the battle to end")
EndFunc
Func SetSlotSpecialTroops()
$g_iKingSlot = -1
$g_iQueenSlot = -1
$g_iClanCastleSlot = -1
$g_iWardenSlot = -1
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eCastle Or $g_avAttackTroops[$i][0] = $eWallW Or $g_avAttackTroops[$i][0] = $eBattleB Or $g_avAttackTroops[$i][0] = $eStoneS Then
$g_iClanCastleSlot = $i
ElseIf $g_avAttackTroops[$i][0] = $eKing Then
$g_iKingSlot = $i
ElseIf $g_avAttackTroops[$i][0] = $eQueen Then
$g_iQueenSlot = $i
ElseIf $g_avAttackTroops[$i][0] = $eWarden Then
$g_iWardenSlot = $i
EndIf
Next
If $g_bDebugSetlog Then
SetDebugLog("SetSlotSpecialTroops() King Slot: " & $g_iKingSlot, $COLOR_DEBUG)
SetDebugLog("SetSlotSpecialTroops() Queen Slot: " & $g_iQueenSlot, $COLOR_DEBUG)
SetDebugLog("SetSlotSpecialTroops() Warden Slot: " & $g_iWardenSlot, $COLOR_DEBUG)
SetDebugLog("SetSlotSpecialTroops() Clan Castle Slot: " & $g_iClanCastleSlot, $COLOR_DEBUG)
EndIf
EndFunc
Func CloseBattle()
If IsAttackPage() Then
For $i = 1 To 30
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) = True Then ExitLoop
If _Sleep($DELAYALGORITHM_ALLTROOPS2) Then Return
Next
EndIf
If IsAttackPage() Then ClickP($aSurrenderButton, 1, 0, "#0030")
If _Sleep($DELAYALGORITHM_ALLTROOPS3) Then Return
If IsEndBattlePage() Then
ClickP($aConfirmSurrender, 1, 0, "#0031")
If _Sleep($DELAYALGORITHM_ALLTROOPS1) Then Return
EndIf
EndFunc
Func SmartAttackStrategy($imode)
If $g_iMatchMode <> $MA Then
If($g_abAttackStdSmartAttack[$imode]) Then
SetLog("Calculating Smart Attack Strategy", $COLOR_INFO)
Local $hTimer = __TimerInit()
_CaptureRegion2()
_GetRedArea()
SetLog("Calculated  (in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds) :")
If($g_abAttackStdSmartNearCollectors[$imode][0] Or $g_abAttackStdSmartNearCollectors[$imode][1] Or $g_abAttackStdSmartNearCollectors[$imode][2]) Then
SetLog("Locating Mines, Collectors & Drills", $COLOR_INFO)
$hTimer = __TimerInit()
Global $g_aiPixelMine[0]
Global $g_aiPixelElixir[0]
Global $g_aiPixelDarkElixir[0]
Global $g_aiPixelNearCollector[0]
If $g_abAttackStdSmartNearCollectors[$imode][0] Then
$g_aiPixelMine = GetLocationMine()
If(IsArray($g_aiPixelMine)) Then
_ArrayAdd($g_aiPixelNearCollector, $g_aiPixelMine, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
EndIf
EndIf
If $g_abAttackStdSmartNearCollectors[$imode][1] Then
$g_aiPixelElixir = GetLocationElixir()
If(IsArray($g_aiPixelElixir)) Then
_ArrayAdd($g_aiPixelNearCollector, $g_aiPixelElixir, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
EndIf
EndIf
If $g_abAttackStdSmartNearCollectors[$imode][2] Then
$g_aiPixelDarkElixir = GetLocationDarkElixir()
If(IsArray($g_aiPixelDarkElixir)) Then
_ArrayAdd($g_aiPixelNearCollector, $g_aiPixelDarkElixir, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
EndIf
EndIf
SetLog("Located  (in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds) :")
SetLog("[" & UBound($g_aiPixelMine) & "] Gold Mines")
SetLog("[" & UBound($g_aiPixelElixir) & "] Elixir Collectors")
SetLog("[" & UBound($g_aiPixelDarkElixir) & "] Dark Elixir Drill/s")
$g_aiNbrOfDetectedMines[$imode] += UBound($g_aiPixelMine)
$g_aiNbrOfDetectedCollectors[$imode] += UBound($g_aiPixelElixir)
$g_aiNbrOfDetectedDrills[$imode] += UBound($g_aiPixelDarkElixir)
UpdateStats()
EndIf
EndIf
EndIf
EndFunc
Func AttackTHGrid($troopKind, $iNbOfSpots = 1, $iAtEachSpot = 1, $Sleep = Random(800, 900, 1), $waveNb = 0)
$g_iSidesAttack = 1
Local $TroopCountBeg
Local $THtroop = -1
Local $troopNb = 0
Local $name = ""
Local $waveName = "first"
Local $NumTroopDeployed = 0
If _Sleep(5) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $troopKind Then
$THtroop = $i
EndIf
Next
If($THtroop = -1) And $g_bDebugSetlog Then SetLog("No " & $name & " Found!!!")
If($THtroop = -1) Then Return False
If $troopKind >= $eKing And $troopKind <= $eCastle Then
$iNbOfSpots = 1
$iAtEachSpot = 1
$troopNb = 1
If $troopKind = $eKing Then
If $g_bDuringMilkingAttack = False And BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing) <> $eHeroKing Then Return
If $g_bDuringMilkingAttack = True And BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing) <> $eHeroKing Then Return
$g_bCheckKingPower = True
SetLog("Dropping King", $COLOR_SUCCESS)
$g_bTHSnipeUsedKing = True
EndIf
If $troopKind = $eQueen Then
If $g_bDuringMilkingAttack = False And BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen) <> $eHeroQueen Then Return
If $g_bDuringMilkingAttack = True And BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen) <> $eHeroQueen Then Return
$g_bCheckQueenPower = True
SetLog("Dropping Queen", $COLOR_SUCCESS)
$g_bTHSnipeUsedQueen = True
EndIf
If $troopKind = $eWarden Then
If $g_bDuringMilkingAttack = False And BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden) <> $eHeroWarden Then Return
If $g_bDuringMilkingAttack = True And BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden) <> $eHeroWarden Then Return
$g_bCheckWardenPower = True
SetLog("Dropping Grand Warden", $COLOR_SUCCESS)
$g_bTHSnipeUsedWarden = True
EndIf
If $troopKind = $eCastle Then
If $g_bDuringMilkingAttack = False And $g_abAttackDropCC[$TS] Then Return
If $g_bDuringMilkingAttack = True And $g_abAttackDropCC[$DB] Then Return
If $g_bPlannedDropCCHoursEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abPlannedDropCCHours[$hour[0]] = False Then
SetLog("Drop Clan Castle not Planned, Skipped..", $COLOR_SUCCESS)
Return
EndIf
EndIf
If $g_bUseCCBalanced = True Then
If Number($g_iTroopsReceived) <> 0 Then
If Number(Number($g_iTroopsDonated) / Number($g_iTroopsReceived)) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") >= " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Else
SetLog("Not Dropping Clan Castle, donated  (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") < " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Return
EndIf
Else
If Number(Number($g_iTroopsDonated) / 1) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") >= " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Else
SetLog("Not Dropping Clan Castle, donated  (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") < " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
Return
EndIf
EndIf
EndIf
EndIf
EndIf
If $troopKind >= $eBarb And $troopKind <= $eIceG Then
$troopNb = $iNbOfSpots * $iAtEachSpot
$name = GetTroopName($troopKind, $troopNb)
$TroopCountBeg = Number(ReadTroopQuantity($THtroop))
If($TroopCountBeg = 0) And $g_bDebugSetlog Then SetLog("No " & $name & " Remaining!!!")
If($TroopCountBeg = 0) Then Return False
If $waveNb = 0 Then $waveName = "Only"
If $waveNb = 1 Then $waveName = "First"
If $waveNb = 2 Then $waveName = "Second"
If $waveNb = 3 Then $waveName = "Third"
If $waveNb = 4 Then $waveName = "Last"
SetLog("Dropping " & $waveName & " wave of " & $troopNb & " " & $name, $COLOR_SUCCESS)
EndIf
SelectDropTroop($THtroop)
If _Sleep($DELAYCASTSPELL1) Then Return
DeployTHNormal($iAtEachSpot, $iNbOfSpots)
If $troopKind >= $eBarb And $troopKind <= $eIceG Then
If $TroopCountBeg <> Number(ReadTroopQuantity($THtroop)) Then
$NumTroopDeployed = $TroopCountBeg - Number(ReadTroopQuantity($THtroop))
SetLog("Deployment of " & $NumTroopDeployed & " " & $name & " was Successful!")
If _Sleep($Sleep) Then Return
Else
SetLog("Deployment of " & $name & " wasn't Successful!")
EndIf
EndIf
If $troopKind >= $eKing And $troopKind <= $eCastle Then
SelectDropTroop(0)
If _Sleep($Sleep) Then Return
EndIf
EndFunc
Func DeployTHNormal($iAtEachSpot, $iNbOfSpots)
Local $aThx = 0, $aThy = 0
Switch $g_iTHside
Case 0
For $num = 0 To $iAtEachSpot - 1
For $i = $g_iTHi - 1 To $g_iTHi - 1 + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 25 - $i * 16
$aThy = 314 + $i * 12
Next
For $ii = $g_iTHi - 1 To $g_iTHi - 1 +($iNbOfSpots - 1)
$aThx = 25 + $ii * 16
$aThy = 314 - $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0019")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 1
For $num = 0 To $iAtEachSpot - 1
For $i = $g_iTHi To $g_iTHi + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 25 - $i * 16
$aThy = 314 - $i * 12
Next
For $ii = $g_iTHi To $g_iTHi +($iNbOfSpots - 1)
$aThx = 25 + $ii * 16
$aThy = 314 + $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0020")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 2
For $num = 0 To $iAtEachSpot - 1
For $i = $g_iTHi To $g_iTHi + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 830 + $i * 16
$aThy = 314 + $i * 12
Next
For $ii = $g_iTHi To $g_iTHi +($iNbOfSpots - 1)
$aThx = 830 - $ii * 16
$aThy = 314 - $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0021")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 3
For $num = 0 To $iAtEachSpot - 1
For $i = $g_iTHi + 1 To $g_iTHi + 1 + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 830 + $i * 16
$aThy = 314 - $i * 12
Next
For $ii = $g_iTHi + 1 To $g_iTHi + 1 +($iNbOfSpots - 1)
$aThx = 830 - $ii * 16
$aThy = 314 + $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0022")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
EndSwitch
EndFunc
Func SpellTHGrid($S)
If $g_bDuringMilkingAttack = False And(($S = $eHSpell And $g_abAttackUseHealSpell[$TS]) Or($S = $eLSpell And $g_abAttackUseLightSpell[$TS]) Or($S = $eRSpell And $g_abAttackUseRageSpell[$TS]) Or($S = $eJSpell And $g_abAttackUseJumpSpell[$TS]) Or($S = $eFSpell And $g_abAttackUseFreezeSpell[$TS]) Or($S = $ePSpell And $g_abAttackUsePoisonSpell[$TS]) Or($S = $eHaSpell And $g_abAttackUseHasteSpell[$TS]) Or($S = $eESpell And $g_abAttackUseEarthquakeSpell[$TS])) Or $g_bDuringMilkingAttack = True And(($S = $eHSpell And $g_abAttackUseHealSpell[$DB]) Or($S = $eLSpell And $g_abAttackUseLightSpell[$DB]) Or($S = $eRSpell And $g_abAttackUseRageSpell[$DB]) Or($S = $eJSpell And $g_abAttackUseJumpSpell[$DB]) Or($S = $eFSpell And $g_abAttackUseFreezeSpell[$DB]) Or($S = $ePSpell And $g_abAttackUsePoisonSpell[$DB]) Or($S = $eHaSpell And $g_abAttackUseHasteSpell[$DB]) Or($S = $eESpell And $g_abAttackUseEarthquakeSpell[$DB])) Then
If _Sleep(10) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
If $g_iTHi <= 15 Or $g_iTHside = 0 Or $g_iTHside = 2 Then
Switch $g_iTHside
Case 0
CastSpell($S, 114 + $g_iTHi * 16 + Ceiling(-2 * 16), 359 - $g_iTHi * 12 + Ceiling(-2 * 12))
Case 1
CastSpell($S, 117 + $g_iTHi * 16 + Ceiling(-2 * 16), 268 + $g_iTHi * 12 - Floor(-2 * 12))
Case 2
CastSpell($S, 743 - $g_iTHi * 16 - Floor(-2 * 16), 358 - $g_iTHi * 12 + Ceiling(-2 * 12))
Case 3
CastSpell($S, 742 - $g_iTHi * 16 - Floor(-2 * 16), 268 + $g_iTHi * 12 - Floor(-2 * 12))
EndSwitch
EndIf
If $g_iTHi > 15 And($g_iTHside = 1 Or $g_iTHside = 3) Then
CastSpell($S, $g_iTHx, $g_iTHy)
EndIf
EndIf
EndFunc
Func CastSpell($THSpell, $x, $y)
Local $Spell = -1
Local $name = ""
If _Sleep(10) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $THSpell Then
$Spell = $i
$name = GetTroopName($THSpell)
EndIf
Next
If $Spell > -1 Then
SetLog("Dropping " & $name)
SelectDropTroop($Spell)
If _Sleep($DELAYATTCKTHGRID1) Then Return
If IsAttackPage() Then Click($x, $y, 1, 0, "#0029")
Else
If $g_bDebugSetlog Then SetDebugLog("No " & $name & " Found")
EndIf
EndFunc
Func CheckOneStar($DelayInSec = 0, $Log = True, $CheckHeroes = True)
For $i = 0 To $DelayInSec
If _Sleep(5) Then Return True
If $g_bRestart = True Then Return True
If $CheckHeroes = True And($g_bCheckQueenPower = True Or $g_bCheckKingPower = True Or $g_bCheckWardenPower = True) Then CheckHeroesHealth()
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) Then
If $Log = True Then SetLog("Townhall has been destroyed!", $COLOR_ACTION)
If $g_bRestart = True Then Return True
If $g_bCheckQueenPower = True Then
SetLog("Activating Queen's power to restore some health before EndBattle", $COLOR_INFO)
SelectDropTroop($g_iQueenSlot)
$g_bCheckQueenPower = False
EndIf
If _Sleep(500) Then Return True
If $g_bRestart = True Then Return True
If $g_bCheckKingPower = True Then
SetLog("Activating King's power to restore some health before EndBattle", $COLOR_INFO)
SelectDropTroop($g_iKingSlot)
$g_bCheckKingPower = False
EndIf
If _Sleep(500) Then Return True
If $g_bRestart = True Then Return True
If $g_bCheckWardenPower = True Then
SetLog("Activating Warden's power to restore some health before EndBattle", $COLOR_INFO)
SelectDropTroop($g_iWardenSlot)
$g_bCheckWardenPower = False
EndIf
If $Log = True Then
If _Sleep(1000) Then Return
EndIf
Return True
Else
If $i <> 0 Then
If _Sleep(1000) Then Return True
If $g_bRestart = True Then Return True
EndIf
EndIf
Next
Return False
EndFunc
Func SwitchAttackTHType()
$g_bTHSnipeUsedKing = False
$g_bTHSnipeUsedQueen = False
AttackTHParseCSV()
EndFunc
Func AttackTHParseCSV($test = False)
If $g_bDebugSetlog Then SetDebugLog("AttackTHParseCSV start", $COLOR_DEBUG)
Local $f, $line, $acommand, $command
Local $attackCSVtoUse = ""
Switch $g_iMatchMode
Case $TS
$attackCSVtoUse = $g_sAtkTSType
Case $LB
$attackCSVtoUse = $g_iTHSnipeBeforeScript[$LB]
Case $DB
$attackCSVtoUse = $g_iTHSnipeBeforeScript[$DB]
EndSwitch
If FileExists($g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv") Then
$f = FileOpen($g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv", 0)
If $g_bDebugSetlog Then SetDebugLog("Use algorithm " & $attackCSVtoUse & ".csv", $COLOR_DEBUG)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
Select
Case $command = "TROOP" Or $command = ""
Case $command = "TEXT"
If $g_bDebugSetlog Then SetDebugLog(">> SETLOG(""" & $acommand[8] & """)")
SetLog($acommand[8], $COLOR_INFO)
Case StringInStr(StringUpper("-Barb-Arch-Giant-Gobl-Wall-Ball-Wiza-Heal-Drag-Pekk-BabyD-Mine-EDrag-Mini-Hogs-Valk-Gole-Witc-Lava-Bowl-IceG"), "-" & $command & "-") > 0
If $g_bDebugSetlog Then SetDebugLog(">> AttackTHGrid($e" & $command & ", Random (" & Int($acommand[2]) & "," & Int($acommand[3]) & ",1), Random(" & Int($acommand[4]) & "," & Int($acommand[5]) & ",1), Random(" & Int($acommand[6]) & "," & Int($acommand[7]) & ",1) )")
Local $iNbOfSpots
If Int($acommand[2]) = Int($acommand[3]) Then
$iNbOfSpots = Int($acommand[2])
Else
$iNbOfSpots = Random(Int($acommand[2]), Int($acommand[3]), 1)
EndIf
Local $iAtEachSpot
If Int($acommand[4]) = Int($acommand[5]) Then
$iAtEachSpot = Int($acommand[4])
Else
$iAtEachSpot = Random(Int($acommand[4]), Int($acommand[5]), 1)
EndIf
Local $Sleep
If Int($acommand[6]) = Int($acommand[7]) Then
$Sleep = Int($acommand[6])
Else
$Sleep = Random(Int($acommand[6]), Int($acommand[7]), 1)
EndIf
AttackTHGrid(Eval("e" & $command), $iNbOfSpots, $iAtEachSpot, $Sleep, 0)
Case $command = "WAIT"
If $g_bDebugSetlog Then SetDebugLog(">> GoldElixirChangeThSnipes(" & Int($acommand[7]) & ") ")
If CheckOneStar(Int($acommand[7]) / 2000) Then ExitLoop
If GoldElixirChangeThSnipes(Int($acommand[7]) / 2000) Then ExitLoop
Case StringInStr(StringUpper("-King-Queen-Castle-"), "-" & $command & "-") > 0
If $g_bDebugSetlog Then SetDebugLog(">> AttackTHGrid($e" & $command & ")")
AttackTHGrid(Eval("e" & $command))
Case StringInStr(StringUpper("-HSpell-RSpell-LSpell-JSpell-FSpell-PSpell-ESpell-HaSpell"), "-" & $command & "-") > 0
If $g_bDebugSetlog Then SetDebugLog(">> SpellTHGrid($e" & $command & ")")
SpellTHGrid(Eval("e" & $command))
Case StringInStr(StringUpper("-LSpell-"), "-" & $command & "-") > 0
If $g_bDebugSetlog Then SetDebugLog(">> CastSpell($e" & $command & ",$g_iTHx, $g_iTHy)")
CastSpell(Eval("e" & $command), $g_iTHx, $g_iTHy)
Case Else
SetLog("attack row bad, discard: " & $line, $COLOR_ERROR)
EndSelect
If $acommand[8] <> "" And $command <> "TEXT" And $command <> "TROOP" Then
If $g_bDebugSetlog Then SetDebugLog(">> SETLOG(""" & $acommand[8] & """)")
SETLOG($acommand[8], $COLOR_INFO)
EndIf
Else
If StringStripWS($acommand[1], 2) <> "" Then SetLog("attack row error, discard: " & $line, $COLOR_ERROR)
EndIf
If $g_bDebugSetlog Then SetDebugLog(">> CheckOneStar()")
If CheckOneStar() Then ExitLoop
WEnd
FileClose($f)
Else
SetLog("Cannot found THSnipe attack file " & $g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Global $MAINSIDE = "BOTTOM-RIGHT"
Global $FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
Global $FRONT_RIGHT = "BOTTOM-RIGHT-UP"
Global $RIGHT_FRONT = "TOP-RIGHT-DOWN"
Global $RIGHT_BACK = "TOP-RIGHT-UP"
Global $LEFT_FRONT = "BOTTOM-LEFT-DOWN"
Global $LEFT_BACK = "BOTTOM-LEFT-UP"
Global $BACK_LEFT = "TOP-LEFT-DOWN"
Global $BACK_RIGHT = "TOP-LEFT-UP"
Global $g_aiPixelTopLeftDropLine
Global $g_aiPixelTopRightDropLine
Global $g_aiPixelBottomLeftDropLine
Global $g_aiPixelBottomRightDropLine
Global $g_aiPixelTopLeftUPDropLine
Global $g_aiPixelTopLeftDOWNDropLine
Global $g_aiPixelTopRightUPDropLine
Global $g_aiPixelTopRightDOWNDropLine
Global $g_aiPixelBottomLeftUPDropLine
Global $g_aiPixelBottomLeftDOWNDropLine
Global $g_aiPixelBottomRightUPDropLine
Global $g_aiPixelBottomRightDOWNDropLine
Local $DeployableLRTB = [0, $g_iGAME_WIDTH - 1, 0, 626]
Local $DiamandAdjX = -28
Local $DiamandAdjY = -24
Local $OuterDiamondLeft = -18 - $DiamandAdjX, $OuterDiamondRight = 857 + $DiamandAdjX, $OuterDiamondTop = 20 - $DiamandAdjY, $OuterDiamondBottom = 679 + $DiamandAdjY
Local $DiamondMiddleX =($OuterDiamondLeft + $OuterDiamondRight) / 2
Local $DiamondMiddleY =($OuterDiamondTop + $OuterDiamondBottom) / 2
Local $InnerDiamandDiffX = 55 + $DiamandAdjX
Local $InnerDiamandDiffY = 47 + $DiamandAdjY
Local $InnerDiamondLeft = $OuterDiamondLeft + $InnerDiamandDiffX, $InnerDiamondRight = $OuterDiamondRight - $InnerDiamandDiffX, $InnerDiamondTop = $OuterDiamondTop + $InnerDiamandDiffY, $InnerDiamondBottom = $OuterDiamondBottom - $InnerDiamandDiffY
Global $CocDiamondECD = "ECD"
Global $ExternalArea[8][3]
Global $ExternalAreaRef[8][3] = [ [$OuterDiamondLeft, $DiamondMiddleY, "LEFT"], [$OuterDiamondRight, $DiamondMiddleY, "RIGHT"], [$DiamondMiddleX, $OuterDiamondTop, "TOP"], [$DiamondMiddleX, $OuterDiamondBottom, "BOTTOM"], [$OuterDiamondLeft +($DiamondMiddleX - $OuterDiamondLeft) / 2, $OuterDiamondTop +($DiamondMiddleY - $OuterDiamondTop) / 2, "TOP-LEFT"], [$DiamondMiddleX +($OuterDiamondRight - $DiamondMiddleX) / 2, $OuterDiamondTop +($DiamondMiddleY - $OuterDiamondTop) / 2, "TOP-RIGHT"], [$OuterDiamondLeft +($DiamondMiddleX - $OuterDiamondLeft) / 2, $DiamondMiddleY +($OuterDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-LEFT"], [$DiamondMiddleX +($OuterDiamondRight - $DiamondMiddleX) / 2, $DiamondMiddleY +($OuterDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-RIGHT"] ]
Global $CocDiamondDCD = "DCD"
Global $InternalArea[8][3]
Global $InternalAreaRef[8][3] = [ [$InnerDiamondLeft, $DiamondMiddleY, "LEFT"], [$InnerDiamondRight, $DiamondMiddleY, "RIGHT"], [$DiamondMiddleX, $InnerDiamondTop, "TOP"], [$DiamondMiddleX, $InnerDiamondBottom, "BOTTOM"], [$InnerDiamondLeft +($DiamondMiddleX - $InnerDiamondLeft) / 2, $InnerDiamondTop +($DiamondMiddleY - $InnerDiamondTop) / 2, "TOP-LEFT"], [$DiamondMiddleX +($InnerDiamondRight - $DiamondMiddleX) / 2, $InnerDiamondTop +($DiamondMiddleY - $InnerDiamondTop) / 2, "TOP-RIGHT"], [$InnerDiamondLeft +($DiamondMiddleX - $InnerDiamondLeft) / 2, $DiamondMiddleY +($InnerDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-LEFT"], [$DiamondMiddleX +($InnerDiamondRight - $DiamondMiddleX) / 2, $DiamondMiddleY +($InnerDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-RIGHT"] ]
ConvertInternalExternArea()
Func ConvertInternalExternArea()
Local $x, $y
For $i = 0 To 7
$x = $ExternalAreaRef[$i][0]
$y = $ExternalAreaRef[$i][1]
ConvertToVillagePos($x, $y)
$ExternalArea[$i][0] = $x
$ExternalArea[$i][1] = $y
$ExternalArea[$i][2] = $ExternalAreaRef[$i][2]
Next
$x = $ExternalAreaRef[2][0]
$y = $ExternalAreaRef[2][1] + $DiamandAdjY
ConvertToVillagePos($x, $y)
$CocDiamondECD = $x & "," & $y
$x = $ExternalAreaRef[1][0] - $DiamandAdjX
$y = $ExternalAreaRef[1][1]
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
$x = $ExternalAreaRef[3][0]
$y = $ExternalAreaRef[3][1] - $DiamandAdjY
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
$x = $ExternalAreaRef[0][0] + $DiamandAdjX
$y = $ExternalAreaRef[0][1]
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
For $i = 0 To 7
$x = $InternalAreaRef[$i][0]
$y = $InternalAreaRef[$i][1]
ConvertToVillagePos($x, $y)
$InternalArea[$i][0] = $x
$InternalArea[$i][1] = $y
$InternalArea[$i][2] = $InternalAreaRef[$i][2]
Next
$CocDiamondDCD = $InternalArea[2][0] & "," & $InternalArea[2][1] & "|" & $InternalArea[1][0] & "," & $InternalArea[1][1] & "|" & $InternalArea[3][0] & "," & $InternalArea[3][1] & "|" & $InternalArea[0][0] & "," & $InternalArea[0][1]
EndFunc
Func CheckAttackLocation(ByRef $x, ByRef $y)
If $y > $DeployableLRTB[3] Then
$y = $DeployableLRTB[3]
Return False
EndIf
Return True
EndFunc
Func GetMinPoint($PointList, $Dim)
Local $Result = [9999, 9999]
For $i = 0 To UBound($PointList) - 1
Local $Point = $PointList[$i]
If $Point[$Dim] < $Result[$Dim] Then $Result = $Point
Next
Return $Result
EndFunc
Func GetMaxPoint($PointList, $Dim)
Local $Result = [-9999, -9999]
For $i = 0 To UBound($PointList) - 1
Local $Point = $PointList[$i]
If $Point[$Dim] > $Result[$Dim] Then $Result = $Point
Next
Return $Result
EndFunc
Func Algorithm_AttackCSV($testattack = False, $captureredarea = True)
Local $g_aiPixelNearCollectorTopLeft[0]
Local $g_aiPixelNearCollectorBottomLeft[0]
Local $g_aiPixelNearCollectorTopRight[0]
Local $g_aiPixelNearCollectorBottomRight[0]
Local $aResult
ParseAttackCSV_Read_SIDE_variables()
$g_iCSVLastTroopPositionDropTroopFromINI = -1
If _Sleep($DELAYRESPOND) Then Return
debugAttackCSV("Troops to be used (purged from troops) ")
For $i = 0 To UBound($g_avAttackTroops) - 1
debugAttackCSV("SLOT n.: " & $i & " - Troop: " & GetTroopName($g_avAttackTroops[$i][0]) & " (" & $g_avAttackTroops[$i][0] & ") - Quantity: " & $g_avAttackTroops[$i][1])
Next
Local $hTimerTOTAL = __timerinit()
Local $hTimer = __timerinit()
SetDebugLog("Redline mode: " & $g_aiAttackScrRedlineRoutine[$g_iMatchMode])
SetDebugLog("Dropline mode: " & $g_aiAttackScrDroplineEdge[$g_iMatchMode])
_CaptureRegion2()
If $captureredarea Then _GetRedArea($g_aiAttackScrRedlineRoutine[$g_iMatchMode])
If _Sleep($DELAYRESPOND) Then Return
Local $htimerREDAREA = Round(__timerdiff($hTimer) / 1000, 2)
debugAttackCSV("Calculated  (in " & $htimerREDAREA & " seconds) :")
debugAttackCSV("	[" & UBound($g_aiPixelTopLeft) & "] pixels TopLeft")
debugAttackCSV("	[" & UBound($g_aiPixelTopRight) & "] pixels TopRight")
debugAttackCSV("	[" & UBound($g_aiPixelBottomLeft) & "] pixels BottomLeft")
debugAttackCSV("	[" & UBound($g_aiPixelBottomRight) & "] pixels BottomRight")
If $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_DROPPOINTS_ONLY Then
$g_aiPixelTopLeftDropLine = $g_aiPixelTopLeft
$g_aiPixelTopRightDropLine = $g_aiPixelTopRight
$g_aiPixelBottomLeftDropLine = $g_aiPixelBottomLeft
$g_aiPixelBottomRightDropLine = $g_aiPixelBottomRight
Else
Local $coordLeft = [$ExternalArea[0][0], $ExternalArea[0][1]]
Local $coordTop = [$ExternalArea[2][0], $ExternalArea[2][1]]
Local $coordRight = [$ExternalArea[1][0], $ExternalArea[1][1]]
Local $coordBottom = [$ExternalArea[3][0], $ExternalArea[3][1]]
Local $StartEndTopLeft = [$coordLeft, $coordTop]
If UBound($g_aiPixelTopLeft) > 2 Then Local $StartEndTopLeft = [$g_aiPixelTopLeft[0], $g_aiPixelTopLeft[UBound($g_aiPixelTopLeft) - 1]]
Local $StartEndTopRight = [$coordTop, $coordRight]
If UBound($g_aiPixelTopRight) > 2 Then Local $StartEndTopRight = [$g_aiPixelTopRight[0], $g_aiPixelTopRight[UBound($g_aiPixelTopRight) - 1]]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
If UBound($g_aiPixelBottomLeft) > 2 Then Local $StartEndBottomLeft = [$g_aiPixelBottomLeft[0], $g_aiPixelBottomLeft[UBound($g_aiPixelBottomLeft) - 1]]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
If UBound($g_aiPixelBottomRight) > 2 Then Local $StartEndBottomRight = [$g_aiPixelBottomRight[0], $g_aiPixelBottomRight[UBound($g_aiPixelBottomRight) - 1]]
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIXED
Local $StartEndTopLeft = [$coordLeft, $coordTop]
Local $StartEndTopRight = [$coordTop, $coordRight]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
EndSwitch
SetDebugLog("MakeDropLines, StartEndTopLeft     = " & PixelArrayToString($StartEndTopLeft, ","))
SetDebugLog("MakeDropLines, StartEndTopRight    = " & PixelArrayToString($StartEndTopRight, ","))
SetDebugLog("MakeDropLines, StartEndBottomLeft  = " & PixelArrayToString($StartEndBottomLeft, ","))
SetDebugLog("MakeDropLines, StartEndBottomRight = " & PixelArrayToString($StartEndBottomRight, ","))
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_EDGE_FIRST
$g_aiPixelTopLeftDropLine = MakeDropLineOriginal($g_aiPixelTopLeft, $StartEndTopLeft[0], $StartEndTopLeft[1])
$g_aiPixelTopRightDropLine = MakeDropLineOriginal($g_aiPixelTopRight, $StartEndTopRight[0], $StartEndTopRight[1])
$g_aiPixelBottomLeftDropLine = MakeDropLineOriginal($g_aiPixelBottomLeft, $StartEndBottomLeft[0], $StartEndBottomLeft[1])
$g_aiPixelBottomRightDropLine = MakeDropLineOriginal($g_aiPixelBottomRight, $StartEndBottomRight[0], $StartEndBottomRight[1])
Case $DROPLINE_FULL_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIRST
Local $iLineDistanceThreshold = 75
If $g_aiAttackScrRedlineRoutine[$g_iMatchMode] = $REDLINE_IMGLOC Then $iLineDistanceThreshold = 25
$g_aiPixelTopLeftDropLine = MakeDropLine($g_aiPixelTopLeft, $StartEndTopLeft[0], $StartEndTopLeft[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$g_aiPixelTopRightDropLine = MakeDropLine($g_aiPixelTopRight, $StartEndTopRight[0], $StartEndTopRight[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$g_aiPixelBottomLeftDropLine = MakeDropLine($g_aiPixelBottomLeft, $StartEndBottomLeft[0], $StartEndBottomLeft[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$g_aiPixelBottomRightDropLine = MakeDropLine($g_aiPixelBottomRight, $StartEndBottomRight[0], $StartEndBottomRight[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
EndSwitch
EndIf
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($g_aiPixelTopLeftDropLine) - 1
Local $pixel = $g_aiPixelTopLeftDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "6"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "5"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("TOP LEFT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$g_aiPixelTopLeftDOWNDropLine = GetListPixel($tempvectstr1, ",", "TL-DOWN")
$g_aiPixelTopLeftUPDropLine = GetListPixel($tempvectstr2, ",", "TL-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($g_aiPixelTopRightDropLine) - 1
Local $pixel = $g_aiPixelTopRightDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "3"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "4"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("TOP RIGHT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$g_aiPixelTopRightDOWNDropLine = GetListPixel($tempvectstr1, ",", "TR-DOWN")
$g_aiPixelTopRightUPDropLine = GetListPixel($tempvectstr2, ",", "TR-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($g_aiPixelBottomLeftDropLine) - 1
Local $pixel = $g_aiPixelBottomLeftDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "8"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "7"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("BOTTOM LEFT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$g_aiPixelBottomLeftDOWNDropLine = GetListPixel($tempvectstr1, ",", "BL-DOWN")
$g_aiPixelBottomLeftUPDropLine = GetListPixel($tempvectstr2, ",", "BL-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($g_aiPixelBottomRightDropLine) - 1
Local $pixel = $g_aiPixelBottomRightDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "1"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "2"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("BOTTOM RIGHT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$g_aiPixelBottomRightDOWNDropLine = GetListPixel($tempvectstr1, ",", "BR-DOWN")
$g_aiPixelBottomRightUPDropLine = GetListPixel($tempvectstr2, ",", "BR-UP")
SetLog("> Drop Lines located in  " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return
If $g_bCSVLocateStorageTownHall = True Then
If $g_iSearchTH = "-" Or $g_oBldgAttackInfo.Exists($eBldgTownHall & "_LOCATION") = False Then
imglocTHSearch(True, False, False)
Else
SetLog("> Townhall has already been located in while searching for an image", $COLOR_INFO)
EndIf
Else
SetLog("> Townhall search not needed, skip")
EndIf
If _Sleep($DELAYRESPOND) Then Return
Global $g_aiPixelMine[0]
Global $g_aiPixelElixir[0]
Global $g_aiPixelDarkElixir[0]
Local $g_aiPixelNearCollectorTopLeftSTR = ""
Local $g_aiPixelNearCollectorBottomLeftSTR = ""
Local $g_aiPixelNearCollectorTopRightSTR = ""
Local $g_aiPixelNearCollectorBottomRightSTR = ""
If $g_bCSVLocateMine = True Then
$hTimer = __timerinit()
SuspendAndroid()
$g_aiPixelMine = GetLocationMine()
ResumeAndroid()
If _Sleep($DELAYRESPOND) Then Return
CleanRedArea($g_aiPixelMine)
Local $htimerMine = Round(__timerdiff($hTimer) / 1000, 2)
If(IsArray($g_aiPixelMine)) Then
For $i = 0 To UBound($g_aiPixelMine) - 1
Local $pixel = $g_aiPixelMine[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "MINE"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopLeftSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopRightSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
SetLog("> Mines located in " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
SetLog("> Mines detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $g_bCSVLocateElixir = True Then
$hTimer = __timerinit()
SuspendAndroid()
$g_aiPixelElixir = GetLocationElixir()
ResumeAndroid()
If _Sleep($DELAYRESPOND) Then Return
CleanRedArea($g_aiPixelElixir)
Local $htimerMine = Round(__timerdiff($hTimer) / 1000, 2)
If(IsArray($g_aiPixelElixir)) Then
For $i = 0 To UBound($g_aiPixelElixir) - 1
Local $pixel = $g_aiPixelElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "ELIXIR"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopLeftSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopRightSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
SetLog("> Elixir collectors located in " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
SetLog("> Elixir collectors detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $g_bCSVLocateDrill = True Then
$hTimer = __timerinit()
SuspendAndroid()
$g_aiPixelDarkElixir = GetLocationDarkElixir()
ResumeAndroid()
If _Sleep($DELAYRESPOND) Then Return
CleanRedArea($g_aiPixelDarkElixir)
Local $htimerMine = Round(__timerdiff($hTimer) / 1000, 2)
If(IsArray($g_aiPixelDarkElixir)) Then
For $i = 0 To UBound($g_aiPixelDarkElixir) - 1
Local $pixel = $g_aiPixelDarkElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "DRILL"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopLeftSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$g_aiPixelNearCollectorTopRightSTR &= $str & "|"
Else
$g_aiPixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
SetLog("> Drills located in " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
SetLog("> Drills detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If StringLen($g_aiPixelNearCollectorTopLeftSTR) > 0 Then $g_aiPixelNearCollectorTopLeftSTR = StringLeft($g_aiPixelNearCollectorTopLeftSTR, StringLen($g_aiPixelNearCollectorTopLeftSTR) - 1)
If StringLen($g_aiPixelNearCollectorTopRightSTR) > 0 Then $g_aiPixelNearCollectorTopRightSTR = StringLeft($g_aiPixelNearCollectorTopRightSTR, StringLen($g_aiPixelNearCollectorTopRightSTR) - 1)
If StringLen($g_aiPixelNearCollectorBottomLeftSTR) > 0 Then $g_aiPixelNearCollectorBottomLeftSTR = StringLeft($g_aiPixelNearCollectorBottomLeftSTR, StringLen($g_aiPixelNearCollectorBottomLeftSTR) - 1)
If StringLen($g_aiPixelNearCollectorBottomRightSTR) > 0 Then $g_aiPixelNearCollectorBottomRightSTR = StringLeft($g_aiPixelNearCollectorBottomRightSTR, StringLen($g_aiPixelNearCollectorBottomRightSTR) - 1)
$g_aiPixelNearCollectorTopLeft = GetListPixel3($g_aiPixelNearCollectorTopLeftSTR)
$g_aiPixelNearCollectorTopRight = GetListPixel3($g_aiPixelNearCollectorTopRightSTR)
$g_aiPixelNearCollectorBottomLeft = GetListPixel3($g_aiPixelNearCollectorBottomLeftSTR)
$g_aiPixelNearCollectorBottomRight = GetListPixel3($g_aiPixelNearCollectorBottomRightSTR)
If $g_bCSVLocateStorageGold = True Then
$aResult = GetLocationBuilding($eBldgGoldS, $g_iSearchTH, False)
If $aResult <> -1 Then
If $aResult = 1 Then
SetLog("> " & $g_sBldgNames[$eBldgGoldS] & " Not found", $COLOR_WARNING)
Else
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgGoldS & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgGoldS] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgGoldS] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVGoldStoragePos = $aResult
EndIf
EndIf
Else
SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgGoldS], $COLOR_ERROR)
EndIf
EndIf
If $g_bCSVLocateStorageElixir = True Then
$aResult = GetLocationBuilding($eBldgElixirS, $g_iSearchTH, False)
If @error And $g_bDebugSetlog Then _logErrorGetBuilding(@error)
If $aResult <> -1 Then
If $aResult = 1 Then
SetLog("> " & $g_sBldgNames[$eBldgElixirS] & " Not found", $COLOR_WARNING)
Else
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgElixirS & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgElixirS] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgElixirS] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVElixirStoragePos = $aResult
EndIf
EndIf
Else
SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgElixirS], $COLOR_ERROR)
EndIf
EndIf
If $g_bCSVLocateStorageDarkElixir = True Then
$hTimer = __timerinit()
SuspendAndroid()
Local $g_aiPixelDarkElixirStorage = GetLocationDarkElixirStorageWithLevel()
ResumeAndroid()
If _Sleep($DELAYRESPOND) Then Return
CleanRedArea($g_aiPixelDarkElixirStorage)
Local $pixel = StringSplit($g_aiPixelDarkElixirStorage, "#", 2)
If UBound($pixel) >= 2 Then
Local $pixelpos = StringSplit($pixel[1], "-", 2)
If UBound($pixelpos) >= 2 Then
Local $temp = [Int($pixelpos[0]), Int($pixelpos[1])]
$g_aiCSVDarkElixirStoragePos = $temp
EndIf
EndIf
SetLog("> Dark Elixir Storage located in " & Round(__timerdiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
SetLog("> Dark Elixir Storage detection not need, skip", $COLOR_INFO)
EndIf
$g_aiCSVEagleArtilleryPos = ""
If $g_bCSVLocateEagle = True Then
If $g_iSearchTH = "-" Or $g_iSearchTH > 10 Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgEagle & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgEagle, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgEagle], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgEagle & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgEagle] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgEagle] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult[0]) Then $g_aiCSVEagleArtilleryPos = $aResult[0]
EndIf
Else
SetLog("> TH Level to low for Eagle, skip detection", $COLOR_INFO)
EndIf
Else
SetDebugLog("> Eagle Artillery detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVInfernoPos = ""
If $g_bCSVLocateInferno = True Then
If $g_iSearchTH = "-" Or $g_iSearchTH > 9 Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgInferno & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgInferno, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgInferno], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgInferno & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgInferno] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgInferno] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVInfernoPos = $aResult
EndIf
Else
SetLog("> TH Level to low for Inferno, ignore location", $COLOR_INFO)
EndIf
Else
SetDebugLog("> Inferno detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVXBowPos = ""
If $g_bCSVLocateXBow = True Then
If $g_iSearchTH = "-" Or $g_iSearchTH > 8 Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgXBow & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgXBow, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgXBow], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgXBow & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgXBow] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgXBow] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVXBowPos = $aResult
EndIf
Else
SetLog("> TH Level to low for " & $g_sBldgNames[$eBldgXBow] & " , ignore location", $COLOR_INFO)
EndIf
Else
SetDebugLog("> " & $g_sBldgNames[$eBldgXBow] & " detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVWizTowerPos = ""
If $g_bCSVLocateWizTower = True Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgWizTower & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgWizTower, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgWizTower], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgWizTower & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgWizTower] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgWizTower] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVWizTowerPos = $aResult
EndIf
Else
SetDebugLog("> " & $g_sBldgNames[$eBldgWizTower] & " detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVMortarPos = ""
If $g_bCSVLocateMortar = True Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgMortar & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgMortar, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgMortar], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgMortar & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgMortar] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgMortar] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVMortarPos = $aResult
EndIf
Else
SetDebugLog("> " & $g_sBldgNames[$eBldgMortar] & " detection not need, skipping", $COLOR_DEBUG)
EndIf
$g_aiCSVAirDefensePos = ""
If $g_bCSVLocateAirDefense = True Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgAirDefense & "_LOCATION") = False Then
$aResult = GetLocationBuilding($eBldgAirDefense, $g_iSearchTH, False)
If $aResult = -1 Then SetLog("Monkey ate bad banana: " & "GetLocationBuilding " & $g_sBldgNames[$eBldgAirDefense], $COLOR_ERROR)
EndIf
$aResult = _ObjGetValue($g_oBldgAttackInfo, $eBldgAirDefense & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$eBldgAirDefense] & " _LOCATION", @error)
SetLog("> " & $g_sBldgNames[$eBldgAirDefense] & " location not in dictionary", $COLOR_WARNING)
Else
If IsArray($aResult) Then $g_aiCSVAirDefensePos = $aResult
EndIf
Else
SetDebugLog("> " & $g_sBldgNames[$eBldgAirDefense] & " detection not need, skipping", $COLOR_DEBUG)
EndIf
ParseAttackCSV_MainSide()
If $g_bCSVLocateWall Then
Local $aCSVExternalWall[1], $aCSVInternalWall[1]
If FindWallCSV($aCSVExternalWall, $aCSVInternalWall) Then
_ObjAdd($g_oBldgAttackInfo, $eExternalWall & "_LOCATION", $aCSVExternalWall)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$eExternalWall] & " _LOCATION", @error)
_ObjAdd($g_oBldgAttackInfo, $eInternalWall & "_LOCATION", $aCSVInternalWall)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$eInternalWall] & " _LOCATION", @error)
EndIf
EndIf
SetLog(">> Total time: " & Round(__timerdiff($hTimerTOTAL) / 1000, 2) & " seconds", $COLOR_INFO)
If $g_bDebugMakeIMGCSV Then AttackCSVDEBUGIMAGE()
If $g_bDebugAttackCSV Then _LogObjList($g_oBldgAttackInfo)
If $g_bTHSnipeBeforeEnable[$DB] And $g_iSearchTH = "-" Then FindTownHall(True)
If $g_bTHSnipeBeforeEnable[$DB] Then
If $g_iSearchTH <> "-" Then
If SearchTownHallLoc() Then
SetLogCentered(" TH snipe Before Scripted Attack ", Default, $COLOR_INFO)
$g_bTHSnipeUsedKing = False
$g_bTHSnipeUsedQueen = False
AttackTHParseCSV()
Else
If $g_bDebugSetlog Then SetDebugLog("TH snipe before scripted attack skip, th internal village", $COLOR_DEBUG)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("TH snipe before scripted attack skip, no th found", $COLOR_DEBUG)
EndIf
EndIf
SetSlotSpecialTroops()
If _Sleep($DELAYRESPOND) Then Return
ParseAttackCSV($testattack)
CheckHeroesHealth()
EndFunc
Func FindWallCSV(ByRef $aCSVExternalWall, ByRef $aCSVInternalWall)
SetLog("Searching for wall location...")
Local $aOuterWall[2], $aInnerWall[2], $bResult = False
Local $aiWallPos[1][3]
Local $aEdgeCoord[2], $aCenterCoord[2] = [$ExternalArea[2][0], $ExternalArea[0][1]]
For $i = 0 To UBound($ExternalArea) - 1
If $MAINSIDE = $ExternalArea[$i][2] Then
$aEdgeCoord[0] = Number($ExternalArea[$i][0])
$aEdgeCoord[1] = Number($ExternalArea[$i][1])
ExitLoop
EndIf
Next
If $g_bDebugImageSave Then
_CaptureRegion2()
Local $subDirectory = $g_sProfileTempDebugPath & "CSVWall"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = String($Date & "_" & $Time & "_.png")
Local $editedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 3)
Local $hPenBLUE = _GDIPlus_PenCreate(0xFF0000FF, 2)
EndIf
For $i = 0 To 2
Local $X1 = Int($aEdgeCoord[0] + $i *($aEdgeCoord[0] < $aCenterCoord[0] ? 63 : -63))
Local $Y1 = Int($aEdgeCoord[1] + $i *($aEdgeCoord[1] < $aCenterCoord[1] ? 47 : -47))
Local $X2 = Int($X1 +($aEdgeCoord[0] < $aCenterCoord[0] ? 80 : -80))
Local $Y2 = Int($Y1 +($aEdgeCoord[1] < $aCenterCoord[1] ? 60 : -60))
_CaptureRegion2(_Min($X1, $X2), _Min($Y1, $Y2), _Max($X1, $X2), _Max($Y1, $Y2))
Local $FoundWalls = imglocFindWalls("AnyWallLevel", "FV", "FV", 10)
If $g_bDebugImageSave Then _GDIPlus_GraphicsDrawRect($hGraphic, _Min($X1, $X2), _Min($Y1, $Y2), Abs($X1 - $X2), Abs($Y1 - $Y2), $hPenBLUE)
If $FoundWalls[0] = "" Then
SetDebugLog("No wall(s) found in section " & $i + 1)
Else
Local $sWallString = _ArrayToString($FoundWalls)
Local $aWallCoordsArray = decodeMultipleCoords($sWallString, 7, 7)
SetDebugLog("Found " & UBound($aWallCoordsArray) & " walls in section " & $i + 1 & ": " & $sWallString)
For $j = 0 To UBound($aWallCoordsArray) - 1
Local $aTempPos = $aWallCoordsArray[$j]
Local $index = UBound($aiWallPos) - 1
$aiWallPos[$index][0] = $aTempPos[0] + _Min($X1, $X2)
$aiWallPos[$index][1] = $aTempPos[1] + _Min($Y1, $Y2)
$aiWallPos[$index][2] = Int(Sqrt(($aiWallPos[$index][0] - $aEdgeCoord[0]) ^ 2 +($aiWallPos[$index][1] - $aEdgeCoord[1]) ^ 2))
ReDim $aiWallPos[UBound($aiWallPos) + 1][3]
If $g_bDebugImageSave Then _GDIPlus_GraphicsDrawEllipse($hGraphic, $aiWallPos[$index][0], $aiWallPos[$index][1], 3, 3, $hPenBLUE)
Next
EndIf
Next
If UBound($aiWallPos) > 1 And $aiWallPos[0][0] <> "" Then
_ArraySort($aiWallPos, 0, 0, 0, 2)
_ArrayDelete($aiWallPos, 0)
SetDebugLog(@CRLF & _ArrayToString($aiWallPos))
$aOuterWall[0] = $aiWallPos[0][0]
$aOuterWall[1] = $aiWallPos[0][1]
For $i = 0 To UBound($aiWallPos) - 1
If $i = 0 Then ContinueLoop
If $aiWallPos[$i][2] - $aiWallPos[0][2] >= 40 Then
$aInnerWall[0] = $aiWallPos[$i][0]
$aInnerWall[1] = $aiWallPos[$i][1]
ExitLoop
EndIf
Next
Setlog("External Wall: " & _ArrayToString($aOuterWall) & " , Internal Wall: " & _ArrayToString($aInnerWall))
If $aOuterWall[0] <> "" Then
$aCSVExternalWall[0] = $aOuterWall
$aCSVInternalWall[0] = $aInnerWall
If $g_bDebugImageSave Then
_GDIPlus_GraphicsDrawEllipse($hGraphic, $aOuterWall[0], $aOuterWall[1], 3, 3, $hPenRED)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $aInnerWall[0], $aInnerWall[1], 3, 3, $hPenRED)
EndIf
$bResult = True
EndIf
Else
SetLog("No wall found")
EndIf
If $g_bDebugImageSave Then
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $filename)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($editedImage)
EndIf
Return $bResult
EndFunc
Func TestSmartFarm()
$g_iDetectedImageType = 0
Local $RuntimeA = $g_bRunState
$g_bRunState = True
Setlog("Starting the SmartFarm Attack Test()", $COLOR_INFO)
checkMainScreen(False)
CheckIfArmyIsReady()
ClickP($aAway, 2, 0, "")
If _Sleep(100) Then Return FuncReturn()
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If _Sleep(100) Then Return FuncReturn()
PrepareSearch()
If _Sleep(1000) Then Return FuncReturn()
VillageSearch()
If $g_bOutOfGold = True Then Return
If _Sleep(100) Then Return FuncReturn()
Else
SetLog("Your Army is not prepared, check the Attack/train options")
EndIf
PrepareAttack($g_iMatchMode)
$g_bAttackActive = True
Local $Nside = ChkSmartFarm()
AttackSmartFarm($Nside[1], $Nside[2])
$g_bAttackActive = False
ReturnHome($g_bTakeLootSnapShot)
Setlog("Finish the SmartFarm Attack()", $COLOR_INFO)
$g_bRunState = $RuntimeA
EndFunc
Func ChkSmartFarm($TypeResources = "All")
Local $hTimer = TimerInit()
Local $aResourcesOUT[0][6]
Local $aResourcesIN[0][6]
Local $aMainSide[4] = [0, 0, 0, 0]
SetDebugLog(" - INI|SmartFarm detection.", $COLOR_INFO)
$hTimer = TimerInit()
If $g_iSearchTH = "-" Then FindTownHall(True, True)
Local $THdetails[4] = [$g_iSearchTH, $g_iTHx, $g_iTHy, _ObjGetValue($g_oBldgAttackInfo, $eBldgTownHall & "_REDLINEDISTANCE")]
setlog("TH Details: " & _ArrayToString($THdetails, "|"))
Local $aAll = SmartFarmDetection($TypeResources)
SetDebugLog(" TOTAL detection Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
For $x = 0 To UBound($aAll) - 1
If $aAll[$x][0] <> -1 Then
If $aAll[$x][3] = "In" Then
ReDim $aResourcesIN[UBound($aResourcesIN) + 1][6]
For $t = 0 To 5
$aResourcesIN[UBound($aResourcesIN) - 1][$t] = $aAll[$x][$t]
Next
Else
ReDim $aResourcesOUT[UBound($aResourcesOUT) + 1][6]
For $t = 0 To 5
$aResourcesOUT[UBound($aResourcesOUT) - 1][$t] = $aAll[$x][$t]
Next
EndIf
Switch $aAll[$x][4]
Case "TL"
$aMainSide[0] += 1
Case "TR"
$aMainSide[1] += 1
Case "BL"
$aMainSide[2] += 1
Case "BR"
$aMainSide[3] += 1
EndSwitch
EndIf
If _Sleep(50) Then Return
If Not $g_bRunState Then Return
Next
If $g_bDebugSmartFarm Then
For $i = 0 To UBound($aResourcesIN) - 1
For $x = 0 To 4
SetDebugLog("$aResourcesIN[" & $i & "][" & $x & "]: " & $aResourcesIN[$i][$x], $COLOR_INFO)
Next
Next
For $i = 0 To UBound($aResourcesOUT) - 1
For $x = 0 To 4
SetDebugLog("$aResourcesOUT[" & $i & "][" & $x & "]: " & $aResourcesOUT[$i][$x], $COLOR_INFO)
Next
Next
EndIf
Local $TotalOfResources = UBound($aResourcesIN) + UBound($aResourcesOUT)
Setlog("Total of Resources: " & $TotalOfResources, $COLOR_INFO)
Setlog(" - Inside the Village: " & UBound($aResourcesIN), $COLOR_INFO)
Setlog(" - Outside the village: " & UBound($aResourcesOUT), $COLOR_INFO)
SetDebugLog("MainSide array: " & _ArrayToString($aMainSide))
$g_sResourcesIN = UBound($aResourcesIN)
$g_sResourcesOUT = UBound($aResourcesOUT)
$g_sResBySide = _ArrayToString($aMainSide)
Local $AttackInside = False
Local $Percentage_In = Int((UBound($aResourcesIN) / $TotalOfResources) * 100), $Percentage_Out = Int((UBound($aResourcesOUT) / $TotalOfResources) * 100)
Local $PercentageInSide = Int($g_iTxtInsidePercentage)
Local $PercentageOutSide = Int($g_iTxtOutsidePercentage)
If $Percentage_In > $PercentageInSide Then $AttackInside = True
Local $TxtLog =($AttackInside = True) ?("Inside with " & $Percentage_In & "%") :("Outside with " & $Percentage_Out & "%")
Setlog(" - Best Attack will be " & $TxtLog)
If Not $g_bRunState Then Return
Local $OneSide = Floor($TotalOfResources / 4)
Local $Sides[4] = ["TL", "TR", "BL", "BR"]
Local $SidesExt[4] = ["Top-Left", "Top-Right", "Bottom-Left", "Bottom-Right"]
Local $aHowManySides[0]
For $i = 0 To 3
If $aMainSide[$i] >= $OneSide Or($Percentage_Out > $PercentageOutSide And $aMainSide[$i] <> 0) Then
ReDim $aHowManySides[UBound($aHowManySides) + 1]
$aHowManySides[UBound($aHowManySides) - 1] = $Sides[$i]
EndIf
Next
Local $BestSideToAttack[1] = ["TR"]
Local $number = 0
If $AttackInside Then
For $i = 0 To UBound($aMainSide) - 1
If $aMainSide[$i] > $number Then
$number = $aMainSide[$i]
$BestSideToAttack[0] = $Sides[$i]
EndIf
Next
For $i = 0 To UBound($aMainSide) - 1
If $BestSideToAttack[0] = $Sides[$i] Then Setlog("Best Side To Attack Inside: " & $SidesExt[$i])
Setlog(" - Side " & $SidesExt[$i] & " with " & $aMainSide[$i] & " Resources.", $COLOR_INFO)
Next
Else
$BestSideToAttack = $aHowManySides
EndIf
Setlog("Attack at " & UBound($BestSideToAttack) & " Side(s) - " & _ArrayToString($BestSideToAttack), $COLOR_INFO)
Setlog(" Check Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
If Not $g_bRunState Then Return
Local $redline[UBound($BestSideToAttack)]
If $g_bDebugSmartFarm Then
For $i = 0 To UBound($BestSideToAttack) - 1
$redline[$i] = GetOffsetRedline($BestSideToAttack[$i], 5)
Next
DebugImageSmartFarm($THdetails, $aResourcesIN, $aResourcesOUT, Round(TimerDiff($hTimer) / 1000, 2) & "'s", _ArrayToString($BestSideToAttack), $redline)
EndIf
Local $Return[3] = [$AttackInside, UBound($BestSideToAttack), _ArrayToString($BestSideToAttack)]
Return $Return
EndFunc
Func SmartFarmDetection($txtBuildings = "Mines")
Local $aReturn[0][6]
Local $sdirectory, $iMaxReturnPoints, $iMaxLevel, $offsetx, $offsety
If Not $g_bRunState Then Return
Local $hTimer = TimerInit()
Switch $txtBuildings
Case "Mines"
If $g_iDetectedImageType = 1 Then
$sdirectory = @ScriptDir & "\imgxml\Storages\Mines_Snow"
Else
$sdirectory = @ScriptDir & "\imgxml\Storages\GoldMines"
EndIf
$iMaxReturnPoints = 7
$iMaxLevel = 13
Case "Collectors"
If $g_iDetectedImageType = 1 Then
$sdirectory = @ScriptDir & "\imgxml\Storages\Collectors_Snow"
Else
$sdirectory = @ScriptDir & "\imgxml\Storages\Collectors"
EndIf
$iMaxReturnPoints = 7
$iMaxLevel = 13
Case "Drills"
$sdirectory = @ScriptDir & "\imgxml\Storages\Drills"
$iMaxReturnPoints = 3
$iMaxLevel = 7
Case "All"
If $g_iDetectedImageType = 1 Then
$sdirectory = @ScriptDir & "\imgxml\Storages\All_Snow"
Else
$sdirectory = @ScriptDir & "\imgxml\Storages\All"
EndIf
$iMaxReturnPoints = 21
$iMaxLevel = 13
EndSwitch
Local $sCocDiamond = "ECD"
Local $sRedLines = ""
Local $iMinLevel = 1
Local $sReturnProps = "objectname,objectpoints,nearpoints,redlinedistance"
Local $bForceCapture = True
Local $aResult = findMultiple($sdirectory, $sCocDiamond, $sRedLines, $iMinLevel, $iMaxLevel, $iMaxReturnPoints, $sReturnProps, $bForceCapture)
Local $aTEMP, $sObjectname, $aObjectpoints, $sNear, $sRedLineDistance
Local $tempObbj, $sNearTemp, $Distance, $tempObbjs, $sString
Local $distance2RedLine = 40
If IsArray($aResult) And UBound($aResult) > 0 Then
For $buildings = 0 To UBound($aResult) - 1
If _Sleep(50) Then Return
If Not $g_bRunState Then Return
SetDebugLog(_ArrayToString($aResult[$buildings]))
$aTEMP = $aResult[$buildings]
$sObjectname = String($aTEMP[0])
SetDebugLog("Building name: " & String($aTEMP[0]), $COLOR_INFO)
$aObjectpoints = $aTEMP[1]
SetDebugLog("Object points: " & String($aTEMP[1]), $COLOR_INFO)
$sNear = $aTEMP[2]
SetDebugLog("Near points: " & String($aTEMP[2]), $COLOR_INFO)
$sRedLineDistance = $aTEMP[3]
SetDebugLog("Near points: " & String($aTEMP[3]), $COLOR_INFO)
Switch String($aTEMP[0])
Case "Mines"
$offsetx = 3
$offsety = 12
Case "Collector"
$offsetx = -9
$offsety = 9
Case "Drill"
$offsetx = 2
$offsety = 14
EndSwitch
If StringInStr($aObjectpoints, "|") Then
$aObjectpoints = StringReplace($aObjectpoints, "||", "|")
$sString = StringRight($aObjectpoints, 1)
If $sString = "|" Then $aObjectpoints = StringTrimRight($aObjectpoints, 1)
$tempObbj = StringSplit($aObjectpoints, "|", $STR_NOCOUNT)
$sNearTemp = StringSplit($sNear, "#", $STR_NOCOUNT)
$Distance = StringSplit($sRedLineDistance, "#", $STR_NOCOUNT)
For $i = 0 To UBound($tempObbj) - 1
$tempObbjs = StringSplit($tempObbj[$i], ",", $STR_NOCOUNT)
If UBound($tempObbjs) <> 2 Then ContinueLoop
Local $DetectedPoint[2] = [Number($tempObbjs[0] + $offsetx), Number($tempObbjs[1] + $offsety)]
If DoublePoint($aTEMP[0], $aReturn, $DetectedPoint) Then ContinueLoop
ReDim $aReturn[UBound($aReturn) + 1][6]
$aReturn[UBound($aReturn) - 1][0] = $DetectedPoint[0]
$aReturn[UBound($aReturn) - 1][1] = $DetectedPoint[1]
$aReturn[UBound($aReturn) - 1][4] = Side($tempObbjs)
$distance2RedLine = $aReturn[UBound($aReturn) - 1][4] = "BL" ? 50 : 45
$aReturn[UBound($aReturn) - 1][5] = $sNearTemp[$i] <> "" ? $sNearTemp[$i] : "0,0"
$aReturn[UBound($aReturn) - 1][2] = Number($Distance[$i]) > 0 ? Number($Distance[$i]) : 200
$aReturn[UBound($aReturn) - 1][3] =($aReturn[UBound($aReturn) - 1][2] > $distance2RedLine) ?("In") :("Out")
Next
Else
$tempObbj = StringSplit($aObjectpoints, ",", $STR_NOCOUNT)
If UBound($tempObbj) <> 2 Then ContinueLoop
Local $DetectedPoint[2] = [Number($tempObbj[0] + $offsetx), Number($tempObbj[1] + $offsety)]
If DoublePoint($aTEMP[0], $aReturn, $DetectedPoint) Then ContinueLoop
ReDim $aReturn[UBound($aReturn) + 1][6]
$aReturn[UBound($aReturn) - 1][0] = $DetectedPoint[0]
$aReturn[UBound($aReturn) - 1][1] = $DetectedPoint[1]
$aReturn[UBound($aReturn) - 1][4] = Side($tempObbj)
$distance2RedLine = $aReturn[UBound($aReturn) - 1][4] = "BL" ? 50 : 45
$aReturn[UBound($aReturn) - 1][5] = $sNear
$aReturn[UBound($aReturn) - 1][2] = Number($sRedLineDistance)
$aReturn[UBound($aReturn) - 1][3] =($aReturn[UBound($aReturn) - 1][2] > $distance2RedLine) ?("In") :("Out")
EndIf
$aTEMP = Null
$sObjectname = Null
$aObjectpoints = Null
$sNear = Null
$sRedLineDistance = Null
$tempObbj = Null
$sNearTemp = Null
$Distance = Null
$tempObbjs = Null
Next
SetDebugLog($txtBuildings & " Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
Return $aReturn
Else
SetLog("ERROR|NONE Building - Detection: " & $txtBuildings, $COLOR_INFO)
EndIf
EndFunc
Func DoublePoint($sName, $aReturn, $aPoint, $iDistance = 18)
Local $x, $y
Local $x1 = Number($aPoint[0])
Local $y1 = Number($aPoint[1])
For $i = 0 To UBound($aReturn) - 1
If Not $g_bRunState Then Return
$x = Number($aReturn[$i][0])
$y = Number($aReturn[$i][1])
If Pixel_Distance($x, $y, $x1, $y1) < $iDistance Then
SetDebugLog("Detected a " & $sName & " double detection at (" & $x & "," & $y & ")")
Return True
EndIf
Next
Return False
EndFunc
Func Pixel_Distance($x, $y, $x1, $y1)
Local $a, $b, $c
If $x1 = $x And $y1 = $y Then
Return 0
Else
$a = $y1 - $y
$b = $x1 - $x
$c = Sqrt($a * $a + $b * $b)
Return $c
EndIf
EndFunc
Func Side($Pixel)
Local $sReturn = ""
If IsArray($Pixel) And UBound($Pixel) = 2 Then
If $Pixel[0] < 430 And $Pixel[1] <= 330 Then $sReturn = "TL"
If $Pixel[0] >= 430 And $Pixel[1] < 330 Then $sReturn = "TR"
If $Pixel[0] < 430 And $Pixel[1] > 330 Then $sReturn = "BL"
If $Pixel[0] >= 430 And $Pixel[1] >= 330 Then $sReturn = "BR"
If $sReturn = "" Then
Setlog("Error on SIDE...: " & _ArrayToString($Pixel), $COLOR_RED)
$sReturn = "ERROR"
EndIf
Return $sReturn
Else
Setlog("ERROR SIDE|SmartFarm!!", $COLOR_RED)
EndIf
EndFunc
Func DebugImageSmartFarm($THdetails, $aIn, $aOut, $sTime, $BestSideToAttack, $redline)
_CaptureRegion()
Local $editedImage = $g_hBitmap
Local $subDirectory = @ScriptDir & "\SmartFarm\"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = "SmartFarm" & "_" & $Date & "_" & $Time & ".png"
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $hPen2 = _GDIPlus_PenCreate(0xFF000000, 2)
addInfoToDebugImage($hGraphic, $hPen, "TH_" & $THdetails[0] & "|" & $THdetails[3], $THdetails[1], $THdetails[2])
_GDIPlus_GraphicsDrawRect($hGraphic, $THdetails[1] - 5, $THdetails[2] - 5, 10, 10, $hPen2)
Local $tempObbj, $tempObbjs
For $i = 0 To UBound($aIn) - 1
addInfoToDebugImage($hGraphic, $hPen, $aIn[$i][3] & "|" & $aIn[$i][4] & "|" & $aIn[$i][2], $aIn[$i][0], $aIn[$i][1])
If StringInStr($aIn[$i][5], "|") Then
$tempObbj = StringSplit($aIn[$i][5], "|", $STR_NOCOUNT)
For $t = 0 To UBound($tempObbj) - 1
$tempObbjs = StringSplit($tempObbj[$t], ",", $STR_NOCOUNT)
If UBound($tempObbjs) > 1 Then _GDIPlus_GraphicsDrawRect($hGraphic, $tempObbjs[0], $tempObbjs[1], 5, 5, $hPen2)
Next
Else
$tempObbj = StringSplit($aOut[$i][5], ",", $STR_NOCOUNT)
If UBound($tempObbj) > 1 Then _GDIPlus_GraphicsDrawRect($hGraphic, $tempObbj[0], $tempObbj[1], 5, 5, $hPen2)
EndIf
$tempObbj = Null
$tempObbjs = Null
Next
For $i = 0 To UBound($aOut) - 1
addInfoToDebugImage($hGraphic, $hPen, $aOut[$i][3] & "|" & $aOut[$i][4] & "|" & $aOut[$i][2], $aOut[$i][0], $aOut[$i][1])
If StringInStr($aOut[$i][5], "|") Then
$tempObbj = StringSplit($aOut[$i][5], "|", $STR_NOCOUNT)
For $t = 0 To UBound($tempObbj) - 1
$tempObbjs = StringSplit($tempObbj[$t], ",", $STR_NOCOUNT)
If UBound($tempObbjs) > 1 Then _GDIPlus_GraphicsDrawRect($hGraphic, $tempObbjs[0], $tempObbjs[1], 5, 5, $hPen2)
Next
Else
$tempObbj = StringSplit($aOut[$i][5], ",", $STR_NOCOUNT)
If UBound($tempObbj) > 1 Then _GDIPlus_GraphicsDrawRect($hGraphic, $tempObbj[0], $tempObbj[1], 5, 5, $hPen2)
EndIf
$tempObbj = Null
$tempObbjs = Null
Next
$hPen2 = _GDIPlus_PenCreate(0xFF0038ff, 2)
Local $aTEMP, $DecodeEachPoint
SetDebugLog("$redline: " & _ArrayToString($redline))
For $l = 0 To UBound($redline) - 1
$aTEMP = StringSplit($redline[$l], "|", 2)
For $i = 0 To UBound($aTEMP) - 1
$DecodeEachPoint = StringSplit($aTEMP[$i], ",", 2)
If UBound($DecodeEachPoint) > 1 Then _GDIPlus_GraphicsDrawRect($hGraphic, $DecodeEachPoint[0], $DecodeEachPoint[1], 5, 5, $hPen2)
Next
Next
_GDIPlus_GraphicsDrawString($hGraphic, $sTime & " - " & $BestSideToAttack, 370, 70, "ARIAL", 20)
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_PenDispose($hPen2)
_GDIPlus_GraphicsDispose($hGraphic)
Setlog(" » Debug Image saved!")
EndFunc
Func AttackSmartFarm($Nside, $SIDESNAMES)
Setlog(" ====== Start Smart Farm Attack ====== ", $COLOR_INFO)
SetSlotSpecialTroops()
Local $nbSides = Null
Local $GiantComp = 0
_CaptureRegion2()
_GetRedArea()
Switch $Nside
Case 1
SetLog("Attacking on a single side", $COLOR_INFO)
$nbSides = $Nside
Case 2
SetLog("Attacking on two sides", $COLOR_INFO)
$nbSides = $Nside
Case 3
SetLog("Attacking on three sides", $COLOR_INFO)
$nbSides = $Nside
Case 4
SetLog("Attacking on all sides", $COLOR_INFO)
$nbSides = $Nside
EndSwitch
If Not $g_bRunState Then Return
$g_iSidesAttack = $nbSides
$g_iSlotsGiants = 0
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eGiant Then
$GiantComp = $g_avAttackTroops[$i][1]
EndIf
Next
Switch $GiantComp
Case 0 To 10
$g_iSlotsGiants = 2
Case Else
Switch $nbSides
Case 1 To 2
$g_iSlotsGiants = 4
Case Else
$g_iSlotsGiants = 0
EndSwitch
EndSwitch
SetDebugLog("Giants : " & $GiantComp & "  , per side: " &($GiantComp / $nbSides) & " / deploy points per side: " & $g_iSlotsGiants)
If $g_bCustomDropOrderEnable Then
Local $listInfoDeploy[23][5] = [[MatchTroopDropName(0), $nbSides, MatchTroopWaveNb(0), 1, MatchSlotsPerEdge(0)], [MatchTroopDropName(1), $nbSides, MatchTroopWaveNb(1), 1, MatchSlotsPerEdge(1)], [MatchTroopDropName(2), $nbSides, MatchTroopWaveNb(2), 1, MatchSlotsPerEdge(2)], [MatchTroopDropName(3), $nbSides, MatchTroopWaveNb(3), 1, MatchSlotsPerEdge(3)], [MatchTroopDropName(4), $nbSides, MatchTroopWaveNb(4), 1, MatchSlotsPerEdge(4)], [MatchTroopDropName(5), $nbSides, MatchTroopWaveNb(5), 1, MatchSlotsPerEdge(5)], [MatchTroopDropName(6), $nbSides, MatchTroopWaveNb(6), 1, MatchSlotsPerEdge(6)], [MatchTroopDropName(7), $nbSides, MatchTroopWaveNb(7), 1, MatchSlotsPerEdge(7)], [MatchTroopDropName(8), $nbSides, MatchTroopWaveNb(8), 1, MatchSlotsPerEdge(8)], [MatchTroopDropName(9), $nbSides, MatchTroopWaveNb(9), 1, MatchSlotsPerEdge(9)], [MatchTroopDropName(10), $nbSides, MatchTroopWaveNb(10), 1, MatchSlotsPerEdge(10)], [MatchTroopDropName(11), $nbSides, MatchTroopWaveNb(11), 1, MatchSlotsPerEdge(11)], [MatchTroopDropName(12), $nbSides, MatchTroopWaveNb(12), 1, MatchSlotsPerEdge(12)], [MatchTroopDropName(13), $nbSides, MatchTroopWaveNb(13), 1, MatchSlotsPerEdge(13)], [MatchTroopDropName(14), $nbSides, MatchTroopWaveNb(14), 1, MatchSlotsPerEdge(14)], [MatchTroopDropName(15), $nbSides, MatchTroopWaveNb(15), 1, MatchSlotsPerEdge(15)], [MatchTroopDropName(16), $nbSides, MatchTroopWaveNb(16), 1, MatchSlotsPerEdge(16)], [MatchTroopDropName(17), $nbSides, MatchTroopWaveNb(17), 1, MatchSlotsPerEdge(17)], [MatchTroopDropName(18), $nbSides, MatchTroopWaveNb(18), 1, MatchSlotsPerEdge(18)], [MatchTroopDropName(19), $nbSides, MatchTroopWaveNb(19), 1, MatchSlotsPerEdge(19)], [MatchTroopDropName(20), $nbSides, MatchTroopWaveNb(20), 1, MatchSlotsPerEdge(20)], [MatchTroopDropName(21), $nbSides, MatchTroopWaveNb(21), 1, MatchSlotsPerEdge(21)], [MatchTroopDropName(22), $nbSides, MatchTroopWaveNb(22), 1, MatchSlotsPerEdge(22)]]
Else
Local $listInfoDeploy[23][5] = [[$eGole, $nbSides, 1, 1, 2] , [$eLava, $nbSides, 1, 1, 2] , [$eGiant, $nbSides, 1, 1, $g_iSlotsGiants] , [$eDrag, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , [$eBall, $nbSides, 1, 1, 0] , [$eBabyD, $nbSides, 1, 1, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eValk, $nbSides, 1, 1, 0] , [$eBowl, $nbSides, 1, 1, 0] , [$eIceG, $nbSides, 1, 1, 0] , [$eMine, $nbSides, 1, 1, 0] , [$eEDrag, $nbSides, 1, 1, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eBarb, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 1, 1, 0] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eWitc, $nbSides, 1, 1, 1] , [$eGobl, $nbSides, 1, 1, 0] , [$eHeal, $nbSides, 1, 1, 1] , [$ePekk, $nbSides, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
EndIf
$g_bIsCCDropped = False
$g_aiDeployCCPosition[0] = -1
$g_aiDeployCCPosition[1] = -1
$g_bIsHeroesDropped = False
$g_aiDeployHeroesPosition[0] = -1
$g_aiDeployHeroesPosition[1] = -1
LaunchTroopSmartFarm($listInfoDeploy, $g_iClanCastleSlot, $g_iKingSlot, $g_iQueenSlot, $g_iWardenSlot, $SIDESNAMES)
If Not $g_bRunState Then Return
CheckHeroesHealth()
If _Sleep($DELAYALGORITHM_ALLTROOPS4) Then Return
SetLog("Dropping left over troops", $COLOR_INFO)
For $x = 0 To 1
If PrepareAttack($g_iMatchMode, True) = 0 Then
If $g_bDebugSetlog Then SetDebugLog("No Wast time... exit, no troops usable left", $COLOR_DEBUG)
ExitLoop
EndIf
For $i = $eBarb To $eIceG
If LaunchTroop($i, $nbSides, 1, 1, 1) Then
CheckHeroesHealth()
If _Sleep($DELAYALGORITHM_ALLTROOPS5) Then Return
EndIf
Next
Next
CheckHeroesHealth()
SetLog("Finished Attacking, waiting for the battle to end")
EndFunc
Func LaunchTroopSmartFarm($listInfoDeploy, $iCC, $iKing, $iQueen, $iWarden, $SIDESNAMES = "TR|TL|BR|BL")
If $g_bDebugSetlog Then SetDebugLog("LaunchTroopSmartFarm with CC " & $iCC & ", K " & $iKing & ", Q " & $iQueen & ", W " & $iWarden, $COLOR_DEBUG)
Local $listListInfoDeployTroopPixel[0]
Local $pixelRandomDrop[2]
Local $pixelRandomDropcc[2]
Local $troop, $troopNb, $name
For $i = 0 To UBound($listInfoDeploy) - 1
Local $troop = -1
Local $troopNb = 0
Local $name = ""
Local $troopKind = $listInfoDeploy[$i][0]
Local $nbSides = $listInfoDeploy[$i][1]
Local $waveNb = $listInfoDeploy[$i][2]
Local $maxWaveNb = $listInfoDeploy[$i][3]
Local $slotsPerEdge = $listInfoDeploy[$i][4]
If $g_bDebugSetlog Then SetDebugLog("**ListInfoDeploy row " & $i & ": USE " & GetTroopName($troopKind, 0) & " SIDES " & $nbSides & " WAVE " & $waveNb & " XWAVE " & $maxWaveNb & " SLOTXEDGE " & $slotsPerEdge, $COLOR_DEBUG)
If(IsNumber($troopKind)) Then
For $j = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$j][0] = $troopKind Then
$troop = $j
$troopNb = Ceiling($g_avAttackTroops[$j][1] / $maxWaveNb)
$name = GetTroopName($troopKind, $troopNb)
EndIf
Next
EndIf
If($troop <> -1 And $troopNb > 0) Or IsString($troopKind) Then
Local $listInfoDeployTroopPixel
If(UBound($listListInfoDeployTroopPixel) < $waveNb) Then
ReDim $listListInfoDeployTroopPixel[$waveNb]
Local $newListInfoDeployTroopPixel[0]
$listListInfoDeployTroopPixel[$waveNb - 1] = $newListInfoDeployTroopPixel
EndIf
$listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$waveNb - 1]
ReDim $listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) + 1]
If(IsString($troopKind)) Then
Local $arrCCorHeroes[1] = [$troopKind]
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $arrCCorHeroes
Else
Local $infoDropTroop = DropTroopSmartFarm($troop, $nbSides, $troopNb, $slotsPerEdge, $name, $SIDESNAMES)
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $infoDropTroop
EndIf
$listListInfoDeployTroopPixel[$waveNb - 1] = $listInfoDeployTroopPixel
EndIf
Next
Local $numberSidesDropTroop = 1
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
If(UBound($listInfoDeployTroopPixel) > 0) Then
Local $infoTroopListArrPixel = $listInfoDeployTroopPixel[0]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$i]
If(UBound($infoTroopListArrPixel) > 1) Then
Local $infoListArrPixel = $infoTroopListArrPixel[1]
$numberSidesDropTroop = UBound($infoListArrPixel)
ExitLoop
EndIf
Next
If($numberSidesDropTroop > 0) Then
For $i = 0 To $numberSidesDropTroop - 1
For $j = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$j]
If(IsString($infoTroopListArrPixel[0]) And($infoTroopListArrPixel[0] = "CC" Or $infoTroopListArrPixel[0] = "HEROES")) Then
If $g_aiDeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $g_aiDeployHeroesPosition[0]
$pixelRandomDrop[1] = $g_aiDeployHeroesPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aiDeployHeroesPosition")
Else
$pixelRandomDrop[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDrop[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aaiBottomRightDropPoints")
EndIf
If $g_aiDeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $g_aiDeployCCPosition[0]
$pixelRandomDropcc[1] = $g_aiDeployCCPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aiDeployHeroesPosition")
Else
$pixelRandomDropcc[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDropcc[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aaiBottomRightDropPoints")
EndIf
If($g_bIsCCDropped = False And $infoTroopListArrPixel[0] = "CC" And $i = $numberSidesDropTroop - 1) Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $iCC)
$g_bIsCCDropped = True
ElseIf($g_bIsHeroesDropped = False And $infoTroopListArrPixel[0] = "HEROES" And $i = $numberSidesDropTroop - 1) Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $iKing, $iQueen, $iWarden)
$g_bIsHeroesDropped = True
EndIf
Else
$infoListArrPixel = $infoTroopListArrPixel[1]
Local $listPixel = $infoListArrPixel[$i]
If _Sleep($DELAYLAUNCHTROOP21) Then Return
SelectDropTroop($infoTroopListArrPixel[0])
If _Sleep($DELAYLAUNCHTROOP23) Then Return
SetLog("Dropping " & $infoTroopListArrPixel[2] & "  of " & $infoTroopListArrPixel[5] & " Points Per Side: " & $infoTroopListArrPixel[3] & " (side " & $i + 1 & ")", $COLOR_SUCCESS)
Local $pixelDropTroop[1] = [$listPixel]
DropOnPixel($infoTroopListArrPixel[0], $pixelDropTroop, $infoTroopListArrPixel[2], $infoTroopListArrPixel[3])
EndIf
If($g_bIsHeroesDropped) Then
If _sleep(1000) Then Return
CheckHeroesHealth()
EndIf
Next
If _Sleep(SetSleep(0)) Then Return
Next
EndIf
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If Not(IsString($infoPixelDropTroop[0]) And($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
Local $numberLeft = ReadTroopQuantity($infoPixelDropTroop[0])
If $g_bDebugSetlog Then
Local $aiSlotPos = GetSlotPosition($infoDropTroop[0])
SetDebugLog("Slot Nun= " & $infoPixelDropTroop[0])
SetDebugLog("Slot Xaxis= " & $aiSlotPos[0])
SetDebugLog($infoPixelDropTroop[5] & " - NumberLeft : " & $numberLeft)
EndIf
If($numberLeft > 0) Then
If _Sleep($DELAYLAUNCHTROOP21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($DELAYLAUNCHTROOP23) Then Return
SetLog("Dropping last " & $numberLeft & "  of " & $infoPixelDropTroop[5], $COLOR_SUCCESS)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], Ceiling($numberLeft), $infoPixelDropTroop[3])
EndIf
EndIf
If _Sleep(SetSleep(0)) Then Return
Next
If _Sleep(SetSleep(1)) Then Return
Next
EndFunc
Func DropTroopSmartFarm($troop, $nbSides, $number, $slotsPerEdge = 0, $name = "", $SIDESNAMES = "TR|TL|BR|BL")
Local $listInfoPixelDropTroop[0]
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = Ceiling($number / $nbSides)
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
Local $nbTroopsPerEdge = Round($nbTroopsLeft / $nbSides)
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
If $g_bDebugSmartFarm Then Setlog(" - " & GetTroopName($troop) & " Number: " & $number & " Sides: " & $nbSides & " SlotsPerEdge: " & $slotsPerEdge)
If $nbSides = 4 Then
ReDim $listInfoPixelDropTroop[4]
$listInfoPixelDropTroop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
Else
Local $TEMPlistInfoPixelDropTroop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
If StringInStr($SIDESNAMES, "|") <> 0 Then
Local $iTempSides = StringSplit($SIDESNAMES, "|", $STR_NOCOUNT)
ReDim $listInfoPixelDropTroop[UBound($iTempSides)]
For $i = 0 To UBound($iTempSides) - 1
Switch $iTempSides[$i]
Case "BR"
$listInfoPixelDropTroop[$i] = $TEMPlistInfoPixelDropTroop[0]
Case "TL"
$listInfoPixelDropTroop[$i] = $TEMPlistInfoPixelDropTroop[1]
Case "BL"
$listInfoPixelDropTroop[$i] = $TEMPlistInfoPixelDropTroop[2]
Case "TR"
$listInfoPixelDropTroop[$i] = $TEMPlistInfoPixelDropTroop[3]
EndSwitch
Next
Else
ReDim $listInfoPixelDropTroop[1]
Switch $SIDESNAMES
Case "BR"
$listInfoPixelDropTroop[0] = $TEMPlistInfoPixelDropTroop[0]
Case "TL"
$listInfoPixelDropTroop[0] = $TEMPlistInfoPixelDropTroop[1]
Case "BL"
$listInfoPixelDropTroop[0] = $TEMPlistInfoPixelDropTroop[2]
Case "TR"
$listInfoPixelDropTroop[0] = $TEMPlistInfoPixelDropTroop[3]
EndSwitch
EndIf
EndIf
Local $infoDropTroop[6] = [$troop, $listInfoPixelDropTroop, $nbTroopsPerEdge, $slotsPerEdge, $number, $name]
Return $infoDropTroop
EndFunc
Func AttackCSVDEBUGIMAGE()
Local $iTimer = __TimerInit()
_CaptureRegion2()
Local $EditedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $testx
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $pixel
Local $hPenLtGreen = _GDIPlus_PenCreate(0xFF00DC00, 2)
Local $hPenDkGreen = _GDIPlus_PenCreate(0xFF006E00, 2)
Local $hPenMdGreen = _GDIPlus_PenCreate(0xFF4CFF00, 2)
Local $hPenRed = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $hPenDkRed = _GDIPlus_PenCreate(0xFF6A0000, 2)
Local $hPenNavyBlue = _GDIPlus_PenCreate(0xFF000066, 2)
Local $hPenBlue = _GDIPlus_PenCreate(0xFF0000CC, 2)
Local $hPenSteelBlue = _GDIPlus_PenCreate(0xFF0066CC, 2)
Local $hPenLtBlue = _GDIPlus_PenCreate(0xFF0080FF, 2)
Local $hPenPaleBlue = _GDIPlus_PenCreate(0xFF66B2FF, 2)
Local $hPenCyan = _GDIPlus_PenCreate(0xFF00FFFF, 2)
Local $hPenYellow = _GDIPlus_PenCreate(0xFFFFD800, 2)
Local $hPenLtGrey = _GDIPlus_PenCreate(0xFFCCCCCC, 2)
Local $hPenWhite = _GDIPlus_PenCreate(0xFFFFFFFF, 2)
Local $hPenMagenta = _GDIPlus_PenCreate(0xFFFF00F6, 2)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[0][0], $ExternalArea[0][1], $ExternalArea[2][0], $ExternalArea[2][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[0][0], $ExternalArea[0][1], $ExternalArea[3][0], $ExternalArea[3][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[1][0], $ExternalArea[1][1], $ExternalArea[2][0], $ExternalArea[2][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[1][0], $ExternalArea[1][1], $ExternalArea[3][0], $ExternalArea[3][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[0][0], $InternalArea[0][1], $InternalArea[2][0], $InternalArea[2][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[0][0], $InternalArea[0][1], $InternalArea[3][0], $InternalArea[3][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[1][0], $InternalArea[1][1], $InternalArea[2][0], $InternalArea[2][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[1][0], $InternalArea[1][1], $InternalArea[3][0], $InternalArea[3][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[2][0], 0, $InternalArea[2][0], $g_iDEFAULT_HEIGHT, $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, $InternalArea[0][1], $g_iDEFAULT_WIDTH, $InternalArea[0][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[4][0], $ExternalArea[4][1], $ExternalArea[7][0], $ExternalArea[7][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[5][0], $ExternalArea[5][1], $ExternalArea[6][0], $ExternalArea[6][1], $hPenLtGreen)
For $i = 0 To UBound($g_aiPixelTopLeft) - 1
$pixel = $g_aiPixelTopLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($g_aiPixelTopRight) - 1
$pixel = $g_aiPixelTopRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($g_aiPixelBottomLeft) - 1
$pixel = $g_aiPixelBottomLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($g_aiPixelBottomRight) - 1
$pixel = $g_aiPixelBottomRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($g_aiPixelTopLeftDropLine) - 1
$pixel = $g_aiPixelTopLeftDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($g_aiPixelTopRightDropLine) - 1
$pixel = $g_aiPixelTopRightDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($g_aiPixelBottomLeftDropLine) - 1
$pixel = $g_aiPixelBottomLeftDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($g_aiPixelBottomRightDropLine) - 1
$pixel = $g_aiPixelBottomRightDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
For $i = 0 To UBound($g_aiPixelTopLeftDOWNDropLine) - 1
$pixel = $g_aiPixelTopLeftDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($g_aiPixelTopLeftUPDropLine) - 1
$pixel = $g_aiPixelTopLeftUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($g_aiPixelBottomLeftDOWNDropLine) - 1
$pixel = $g_aiPixelBottomLeftDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($g_aiPixelBottomLeftUPDropLine) - 1
$pixel = $g_aiPixelBottomLeftUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
For $i = 0 To UBound($g_aiPixelTopRightDOWNDropLine) - 1
$pixel = $g_aiPixelTopRightDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($g_aiPixelTopRightUPDropLine) - 1
$pixel = $g_aiPixelTopRightUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($g_aiPixelBottomRightDOWNDropLine) - 1
$pixel = $g_aiPixelBottomRightDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($g_aiPixelBottomRightUPDropLine) - 1
$pixel = $g_aiPixelBottomRightUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
$testx = MakeDropPoints("TOP-LEFT-DOWN", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-LEFT-DOWN", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-UP", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-UP", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-RIGHT-DOWN", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-RIGHT-DOWN", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-UP", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-UP", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-LEFT-UP", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-LEFT-UP", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-DOWN", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-DOWN", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-RIGHT-UP", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-RIGHT-UP", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-DOWN", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-DOWN", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
For $i = 0 To UBound($g_aiPixelMine) - 1
$pixel = $g_aiPixelMine[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenLtGreen)
Next
For $i = 0 To UBound($g_aiPixelElixir) - 1
$pixel = $g_aiPixelElixir[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 5, 20, 20, $hPenDkGreen)
Next
For $i = 0 To UBound($g_aiPixelDarkElixir) - 1
$pixel = $g_aiPixelDarkElixir[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 5, 20, 20, $hPenDkRed)
Next
If $g_bCSVLocateStorageGold = True And IsArray($g_aiCSVGoldStoragePos) Then
For $i = 0 To UBound($g_aiCSVGoldStoragePos) - 1
$pixel = $g_aiCSVGoldStoragePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 20, 20, $hPenWhite)
Next
EndIf
If $g_bCSVLocateStorageElixir = True And IsArray($g_aiCSVElixirStoragePos) Then
For $i = 0 To UBound($g_aiCSVElixirStoragePos) - 1
$pixel = $g_aiCSVElixirStoragePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 20, 20, $hPenMagenta)
Next
EndIf
_GDIPlus_GraphicsDrawRect($hGraphic, $g_iTHx - 5, $g_iTHy - 10, 30, 30, $hPenRed)
If $g_bCSVLocateEagle = True And IsArray($g_aiCSVEagleArtilleryPos) Then
_GDIPlus_GraphicsDrawRect($hGraphic, $g_aiCSVEagleArtilleryPos[0] - 15, $g_aiCSVEagleArtilleryPos[1] - 15, 30, 30, $hPenBlue)
EndIf
If $g_bCSVLocateInferno = True And IsArray($g_aiCSVInfernoPos) Then
For $i = 0 To UBound($g_aiCSVInfernoPos) - 1
$pixel = $g_aiCSVInfernoPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenNavyBlue)
Next
EndIf
If $g_bCSVLocateXBow = True And IsArray($g_aiCSVXBowPos) Then
For $i = 0 To UBound($g_aiCSVXBowPos) - 1
$pixel = $g_aiCSVXBowPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 25, 25, 25, $hPenBlue)
Next
EndIf
If $g_bCSVLocateWizTower = True And IsArray($g_aiCSVWizTowerPos) Then
For $i = 0 To UBound($g_aiCSVWizTowerPos) - 1
$pixel = $g_aiCSVWizTowerPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 5, $pixel[1] - 15, 25, 25, $hPenSteelBlue)
Next
EndIf
If $g_bCSVLocateMortar = True And IsArray($g_aiCSVMortarPos) Then
For $i = 0 To UBound($g_aiCSVMortarPos) - 1
$pixel = $g_aiCSVMortarPos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 15, 25, 25, $hPenLtBlue)
Next
EndIf
If $g_bCSVLocateAirDefense = True And IsArray($g_aiCSVAirDefensePos) Then
For $i = 0 To UBound($g_aiCSVAirDefensePos) - 1
$pixel = $g_aiCSVAirDefensePos[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 12, $pixel[1] - 10, 25, 25, $hPenPaleBlue)
Next
EndIf
_GDIPlus_GraphicsDrawString($hGraphic, "1", 580, 580, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "2", 750, 450, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "3", 750, 200, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "4", 580, 110, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "5", 260, 110, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "6", 110, 200, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "7", 110, 450, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "8", 310, 580, "Arial", 20)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $g_sProfileTempDebugPath & String("AttackDebug_" & $Date & "_" & $Time) & ".jpg"
_GDIPlus_ImageSaveToFile($EditedImage, $filename)
If @error Then SetLog("Debug Image save error: " & @extended, $COLOR_ERROR)
SetDebugLog("Attack CSV image saved: " & $filename)
_GDIPlus_PenDispose($hPenLtGreen)
_GDIPlus_PenDispose($hPenDkGreen)
_GDIPlus_PenDispose($hPenMdGreen)
_GDIPlus_PenDispose($hPenRed)
_GDIPlus_PenDispose($hPenDkRed)
_GDIPlus_PenDispose($hPenBlue)
_GDIPlus_PenDispose($hPenNavyBlue)
_GDIPlus_PenDispose($hPenSteelBlue)
_GDIPlus_PenDispose($hPenLtBlue)
_GDIPlus_PenDispose($hPenPaleBlue)
_GDIPlus_PenDispose($hPenCyan)
_GDIPlus_PenDispose($hPenYellow)
_GDIPlus_PenDispose($hPenLtGrey)
_GDIPlus_PenDispose($hPenWhite)
_GDIPlus_PenDispose($hPenMagenta)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($EditedImage)
If TestCapture() = True Then
ShellExecute($filename)
EndIf
SetDebugLog("AttackCSV DEBUG IMAGE Create Required: " & Round((__TimerDiff($iTimer) * 0.001), 1) & "Seconds", $COLOR_DEBUG)
EndFunc
Func CheckCsvValues($instruction, $variablenumber, $variable)
Switch $instruction
Case "MAKE"
Switch $variablenumber
Case 1
If $variable = "RANDOM" Then
Return True
Else
Local $vect1 = StringSplit($variable, "-", 2)
If UBound($vect1) = 0 Then
If StringLen($vect1) = 1 Then
If(Asc($vect1[$i]) >= 65 And Asc($vect1[$i]) <= 90) Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
Else
For $i = 0 To UBound($vect1) - 1
Local $tempstr = $vect1[$i]
If StringLen($tempstr) <> 1 Then
Return False
Else
If Not(Asc($vect1[$i]) >= 65 And Asc($vect1[$i]) <= 90) Then Return False
EndIf
Next
Return True
EndIf
EndIf
Case 2
Switch $variable
Case "FRONT-LEFT"
Return True
Case "FRONT-RIGHT"
Return True
Case "RIGHT-FRONT"
Return True
Case "RIGHT-BACK"
Return True
Case "LEFT-FRONT"
Return True
Case "LEFT-BACK"
Return True
Case "BACK-LEFT"
Return True
Case "BACK-RIGHT"
Return True
Case "RANDOM"
Return True
EndSwitch
Case 5
Switch $variable
Case "EXT-INT"
Return True
Case "INT-EXT"
Return True
Case "IGNORE"
Return True
Case Else
Return False
EndSwitch
Case 8
Switch $variable
Case "TOWNHALL"
Return True
Case "EAGLE"
Return True
Case "INFERNO"
Return True
Case "XBOW"
Return True
Case "WIZTOWER"
Return True
Case "MORTAR"
Return True
Case "AIRDEFENSE"
Return True
Case "EX-WALL"
Return True
Case "IN-WALL"
Return True
Case Else
Return False
EndSwitch
EndSwitch
EndSwitch
Return False
EndFunc
Func debugAttackCSV($string)
If $g_bDebugAttackCSV Then
_ConsoleWrite("A " & TimeDebug() & $string & @CRLF)
Local $hfile = FileOpen($g_sProfileLogsPath & "debugAttackCSV.log", $FO_APPEND)
_FileWriteLog($hfile, $string)
FileClose($hfile)
EndIf
EndFunc
Func DropTroopFromINI($vectors, $indexStart, $indexEnd, $indexArray, $qtaMin, $qtaMax, $troopName, $delayPointmin, $delayPointmax, $delayDropMin, $delayDropMax, $sleepafterMin, $sleepAfterMax, $sleepBeforeMin, $sleepBeforeMax, $debug = False)
If IsArray($indexArray) = 0 Then
debugAttackCSV("drop using vectors " & $vectors & " index " & $indexStart & "-" & $indexEnd & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
Else
debugAttackCSV("drop using vectors " & $vectors & " index " & _ArrayToString($indexArray, ",") & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
EndIf
debugAttackCSV(" - delay for multiple troops in same point: " & $delayPointmin & "-" & $delayPointmax)
debugAttackCSV(" - delay when change deploy point : " & $delayDropMin & "-" & $delayDropMax)
debugAttackCSV(" - delay after drop all troops : " & $sleepafterMin & "-" & $sleepAfterMax)
debugAttackCSV(" - delay before drop all troops : " & $sleepBeforeMin & "-" & $sleepBeforeMax)
Local $temp = StringSplit($vectors, "-")
Local $numbersOfVectors
If UBound($temp) > 0 Then
$numbersOfVectors = $temp[0]
Else
$numbersOfVectors = 0
EndIf
Local $vector1, $vector2, $vector3, $vector4
If UBound($temp) > 0 Then
If $temp[0] >= 1 Then $vector1 = "ATTACKVECTOR_" & $temp[1]
If $temp[0] >= 2 Then $vector2 = "ATTACKVECTOR_" & $temp[2]
If $temp[0] >= 3 Then $vector3 = "ATTACKVECTOR_" & $temp[3]
If $temp[0] >= 4 Then $vector4 = "ATTACKVECTOR_" & $temp[4]
Else
$vector1 = $vectors
EndIf
If $qtaMin <> $qtaMax Then
Local $qty = Random($qtaMin, $qtaMax, 1)
Else
Local $qty = $qtaMin
EndIf
debugAttackCSV(">> qty to deploy: " & $qty)
Local $qtyxpoint = Int($qty /($indexEnd - $indexStart + 1))
Local $extraunit = Mod($qty,($indexEnd - $indexStart + 1))
debugAttackCSV(">> qty x point: " & $qtyxpoint)
debugAttackCSV(">> qty extra: " & $extraunit)
Local $iTroopIndex = TroopIndexLookup($troopName, "DropTroopFromINI")
If $iTroopIndex = -1 Then
SetLog("CSV troop name '" & $troopName & "' is unrecognized.")
Return
EndIf
Local $bHeroDrop =($iTroopIndex = $eWarden ? True : False)
Local $troopPosition = -1
Local $troopSlotConst = -1
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $iTroopIndex And $g_avAttackTroops[$i][1] > 0 Then
debugAttackCSV("Found troop position " & $i & ". " & $troopName & " x" & $g_avAttackTroops[$i][1])
$troopSlotConst = $i
$troopPosition = $troopSlotConst
ExitLoop
EndIf
Next
debugAttackCSV("Troop position / Total slots: " & $troopSlotConst & " / " & $g_iTotalAttackSlot)
If $troopSlotConst >= 0 And $troopSlotConst < $g_iTotalAttackSlot - 10 Then
If $g_bDraggedAttackBar Then DragAttackBar($g_iTotalAttackSlot, True)
ElseIf $troopSlotConst > 10 Then
If $g_bDraggedAttackBar = False Then DragAttackBar($g_iTotalAttackSlot, False)
EndIf
If $g_bDraggedAttackBar And $troopPosition > -1 Then
$troopPosition = $troopSlotConst -($g_iTotalAttackSlot - 10)
debugAttackCSV("New troop position: " & $troopPosition)
EndIf
Local $bUseSpell = True
Switch $iTroopIndex
Case $eLSpell
If Not $g_abAttackUseLightSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eHSpell
If Not $g_abAttackUseHealSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eRSpell
If Not $g_abAttackUseRageSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eJSpell
If Not $g_abAttackUseJumpSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eFSpell
If Not $g_abAttackUseFreezeSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eCSpell
If Not $g_abAttackUseCloneSpell[$g_iMatchMode] Then $bUseSpell = False
Case $ePSpell
If Not $g_abAttackUsePoisonSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eESpell
If Not $g_abAttackUseEarthquakeSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eHaSpell
If Not $g_abAttackUseHasteSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eSkSpell
If Not $g_abAttackUseSkeletonSpell[$g_iMatchMode] Then $bUseSpell = False
Case $eBtSpell
If Not $g_abAttackUseBatSpell[$g_iMatchMode] Then $bUseSpell = False
EndSwitch
If $troopPosition = -1 Or Not $bUseSpell Then
If $bUseSpell Then
SetLog("No " & GetTroopName($iTroopIndex) & " found in your attack troops list")
debugAttackCSV("No " & GetTroopName($iTroopIndex) & " found in your attack troops list")
Else
If $g_bDebugSetlog Then SetDebugLog("Discard use " & GetTroopName($iTroopIndex), $COLOR_DEBUG)
EndIf
Else
If $g_iCSVLastTroopPositionDropTroopFromINI <> $troopSlotConst Then
ReleaseClicks()
SelectDropTroop($troopPosition)
$g_iCSVLastTroopPositionDropTroopFromINI = $troopSlotConst
ReleaseClicks()
KeepClicks()
EndIf
Local $sleepBefore = 0
If $sleepBeforeMin <> $sleepBeforeMax Then
$sleepBefore = Random($sleepBeforeMin, $sleepBeforeMax, 1)
Else
$sleepBefore = Int($sleepBeforeMin)
EndIf
$sleepBefore = Int($sleepBefore / $g_CSVSpeedDivider[$g_iMatchMode])
If $sleepBefore > 50 And IsKeepClicksActive() = False Then
debugAttackCSV("- delay Before drop all troops: " & $sleepBefore & " (x" & $g_CSVSpeedDivider[$g_iMatchMode] & " faster)")
If $sleepBefore <= 1000 Then
If _Sleep($sleepBefore) Then Return
CheckHeroesHealth()
Else
For $z = 1 To Int($sleepBefore/1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepBefore,1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
For $i = $indexStart To $indexEnd
Local $delayDrop = 0
Local $index = $i
Local $indexMax = $indexEnd
If IsArray($indexArray) = 1 Then
$index = $indexArray[$i]
$indexMax = $indexArray[$indexEnd]
EndIf
If $index <> $indexMax Then
If $delayDropMin <> $delayDropMax Then
$delayDrop = Random($delayDropMin, $delayDropMax, 1)
Else
$delayDrop = $delayDropMin
EndIf
$delayDrop = Int($delayDrop / $g_CSVSpeedDivider[$g_iMatchMode])
debugAttackCSV("- delay change drop point: " & $delayDrop & " (x" & $g_CSVSpeedDivider[$g_iMatchMode] & " faster)")
EndIf
For $j = 1 To $numbersOfVectors
Local $delayDropLast = 0
If $j = $numbersOfVectors Then $delayDropLast = $delayDrop
If $index <= UBound(Execute("$" & Eval("vector" & $j))) Then
Local $pixel = Execute("$" & Eval("vector" & $j) & "[" & $index - 1 & "]")
Local $qty2 = $qtyxpoint
If $index < $indexStart + $extraunit Then $qty2 += 1
If $delayPointmin <> $delayPointmax Then
Local $delayPoint = Random($delayPointmin, $delayPointmax, 1)
$delayPoint = Int($delayPoint / $g_CSVSpeedDivider[$g_iMatchMode])
debugAttackCSV("- random delay deploy point: " & $delayPoint & " (x" & $g_CSVSpeedDivider[$g_iMatchMode] & " faster)")
Else
Local $delayPoint = $delayPointmin
$delayPoint = Int($delayPoint / $g_CSVSpeedDivider[$g_iMatchMode])
EndIf
debugAttackCSV("- delay change deploy point: " & $delayPoint & " (x" & $g_CSVSpeedDivider[$g_iMatchMode] & " faster)")
Switch $iTroopIndex
Case $eBarb To $eIceG
If $debug = True Then
SetLog("AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0666")
EndIf
Case $eKing
If $debug = True Then
SetLog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ", " & $troopPosition & ", -1, -1) ")
Else
dropHeroes($pixel[0], $pixel[1], $troopPosition, -1, -1)
EndIf
Case $eQueen
If $debug = True Then
SetLog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ",-1," & $troopPosition & ", -1) ")
Else
dropHeroes($pixel[0], $pixel[1], -1, $troopPosition, -1)
EndIf
Case $eWarden
If $debug = True Then
SetLog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ", -1, -1," & $troopPosition & ") ")
Else
dropHeroes($pixel[0], $pixel[1], -1, -1, $troopPosition)
EndIf
Case $eCastle, $eWallW, $eBattleB, $eStoneS
If $debug = True Then
SetLog("dropCC(" & $pixel[0] & ", " & $pixel[1] & ", " & $troopPosition & ")")
Else
dropCC($pixel[0], $pixel[1], $troopPosition)
EndIf
Case $eLSpell To $eBtSpell
If $debug = True Then
SetLog("Drop Spell AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0667")
EndIf
If UBound($g_avAttackTroops) > $troopSlotConst And $g_avAttackTroops[$troopSlotConst][1] > 0 And $qty2 > 0 Then
$g_avAttackTroops[$troopSlotConst][1] -= $qty2
debugAttackCSV("Adjust quantity of spell use: " & $g_avAttackTroops[$troopSlotConst][0] & " x" & $g_avAttackTroops[$troopSlotConst][1])
EndIf
Case Else
SetLog("Error parsing line")
EndSwitch
debugAttackCSV($troopName & " qty " & $qty2 & " in (" & $pixel[0] & "," & $pixel[1] & ") delay " & $delayPoint)
EndIf
Next
Next
ReleaseClicks()
Local $sleepafter = 0
If $sleepafterMin <> $sleepAfterMax Then
$sleepafter = Random($sleepafterMin, $sleepAfterMax, 1)
Else
$sleepafter = Int($sleepafterMin)
EndIf
$sleepafter = Int($sleepafter / $g_CSVSpeedDivider[$g_iMatchMode])
If $sleepafter > 0 And IsKeepClicksActive() = False Then
debugAttackCSV("- delay after drop all troops: " & $sleepafter & " (x" & $g_CSVSpeedDivider[$g_iMatchMode] & " faster)")
If $sleepafter <= 1000 Then
If _Sleep($sleepafter) Then Return
If $bHeroDrop = True Then
Local $bHold = $g_bCheckWardenPower
$g_bCheckWardenPower = False
CheckHeroesHealth()
$g_bCheckWardenPower = $bHold
Else
CheckHeroesHealth()
EndIf
Else
For $z = 1 To Int($sleepafter / 1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepafter, 1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
EndIf
EndFunc
Func GetListPixel3($listPixel)
Local $listPixelSideStr = StringSplit($listPixel, "|")
If($listPixelSideStr[0] > 1) Then
Local $listPixelSide[UBound($listPixelSideStr) - 1]
For $i = 0 To UBound($listPixelSide) - 1
Local $pixelStr = StringSplit($listPixelSideStr[$i + 1], "-")
If($pixelStr[0] > 2) Then
Local $pixel = [Int($pixelStr[1]), Int($pixelStr[2]), Int($pixelStr[3])]
$listPixelSide[$i] = $pixel
EndIf
Next
Return $listPixelSide
Else
If StringInStr($listPixel, "-") > 0 Then
Local $pixelStrHere = StringSplit($listPixel, "-")
Local $pixelHere = [Int($pixelStrHere[1]), Int($pixelStrHere[2]), Int($pixelStrHere[3])]
Local $listPixelHere = [$pixelHere]
Return $listPixelHere
EndIf
Return -1
EndIf
EndFunc
Func isInsideDiamondRedArea($aCoords)
Local $Left = $ExternalArea[0][0], $Right = $ExternalArea[1][0], $Top = $ExternalArea[2][1], $Bottom = $ExternalArea[3][1]
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
Local $aSize = [$aMiddle[0] - $aDiamond[0][0], $aMiddle[1] - $aDiamond[0][1]]
Local $DX = Abs($aCoords[0] - $aMiddle[0])
Local $DY = Abs($aCoords[1] - $aMiddle[1])
If $DX >= 5 Then $DX -= 5
If $DY >= 5 Then $DY -= 5
If($DX / $aSize[0] + $DY / $aSize[1] <= 1) And $aCoords[0] > $DeployableLRTB[0] And $aCoords[0] <= $DeployableLRTB[1] And $aCoords[1] >= $DeployableLRTB[2] And $aCoords[1] <= $DeployableLRTB[3] Then
Return True
Else
Return False
EndIf
EndFunc
Func Line2Points($pixel0, $pixel1, $iXY, $iDim0 = 0)
Local $iDim1 = 1 - $iDim0
Return Round(($iXY - $pixel0[$iDim0]) /($pixel1[$iDim0] - $pixel0[$iDim0]) *($pixel1[$iDim1] - $pixel0[$iDim1]) + $pixel0[$iDim1])
EndFunc
Func MakeDropLine($searchvect, $startpoint, $endpoint, $iLineDistanceThreshold = 75, $bLineToCorner = False)
SetDebugLog("MakeDropLine for " & UBound($searchvect) & " points")
If $bLineToCorner = False And UBound($searchvect) > 0 Then $startpoint = $searchvect[0]
If $bLineToCorner = False And UBound($searchvect) > 0 Then $endpoint = $searchvect[UBound($searchvect) - 1]
SetDebugLog("MakeDropLine: Start = " & PixelToString($startpoint) & ", End = " & PixelToString($endpoint) & ": " & PixelArrayToString($searchvect, ","))
Local $startX = $startpoint[0]
Local $startY = $startpoint[1]
Local $size = UBound($searchvect)
ReDim $searchvect[$size + 1]
$searchvect[$size] = $endpoint
Local $Pixel0 = [$startX, $startY]
Local $ReturnVect = $startX & "," & $startY
For $idx = 0 To $size
Local $Pixel1 = $searchvect[$idx]
If $Pixel1[0] < 0 Then ContinueLoop
Local $aLen = [$Pixel1[0] - $Pixel0[0], $Pixel1[1] - $Pixel0[1]]
Local $iStart
Local $iEnd
Local $iStep
Local $iLoopAxis =((Abs($aLen[0]) >= Abs($aLen[1])) ?(0) :(1))
Local $iOtherAxis = 1 - $iLoopAxis
Local $iDistance
$iStep =(($aLen[$iLoopAxis] > 0) ?(1) :(-1))
$iStart = $Pixel0[$iLoopAxis]
$iEnd = $Pixel1[$iLoopAxis]
$iDistance = GetPixelDistance($Pixel0, $Pixel1)
If $iLineDistanceThreshold = -1 Or $iDistance <= $iLineDistanceThreshold Or($bLineToCorner = True And($idx = 0 Or $idx = $size)) Then
For $i = $iStart + $iStep To $iEnd Step $iStep
Local $j = Line2Points($Pixel0, $Pixel1, $i, $iLoopAxis)
Local $p[2]
$p[$iLoopAxis] = $i
$p[$iOtherAxis] = $j
$ReturnVect &= "|" & $p[0] & "," & $p[1]
Next
Else
$ReturnVect &= "|" & $Pixel1[0] & "," & $Pixel1[1]
EndIf
$Pixel0 = $Pixel1
Next
SetDebugLog("MakeDropLine: Done: " & $ReturnVect)
Return GetListPixel($ReturnVect, ",")
EndFunc
Func MakeDropLineOriginal($searchvect, $startpoint, $endpoint)
SetDebugLog("MakeDropLine for " & UBound($searchvect) & " points")
Local $startX = $startpoint[0]
Local $startY = $startpoint[1]
Local $endX = $endpoint[0]
Local $endY = $endpoint[1]
CheckAttackLocation($startX, $startY)
CheckAttackLocation($endX, $endY)
Local $point1 = [$startX, $startY]
Local $t, $f
$t = 0
$f = 0
Local $ReturnVect = $startX & "," & $startY
For $i = $startX + 1 To $endX
For $j = $t To UBound($searchvect) - 1
Local $pixel = $searchvect[$j]
If $i < $pixel[0] Then
Local $h = Line2Points($point1, $pixel, $i)
CheckAttackLocation($i, $h)
$ReturnVect &= "|" & $i & "," & $h
$f = $i
ExitLoop
Else
If $i = $pixel[0] Then
Local $x = $pixel[0]
Local $h = $pixel[1]
CheckAttackLocation($x, $h)
$ReturnVect &= "|" & $x & "," & $h
$point1 = $pixel
$t = $j + 1
$f = $i
ExitLoop
EndIf
EndIf
Next
Next
For $i = $f + 1 To $endX
Local $h = Line2Points($point1, $endpoint, $i)
CheckAttackLocation($i, $h)
$ReturnVect &= "|" & $i & "," & $h
Next
Return GetListPixel($ReturnVect, ",")
EndFunc
Func MakeDropPoints($side, $pointsQty, $addtiles, $versus, $randomx = 2, $randomy = 2)
debugAttackCSV("make for side " & $side)
Local $Vector, $Output = ""
Local $rndx = Random(0, Abs(Int($randomx)), 1)
Local $rndy = Random(0, Abs(Int($randomy)), 1)
If $side = "RANDOM" Then
EndIf
Switch $side
Case "TOP-LEFT-DOWN"
Local $Vector = $g_aiPixelTopLeftDOWNDropLine
Case "TOP-LEFT-UP"
Local $Vector = $g_aiPixelTopLeftUPDropLine
Case "TOP-RIGHT-DOWN"
Local $Vector = $g_aiPixelTopRightDOWNDropLine
Case "TOP-RIGHT-UP"
Local $Vector = $g_aiPixelTopRightUPDropLine
Case "BOTTOM-LEFT-UP"
Local $Vector = $g_aiPixelBottomLeftUPDropLine
Case "BOTTOM-LEFT-DOWN"
Local $Vector = $g_aiPixelBottomLeftDOWNDropLine
Case "BOTTOM-RIGHT-UP"
Local $Vector = $g_aiPixelBottomRightUPDropLine
Case "BOTTOM-RIGHT-DOWN"
Local $Vector = $g_aiPixelBottomRightDOWNDropLine
Case Else
EndSwitch
If $versus = "IGNORE" Then $versus = "EXT-INT"
If Int($pointsQty) > 0 Then
Local $pointsQtyCleaned = Abs(Int($pointsQty))
Else
Local $pointsQtyCleaned = 1
EndIf
Local $p = Int(UBound($Vector) / $pointsQtyCleaned)
If $p = 0 Then $p = 1
Local $x = 0
Local $y = 0
Local $str = ""
For $i = 0 To UBound($Vector) - 1
Local $pixel = $Vector[$i]
$str &= $pixel[0] & "-" & $pixel[1] & "|"
Next
Switch $side & "|" & $versus
Case "TOP-LEFT-DOWN|INT-EXT", "TOP-LEFT-UP|EXT-INT", "TOP-RIGHT-DOWN|EXT-INT", "TOP-RIGHT-UP|INT-EXT", "BOTTOM-LEFT-DOWN|EXT-INT", "BOTTOM-LEFT-UP|INT-EXT", "BOTTOM-RIGHT-DOWN|INT-EXT", "BOTTOM-RIGHT-UP|EXT-INT"
For $i = UBound($Vector) To 1 Step -1
$pixel = $Vector[$i - 1]
$x += $pixel[0]
$y += $pixel[1]
If Mod(UBound($Vector) - $i + 1, $p) = 0 Then
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case Else
EndSwitch
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
$Output &= $pixel[0] & "-" & $pixel[1] & "|"
$x = 0
$y = 0
EndIf
Next
Case "TOP-LEFT-DOWN|EXT-INT", "TOP-LEFT-UP|INT-EXT", "TOP-RIGHT-DOWN|INT-EXT", "TOP-RIGHT-UP|EXT-INT", "BOTTOM-LEFT-DOWN|INT-EXT", "BOTTOM-LEFT-UP|EXT-INT", "BOTTOM-RIGHT-DOWN|EXT-INT", "BOTTOM-RIGHT-UP|INT-EXT"
For $i = 1 To UBound($Vector)
$pixel = $Vector[$i - 1]
$x += $pixel[0]
$y += $pixel[1]
If Mod($i, $p) = 0 Then
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case Else
EndSwitch
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
$Output &= $pixel[0] & "-" & $pixel[1] & "|"
$x = 0
$y = 0
EndIf
Next
Case Else
EndSwitch
If StringLen($Output) > 0 Then $Output = StringLeft($Output, StringLen($Output) - 1)
Return GetListPixel($Output)
EndFunc
Func MakeTargetDropPoints($side, $pointsQty, $addtiles, $building)
debugAttackCSV("make for side " & $side & ", target: " & $building)
Local $Vector, $Output = ""
Local $x, $y
Local $sLoc, $aLocation, $pixel[2], $BuildingEnum, $result, $array
Switch $building
Case "TOWNHALL"
$BuildingEnum = $eBldgTownHall
Case "EAGLE"
$BuildingEnum = $eBldgEagle
Case "INFERNO"
$BuildingEnum = $eBldgInferno
Case "XBOW"
$BuildingEnum = $eBldgXBow
Case "WIZTOWER"
$BuildingEnum = $eBldgWizTower
Case "MORTAR"
$BuildingEnum = $eBldgMortar
Case "AIRDEFENSE"
$BuildingEnum = $eBldgAirDefense
Case "EX-WALL"
$BuildingEnum = $eExternalWall
Case "IN-WALL"
$BuildingEnum = $eInternalWall
Case Else
SetLog("Defense name not understood", $COLOR_ERROR)
SetError(1, 0, "")
Return
EndSwitch
Local $aBuildingLoc = _ObjGetValue($g_oBldgAttackInfo, $BuildingEnum & "_LOCATION")
If @error Then
_ObjErrMsg("_ObjGetValue " & $g_sBldgNames[$BuildingEnum] & " _LOCATION", @error)
SetError(2, 0, "")
Return
EndIf
If IsArray($aBuildingLoc) Then
If UBound($aBuildingLoc, 1) > 1 And IsArray($aBuildingLoc[1]) Then
For $p = 0 To UBound($aBuildingLoc) - 1
$array = $aBuildingLoc[$p]
$result = IsPointOnSide($array, $side)
If @error Then
Return SetError(4, 0, "")
EndIf
If $result = True Then
$aLocation = $aBuildingLoc[$p]
ExitLoop
EndIf
Next
If $aLocation = "" Then
SetLog("Building location not found on side, random pick", $COLOR_ERROR)
If IsArray($aBuildingLoc[0]) Then $aLocation = $aBuildingLoc[0]
EndIf
Else
$aLocation = $aBuildingLoc[0]
EndIf
Else
SetLog($g_sBldgNames[$BuildingEnum] & " _LOCATION not an array", $COLOR_ERROR)
Return SetError(3, 0, "")
EndIf
Switch Int($pointsQty)
Case 1
$x += $aLocation[0]
$y += $aLocation[1]
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
$pixel[0] = $x - $l
$pixel[1] = $y - $l
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
$pixel[0] = $x + $l
$pixel[1] = $y - $l
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
$pixel[0] = $x - $l
$pixel[1] = $y + $l
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
$pixel[0] = $x + $l
$pixel[1] = $y + $l
Case Else
SetLog("Silly code monkey 'MAKE' TargetDropPoints mistake", $COLOR_ERROR)
SetError(5, 0, "")
Return
EndSwitch
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
If isInsideDiamondRedArea($pixel) = False Then SetDebugLog("MakeTargetDropPoints() ADDTILES error!")
$sLoc = $pixel[0] & "-" & $pixel[1]
SetLog("Target drop point for " & $g_sBldgNames[$BuildingEnum] & " (adding " & $addtiles & " tiles): " & $sLoc)
Return GetListPixel($sLoc, "-", "MakeTargetDropPoints TARGET")
Case 5
$sLoc = $aLocation[0] & "|" & $aLocation[1]
$Output = GetDeployableNextTo($sLoc, 10, $g_oBldgAttackInfo.item($eBldgRedLine & "_OBJECTPOINTS"))
Return GetListPixel($Output, ",", "MakeTargetDropPoints NEARPOINTS")
Case Else
SetLog("Strange MakeTargetDropPoint Error", $COLOR_ERROR)
Return SetError(6, 0, "")
EndSwitch
EndFunc
Func ParseAttackCSV($debug = False)
Local $sErrorText, $sTargetVectors = ""
Local $iTroopIndex, $bWardenDrop = False
Local $sides2drop[4] = [False, False, False, False]
For $v = 0 To 25
Assign("ATTACKVECTOR_" & Chr(65 + $v), "", $ASSIGN_EXISTFAIL)
If @error Then SetLog("Failed to erase old vector: " & Chr(65 + $v) & ", ask code monkey to fix!", $COLOR_ERROR)
Next
If $g_iMatchMode = $DB Then
Local $filename = $g_sAttackScrScriptName[$DB]
Else
Local $filename = $g_sAttackScrScriptName[$LB]
EndIf
SetLog("execute " & $filename)
Local $f, $line, $acommand, $command
Local $value1 = "", $value2 = "", $value3 = "", $value4 = "", $value5 = "", $value6 = "", $value7 = "", $value8 = "", $value9 = ""
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
Local $aLines = FileReadToArray($g_sCSVAttacksPath & "\" & $filename & ".csv")
For $iLine = 0 To UBound($aLines) - 1
$line = $aLines[$iLine]
$sErrorText = ""
debugAttackCSV("line: " & $iLine + 1)
If @error = -1 Then ExitLoop
If $debug = True Then SetLog("parse line:<<" & $line & ">>")
debugAttackCSV("line content: " & $line)
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), $STR_STRIPTRAILING)
If $command = "TRAIN" Or $command = "REDLN" Or $command = "DRPLN" Or $command = "CCREQ" Then ContinueLoop
If $command = "SIDE" Or $command = "SIDEB" Then ContinueLoop
For $i = 2 To(UBound($acommand) - 1)
Assign("value" & Number($i - 1), StringStripWS(StringUpper($acommand[$i]), $STR_STRIPTRAILING))
Next
Switch $command
Case ""
debugAttackCSV("comment line")
Case "MAKE"
ReleaseClicks()
If CheckCsvValues("MAKE", 2, $value2) Then
Local $sidex = StringReplace($value2, "-", "_")
If $sidex = "RANDOM" Then
Switch Random(1, 4, 1)
Case 1
$sidex = "FRONT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "LEFT"
Else
$sidex &= "RIGHT"
EndIf
$sides2drop[0] = True
Case 2
$sidex = "BACK_"
If Random(0, 1, 1) = 0 Then
$sidex &= "LEFT"
Else
$sidex &= "RIGHT"
EndIf
$sides2drop[1] = True
Case 3
$sidex = "LEFT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "FRONT"
Else
$sidex &= "BACK"
EndIf
$sides2drop[2] = True
Case 4
$sidex = "RIGHT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "FRONT"
Else
$sidex &= "BACK"
EndIf
$sides2drop[3] = True
EndSwitch
EndIf
Switch Eval($sidex)
Case StringInStr(Eval($sidex), "TOP-LEFT") > 0
$sides2drop[0] = True
Case StringInStr(Eval($sidex), "TOP-RIGHT") > 0
$sides2drop[1] = True
Case StringInStr(Eval($sidex), "BOTTOM-LEFT") > 0
$sides2drop[2] = True
Case StringInStr(Eval($sidex), "BOTTOM-RIGHT") > 0
$sides2drop[3] = True
EndSwitch
If CheckCsvValues("MAKE", 1, $value1) And CheckCsvValues("MAKE", 5, $value5) Then
$sTargetVectors = StringReplace($sTargetVectors, $value3, "", Default, $STR_NOCASESENSEBASIC)
If CheckCsvValues("MAKE", 8, $value8) Then
If $value3 = 1 Or $value3 = 5 Then
Local $tmpArray = MakeTargetDropPoints(Eval($sidex), $value3, $value4, $value8)
If @error Then
$sErrorText = "MakeTargetDropPoints: " & @error
Else
Assign("ATTACKVECTOR_" & $value1, $tmpArray)
$sTargetVectors &= $value1
EndIf
Else
$sErrorText = "value 3"
EndIf
Else
Assign("ATTACKVECTOR_" & $value1, MakeDropPoints(Eval($sidex), $value3, $value4, $value5, $value6, $value7))
EndIf
Else
$sErrorText = "value1 or value 5"
EndIf
Else
$sErrorText = "value2"
EndIf
If $sErrorText <> "" Then
SetLog("Discard row, bad " & $sErrorText & " parameter: row " & $iLine + 1)
debugAttackCSV("Discard row, bad " & $sErrorText & " parameter: row " & $iLine + 1)
Else
For $i = 0 To UBound(Execute("$ATTACKVECTOR_" & $value1)) - 1
Local $pixel = Execute("$ATTACKVECTOR_" & $value1 & "[" & $i & "]")
debugAttackCSV($i & " - " & $pixel[0] & "," & $pixel[1])
Next
EndIf
Case "DROP"
KeepClicks()
Local $index1, $index2, $indexArray, $indexvect
$indexvect = StringSplit($value2, "-", 2)
If UBound($indexvect) > 1 Then
$indexArray = 0
If Int($indexvect[0]) > 0 And Int($indexvect[1]) > 0 Then
$index1 = Int($indexvect[0])
$index2 = Int($indexvect[1])
Else
$index1 = 1
$index2 = 1
EndIf
Else
$indexArray = StringSplit($value2, ",", 2)
If UBound($indexArray) > 1 Then
$index1 = 0
$index2 = UBound($indexArray) - 1
Else
$indexArray = 0
If Int($value2) > 0 Then
$index1 = Int($value2)
$index2 = Int($value2)
Else
$index1 = 1
$index2 = 1
EndIf
EndIf
EndIf
Local $qty1, $qty2, $qtyvect, $bUpdateQuantity = False
If StringInStr($value3, "%") > 0 Then
$qtyvect = StringSplit($value3, "%", 2)
If UBound($qtyvect) > 0 Then
If UBound($qtyvect) > 1 Then $bUpdateQuantity =(($qtyvect[1] = "U") ? True : False)
Local $theTroopPosition = -2
Local $troopName = $value4
Local $iTroopIndex = TroopIndexLookup($troopName)
If $iTroopIndex = -1 Then
SetLog("CSV CMD '%' troop name '" & $troopName & "' is unrecognized.")
Return
EndIf
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $iTroopIndex Then
$theTroopPosition = $i
ExitLoop
EndIf
Next
If $bUpdateQuantity = True Then
If $theTroopPosition >= 0 Then
SetLog("Updating Available " & GetTroopName($iTroopIndex) & " Quantities", $COLOR_INFO)
$theTroopPosition = UpdateTroopQuantity($troopName)
EndIf
EndIf
If $theTroopPosition >= 0 And UBound($g_avAttackTroops) > $theTroopPosition Then
If Int($qtyvect[0]) > 0 Then
$qty1 = Round((Number($qtyvect[0]) / 100) * Number($g_avAttackTroops[Number($theTroopPosition)][1]))
$qty2 = $qty1
SetLog($qtyvect[0] & "% Of x" & Number($g_avAttackTroops[$theTroopPosition][1]) & " " & GetTroopName($g_avAttackTroops[$theTroopPosition][0]) & " = " & $qty1, $COLOR_INFO)
Else
$index1 = 1
$qty2 = 1
EndIf
Else
$qty1 = 0
$qty2 = 0
EndIf
Else
If Int($value3) > 0 Then
$qty1 = Int($value3)
$qty2 = Int($value3)
Else
$qty1 = 1
$qty2 = 1
EndIf
EndIf
Else
$qtyvect = StringSplit($value3, "-", 2)
If UBound($qtyvect) > 1 Then
If Int($qtyvect[0]) > 0 And Int($qtyvect[1]) > 0 Then
$qty1 = Int($qtyvect[0])
$qty2 = Int($qtyvect[1])
Else
$index1 = 1
$qty2 = 1
EndIf
Else
If Int($value3) > 0 Then
$qty1 = Int($value3)
$qty2 = Int($value3)
Else
$qty1 = 1
$qty2 = 1
EndIf
EndIf
EndIf
Local $delaypoints1, $delaypoints2, $delaypointsvect
$delaypointsvect = StringSplit($value5, "-", 2)
If UBound($delaypointsvect) > 1 Then
If Int($delaypointsvect[0]) >= 0 And Int($delaypointsvect[1]) >= 0 Then
$delaypoints1 = Int($delaypointsvect[0])
$delaypoints2 = Int($delaypointsvect[1])
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
Else
If Int($value5) >= 0 Then
$delaypoints1 = Int($value5)
$delaypoints2 = Int($value5)
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
EndIf
Local $delaydrop1, $delaydrop2, $delaydropvect
$delaydropvect = StringSplit($value6, "-", 2)
If UBound($delaydropvect) > 1 Then
If Int($delaydropvect[0]) >= 0 And Int($delaydropvect[1]) >= 0 Then
$delaydrop1 = Int($delaydropvect[0])
$delaydrop2 = Int($delaydropvect[1])
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
Else
If Int($value6) >= 0 Then
$delaydrop1 = Int($value6)
$delaydrop2 = Int($value6)
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
EndIf
Local $sleepdrop1, $sleepdrop2, $sleepdroppvect
$sleepdroppvect = StringSplit($value7, "-", 2)
If UBound($sleepdroppvect) > 1 Then
If Int($sleepdroppvect[0]) >= 0 And Int($sleepdroppvect[1]) >= 0 Then
$sleepdrop1 = Int($sleepdroppvect[0])
$sleepdrop2 = Int($sleepdroppvect[1])
Else
$index1 = 1
$sleepdrop2 = 1
EndIf
Else
If Int($value7) >= 0 Then
$sleepdrop1 = Int($value7)
$sleepdrop2 = Int($value7)
Else
$sleepdrop1 = 1
$sleepdrop2 = 1
EndIf
EndIf
Local $sleepbeforedrop1 = 0, $sleepbeforedrop2 = 0, $sleepbeforedroppvect
$sleepbeforedroppvect = StringSplit($value8, "-", 2)
If UBound($sleepbeforedroppvect) > 1 Then
If Int($sleepbeforedroppvect[0]) > 0 And Int($sleepbeforedroppvect[1]) > 0 Then
$sleepbeforedrop1 = Int($sleepbeforedroppvect[0])
$sleepbeforedrop2 = Int($sleepbeforedroppvect[1])
Else
$sleepbeforedrop1 = 0
$sleepbeforedrop2 = 0
EndIf
Else
If Int($value3) > 0 Then
$sleepbeforedrop1 = Int($value8)
$sleepbeforedrop2 = Int($value8)
Else
$sleepbeforedrop1 = 0
$sleepbeforedrop2 = 0
EndIf
EndIf
Local $tmpVectorList = StringSplit($value1, "-", $STR_NOCOUNT)
For $v = 0 To UBound($tmpVectorList) - 1
If StringInStr($sTargetVectors, $tmpVectorList[$v], $STR_NOCASESENSEBASIC) = True Then
If IsArray($indexArray) Then
For $i = $index1 To $index2
If $indexArray[$i] < 1 Or $indexArray[$i] > 5 Then
$sErrorText &= "Invalid INDEX for near building DROP"
SetDebugLog("$index1: " & $index1 & ", $index2: " & $index2 & ", $indexArray[" & $i & "]: " & $indexArray[$i], $COLOR_ERROR)
ExitLoop
EndIf
Next
ElseIf $indexArray = 0 Then
Select
Case $index1 = 1 And $index1 = $index2
Case $index1 >= 1 And $index1 <= 5 And $index2 > 1 And $index2 <= 5
Case Else
$sErrorText &= "Invalid INDEX for building target"
SetDebugLog("$index1: " & $index1 & ", $index2: " & $index2, $COLOR_ERROR)
EndSelect
Else
SetDebugLog("Monkey found a bad banana checking Bdlg target INDEX!", $COLOR_ERROR)
EndIf
EndIf
Next
If $sErrorText <> "" Then
SetLog("Discard row, " & $sErrorText & ": row " & $iLine + 1)
debugAttackCSV("Discard row, " & $sErrorText & ": row " & $iLine + 1)
Else
If $value4 = "REMAIN" Then
ReleaseClicks()
SetLog("Drop|Remain:  Dropping left over troops", $COLOR_INFO)
If PrepareAttack($g_iMatchMode, True) > 0 Then
For $ii = $eBarb To $eIceG
For $x = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$x][0] = $ii And $g_avAttackTroops[$x][1] > 0 Then
Local $name = GetTroopName($g_avAttackTroops[$x][0], $g_avAttackTroops[$x][1])
SetLog("Name: " & $name, $COLOR_DEBUG)
SetLog("Qty: " & $g_avAttackTroops[$x][1], $COLOR_DEBUG)
DropTroopFromINI($value1, $index1, $index2, $indexArray, $g_avAttackTroops[$x][1], $g_avAttackTroops[$x][1], $g_asTroopShortNames[$ii], $delaypoints1, $delaypoints2, $delaydrop1, $delaydrop2, $sleepdrop1, $sleepdrop2, $sleepbeforedrop1, $sleepbeforedrop2, $debug)
CheckHeroesHealth()
If _Sleep($DELAYALGORITHM_ALLTROOPS5) Then Return
EndIf
Next
Next
EndIf
Else
DropTroopFromINI($value1, $index1, $index2, $indexArray, $qty1, $qty2, $value4, $delaypoints1, $delaypoints2, $delaydrop1, $delaydrop2, $sleepdrop1, $sleepdrop2, $sleepbeforedrop1, $sleepbeforedrop2, $debug)
EndIf
EndIf
ReleaseClicks($g_iAndroidAdbClicksTroopDeploySize)
If _Sleep($DELAYRESPOND) Then Return
If $value4 <> "REMAIN" Then
$iTroopIndex = TroopIndexLookup($value4, "ParseAttackCSV")
$bWardenDrop =($iTroopIndex = $eWarden) And($sleepdrop1 < 1000)
EndIf
Case "WAIT"
Local $hSleepTimer = __TimerInit()
ReleaseClicks()
Local $sleep1, $sleep2, $sleepvect
$sleepvect = StringSplit($value1, "-", 2)
If UBound($sleepvect) > 1 Then
If Int($sleepvect[0]) > 0 And Int($sleepvect[1]) > 0 Then
$sleep1 = Int($sleepvect[0])
$sleep2 = Int($sleepvect[1])
Else
$sleep1 = 1
$sleep2 = 1
EndIf
Else
If Int($value1) > 0 Then
$sleep1 = Int($value1)
$sleep2 = Int($value1)
Else
$sleep1 = 1
$sleep2 = 1
EndIf
EndIf
If $sleep1 <> $sleep2 Then
Local $sleep = Random(Int($sleep1), Int($sleep2), 1)
Else
Local $sleep = Int($sleep1)
EndIf
debugAttackCSV("wait " & $sleep)
Local $Gold = 0
Local $Elixir = 0
Local $DarkElixir = 0
Local $Trophies = 0
Local $exitOneStar = 0
Local $exitTwoStars = 0
Local $exitNoResources = 0
Local $exitAttackEnded = 0
Local $bBreakOnTH = False
Local $bBreakOnSiege = False
Local $bBreakOnTHAndSiege = False
Local $aSiegeSlotPos = [0,0]
Local $tempvalue2 = StringStripWS($value2, $STR_STRIPALL)
If StringLen($tempvalue2) > 0 Then
Local $aParam = StringSplit($tempvalue2, ",", $STR_NOCOUNT)
For $iParam = 0 To UBound($aParam) - 1
Switch $aParam[$iParam]
Case "TH"
$bBreakOnTH = True
Case "SIEGE"
$bBreakOnSiege = True
Case "TH+SIEGE"
$bBreakOnTHAndSiege = True
EndSwitch
Next
SetDebugLog("$bBreakOnTH = " & $bBreakOnTH & ", $bBreakOnSiege = " & $bBreakOnSiege & ", $bBreakOnTHAndSiege = " & $bBreakOnTHAndSiege, $COLOR_INFO)
If $bBreakOnSiege Or $bBreakOnTHAndSiege Then
debugAttackCSV("WAIT Condition Break on Siege Troop Drop set")
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eCastle Then
SetDebugLog("WAIT Break on Siege Machine is set but Clan Castle Troop selected.", $COLOR_INFO)
ExitLoop
ElseIf $g_avAttackTroops[$i][0] = $eWallW Or $g_avAttackTroops[$i][0] = $eBattleB Or $g_avAttackTroops[$i][0] = $eStoneS Then
Local $sSiegeName = GetTroopName($g_avAttackTroops[$i][0])
SetDebugLog("	" & $sSiegeName & " found. Let's Check If is Dropped Or Not?", $COLOR_SUCCESS)
If ReadTroopQuantity($i) = 0 Then
SetDebugLog("	" & $sSiegeName & " is dropped.", $COLOR_SUCCESS)
$aSiegeSlotPos = GetSlotPosition($i, True)
Else
SetDebugLog("	" & $sSiegeName & " is not dropped yet.", $COLOR_SUCCESS)
EndIf
ExitLoop
EndIf
Next
If $aSiegeSlotPos[0] = 0 And $aSiegeSlotPos[1] = 0 Then
SetDebugLog("WAIT no dropped Siege found, so unset Break on Siege.", $COLOR_INFO)
If $bBreakOnTHAndSiege Then $bBreakOnTH = True
$bBreakOnSiege = False
$bBreakOnTHAndSiege = False
If Not $bBreakOnTH Then ContinueLoop
EndIf
EndIf
EndIf
While __TimerDiff($hSleepTimer) < $sleep
CheckHeroesHealth()
If $bBreakOnSiege And CheckIfSiegeDroppedTheTroops($hSleepTimer, $aSiegeSlotPos) Then ContinueLoop 2
If $bBreakOnTH And CheckIfTownHallGotDestroyed($hSleepTimer) Then ContinueLoop 2
If $bBreakOnTHAndSiege And CheckIfSiegeDroppedTheTroops($hSleepTimer, $aSiegeSlotPos) And CheckIfTownHallGotDestroyed($hSleepTimer) Then ContinueLoop 2
$Gold = getGoldVillageSearch(48, 69)
$Elixir = getElixirVillageSearch(48, 69 + 29)
If _Sleep($DELAYRESPOND) Then Return
$Trophies = getTrophyVillageSearch(48, 69 + 99)
If $Trophies <> "" Then
$DarkElixir = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
CheckHeroesHealth()
If $bBreakOnSiege And CheckIfSiegeDroppedTheTroops($hSleepTimer, $aSiegeSlotPos) Then ContinueLoop 2
If $bBreakOnTH And CheckIfTownHallGotDestroyed($hSleepTimer) Then ContinueLoop 2
If $bBreakOnTHAndSiege And CheckIfSiegeDroppedTheTroops($hSleepTimer, $aSiegeSlotPos) And CheckIfTownHallGotDestroyed($hSleepTimer) Then ContinueLoop 2
If $g_bDebugSetlog Then SetDebugLog("detected [G]: " & $Gold & " [E]: " & $Elixir & " [DE]: " & $DarkElixir, $COLOR_INFO)
If $g_abStopAtkNoResources[$g_iMatchMode] And Number($Gold) = 0 And Number($Elixir) = 0 And Number($DarkElixir) = 0 Then
If Not $g_bDebugSetlog Then SetDebugLog("detected [G]: " & $Gold & " [E]: " & $Elixir & " [DE]: " & $DarkElixir, $COLOR_INFO)
SetDebugLog("From Attackcsv: Gold & Elixir & DE = 0, end battle ", $COLOR_DEBUG)
$exitNoResources = 1
ExitLoop
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And _CheckPixel($aWonTwoStar, True) Then
SetDebugLog("From Attackcsv: Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
ExitLoop
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And _CheckPixel($aWonOneStar, True) Then
SetDebugLog("From Attackcsv: One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
ExitLoop
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Int($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
ExitLoop
EndIf
If _CheckPixel($aEndFightSceneBtn, True) And _CheckPixel($aEndFightSceneAvl, True) And _CheckPixel($aEndFightSceneReportGold, True) Then
SetDebugLog("From Attackcsv: Found End Fight Scene to close, exit", $COLOR_SUCCESS)
$exitAttackEnded = 1
ExitLoop
EndIf
If _Sleep($DELAYRESPOND) Then Return
WEnd
If $exitOneStar = 1 Or $exitTwoStars = 1 Or $exitNoResources = 1 Or $exitAttackEnded = 1 Then ExitLoop
Case "RECALC"
ReleaseClicks()
PrepareAttack($g_iMatchMode, True)
Case Else
Switch StringLeft($command, 1)
Case ";", "#", "'"
debugAttackCSV("comment line")
Case Else
SetLog("attack row bad, discard: row " & $iLine + 1, $COLOR_ERROR)
EndSwitch
EndSwitch
Else
If StringLeft($line, 7) <> "NOTE  |" And StringLeft($line, 7) <> "      |" And StringStripWS(StringUpper($line), 2) <> "" Then SetLog("attack row error, discard: row " & $iLine + 1, $COLOR_ERROR)
EndIf
If $bWardenDrop = True Then
Local $bHold = $g_bCheckWardenPower
$g_bCheckWardenPower = False
CheckHeroesHealth()
$g_bCheckWardenPower = $bHold
Else
CheckHeroesHealth()
EndIf
If _Sleep($DELAYRESPOND) Then Return
Next
For $i = 0 To 3
If $sides2drop[$i] Then $g_iSidesAttack += 1
Next
ReleaseClicks()
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Func CheckIfSiegeDroppedTheTroops($hSleepTimer, $aSiegeSlotPos)
If _ColorCheck(_GetPixelColor($aSiegeSlotPos[0] + 20, $aSiegeSlotPos[1] + 20, True, "WAIT--> IsSiegeDestroyed"), Hex(0x474747, 6), 10) Then
SetDebugLog("WAIT--> Siege Got Destroyed After " & Round(__TimerDiff($hSleepTimer)) & "ms.", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func CheckIfTownHallGotDestroyed($hSleepTimer)
Static $hPopupTimer = 0
Local $bIsTHDestroyed = False
Local $bWonOneStar = _CheckPixel($aWonOneStar, True)
Local $bWonTwoStar = _CheckPixel($aWonTwoStar, True)
Local $bCentralStarPopup = _ColorCheck(_GetPixelColor(Int($g_iGAME_WIDTH / 2) - 2, Int($g_iGAME_HEIGHT / 2) - 2, True), Hex(0xC0C4C0, 6), 20) And  _ColorCheck(_GetPixelColor(Int($g_iGAME_WIDTH / 2) - 2, Int($g_iGAME_HEIGHT / 2) + 2, True), Hex(0xC0C4C0, 6), 20) And  _ColorCheck(_GetPixelColor(Int($g_iGAME_WIDTH / 2) + 2, Int($g_iGAME_HEIGHT / 2) + 2, True), Hex(0xC0C4C0, 6), 20) And  _ColorCheck(_GetPixelColor(Int($g_iGAME_WIDTH / 2) + 2, Int($g_iGAME_HEIGHT / 2) - 2, True), Hex(0xC0C4C0, 6), 20)
Local $iDamage = Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY))
If $bCentralStarPopup Then
If $iDamage < 50 Then
$bIsTHDestroyed = True
ElseIf $bWonOneStar Then
$bIsTHDestroyed = True
ElseIf $hPopupTimer = 0 Or __TimerDiff($hPopupTimer) > 1500 Then
$hPopupTimer = __TimerInit()
ElseIf __TimerDiff($hPopupTimer) > 500 Then
$bIsTHDestroyed = True
EndIf
ElseIf $bWonOneStar And $iDamage < 50 Then
$bIsTHDestroyed = True
ElseIf $bWonTwoStar Then
$bIsTHDestroyed = True
EndIf
SetDebugLog("WAIT--> $iDamage: " & $iDamage & ", $bCentralStarPopup: " & $bCentralStarPopup & ", $bWonOneStar: " & $bWonOneStar & ", $bWonTwoStar: " & $bWonTwoStar & ", $bIsTHDestroyed: " & $bIsTHDestroyed, $COLOR_INFO)
If $bIsTHDestroyed Then SetDebugLog("WAIT--> Town Hall Got Destroyed After " & Round(__TimerDiff($hSleepTimer)) & "ms.", $COLOR_SUCCESS)
Return $bIsTHDestroyed
EndFunc
Func ParseAttackCSV_MainSide($debug = False)
Local $bForceSideExist = False
If $g_iMatchMode = $DB Then
Local $filename = $g_sAttackScrScriptName[$DB]
Else
Local $filename = $g_sAttackScrScriptName[$LB]
EndIf
Local $line, $acommand, $command
Local $value1 = "", $value2 = "", $value3 = "", $value4 = "", $value5 = "", $value6 = "", $value7 = "", $value8 = "", $value9 = ""
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
Local $aLines = FileReadToArray($g_sCSVAttacksPath & "\" & $filename & ".csv")
For $iLine = 0 To UBound($aLines) - 1
$line = $aLines[$iLine]
debugAttackCSV("line: " & $iLine + 1)
If @error = -1 Then ExitLoop
If $debug = True Then SetLog("parse line:<<" & $line & ">>")
debugAttackCSV("line content: " & $line)
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), $STR_STRIPTRAILING)
If $command <> "SIDE" And $command <> "SIDEB" Then ContinueLoop
For $i = 2 To(UBound($acommand) - 1)
Assign("value" & Number($i - 1), StringStripWS(StringUpper($acommand[$i]), $STR_STRIPTRAILING))
Next
Switch $command
Case "SIDE"
ReleaseClicks()
SetLog("Calculate main side... ")
Local $heightTopLeft = 0, $heightTopRight = 0, $heightBottomLeft = 0, $heightBottomRight = 0
If StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
$MAINSIDE = StringUpper($value8)
SetLog("Forced side: " & StringUpper($value8), $COLOR_INFO)
$bForceSideExist = True
Else
For $i = 0 To UBound($g_aiPixelMine) - 1
Local $str = ""
Local $pixel = $g_aiPixelMine[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value1)
Case 3, 4
$heightTopRight += Int($value1)
Case 5, 6
$heightTopLeft += Int($value1)
Case 7, 8
$heightBottomLeft += Int($value1)
EndSwitch
EndIf
Next
For $i = 0 To UBound($g_aiPixelElixir) - 1
Local $str = ""
Local $pixel = $g_aiPixelElixir[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value2)
Case 3, 4
$heightTopRight += Int($value2)
Case 5, 6
$heightTopLeft += Int($value2)
Case 7, 8
$heightBottomLeft += Int($value2)
EndSwitch
EndIf
Next
For $i = 0 To UBound($g_aiPixelDarkElixir) - 1
Local $str = ""
Local $pixel = $g_aiPixelDarkElixir[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value3)
Case 3, 4
$heightTopRight += Int($value3)
Case 5, 6
$heightTopLeft += Int($value3)
Case 7, 8
$heightBottomLeft += Int($value3)
EndSwitch
EndIf
Next
If IsArray($g_aiCSVGoldStoragePos) Then
For $i = 0 To UBound($g_aiCSVGoldStoragePos) - 1
Local $pixel = $g_aiCSVGoldStoragePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVElixirStoragePos) Then
For $i = 0 To UBound($g_aiCSVElixirStoragePos) - 1
Local $pixel = $g_aiCSVElixirStoragePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value5)
Case 3, 4
$heightTopRight += Int($value5)
Case 5, 6
$heightTopLeft += Int($value5)
Case 7, 8
$heightBottomLeft += Int($value5)
EndSwitch
EndIf
Next
EndIf
Switch StringLeft(Slice8($g_aiCSVDarkElixirStoragePos), 1)
Case 1, 2
$heightBottomRight += Int($value6)
Case 3, 4
$heightTopRight += Int($value6)
Case 5, 6
$heightTopLeft += Int($value6)
Case 7, 8
$heightBottomLeft += Int($value6)
EndSwitch
Local $pixel = StringSplit($g_iTHx & "-" & $g_iTHy, "-", 2)
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value7)
Case 3, 4
$heightTopRight += Int($value7)
Case 5, 6
$heightTopLeft += Int($value7)
Case 7, 8
$heightBottomLeft += Int($value7)
EndSwitch
EndIf
If $bForceSideExist = False Then
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
SetLog("Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight)
$MAINSIDE = $sidename
EndIf
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
Case "SIDEB"
ReleaseClicks()
If $bForceSideExist = False Then
SetLog("Recalculate main side for additional defense buildings... ", $COLOR_INFO)
Switch StringLeft(Slice8($g_aiCSVEagleArtilleryPos), 1)
Case 1, 2
$heightBottomRight += Int($value1)
Case 3, 4
$heightTopRight += Int($value1)
Case 5, 6
$heightTopLeft += Int($value1)
Case 7, 8
$heightBottomLeft += Int($value1)
EndSwitch
If IsArray($g_aiCSVInfernoPos) Then
For $i = 0 To UBound($g_aiCSVInfernoPos) - 1
Local $pixel = $g_aiCSVInfernoPos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVXBowPos) Then
For $i = 0 To UBound($g_aiCSVXBowPos) - 1
Local $pixel = $g_aiCSVXBowPos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVWizTowerPos) Then
For $i = 0 To UBound($g_aiCSVWizTowerPos) - 1
Local $pixel = $g_aiCSVWizTowerPos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVMortarPos) Then
For $i = 0 To UBound($g_aiCSVMortarPos) - 1
Local $pixel = $g_aiCSVMortarPos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($g_aiCSVAirDefensePos) Then
For $i = 0 To UBound($g_aiCSVAirDefensePos) - 1
Local $pixel = $g_aiCSVAirDefensePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
SetLog("New Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight, $COLOR_INFO)
$MAINSIDE = $sidename
EndIf
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
Case Else
SetLog("No 'SIDE' or 'SIDEB' csv line found, using default attack side: " & $MAINSIDE)
EndSwitch
EndIf
If _Sleep($DELAYRESPOND) Then Return
Next
ReleaseClicks()
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Func ParseAttackCSV_Read_SIDE_variables()
$g_bCSVLocateMine = False
$g_bCSVLocateElixir = False
$g_bCSVLocateDrill = False
$g_bCSVLocateStorageGold = False
$g_bCSVLocateStorageElixir = False
$g_bCSVLocateStorageDarkElixir = False
$g_bCSVLocateStorageTownHall = False
$g_bCSVLocateEagle = False
$g_bCSVLocateInferno = False
$g_bCSVLocateXBow = False
$g_bCSVLocateWizTower = False
$g_bCSVLocateMortar = False
$g_bCSVLocateAirDefense = False
$g_bCSVLocateWall = False
If $g_iMatchMode = $DB Then
Local $filename = $g_sAttackScrScriptName[$DB]
Else
Local $filename = $g_sAttackScrScriptName[$LB]
EndIf
Local $f, $line, $acommand, $command
Local $value1, $value2, $value3, $value4, $value5, $value6, $value7, $value8, $value9
Local $bForceSideExist = False
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
Local $aLines = FileReadToArray($g_sCSVAttacksPath & "\" & $filename & ".csv")
If @error Then
SetLog("Attack CSV script not found: " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
Return
EndIf
For $iLine = 0 To UBound($aLines) - 1
$line = $aLines[$iLine]
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), $STR_STRIPTRAILING)
If $command <> "SIDE" And $command <> "SIDEB" And $command <> "MAKE" Then ContinueLoop
$value1 = StringStripWS(StringUpper($acommand[2]), $STR_STRIPTRAILING)
$value2 = StringStripWS(StringUpper($acommand[3]), $STR_STRIPTRAILING)
$value3 = StringStripWS(StringUpper($acommand[4]), $STR_STRIPTRAILING)
$value4 = StringStripWS(StringUpper($acommand[5]), $STR_STRIPTRAILING)
$value5 = StringStripWS(StringUpper($acommand[6]), $STR_STRIPTRAILING)
$value6 = StringStripWS(StringUpper($acommand[7]), $STR_STRIPTRAILING)
$value7 = StringStripWS(StringUpper($acommand[8]), $STR_STRIPTRAILING)
$value8 = StringStripWS(StringUpper($acommand[9]), $STR_STRIPTRAILING)
$value9 = StringStripWS(StringUpper($acommand[10]), $STR_STRIPTRAILING)
If $command = "SIDE" And StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
$bForceSideExist = True
EndIf
Switch $command
Case "SIDE"
If $bForceSideExist = False Then
If Int($value1) > 0 Then $g_bCSVLocateMine = True
If Int($value2) > 0 Then $g_bCSVLocateElixir = True
If Int($value3) > 0 Then $g_bCSVLocateDrill = True
If Int($value4) > 0 Then $g_bCSVLocateStorageGold = True
If Int($value5) > 0 Then $g_bCSVLocateStorageElixir = True
If Int($value6) > 0 Then $g_bCSVLocateStorageDarkElixir = True
If Int($value7) > 0 Then $g_bCSVLocateStorageTownHall = True
EndIf
Case "SIDEB"
If $bForceSideExist = False Then
If Int($value1) > 0 Then $g_bCSVLocateEagle = True
If Int($value2) > 0 Then $g_bCSVLocateInferno = True
If Int($value3) > 0 Then $g_bCSVLocateXBow = True
If Int($value4) > 0 Then $g_bCSVLocateWizTower = True
If Int($value5) > 0 Then $g_bCSVLocateMortar = True
If Int($value6) > 0 Then $g_bCSVLocateAirDefense = True
EndIf
Case "MAKE"
If StringLen(StringStripWS($value8, $STR_STRIPALL)) > 0 Then
Switch $value8
Case "TOWNHALL"
$g_bCSVLocateStorageTownHall = True
Case "EAGLE"
$g_bCSVLocateEagle = True
Case "INFERNO"
$g_bCSVLocateInferno = True
Case "XBOW"
$g_bCSVLocateXBow = True
Case "WIZTOWER"
$g_bCSVLocateWizTower = True
Case "MORTAR"
$g_bCSVLocateMortar = True
Case "AIRDEFENSE"
$g_bCSVLocateAirDefense = True
Case "EX-WALL"
$g_bCSVLocateWall = True
Case "IN-WALL"
$g_bCSVLocateWall = True
Case Else
SetDebugLog("Invalid MAKE building target name: " & $value8, $COLOR_WARNING)
debugAttackCSV("Invalid MAKE building target name: " & $value8)
EndSwitch
debugAttackCSV("SIDE Parse MAKE target building= " & $value8)
EndIf
EndSwitch
EndIf
Next
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Func Slice8($pixel)
If UBound($pixel) < 2 Then Return "0_NO_ARRAY"
Local $Left = $ExternalArea[0][0]
Local $Right = $ExternalArea[1][0]
Local $Top = $ExternalArea[2][1]
Local $Bottom = $ExternalArea[3][1]
Local $LeftY = $ExternalArea[0][1]
Local $RightY = $ExternalArea[1][1]
Local $TopX = $ExternalArea[2][0]
Local $BottomX = $ExternalArea[3][0]
Local $TLX = $ExternalArea[4][0]
Local $TLY = $ExternalArea[4][1]
Local $TRX = $ExternalArea[5][0]
Local $TRY = $ExternalArea[5][1]
Local $BLX = $ExternalArea[6][0]
Local $BLY = $ExternalArea[6][1]
Local $BRX = $ExternalArea[7][0]
Local $BRY = $ExternalArea[7][1]
Local $isIn = 1.01
If $pixel[0] < $Left Or $pixel[0] > $Right Or $pixel[1] < $Top Or $pixel[1] > $Bottom Then
Return "0_O"
Else
If $pixel[0] <= $TopX Then
If $pixel[1] <= $LeftY Then
If $pixel[0] <= $TLX Then
If($TLX - $pixel[0]) /($TLX - $Left) +($LeftY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
Return "6E"
Else
Return "0_6E"
EndIf
Else
If($pixel[0] - $TLX) /($TopX - $TLX) +($LeftY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
Return "6_I"
Else
If($TopX - $pixel[0]) /($TopX - $TLX) + Abs($TLY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
If $pixel[1] <= $TLY Then
Return "5_E"
Else
Return "5_I"
EndIf
Else
Return "O_5"
EndIf
EndIf
EndIf
Else
If $pixel[0] <= $BLX Then
If($BLX - $pixel[0]) /($BLX - $Left) +($pixel[1] - $LeftY) /($BLY - $LeftY) <= $isIn Then
Return "7_E"
Else
Return "0_7"
EndIf
Else
If($pixel[0] - $BLX) /($TopX - $BLX) +($pixel[1] - $LeftY) /($BLY - $LeftY) <= $isIn Then
Return "7_I"
Else
If($TopX - $pixel[0]) /($TopX - $BLX) + Abs($BLY - $pixel[1]) /($BLY - $LeftY) <= $isIn Then
If $pixel[1] <= $BLY Then
Return "8_I"
Else
Return "8_E"
EndIf
Else
Return "0_8"
EndIf
EndIf
EndIf
EndIf
Else
If $pixel[1] <= $RightY Then
If $pixel[0] > $TRX Then
If($pixel[0] - $TRX) /($Right - $TRX) +($RightY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
Return "3_E"
Else
Return "0_3"
EndIf
Else
If($TRX - $pixel[0]) /($TRX - $TopX) +($RightY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
Return "3_I"
Else
If($pixel[0] - $TopX) /($TRX - $TopX) + Abs($TRY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
If $pixel[1] <= $TRY Then
Return "4_E"
Else
Return "4_I"
EndIf
Else
Return "0_4"
EndIf
EndIf
EndIf
Else
If $pixel[0] > $BRX Then
If($pixel[0] - $BRX) /($Right - $BRX) +($pixel[1] - $RightY) /($BRY - $RightY) <= $isIn Then
Return "2_E"
Else
Return "0_2"
EndIf
Else
If($BRX - $pixel[0]) /($BRX - $BottomX) +($pixel[1] - $RightY) /($BRY - $RightY) <= $isIn Then
Return "2_I"
Else
If($pixel[0] - $BottomX) /($BRX - $BottomX) + Abs($BRY - $pixel[1]) /($BRY - $RightY) <= $isIn Then
If $pixel[1] <= $BRY Then
Return "1_I"
Else
Return "1_E"
EndIf
Else
Return "0_1"
EndIf
EndIf
EndIf
EndIf
EndIf
EndIf
EndFunc
Func CleanRedArea(ByRef $InputVect, $side = "")
Local $TempVectStr = ""
For $i = 0 To UBound($InputVect) - 1
Local $pixel = $InputVect[$i]
If isInsideDiamondRedArea($pixel) Then
$TempVectStr &= $pixel[0] & "-" & $pixel[1] & "|"
Else
debugAttackCSV("CleanRedArea removed (" & $pixel[0] & "," & $pixel[1] & ")")
EndIf
Next
If StringLen($TempVectStr) > 0 Then
$TempVectStr = StringLeft($TempVectStr, StringLen($TempVectStr) - 1)
$InputVect = GetListPixel($TempVectStr)
EndIf
EndFunc
Func ChkAttackCSVConfig()
If Not(FileExists($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$DB] & ".csv")) Then
SetLog("Dead base scripted attack file do not exists (renamed, deleted?)", $COLOR_ERROR)
SetLog("Please select a new scripted algorithm from 'scripted attack' tab", $COLOR_ERROR)
PopulateComboScriptsFilesDB()
btnStop()
EndIf
If Not(FileExists($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$LB] & ".csv")) Then
SetLog("Dead base scripted attack file do not exists (renamed, deleted?)", $COLOR_ERROR)
SetLog("Please select a new scripted algorithm from 'scripted attack' tab", $COLOR_ERROR)
PopulateComboScriptsFilesAB()
btnStop()
EndIf
EndFunc
Func ParseAttackCSV_Settings_variables(ByRef $aiCSVTroops, ByRef $aiCSVSpells, ByRef $aiCSVHeros, ByRef $iCSVRedlineRoutineItem, ByRef $iCSVDroplineEdgeItem, ByRef $sCSVCCReq, $sFilename)
If $g_bDebugAttackCSV Then SetLog("ParseAttackCSV_Settings_variables()", $COLOR_DEBUG)
Local $asCommand
If FileExists($g_sCSVAttacksPath & "\" & $sFilename & ".csv") Then
Local $asLine = FileReadToArray($g_sCSVAttacksPath & "\" & $sFilename & ".csv")
If @error Then
SetLog("Attack CSV script not found: " & $g_sCSVAttacksPath & "\" & $sFilename & ".csv", $COLOR_ERROR)
Return
EndIf
Local $sLine
Local $iTHCol = 0, $iTH = 0
Local $iTroopIndex, $iFlexTroopIndex = 999
Local $iCommandCol = 1, $iTroopNameCol = 2, $iFlexCol = 3, $iTHBeginCol = 4
Local $iHeroRadioItemTotal = 3, $iHeroTimedLimit = 99
For $iLine = 0 To UBound($asLine) - 1
$sLine = $asLine[$iLine]
$asCommand = StringSplit($sLine, "|")
If $asCommand[0] >= 8 Then
$asCommand[$iCommandCol] = StringStripWS(StringUpper($asCommand[$iCommandCol]), $STR_STRIPTRAILING)
If $asCommand[$iCommandCol] <> "TRAIN" And $asCommand[$iCommandCol] <> "REDLN" And $asCommand[$iCommandCol] <> "DRPLN" And $asCommand[$iCommandCol] <> "CCREQ" Then ContinueLoop
If $iTHCol = 0 Then
If $g_bDebugAttackCSV Then SetLog("Camp Total Space: " & $g_iTotalCampSpace, $COLOR_DEBUG)
If $g_bDebugAttackCSV Then SetLog("Spell Total Space: " & $g_iTotalSpellValue, $COLOR_DEBUG)
If $g_iTotalCampSpace = 0 Then
SetLog("Has to run bot once first to get correct total camp space", $COLOR_ERROR)
Return
EndIf
If $g_iTotalSpellValue = 0 Then
SetLog("Has to set spell capacity first", $COLOR_ERROR)
Return
EndIf
Switch $g_iTotalCampSpace
Case $g_iMaxCapTroopTH[11] + 5 To $g_iMaxCapTroopTH[12]
$iTHCol = $iTHBeginCol + 6
$iTH = 12
Case $g_iMaxCapTroopTH[10] + 5 To $g_iMaxCapTroopTH[11]
$iTHCol = $iTHBeginCol + 5
$iTH = 11
Case $g_iMaxCapTroopTH[9] + 5 To $g_iMaxCapTroopTH[10]
$iTHCol = $iTHBeginCol + 4
$iTH = 10
Case $g_iMaxCapTroopTH[8] + 5 To $g_iMaxCapTroopTH[9]
$iTHCol = $iTHBeginCol + 3
$iTH = 9
Case $g_iMaxCapTroopTH[6] + 5 To $g_iMaxCapTroopTH[8]
Switch $g_iTotalSpellValue
Case $g_iMaxCapSpellTH[7] + 1 To $g_iMaxCapSpellTH[8]
$iTHCol = $iTHBeginCol + 2
$iTH = 8
Case $g_iMaxCapSpellTH[6] + 1 To $g_iMaxCapSpellTH[7]
$iTHCol = $iTHBeginCol + 1
$iTH = 7
Case Else
SetLog("Invalid spell size ( <" & $g_iMaxCapSpellTH[6] + 1 & " or >" & $g_iMaxCapSpellTH[8] & " ): " & $g_iTotalSpellValue & " for CSV", $COLOR_ERROR)
Return
EndSwitch
Case $g_iMaxCapTroopTH[5] + 5 To $g_iMaxCapTroopTH[6]
$iTHCol = $iTHBeginCol
$iTH = 6
Case Else
SetLog("Invalid camp size ( <" & $g_iMaxCapTroopTH[5] + 5 & " or >" & $g_iMaxCapTroopTH[11] & " ): " & $g_iTotalCampSpace & " for CSV", $COLOR_ERROR)
Return
EndSwitch
EndIf
If $g_bDebugAttackCSV Then SetLog("Line: " & $iLine + 1 & " Command: " & $asCommand[$iCommandCol] &($iTHCol >= $iTHBeginCol ? " Column: " & $iTHCol & " TH" & $iTH : ""), $COLOR_DEBUG)
For $i = 2 To(UBound($asCommand) - 1)
$asCommand[$i] = StringStripWS($asCommand[$i], $STR_STRIPTRAILING)
Next
Switch $asCommand[$iCommandCol]
Case "TRAIN"
$iTroopIndex = TroopIndexLookup($asCommand[$iTroopNameCol], "ParseAttackCSV_Settings_variables")
If $iTroopIndex = -1 Then
SetLog("CSV troop name '" & $asCommand[$iTroopNameCol] & "' is unrecognized - Line: " & $iLine + 1, $COLOR_ERROR)
ContinueLoop
EndIf
If int($asCommand[$iTHCol]) <= 0 Then
If $asCommand[$iTHCol] <> "0" Then SetLog("CSV troop amount/setting '" & $asCommand[$iTHCol] & "' is unrecognized - Line: " & $iLine + 1, $COLOR_ERROR)
ContinueLoop
EndIf
Switch $iTroopIndex
Case $eBarb To $eIceG
$aiCSVTroops[$iTroopIndex] = int($asCommand[$iTHCol])
If int($asCommand[$iFlexCol]) > 0 Then $iFlexTroopIndex = $iTroopIndex
Case $eLSpell To $eBtSpell
$aiCSVSpells[$iTroopIndex - $eLSpell] = int($asCommand[$iTHCol])
Case $eKing To $eWarden
Local $iHeroRadioItem = int(StringLeft($asCommand[$iTHCol], 1))
Local $iHeroTimed = Int(StringTrimLeft($asCommand[$iTHCol], 1))
If $iHeroRadioItem <= 0 Or $iHeroRadioItem > $iHeroRadioItemTotal Or $iHeroTimed < 0 Or $iHeroTimed > $iHeroTimedLimit Then
SetLog("CSV hero ability setting '" & $asCommand[$iTHCol] & "' is unrecognized - Line: " & $iLine + 1, $COLOR_ERROR)
ContinueLoop
EndIf
$aiCSVHeros[$iTroopIndex - $eKing][0] = $iHeroRadioItem
$aiCSVHeros[$iTroopIndex - $eKing][1] = $iHeroTimed * 1000
EndSwitch
If $g_bDebugAttackCSV Then SetLog("Train " & $asCommand[$iTHCol] & "x " & $asCommand[$iTroopNameCol], $COLOR_DEBUG)
Case "REDLN"
$iCSVRedlineRoutineItem = int($asCommand[$iTHCol])
If $g_bDebugAttackCSV Then SetLog("Redline ComboBox #" &($iCSVRedlineRoutineItem > 0 ? $iCSVRedlineRoutineItem : "None"), $COLOR_DEBUG)
Case "DRPLN"
$iCSVDroplineEdgeItem = int($asCommand[$iTHCol])
If $g_bDebugAttackCSV Then SetLog("Dropline ComboBox #" &($iCSVDroplineEdgeItem > 0 ? $iCSVDroplineEdgeItem : "None"), $COLOR_DEBUG)
Case "CCREQ"
$sCSVCCReq = $asCommand[$iTHCol]
If $g_bDebugAttackCSV Then SetLog("CC Request: " & $sCSVCCReq, $COLOR_DEBUG)
EndSwitch
EndIf
Next
If $iTHCol >= $iTHBeginCol Then
Local $iCSVTotalCapTroops = 0, $bTotalInRange = False
For $i = 0 To UBound($aiCSVTroops) - 1
$iCSVTotalCapTroops += $aiCSVTroops[$i] * $g_aiTroopSpace[$i]
Next
If $g_bDebugAttackCSV Then SetLog("CSV troop total: " & $iCSVTotalCapTroops, $COLOR_DEBUG)
If $iCSVTotalCapTroops > 0 Then
If $iTH = 8 Then
If $iCSVTotalCapTroops > $g_iMaxCapTroopTH[$iTH - 2] And $iCSVTotalCapTroops <= $g_iMaxCapTroopTH[$iTH] Then $bTotalInRange = True
Else
If $iCSVTotalCapTroops > $g_iMaxCapTroopTH[$iTH - 1] And $iCSVTotalCapTroops <= $g_iMaxCapTroopTH[$iTH] Then $bTotalInRange = True
EndIf
If $bTotalInRange Then
If $iCSVTotalCapTroops <> $g_iTotalCampSpace Then
Local $iDiff = $iCSVTotalCapTroops - $g_iTotalCampSpace
If $g_bDebugAttackCSV Then SetLog("Camp Total Space: " & $g_iTotalCampSpace, $COLOR_DEBUG)
If $g_bDebugAttackCSV Then SetLog("Difference: " & $iDiff, $COLOR_DEBUG)
If $g_bDebugAttackCSV Then SetLog("Flexible Index: " & $iFlexTroopIndex, $COLOR_DEBUG)
If $iFlexTroopIndex <> 999 And Mod($iDiff, $g_aiTroopSpace[$iFlexTroopIndex]) = 0 Then
Local $iCSVTroopAmount = $aiCSVTroops[$iFlexTroopIndex]
$aiCSVTroops[$iFlexTroopIndex] -= $iDiff / $g_aiTroopSpace[$iFlexTroopIndex]
SetLog("Adjust CSV Train Troop - " & GetTroopName($iFlexTroopIndex) & " amount from " & $iCSVTroopAmount & " to " & $aiCSVTroops[$iFlexTroopIndex], $COLOR_SUCCESS)
Else
SetLog("CSV Troop Total does not equal to Camp Total Space,", $COLOR_ERROR)
SetLog("adjust train settings manually", $COLOR_ERROR)
For $i = 0 to UBound($aiCSVTroops) - 1
$aiCSVTroops[$i] = 0
Next
EndIf
EndIf
Else
SetLog("CSV troops total: " & $iCSVTotalCapTroops & " for TH" & $iTH & " is out of range", $COLOR_ERROR)
For $i = 0 to UBound($aiCSVTroops) - 1
$aiCSVTroops[$i] = 0
Next
EndIf
EndIf
EndIf
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $sFilename & ".csv", $COLOR_ERROR)
Return
EndIf
Return 1
EndFunc
Func _FindPixelCloser($arrPixel, $pixel, $nb = 1)
If IsArray($arrPixel) = False Then Return
Local $arrPixelCloser[0]
For $j = 0 To $nb
Local $PixelCloser = $arrPixel[0]
For $i = 0 To UBound($arrPixel) - 1
Local $alreadyExist = False
Local $arrTemp = $arrPixel[$i]
Local $found = False
If($pixel[0] = -1) Then
If(Abs($arrTemp[1] - $pixel[1]) < Abs($PixelCloser[1] - $pixel[1])) Then
$found = True
EndIf
ElseIf($pixel[1] = -1) Then
If(Abs($arrTemp[0] - $pixel[0]) < Abs($PixelCloser[0] - $pixel[0])) Then
$found = True
EndIf
Else
If((Abs($arrTemp[0] - $pixel[0]) + Abs($arrTemp[1] - $pixel[1])) <(Abs($PixelCloser[0] - $pixel[0]) + Abs($PixelCloser[1] - $pixel[1]))) Then
$found = True
EndIf
EndIf
If($found) Then
For $k = 0 To UBound($arrPixelCloser) - 1
Local $arrTemp2 = $arrPixelCloser[$k]
If($arrTemp[0] = $arrTemp2[0] And $arrTemp[1] = $arrTemp2[1]) Then
$alreadyExist = True
ExitLoop
EndIf
Next
If($alreadyExist = False) Then
$PixelCloser = $arrTemp
EndIf
EndIf
Next
ReDim $arrPixelCloser[UBound($arrPixelCloser) + 1]
$arrPixelCloser[UBound($arrPixelCloser) - 1] = $PixelCloser
Next
Return $arrPixelCloser
EndFunc
Func _GetOffsetTroopFurther($pixel, $eVectorType, $offset)
debugRedArea("_GetOffsetTroopFurther IN")
Local $xMin, $xMax, $yMin, $yMax, $xStep, $yStep, $xOffset, $yOffset
Local $pixelOffset = GetOffestPixelRedArea2($pixel, $eVectorType, $offset)
If($eVectorType = $eVectorLeftTop) Then
$xMin = $InternalArea[0][0] + 2
$yMin = $InternalArea[0][1]
$xMax = $InternalArea[2][0]
$yMax = $InternalArea[2][1] + 2
$xStep = 4
$yStep = -3
$yOffset = -1 * $offset
$xOffset = Floor($yOffset)
ElseIf($eVectorType = $eVectorRightTop) Then
$xMin = $InternalArea[2][0]
$yMin = $InternalArea[2][1] + 2
$xMax = $InternalArea[1][0] - 2
$yMax = $InternalArea[1][1]
$xStep = 4
$yStep = 3
$yOffset = -1 * $offset
$xOffset = Floor($yOffset) * -1
ElseIf($eVectorType = $eVectorLeftBottom) Then
$xMin = $InternalArea[0][0] + 2
$yMin = $InternalArea[0][1]
$xMax = $InternalArea[3][0]
$yMax = $InternalArea[3][1] - 2
$xStep = 4
$yStep = 3
$yOffset = $offset
$xOffset = Floor($yOffset) * -1
Else
$xMin = $InternalArea[3][0]
$yMin = $InternalArea[3][1] - 2
$xMax = $InternalArea[1][0] - 2
$yMax = $InternalArea[1][1]
$xStep = 4
$yStep = -3
$yOffset = $offset
$xOffset = Floor($yOffset)
EndIf
Local $y = $yMin
Local $found = False
For $x = $xMin To $xMax Step $xStep
If($eVectorType = $eVectorRightBottom And $y > $yMax And $pixelOffset[0] > $x And $pixelOffset[1] > $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorLeftBottom And $y < $yMax And $pixelOffset[0] < $x And $pixelOffset[1] > $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorLeftTop And $y > $yMax And $pixelOffset[0] < $x And $pixelOffset[1] < $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorRightTop And $y < $yMax And $pixelOffset[0] > $x And $pixelOffset[1] < $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
EndIf
$y += $yStep
If($found) Then ExitLoop
Next
If $pixelOffset[1] > 555 + $g_iBottomOffsetY Then
$pixelOffset[1] = 555 + $g_iBottomOffsetY
EndIf
debugRedArea("$pixelOffset x : [" & $pixelOffset[0] & "] / y : [" & $pixelOffset[1] & "]")
Return $pixelOffset
EndFunc
Func _GetRedArea($iMode = $REDLINE_IMGLOC, $iMaxAllowedPixelDistance = 25, $fMinSideLengthFactor = 0.65)
Local $nameFunc = "[_GetRedArea] "
debugRedArea($nameFunc & " IN")
Local $colorVariation = 40
Local $xSkip = 1
Local $ySkip = 5
Local $result = 0
Local $listPixelBySide
If $g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 0 And $g_aiAttackStdDropSides[$LB] = 5 Then
$result = DllCallMyBot("getRedAreaSideBuilding", "ptr", $g_hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation, "int", $eSideBuildingDES)
If $g_bDebugSetlog Then SetDebugLog("Debug: Redline with DES Side chosen")
ElseIf $g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 0 And $g_aiAttackStdDropSides[$LB] = 6 Then
$result = DllCallMyBot("getRedAreaSideBuilding", "ptr", $g_hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation, "int", $eSideBuildingTH)
If $g_bDebugSetlog Then SetDebugLog("Debug: Redline with TH Side chosen")
Else
Switch $iMode
Case $REDLINE_NONE
Local $a = ["NoRedLine", "", "", "", ""]
$listPixelBySide = $a
Case $REDLINE_IMGLOC_RAW
SearchRedLinesMultipleTimes()
$listPixelBySide = getRedAreaSideBuilding()
Case $REDLINE_IMGLOC
SearchRedLinesMultipleTimes()
Local $dropPoints = GetOffSetRedline("TL") & "|" & GetOffSetRedline("BL") & "|" & GetOffSetRedline("BR") & "|" & GetOffSetRedline("TR")
$listPixelBySide = getRedAreaSideBuilding($dropPoints)
Case $REDLINE_ORIGINAL
Local $result = DllCallMyBot("getRedArea", "ptr", $g_hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation)
EndSwitch
If $g_bDebugSetlog Then SetDebugLog("Debug: Redline chosen")
EndIf
If IsArray($result) Then
$listPixelBySide = StringSplit($result[0], "#")
EndIf
$g_aiPixelTopLeft = GetPixelSide($listPixelBySide, 1)
$g_aiPixelBottomLeft = GetPixelSide($listPixelBySide, 2)
$g_aiPixelBottomRight = GetPixelSide($listPixelBySide, 3)
$g_aiPixelTopRight = GetPixelSide($listPixelBySide, 4)
CleanRedArea($g_aiPixelTopLeft)
CleanRedArea($g_aiPixelTopRight)
CleanRedArea($g_aiPixelBottomLeft)
CleanRedArea($g_aiPixelBottomRight)
debugAttackCSV("RedArea cleaned")
debugAttackCSV("	[" & UBound($g_aiPixelTopLeft) & "] pixels TopLeft")
debugAttackCSV("	[" & UBound($g_aiPixelTopRight) & "] pixels TopRight")
debugAttackCSV("	[" & UBound($g_aiPixelBottomLeft) & "] pixels BottomLeft")
debugAttackCSV("	[" & UBound($g_aiPixelBottomRight) & "] pixels BottomRight")
If _Sleep($DELAYRESPOND) Then Return
Local $coordLeft = [$ExternalArea[0][0], $ExternalArea[0][1]]
Local $coordTop = [$ExternalArea[2][0], $ExternalArea[2][1]]
Local $coordRight = [$ExternalArea[1][0], $ExternalArea[1][1]]
Local $coordBottom = [$ExternalArea[3][0], $ExternalArea[3][1]]
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIXED
Case $DROPLINE_EDGE_FIRST, $DROPLINE_FULL_EDGE_FIRST
Local $newAxis
Local $aPoint1 = GetMaxPoint($g_aiPixelTopLeft, 1)
Local $aPoint2 = GetMinPoint($g_aiPixelBottomLeft, 1)
$newAxis =(($aPoint1[0] < $aPoint2[0]) ?($aPoint1[0]) :($aPoint2[0]))
If Abs($newAxis) < 9999 Then $coordLeft[0] = $newAxis
Local $aPoint1 = GetMaxPoint($g_aiPixelTopLeft, 0)
Local $aPoint2 = GetMinPoint($g_aiPixelTopRight, 0)
$newAxis =(($aPoint1[1] < $aPoint2[1]) ?($aPoint1[1]) :($aPoint2[1]))
If Abs($newAxis) < 9999 Then $coordTop[1] = $newAxis
Local $aPoint1 = GetMaxPoint($g_aiPixelTopRight, 1)
Local $aPoint2 = GetMinPoint($g_aiPixelBottomRight, 1)
$newAxis =(($aPoint1[0] > $aPoint2[0]) ?($aPoint1[0]) :($aPoint2[0]))
If Abs($newAxis) < 9999 Then $coordRight[0] = $newAxis
Local $aPoint1 = GetMaxPoint($g_aiPixelBottomLeft, 0)
Local $aPoint2 = GetMinPoint($g_aiPixelBottomRight, 0)
$newAxis =(($aPoint1[1] > $aPoint2[1]) ?($aPoint1[1]) :($aPoint2[1]))
If Abs($newAxis) < 9999 Then $coordBottom[1] = $newAxis
EndSwitch
Local $StartEndTopLeft = [$coordLeft, $coordTop]
Local $StartEndTopRight = [$coordTop, $coordRight]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
SetDebugLog("_GetRedArea, StartEndTopLeft     = " & PixelArrayToString($StartEndTopLeft, ","))
SetDebugLog("_GetRedArea, StartEndTopRight    = " & PixelArrayToString($StartEndTopRight, ","))
SetDebugLog("_GetRedArea, StartEndBottomLeft  = " & PixelArrayToString($StartEndBottomLeft, ","))
SetDebugLog("_GetRedArea, StartEndBottomRight = " & PixelArrayToString($StartEndBottomRight, ","))
Local $startPoint, $endPoint, $invalid1, $invalid2
Local $totalInvalid = 0
$startPoint = $StartEndTopLeft[0]
$endPoint = $StartEndTopLeft[1]
Local $g_aiPixelTopLeft1 = SortByDistance($g_aiPixelTopLeft, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndTopLeft[1]
$endPoint = $StartEndTopLeft[0]
Local $g_aiPixelTopLeft2 = SortByDistance($g_aiPixelTopLeft, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$g_aiPixelTopLeft = SortByDistance((($invalid1 <= $invalid2) ?($g_aiPixelTopLeft1) :($g_aiPixelTopLeft2)), $StartEndTopLeft[0], $StartEndTopLeft[1], $invalid1)
$startPoint = $StartEndTopRight[0]
$endPoint = $StartEndTopRight[1]
Local $g_aiPixelTopRight1 = SortByDistance($g_aiPixelTopRight, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndTopRight[1]
$endPoint = $StartEndTopRight[0]
Local $g_aiPixelTopRight2 = SortByDistance($g_aiPixelTopRight, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$g_aiPixelTopRight = SortByDistance((($invalid1 <= $invalid2) ?($g_aiPixelTopRight1) :($g_aiPixelTopRight2)), $StartEndTopRight[0], $StartEndTopRight[1], $invalid1)
$startPoint = $StartEndBottomLeft[0]
$endPoint = $StartEndBottomLeft[1]
Local $g_aiPixelBottomLeft1 = SortByDistance($g_aiPixelBottomLeft, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndBottomLeft[1]
$endPoint = $StartEndBottomLeft[0]
Local $g_aiPixelBottomLeft2 = SortByDistance($g_aiPixelBottomLeft, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$g_aiPixelBottomLeft = SortByDistance((($invalid1 <= $invalid2) ?($g_aiPixelBottomLeft1) :($g_aiPixelBottomLeft2)), $StartEndBottomLeft[0], $StartEndBottomLeft[1], $invalid1)
$startPoint = $StartEndBottomRight[0]
$endPoint = $StartEndBottomRight[1]
Local $g_aiPixelBottomRight1 = SortByDistance($g_aiPixelBottomRight, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndBottomRight[1]
$endPoint = $StartEndBottomRight[0]
Local $g_aiPixelBottomRight2 = SortByDistance($g_aiPixelBottomRight, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$g_aiPixelBottomRight = SortByDistance((($invalid1 <= $invalid2) ?($g_aiPixelBottomRight1) :($g_aiPixelBottomRight2)), $StartEndBottomRight[0], $StartEndBottomRight[1], $invalid1)
Local $offsetArcher = 15
ReDim $g_aiPixelRedArea[UBound($g_aiPixelTopLeft) + UBound($g_aiPixelBottomLeft) + UBound($g_aiPixelTopRight) + UBound($g_aiPixelBottomRight)]
ReDim $g_aiPixelRedAreaFurther[UBound($g_aiPixelRedArea)]
Local $a
If $g_bDebugSetlog Then SetDebugLog("redarea calc pixel further", $COLOR_DEBUG)
Local $count = 0
ReDim $g_aiPixelTopLeftFurther[UBound($g_aiPixelTopLeft)]
For $i = 0 To UBound($g_aiPixelTopLeft) - 1
$g_aiPixelTopLeftFurther[$i] = _GetOffsetTroopFurther($g_aiPixelTopLeft[$i], $eVectorLeftTop, $offsetArcher)
$g_aiPixelRedArea[$count] = $g_aiPixelTopLeft[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelTopLeftFurther[$i]
$count += 1
Next
ReDim $g_aiPixelBottomLeftFurther[UBound($g_aiPixelBottomLeft)]
For $i = 0 To UBound($g_aiPixelBottomLeft) - 1
$g_aiPixelBottomLeftFurther[$i] = _GetOffsetTroopFurther($g_aiPixelBottomLeft[$i], $eVectorLeftBottom, $offsetArcher)
$g_aiPixelRedArea[$count] = $g_aiPixelBottomLeft[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelBottomLeftFurther[$i]
$count += 1
Next
ReDim $g_aiPixelTopRightFurther[UBound($g_aiPixelTopRight)]
For $i = 0 To UBound($g_aiPixelTopRight) - 1
$g_aiPixelTopRightFurther[$i] = _GetOffsetTroopFurther($g_aiPixelTopRight[$i], $eVectorRightTop, $offsetArcher)
$g_aiPixelRedArea[$count] = $g_aiPixelTopRight[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelTopRightFurther[$i]
$count += 1
Next
ReDim $g_aiPixelBottomRightFurther[UBound($g_aiPixelBottomRight)]
For $i = 0 To UBound($g_aiPixelBottomRight) - 1
$g_aiPixelBottomRightFurther[$i] = _GetOffsetTroopFurther($g_aiPixelBottomRight[$i], $eVectorRightBottom, $offsetArcher)
$g_aiPixelRedArea[$count] = $g_aiPixelBottomRight[$i]
$g_aiPixelRedAreaFurther[$count] = $g_aiPixelBottomRightFurther[$i]
$count += 1
Next
Local $aSideLength[4]
$aSideLength[0] =((UBound($g_aiPixelTopLeft) >= 10) ?(GetPixelDistance($g_aiPixelTopLeft[0], $g_aiPixelTopLeft[UBound($g_aiPixelTopLeft) - 1])) :(0))
$aSideLength[1] =((UBound($g_aiPixelBottomLeft) >= 10) ?(GetPixelDistance($g_aiPixelBottomLeft[0], $g_aiPixelBottomLeft[UBound($g_aiPixelBottomLeft) - 1])) :(0))
$aSideLength[2] =((UBound($g_aiPixelTopRight) >= 10) ?(GetPixelDistance($g_aiPixelTopRight[0], $g_aiPixelTopRight[UBound($g_aiPixelTopRight) - 1])) :(0))
$aSideLength[3] =((UBound($g_aiPixelBottomRight) >= 10) ?(GetPixelDistance($g_aiPixelBottomRight[0], $g_aiPixelBottomRight[UBound($g_aiPixelBottomRight) - 1])) :(0))
Local $iAvgSideLength = 0
Local $iAvgSideCount = 0
For $i = 0 To 3
$iAvgSideLength += $aSideLength[$i]
If $aSideLength[$i] > 0 Then $iAvgSideCount += 1
Next
$iAvgSideLength = Round($iAvgSideLength / $iAvgSideCount, 0)
SetDebugLog("Average side length: " & $iAvgSideLength)
Local $bNotEnoughPoints, $iSideLength
$bNotEnoughPoints = UBound($g_aiPixelTopLeft) < 10
$iSideLength = Round(GetPixelListDistance($g_aiPixelTopLeft, $iMaxAllowedPixelDistance), 0)
If $bNotEnoughPoints Or $iSideLength / $fMinSideLengthFactor < $iAvgSideLength Then
SetDebugLog("Attack side top-left: fall back to outer green (" &(($bNotEnoughPoints) ?("not enougth points") :("side length " & $iSideLength & " / " & $fMinSideLengthFactor & " < " & $iAvgSideLength)) & ")")
$g_aiPixelTopLeft = _GetVectorOutZone($eVectorLeftTop)
$g_aiPixelTopLeftFurther = $g_aiPixelTopLeft
EndIf
$bNotEnoughPoints = UBound($g_aiPixelBottomLeft) < 10
$iSideLength = Round(GetPixelListDistance($g_aiPixelBottomLeft, $iMaxAllowedPixelDistance), 0)
If $bNotEnoughPoints Or $iSideLength / $fMinSideLengthFactor < $iAvgSideLength Then
SetDebugLog("Attack side bottom-left: fall back to outer green (" &(($bNotEnoughPoints) ?("not enougth points") :("side length " & $iSideLength & " / " & $fMinSideLengthFactor & " < " & $iAvgSideLength)) & ")")
$g_aiPixelBottomLeft = _GetVectorOutZone($eVectorLeftBottom)
$g_aiPixelBottomLeftFurther = $g_aiPixelBottomLeft
EndIf
$bNotEnoughPoints = UBound($g_aiPixelTopRight) < 10
$iSideLength = Round(GetPixelListDistance($g_aiPixelTopRight, $iMaxAllowedPixelDistance), 0)
If $bNotEnoughPoints Or $iSideLength / $fMinSideLengthFactor < $iAvgSideLength Then
SetDebugLog("Attack side top-right: fall back to outer green (" &(($bNotEnoughPoints) ?("not enougth points") :("side length " & $iSideLength & " / " & $fMinSideLengthFactor & " < " & $iAvgSideLength)) & ")")
$g_aiPixelTopRight = _GetVectorOutZone($eVectorRightTop)
$g_aiPixelTopRightFurther = $g_aiPixelTopRight
EndIf
$bNotEnoughPoints = UBound($g_aiPixelBottomRight) < 10
$iSideLength = Round(GetPixelListDistance($g_aiPixelBottomRight, $iMaxAllowedPixelDistance), 0)
If $bNotEnoughPoints Or $iSideLength / $fMinSideLengthFactor < $iAvgSideLength Then
SetDebugLog("Attack side bottom-right: fall back to outer green (" &(($bNotEnoughPoints) ?("not enougth points") :("side length " & $iSideLength & " / " & $fMinSideLengthFactor & " < " & $iAvgSideLength)) & ")")
$g_aiPixelBottomRight = _GetVectorOutZone($eVectorRightBottom)
$g_aiPixelBottomRightFurther = $g_aiPixelBottomRight
EndIf
debugRedArea($nameFunc & "  Size of arr pixel for TopLeft [" & UBound($g_aiPixelTopLeft) & "] /  BottomLeft [" & UBound($g_aiPixelBottomLeft) & "] /  TopRight [" & UBound($g_aiPixelTopRight) & "] /  BottomRight [" & UBound($g_aiPixelBottomRight) & "] ")
debugRedArea($nameFunc & " OUT ")
EndFunc
Func SortRedline($redline, $StartPixel, $EndPixel, $sDelim = ",")
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
If $size < 2 Then Return StringReplace($redline, $sDelim, "-")
For $i = 0 To $size - 1
Local $sPoint = $aPoints[$i]
Local $aPoint = GetPixel($sPoint, $sDelim)
If UBound($aPoint) > 1 Then $aPoints[$i] = $aPoint
Next
Local $iInvalid = 0
Local $s = PixelArrayToString(SortByDistance($aPoints, $StartPixel, $EndPixel, $iInvalid))
Return $s
EndFunc
Func SortByDistance($PixelList, ByRef $StartPixel, ByRef $EndPixel, ByRef $iInvalid)
If $g_bDebugSetlog Then SetDebugLog("SortByDistance Start = " & PixelToString($StartPixel, ',') & " : " & PixelArrayToString($PixelList, ","))
Local $iMax = UBound($PixelList) - 1
Local $iMin2 = 0
Local $iMax2 = $iMax
Local $Sorted[0]
Local $PrevPixel = $StartPixel
Local $PrevDistance = -1
Local $totalDistances = 0
Local $totalPoints = 0
Local $firstPixel = [-1, -1], $lastPixel = [-1, -1]
Local $avgDistance = 0
$iInvalid = 0
For $i = 0 To $iMax
Local $ClosestIndex = 0
Local $ClosestDistance = 9999
Local $ClosestPixel = [0, 0]
Local $adjustMin = True
Local $adjustMax = 0
For $j = $iMin2 To $iMax2
Local $Pixel = $PixelList[$j]
If IsArray($Pixel) = 0 Then
If $adjustMin Then $iMin2 = $j + 1
If $adjustMax = $iMax Then $adjustMax = $j
ContinueLoop
EndIf
$adjustMin = False
$adjustMax = $iMax
Local $d = GetPixelDistance($PrevPixel, $Pixel)
If $d < $ClosestDistance Then
$ClosestIndex = $j
$ClosestDistance = $d
$ClosestPixel = $Pixel
EndIf
Next
$iMax2 = $adjustMax
$avgDistance = $totalDistances / $totalPoints
Local $invalidPoint = $ClosestPixel[0] < 0 Or $ClosestPixel[1] < 0
If $invalidPoint Or($PrevDistance > -1 And($iMax - $i) / $iMax < 0.20 And($ClosestDistance > $avgDistance * 10 Or($ClosestDistance > $avgDistance * 3 And(GetPixelDistance($PrevPixel, $EndPixel) < 25 Or $ClosestDistance > $totalDistances / 2)))) Then
$iInvalid += 1
Else
If $firstPixel[0] = -1 Then $firstPixel = $ClosestPixel
$lastPixel = $ClosestPixel
$PrevPixel = $ClosestPixel
$PrevDistance = $ClosestDistance
$totalPoints += 1
$totalDistances += $ClosestDistance
ReDim $Sorted[UBound($Sorted) + 1]
$Sorted[UBound($Sorted) - 1] = $ClosestPixel
EndIf
$PixelList[$ClosestIndex] = 0
Next
If $firstPixel[0] > 0 And GetPixelDistance($StartPixel, $firstPixel) > $avgDistance * 3 Then
$StartPixel[0] = $firstPixel[0]
$StartPixel[1] = $firstPixel[1]
EndIf
If $lastPixel[0] > 0 And GetPixelDistance($EndPixel, $lastPixel) > $avgDistance * 3 Then
$EndPixel[0] = $lastPixel[0]
$EndPixel[1] = $lastPixel[1]
EndIf
Return $Sorted
EndFunc
Func PixelArrayToString(Const ByRef $PixelList, $sDelim = "-")
If UBound($PixelList) < 1 Then Return ""
Local $s = ""
For $i = 0 To UBound($PixelList) - 1
Local $Pixel = $PixelList[$i]
$s &= "|" & PixelToString($Pixel, $sDelim)
Next
$s = StringMid($s, 2)
Return $s
EndFunc
Func PixelToString(Const ByRef $Pixel, $sDelim = "-")
If UBound($Pixel) < 2 Then Return ""
Return $Pixel[0] & $sDelim & $Pixel[1]
EndFunc
Func _SortRedline($redline, $sDelim = ",")
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
If $size < 2 Then Return StringReplace($redline, $sDelim, "-")
Local $a1[$size + 1][2] = [[0, 0]]
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, $sDelim)
If UBound($aPoint) > 1 Then getRedAreaSideBuildingSetPoint($a1, $aPoint)
Next
Local $s = getRedAreaSideBuildingString($a1)
Return $s
EndFunc
Func getRedAreaSideBuildingSetPoint(ByRef $aSide, ByRef $aPoint)
$aSide[0][0] += 1
$aSide[$aSide[0][0]][0] = Int($aPoint[0])
$aSide[$aSide[0][0]][1] = Int($aPoint[1])
EndFunc
Func getRedAreaSideBuildingString(ByRef $aSide)
If UBound($aSide) < 2 Or $aSide[0][0] < 1 Then Return ""
_ArraySort($aSide, 0, 1, $aSide[0][0], 0)
Local $s = ""
For $j = 1 To $aSide[0][0]
$s &=("|" & $aSide[$j][0] & "-" & $aSide[$j][1])
Next
$s = StringMid($s, 2)
Return $s
EndFunc
Func getRedAreaSideBuilding($redline = $g_sImglocRedline)
Local $c = 0
Local $a[5]
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
Local $a1[$size + 1][2] = [[0, 0]]
Local $a2[$size + 1][2] = [[0, 0]]
Local $a3[$size + 1][2] = [[0, 0]]
Local $a4[$size + 1][2] = [[0, 0]]
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, ",")
If UBound($aPoint) > 1 Then
$c += 1
Local $i = GetPixelSection($aPoint[0], $aPoint[1])
Switch $i
Case 1
getRedAreaSideBuildingSetPoint($a1, $aPoint)
Case 2
getRedAreaSideBuildingSetPoint($a2, $aPoint)
Case 3
getRedAreaSideBuildingSetPoint($a3, $aPoint)
Case 4
getRedAreaSideBuildingSetPoint($a4, $aPoint)
EndSwitch
EndIf
Next
$a[0] = $c
$a[1] = getRedAreaSideBuildingString($a1)
$a[2] = getRedAreaSideBuildingString($a2)
$a[3] = getRedAreaSideBuildingString($a3)
$a[4] = getRedAreaSideBuildingString($a4)
Return $a
EndFunc
Func GetPixelSection($x, $y)
Local $isLeft =($x <= $ExternalArea[2][0])
Local $isTop =($y <= $ExternalArea[0][1])
If $isLeft Then
If $isTop Then Return 1
Return 2
EndIf
If $isTop Then Return 4
Return 3
EndFunc
Func FindClosestToAxis(Const ByRef $PixelList)
Local $Axis = [$ExternalArea[2][0], $ExternalArea[0][1]]
Local $Search[2] = [9999, 9999]
Local $Points[2]
For $Pixel In $PixelList
For $i = 0 To 1
If Abs($Pixel[$i] - $Axis[$i]) < Abs($Search[$i] - $Axis[$i]) Then
$Search[$i] = $Pixel[$i]
$Points[$i] = $Pixel
EndIf
Next
Next
For $i = 0 To 1
If $Search[$i] = 9999 Then $Search[$i] = $Axis[$i]
Next
Return $Search
EndFunc
Func _GetVectorOutZone($eVectorType)
debugRedArea("_GetVectorOutZone IN")
Local $vectorOutZone[0]
Local $iSteps = 100
Local $xMin, $yMin, $xMax, $yMax
If($eVectorType = $eVectorLeftTop) Then
$xMin = $ExternalArea[0][0] + 2
$yMin = $ExternalArea[0][1]
$xMax = $ExternalArea[2][0]
$yMax = $ExternalArea[2][1] + 2
ElseIf($eVectorType = $eVectorRightTop) Then
$xMin = $ExternalArea[2][0]
$yMin = $ExternalArea[2][1] + 2
$xMax = $ExternalArea[1][0] - 2
$yMax = $ExternalArea[1][1]
ElseIf($eVectorType = $eVectorLeftBottom) Then
$xMin = $ExternalArea[0][0] + 2
$yMin = $ExternalArea[0][1]
$xMax = $ExternalArea[3][0]
$yMax = $ExternalArea[3][1] - 2
Else
$xMin = $ExternalArea[3][0]
$yMin = $ExternalArea[3][1] - 2
$xMax = $ExternalArea[1][0] - 2
$yMax = $ExternalArea[1][1]
EndIf
For $i = 0 To $iSteps
Local $pixel = [Round($xMin +(($xMax - $xMin) * $i) / $iSteps), Round($yMin +(($yMax - $yMin) * $i) / $iSteps)]
ReDim $vectorOutZone[UBound($vectorOutZone) + 1]
If $pixel[1] > 555 + $g_iBottomOffsetY Then
$pixel[1] = 555 + $g_iBottomOffsetY
EndIf
$vectorOutZone[UBound($vectorOutZone) - 1] = $pixel
Next
Return $vectorOutZone
EndFunc
Func debugRedArea($string)
If $g_bDebugRedArea Then
Local $hFile = FileOpen($g_sProfileLogsPath & "debugRedArea.log", $FO_APPEND)
_FileWriteLog($hFile, $string)
FileClose($hFile)
EndIf
EndFunc
Func DropOnPixel($troop, $listArrPixel, $number, $slotsPerEdge = 0)
If isProblemAffect(True) Then Return
If Not IsAttackPage() Then Return
Local $nameFunc = "[DropOnPixel]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / size arrPixel [" & UBound($listArrPixel) & "] / number [" & $number & "]/ $slotsPerEdge [" & $slotsPerEdge & "] ")
If($number = 0 Or UBound($listArrPixel) = 0) Then Return
KeepClicks()
For $i = 0 To UBound($listArrPixel) - 1
debugRedArea("$listArrPixel $i : [" & $i & "] ")
Local $nbTroopsLeft = $number
Local $offset = 1
Local $nbTroopByPixel = 1
Local $arrPixel = $listArrPixel[$i]
debugRedArea("UBound($arrPixel) " & UBound($arrPixel) & "$number :" & $number)
While($nbTroopsLeft > 0)
If(UBound($arrPixel) = 0) Then
ExitLoop
EndIf
If(UBound($arrPixel) > $nbTroopsLeft) Then
$offset = UBound($arrPixel) / $nbTroopsLeft
Else
$nbTroopByPixel = Floor($number / UBound($arrPixel))
EndIf
If($offset < 1) Then
$offset = 1
EndIf
If($nbTroopByPixel < 1) Then
$nbTroopByPixel = 1
EndIf
For $j = 0 To UBound($arrPixel) - 1 Step $offset
Local $index = Round($j)
If($index > UBound($arrPixel) - 1) Then
$index = UBound($arrPixel) - 1
EndIf
Local $currentPixel = $arrPixel[Floor($index)]
If $j >= Round(UBound($arrPixel) / 2) And $j <= Round((UBound($arrPixel) / 2) + $offset) And $g_bIsHeroesDropped = False Then
$g_aiDeployHeroesPosition[0] = $currentPixel[0]
$g_aiDeployHeroesPosition[1] = $currentPixel[1]
debugRedArea("Heroes : $slotsPerEdge = else ")
debugRedArea("$offset: " & $offset)
EndIf
If $j >= Round(UBound($arrPixel) / 2) And $j <= Round((UBound($arrPixel) / 2) + $offset) And $g_bIsCCDropped = False Then
$g_aiDeployCCPosition[0] = $currentPixel[0]
$g_aiDeployCCPosition[1] = $currentPixel[1]
debugRedArea("CC : $slotsPerEdge = else ")
debugRedArea("$offset: " & $offset)
EndIf
If Number($currentPixel[1]) > 555 + $g_iBottomOffsetY Then $currentPixel[1] = 555 + $g_iBottomOffsetY
AttackClick($currentPixel[0], $currentPixel[1], $nbTroopByPixel, SetSleep(0), 0, "#0098")
$nbTroopsLeft -= $nbTroopByPixel
Next
WEnd
Next
ReleaseClicks()
debugRedArea($nameFunc & " OUT ")
EndFunc
Func DropTroop($troop, $nbSides, $number, $slotsPerEdge = 0, $indexToAttack = -1)
If isProblemAffect(True) Then Return
Local $nameFunc = "[DropTroop]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / nbSides : [" & $nbSides & "] / number : [" & $number & "] / slotsPerEdge [" & $slotsPerEdge & "]")
If($g_abAttackStdSmartAttack[$g_iMatchMode]) And($g_aiAttackStdDropSides[$g_iMatchMode] <> 4) Then
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = Floor($number / $nbSides)
If _Sleep($DELAYDROPTROOP1) Then Return
SelectDropTroop($troop)
If _Sleep($DELAYDROPTROOP2) Then Return
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
If($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2] = False) Then
If $nbSides = 4 Then
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
For $i = 0 To $nbSides - 3
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $listEdgesPixelToDrop[2] = [$g_aaiEdgeDropPointsPixelToDrop[$i], $g_aaiEdgeDropPointsPixelToDrop[$i + 2]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
Next
Return
EndIf
For $i = 0 To $nbSides - 1
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
Local $listEdgesPixelToDrop[1] = [$g_aaiEdgeDropPointsPixelToDrop[$i]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
Local $listEdgesPixelToDrop[2] = [$g_aaiEdgeDropPointsPixelToDrop[$i + 3], $g_aaiEdgeDropPointsPixelToDrop[$i + 1]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
EndIf
Next
Else
Local $listEdgesPixelToDrop[0]
If($indexToAttack <> -1) Then
Local $nbTroopsPerEdge = $number
Local $maxElementNearCollector = $indexToAttack
Local $startIndex = $indexToAttack
Else
Local $nbTroopsPerEdge = Round($number / UBound($g_aiPixelNearCollector))
Local $maxElementNearCollector = UBound($g_aiPixelNearCollector) - 1
Local $startIndex = 0
EndIf
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
For $i = $startIndex To $maxElementNearCollector
Local $pixel = $g_aiPixelNearCollector[$i]
ReDim $listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) + 1]
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
$listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) - 1] = _FindPixelCloser($g_aiPixelRedAreaFurther, $pixel, 5)
Else
$listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) - 1] = _FindPixelCloser($g_aiPixelRedArea, $pixel, 5)
EndIf
Next
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
EndIf
Else
DropOnEdges($troop, $nbSides, $number, $slotsPerEdge)
EndIf
debugRedArea($nameFunc & " OUT ")
EndFunc
Func DropTroop2($troop, $nbSides, $number, $slotsPerEdge = 0, $name = "")
Local $nameFunc = "[DropTroop2]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / nbSides : [" & $nbSides & "] / number : [" & $number & "] / slotsPerEdge [" & $slotsPerEdge & "]")
Local $listInfoPixelDropTroop[0]
If($g_abAttackStdSmartAttack[$g_iMatchMode]) Then
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = Floor($number / $nbSides)
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
Local $nbTroopsPerEdge = Round($nbTroopsLeft / $nbSides)
If(($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2] = False) Or UBound($g_aiPixelNearCollector) = 0) Then
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
If $nbSides = 4 Then
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 4]
Local $listInfoPixelDropTroop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
Else
For $i = 0 To $nbSides - 1
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 1]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = $g_aaiEdgeDropPointsPixelToDrop[$i]
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $g_aaiEdgeDropPointsPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 2]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 2] = $g_aaiEdgeDropPointsPixelToDrop[$i + 3]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = $g_aaiEdgeDropPointsPixelToDrop[$i + 1]
EndIf
Next
EndIf
Else
Local $nbTroopsPerEdge = Round($number / UBound($g_aiPixelNearCollector))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $maxElementNearCollector = UBound($g_aiPixelNearCollector) - 1
Local $startIndex = 0
Local $troopFurther = False
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
$troopFurther = True
EndIf
Local $centerPixel[2] = [430, 338]
For $i = $startIndex To $maxElementNearCollector
Local $pixel = $g_aiPixelNearCollector[$i]
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 1]
Local $arrPixelToSearch
If($pixel[0] < $centerPixel[0] And $pixel[1] < $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $g_aiPixelTopLeftFurther
Else
$arrPixelToSearch = $g_aiPixelTopLeft
EndIf
ElseIf($pixel[0] < $centerPixel[0] And $pixel[1] > $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $g_aiPixelBottomLeftFurther
Else
$arrPixelToSearch = $g_aiPixelBottomLeft
EndIf
ElseIf($pixel[0] > $centerPixel[0] And $pixel[1] > $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $g_aiPixelBottomRightFurther
Else
$arrPixelToSearch = $g_aiPixelBottomRight
EndIf
Else
If($troopFurther) Then
$arrPixelToSearch = $g_aiPixelTopRightFurther
Else
$arrPixelToSearch = $g_aiPixelTopRight
EndIf
EndIf
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = _FindPixelCloser($arrPixelToSearch, $pixel, 1)
Next
EndIf
Else
DropOnEdges($troop, $nbSides, $number, $slotsPerEdge)
EndIf
Local $infoDropTroop[6] = [$troop, $listInfoPixelDropTroop, $nbTroopsPerEdge, $slotsPerEdge, $number, $name]
debugRedArea($nameFunc & " OUT ")
Return $infoDropTroop
EndFunc
Func GetLocationMine()
Local $sDirectory = @ScriptDir & "\imgxml\Storages\GoldMines"
Local $sTxtName = "Mines"
Local $iMaxReturns = 7
If $g_iDetectedImageType = 1 Then
$sDirectory = @ScriptDir & "\imgxml\Storages\Mines_Snow"
$sTxtName = "SnowMines"
EndIf
Local $aTempResult = returnMultipleMatches($sDirectory, $iMaxReturns)
Local $aEndResult = ConvertImgloc2MBR($aTempResult, $iMaxReturns)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocation" & $sTxtName & ": " & $aEndResult, $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult, $sTxtName)
Return GetListPixel($aEndResult)
EndFunc
Func GetLocationElixir()
Local $sDirectory = @ScriptDir & "\imgxml\Storages\Collectors"
Local $sTxtName = "Collectors"
Local $iMaxReturns = 7
If $g_iDetectedImageType = 1 Then
$sDirectory = @ScriptDir & "\imgxml\Storages\Collectors_Snow"
$sTxtName = "SnowCollectors"
EndIf
Local $aTempResult = returnMultipleMatches($sDirectory, $iMaxReturns)
Local $aEndResult = ConvertImgloc2MBR($aTempResult, $iMaxReturns)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocation" & $sTxtName & ": " & $aEndResult, $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult, $sTxtName)
Return GetListPixel($aEndResult)
EndFunc
Func GetLocationDarkElixir()
Local $sDirectory = @ScriptDir & "\imgxml\Storages\Drills"
Local $iMaxReturns = 3
Local $aTempResult = returnMultipleMatches($sDirectory, $iMaxReturns)
Local $aEndResult = ConvertImgloc2MBR($aTempResult, $iMaxReturns)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocationDarkElixir: " & $aEndResult, $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult, "DarkElixir")
Return GetListPixel($aEndResult)
EndFunc
Func GetLocationTownHall()
Local $aEndResult = DllCallMyBot("getLocationTownHall", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocationTownHall: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "TownHall")
Return GetListPixel($aEndResult[0])
EndFunc
Func GetLocationDarkElixirStorageWithLevel()
Local $aEndResult = DllCallMyBot("getLocationDarkElixirStorageWithLevel", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocationDarkElixirStorageWithLevel: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "DarkElixirStorageWithLevel")
Return $aEndResult[0]
EndFunc
Func GetLocationDarkElixirStorage()
Local $aEndResult = DllCallMyBot("getLocationDarkElixirStorage", "ptr", $g_hHBitmap2)
If $g_bDebugBuildingPos Then SetLog("#*# GetLocationDarkElixirStorage: " & $aEndResult[0], $COLOR_DEBUG)
If $g_bDebugGetLocation Then DebugImageGetLocation($aEndResult[0], "DarkElixirStorage")
Return GetListPixel($aEndResult[0])
EndFunc
Func GetLocationBuilding($iBuildingType, $iAttackingTH = 12, $bForceCaptureRegion = True)
If $g_bDebugSetlog Then SetDebugLog("Begin GetLocationBuilding: " & $g_sBldgNames[$iBuildingType], $COLOR_DEBUG1)
Local $hTimer = __TimerInit()
Local $TotalBuildings = 0
Local $minLevel = 0
Local $fullCocAreas = "DCD"
Local $BuildingXY, $redLines, $bRedLineExists, $aBldgCoord, $sTempCoord, $tmpNumFound
Local $tempNewLevel, $tempExistingLevel, $sLocCoord, $sNearCoord, $sFarCoord, $directory, $iCountUpdate
If $iAttackingTH = "-" Then $iAttackingTH = 12
If _ObjSearch($g_oBldgImages, $iBuildingType & "_" & $g_iDetectedImageType) = True Then
$directory = _ObjGetValue($g_oBldgImages, $iBuildingType & "_" & $g_iDetectedImageType)
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgImages " & $g_sBldgNames[$iBuildingType] &($g_iDetectedImageType = 1 ? "Snow " : " "), @error)
SetError(1, 0, -1)
Return
EndIf
Else
$directory = _ObjGetValue($g_oBldgImages, $iBuildingType & "_0")
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgImages" & $g_sBldgNames[$iBuildingType], @error)
SetError(1, 0, -1)
Return
EndIf
EndIf
Local $maxReturnPoints = _ObjGetValue($g_oBldgMaxQty, $iBuildingType)[$iAttackingTH - 1]
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgMaxQty", @error)
$maxReturnPoints = 20
EndIf
If _ObjSearch($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS") = True Then
If _ObjGetValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT") > 50 Then
$redLines = _ObjGetValue($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS")
If @error Then _ObjErrMsg("_ObjGetValue $g_oBldgAttackInfo redline", @error)
If IsString($redLines) And $redLines <> "" And $redLines <> "ECD" Then
$bRedLineExists = True
Else
$redLines = ""
$bRedLineExists = False
EndIf
Else
$redLines = ""
$bRedLineExists = False
EndIf
Else
$redLines = ""
$bRedLineExists = False
EndIf
Local $maxLevel = _ObjGetValue($g_oBldgLevels, $iBuildingType)[$iAttackingTH - 1]
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgLevels", @error)
$maxLevel = 20
EndIf
If $bForceCaptureRegion = True Then _CaptureRegion2()
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If checkImglocError($res, "SearchMultipleTilesBetweenLevels", $directory) = True Then
SetError(2, 1, 1)
Return
EndIf
If $bRedLineExists = False Then
Local $aValue = RetrieveImglocProperty("redline", "")
If $aValue <> "" Then
Local $aCoordsSplit = StringSplit($aValue, "|")
If $aCoordsSplit[0] > 50 Then
$redLines = $aValue
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS", $redLines)
If @error Then _ObjErrMsg("_ObjPutValue $g_oBldgAttackInfo", @error)
Local $redlinesCount = $aCoordsSplit[0]
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT", $redlinesCount)
If @error Then _ObjErrMsg("_ObjSetValue $g_oBldgAttackInfo", @error)
Else
Setdebuglog("> Not enough red line points to save in building dictionary?", $COLOR_WARNING)
EndIf
Else
SetLog("> DLL Error getting Red Lines in GetLocationBuilding", $COLOR_ERROR)
EndIf
EndIf
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($aKeys) - 1
$tempNewLevel = Int(RetrieveImglocProperty($aKeys[$i], "objectlevel"))
$tmpNumFound = Int(RetrieveImglocProperty($aKeys[$i], "totalobjects"))
$sTempCoord = RetrieveImglocProperty($aKeys[$i], "objectpoints")
If $i = 0 And StringLen($sTempCoord) > 7 Then
$iCountUpdate = RemoveDupNearby($sTempCoord)
If $tmpNumFound <> $iCountUpdate And $iCountUpdate <> "" Then $tmpNumFound = $iCountUpdate
EndIf
If _ObjSearch($g_oBldgAttackInfo, $iBuildingType & "_MAXLVLFOUND") Then
$tempExistingLevel = _ObjGetValue($g_oBldgAttackInfo, $iBuildingType & "_MAXLVLFOUND")
Else
$tempExistingLevel = 0
EndIf
If Int($tempNewLevel) > Int($tempExistingLevel) Then
_ObjPutValue($g_oBldgAttackInfo, $iBuildingType & "_MAXLVLFOUND", $tempNewLevel)
If @error Then _ObjErrMsg("_ObjPutValue " & $g_sBldgNames[$iBuildingType] & " _MAXLVLFOUND", @error)
_ObjPutValue($g_oBldgAttackInfo, $iBuildingType & "_NAMEFOUND", $aKeys[$i])
If @error Then _ObjErrMsg("_ObjPutValue " & $g_sBldgNames[$iBuildingType] & " _NAMEFOUND", @error)
EndIf
If UBound($aKeys) > 1 Then
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_LVLFOUND_K" & $i, $tempNewLevel)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _LVLFOUND_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_FILENAME_K" & $i, $aKeys[$i])
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _FILENAME_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_COUNT_K" & $i, $tmpNumFound)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _COUNT_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_OBJECTPOINTS_K" & $i, $sTempCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _OBJECTPOINTS_K" & $i, @error)
EndIf
If $sTempCoord <> "" Then
If $sLocCoord = "" Then
$sLocCoord = $sTempCoord
$TotalBuildings = $tmpNumFound
Else
$iCountUpdate = AddPoints_RemoveDuplicate($sLocCoord, $sTempCoord, $maxReturnPoints)
If $iCountUpdate <> "" Then $TotalBuildings = $iCountUpdate
EndIf
Else
SetDebugLog("> no data in 'objectpoints' request?", $COLOR_WARNING)
EndIf
Next
EndIf
$aBldgCoord = decodeMultipleCoords($sLocCoord)
If $g_bDebugBuildingPos Or $g_bDebugSetlog Then
SetLog("Bldg Loc Coord String: " & $sLocCoord, $COLOR_DEBUG)
Local $sText
Select
Case UBound($aBldgCoord, 1) > 1 And IsArray($aBldgCoord[1])
$sText = PixelArrayToString($aBldgCoord, ",")
Case IsArray($aBldgCoord[0])
Local $aPixelb = $aBldgCoord[0]
$sText = PixelToString($aPixelb, ";")
Case IsArray($aBldgCoord[0]) = 0
$sText = PixelToString($aBldgCoord, ":")
Case Else
$sText = "Monkey ate bad banana!"
EndSelect
SetLog($g_sBldgNames[$iBuildingType] & " $aBldgCoord Array Contents: " & $sText, $COLOR_DEBUG)
EndIf
If IsArray($aBldgCoord) Then
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_OBJECTPOINTS", $sLocCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _OBJECTPOINTS", @error)
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_LOCATION", $aBldgCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _LOCATION", @error)
EndIf
If $TotalBuildings <> 0 Then
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_COUNT", $TotalBuildings)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iBuildingType] & " _COUNT", @error)
EndIf
SetLog("Total " & $g_sBldgNames[$iBuildingType] & " Buildings: " & $TotalBuildings)
Local $iTime = __TimerDiff($hTimer) * 0.001
_ObjAdd($g_oBldgAttackInfo, $iBuildingType & "_FINDTIME", $iTime)
If @error Then _ObjErrMsg("_ObjAdd" & $g_sBldgNames[$iBuildingType] & " _FINDTIME", @error)
If $g_bDebugBuildingPos Then SetLog("  - Location(s) found in: " & Round($iTime, 2) & " seconds ", $COLOR_DEBUG)
EndFunc
Func DebugImageGetLocation($sVector, $sType, $iBuildingENUM = "")
SetLog("DebugImageGetLocation() Start:")
SetLog("$sVector: " & $sVector)
SetLog("$sType: " & $sType)
Switch $sType
Case "DarkElixirStorageWithLevel", "ElixirExtractorWithLevel", "SnowElixirExtractorWithLevel", "MineExtractorWithLevel", "SnowMineExtractorWithLevel", "DarkElixirExtractorWithLevel"
Local $aVector = StringSplit($sVector, "~", 2)
SetLog("- " & $sType)
For $i = 0 To UBound($aVector) - 1
SetLog($sType & " " & $i & " --> " & $aVector[$i])
Local $temp = StringSplit($aVector[$i], "#", 2)
If UBound($temp) = 2 Then
Local $aPixels = StringSplit($temp[1], "-", 2)
If UBound($aPixels) = 2 Then
If isInsideDiamondRedArea($aPixels) Then
If $g_bDebugSetlog Then SetDebugLog("coordinate inside village (" & $aPixels[0] & "," & $aPixels[1] & ")")
_CaptureRegion($aPixels[0] - 30, $aPixels[1] - 30, $aPixels[0] + 30, $aPixels[1] + 30)
DebugImageSave("DebugImageGetLocation_" & $sType & "_", False)
Else
If $g_bDebugSetlog Then SetDebugLog("coordinate out of village (" & $aPixels[0] & "," & $aPixels[1] & ")")
EndIf
EndIf
EndIf
Next
Case "Mine", "SnowMine", "Elixir", "SnowElixir", "DarkElixir", "TownHall", "DarkElixirStorage", "GoldStorage", "ElixirStorage", "Inferno"
Local $aVector = StringSplit($sVector, "|", 2)
SetLog("- " & $sType)
For $i = 0 To UBound($aVector) - 1
Local $aPixels = StringSplit($aVector[$i], "-", 2)
If UBound($aPixels) = 2 Then
If isInsideDiamondRedArea($aPixels) Then
If $g_bDebugSetlog Then SetDebugLog("coordinate inside village (" & $aPixels[0] & "," & $aPixels[1] & ")")
_CaptureRegion($aPixels[0] - 30, $aPixels[1] - 30, $aPixels[0] + 30, $aPixels[1] + 30)
DebugImageSave("DebugImageGetLocation_" & $sType & "_", False)
Else
If $g_bDebugSetlog Then SetDebugLog("coordinate out of village (" & $aPixels[0] & "," & $aPixels[1] & ")")
EndIf
EndIf
Next
Case "GetBuildings"
If $iBuildingENUM = "" Then
SetLog("DebugImageGetLocation Parameter error!", $COLOR_ERROR)
Return
EndIf
Local $aVector = StringSplit($sVector, "|", 2)
SetLog("- " & $sType)
For $i = 0 To UBound($aVector) - 1
Local $aPixels = StringSplit($aVector[$i], ",", 2)
If UBound($aPixels) = 2 Then
If isInsideDiamondRedArea($aPixels) Then
If $g_bDebugSetlog Then SetDebugLog("coordinate inside village (" & $aPixels[0] & "," & $aPixels[1] & ")")
_CaptureRegion($aPixels[0] - 30, $aPixels[1] - 30, $aPixels[0] + 30, $aPixels[1] + 30)
DebugImageSave("DebugImageGetLocation_" & StringStripWS($g_sBldgNames[$iBuildingENUM], $STR_STRIPALL) & "_", False)
Else
If $g_bDebugSetlog Then SetDebugLog("coordinate out of village (" & $aPixels[0] & "," & $aPixels[1] & ")")
EndIf
EndIf
Next
Case Else
SetDebugLog("Bad Input on DebugImageGetLocation(). $sType does not support: " & $sType)
EndSwitch
EndFunc
Func ConvertImgloc2MBR($aArray, $iMaxPositions, $bLevel = False)
Local $sStringConverted = Null
Local $iMax = 0
If IsArray($aArray) Then
For $i = 1 To UBound($aArray) - 1
Local $aCoord = $aArray[$i][5]
If IsArray($aCoord) Then
For $t = 0 To UBound($aCoord) - 1
If isInsideDiamondXY($aCoord[$t][0], $aCoord[$t][1]) Then
If $bLevel Then $sStringConverted &= $aArray[$i][2] & "#" & $aCoord[$t][0] & "-" & $aCoord[$t][1] & "~"
If Not $bLevel Then $sStringConverted &= $aCoord[$t][0] & "-" & $aCoord[$t][1] & "|"
$iMax += 1
If $iMax = $iMaxPositions Then ExitLoop(2)
EndIf
Next
EndIf
Next
Else
SetLog("Error on ConvertImgLoc2MBR(): First Value is no Array!", $COLOR_ERROR)
EndIf
$sStringConverted = StringTrimRight($sStringConverted, 1)
If $g_bDebugSetlog Then SetDebugLog("$sStringConverted: " & $sStringConverted)
Return $sStringConverted
EndFunc
Func GetOffestPixelRedArea2($pixel, $eVectorType, $offset = 3)
Local $pixelOffest = $pixel
If($eVectorType = $eVectorLeftTop) Then
$pixelOffest[0] = Round($pixel[0] - $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] - $offset
ElseIf($eVectorType = $eVectorRightBottom) Then
$pixelOffest[0] = Round($pixel[0] + $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] + $offset
ElseIf($eVectorType = $eVectorLeftBottom) Then
$pixelOffest[0] = Round($pixel[0] - $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] + $offset
ElseIf($eVectorType = $eVectorRightTop) Then
$pixelOffest[0] = Round($pixel[0] + $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] - $offset
EndIf
If $pixelOffest[1] > 555 + $g_iBottomOffsetY Then
$pixelOffest[1] = 555 + $g_iBottomOffsetY
EndIf
Return $pixelOffest
EndFunc
Func GetPixelDropTroop($troop, $number, $slotsPerEdge)
Local $newPixelTopLeft
Local $newPixelBottomLeft
Local $newPixelTopRight
Local $newPixelBottomRight
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
If UBound($g_aiPixelTopLeftFurther) > 0 Then
$newPixelTopLeft = $g_aiPixelTopLeftFurther
Else
$newPixelTopLeft = $g_aiPixelTopLeft
EndIf
If UBound($g_aiPixelBottomLeftFurther) > 0 Then
$newPixelBottomLeft = $g_aiPixelBottomLeftFurther
Else
$newPixelBottomLeft = $g_aiPixelBottomLeft
EndIf
If UBound($g_aiPixelTopRightFurther) > 0 Then
$newPixelTopRight = $g_aiPixelTopRightFurther
Else
$newPixelTopRight = $g_aiPixelTopRight
EndIf
If UBound($g_aiPixelBottomRightFurther) Then
$newPixelBottomRight = $g_aiPixelBottomRightFurther
Else
$newPixelBottomRight = $g_aiPixelBottomRight
EndIf
Else
$newPixelTopLeft = $g_aiPixelTopLeft
$newPixelBottomLeft = $g_aiPixelBottomLeft
$newPixelTopRight = $g_aiPixelTopRight
$newPixelBottomRight = $g_aiPixelBottomRight
EndIf
$newPixelTopLeft = GetVectorPixelOnEachSide2($newPixelTopLeft, 0, $slotsPerEdge)
$newPixelBottomLeft = GetVectorPixelOnEachSide2($newPixelBottomLeft, 1, $slotsPerEdge)
$newPixelTopRight = GetVectorPixelOnEachSide2($newPixelTopRight, 1, $slotsPerEdge)
$newPixelBottomRight = GetVectorPixelOnEachSide2($newPixelBottomRight, 0, $slotsPerEdge)
Local $g_aaiEdgeDropPointsPixelToDrop[4] = [$newPixelBottomRight, $newPixelTopLeft, $newPixelBottomLeft, $newPixelTopRight]
Return $g_aaiEdgeDropPointsPixelToDrop
EndFunc
Func GetPixelSide($listPixel, $index)
If $g_bDebugSetlog Then SetDebugLog("GetPixelSide " & $index & " = " & StringReplace($listPixel[$index], "-", ","))
Return GetListPixel($listPixel[$index])
EndFunc
Func GetVectorPixelOnEachSide2($arrPixel, $vectorDirection, $slotsPerEdge)
Local $vectorPixelEachSide[$slotsPerEdge]
If(UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
If $g_bDebugSmartFarm Then Setlog("Min pixel coord: " & $min & ", Max Pixel coord: " & $max)
Local $posSide = Floor(($max - $min) / $slotsPerEdge)
For $i = 0 To $slotsPerEdge - 1
$pixelSearch[$vectorDirection] = $min + Floor(($posSide *($i + 1)) -($posSide / 2))
Local $coordinate =($vectorDirection = 0) ? "X" : "Y"
If $g_bDebugSmartFarm Then Setlog("Deploy point number[" & $i + 1 & "] at " & $coordinate & ": " & $min + Floor(($posSide *($i + 1)) -($posSide / 2)))
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
If $g_bDebugSmartFarm Then Setlog("Deploy point Closer[" & $i + 1 & "] at: " & _ArrayToString($arrPixelCloser[0]))
$vectorPixelEachSide[$i] = $arrPixelCloser[0]
Next
EndIf
Return $vectorPixelEachSide
EndFunc
Func _IsPointInPoly($x, $y, $aPoints)
Local $bEvenNum = False, $xOnLine, $yMin, $yMax
For $i = 1 To $aPoints[0][0]
$yMin =($aPoints[$i + 1][1] < $aPoints[$i][1] ? $aPoints[$i + 1][1] : $aPoints[$i][1])
$yMax =($aPoints[$i + 1][1] > $aPoints[$i][1] ? $aPoints[$i + 1][1] : $aPoints[$i][1])
$xOnLine = -($y * $aPoints[$i + 1][0] - $y * $aPoints[$i][0] - $aPoints[$i][1] * $aPoints[$i + 1][0] + $aPoints[$i][0] * $aPoints[$i + 1][1]) /(-$aPoints[$i + 1][1] + $aPoints[$i][1])
If($x < $xOnLine) And($y > $yMin) And($y <= $yMax) Then $bEvenNum = Not $bEvenNum
Next
Return $bEvenNum
EndFunc
Func IsPointOnSide($aCoords, $sSide)
If IsArray($aCoords) = False Then
SetLog("IsPointOnSide() coordinates array not recognized", $COLOR_ERROR)
Return SetError(1, 0, "")
EndIf
Switch $sSide
Case "TL", "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $aPoints[5][2] = [[3, 0], [425, 345], [5, 345], [425, 30], [425, 345]]
Case "TR", "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $aPoints[5][2] = [[3, 0], [425, 345], [425, 30], [845, 345], [425, 345]]
Case "BL", "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $aPoints[5][2] = [[3, 0], [425, 345], [5, 345], [425, 660], [425, 345]]
Case "BR", "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $aPoints[5][2] = [[3, 0], [425, 345], [845, 345], [425, 660], [425, 345]]
Case Else
SetLog("IsPointOnSide() 'side' string not recognized", $COLOR_ERROR)
Return SetError(1, 0, "")
EndSwitch
Return _IsPointInPoly($aCoords[0], $aCoords[1], $aPoints)
EndFunc
Func RemoveDupNearby(ByRef $sLocCoord, $iDistance = 8)
SetDebugLog("Begin RemoveDupNearby", $COLOR_DEBUG1)
Local $aCoord = StringSplit($sLocCoord, "|")
Local $aLoc1, $aLoc2, $bRemovedDuplicate = False
Local $sTmpVector = ""
If IsArray($aCoord) Then
For $ep = 1 To $aCoord[0]
If $aCoord[$ep] = "" Then ContinueLoop
$aLoc1 = StringSplit($aCoord[$ep], ",")
If $aLoc1[0] = 2 Then
For $np = 1 To $aCoord[0]
If $np = $ep Then ContinueLoop
$aLoc2 = StringSplit($aCoord[$np], ",")
If $aCoord[$np] = "" Then ContinueLoop
If $aLoc2[0] = 2 Then
If _WinAPI_PtInRectEx($aLoc2[1], $aLoc2[2], $aLoc1[1] - $iDistance, $aLoc1[2] - $iDistance, $aLoc1[1] + $iDistance, $aLoc1[2] + $iDistance) = True Then
SetDebugLog("Duplicate location found, skipping: " & $aLoc2[1] & "," & $aLoc2[2], $COLOR_INFO)
$aCoord[$np] = ""
$bRemovedDuplicate = True
EndIf
Else
SetLog("RemoveDupNearby stringsplit value error!", $COLOR_ERROR)
EndIf
Next
Else
SetLog("RemoveDupNearby string value error!", $COLOR_ERROR)
EndIf
Next
Else
SetLog("RemoveDupNearby location string paramenter error!", $COLOR_ERROR)
EndIf
If $bRemovedDuplicate = True Then
For $np = 1 To $aCoord[0]
If StringStripWS($aCoord[$np], $STR_STRIPALL) = "" Then ContinueLoop
$aLoc1 = StringSplit($aCoord[$np], ",")
If @error Then ContinueLoop
$sTmpVector &= $aLoc1[1] & "," & $aLoc1[2] & "|"
Next
If StringLen($sTmpVector) > 0 Then $sTmpVector = StringLeft($sTmpVector, StringLen($sTmpVector) - 1)
SetDebugLog("Return $sTmpVector= " & $sTmpVector, $COLOR_DEBUG)
If StringInStr($sTmpVector, "|", $STR_NOCASESENSEBASIC) > 0 Then
Local $aCoord2 = StringSplit($sTmpVector, "|")
If @error Then
SetDebugLog("$sTmpVector string split failed: " & $aCoord2[1] & " , skip duplicate removal", $COLOR_WARNING)
Return $aCoord[0]
EndIf
Else
If $sTmpVector <> "" then
Local $aCoord2 = [ 1, $sTmpVector]
Else
SetDebugLog("Impossible error: RemoveDupNearby removed all points!", $COLOR_ERROR)
Return $aCoord[0]
EndIf
EndIf
If $g_bDebugSetlog And $aCoord[0] <> $aCoord2[0] Then
SetDebugLog("Duplicate objectpoints found, removed: " & $aCoord[0] - $aCoord2[0], $COLOR_INFO)
SetDebugLog("Final Coords count= " & $aCoord2[0], $COLOR_DEBUG)
EndIf
$sLocCoord = $sTmpVector
Return $aCoord2[0]
Else
Return $aCoord[0]
EndIf
EndFunc
Func AddPoints_RemoveDuplicate(ByRef $sLoc1Coord, $sLoc2Coord, $iReturnpoints, $iDistance = 8)
If $g_bDebugSetlog Then SetDebugLog("Begin AddPoints_RemoveDuplicate", $COLOR_DEBUG1)
Local $aCoord1 = StringSplit($sLoc1Coord, "|")
Local $aCoord2 = StringSplit($sLoc2Coord, "|")
Local $aLoc1, $aLoc2
Local $iPointsAdded = 0
If IsArray($aCoord1) And IsArray($aCoord2) Then
For $ep = 1 To $aCoord1[0]
$aLoc1 = StringSplit($aCoord1[$ep], ",")
If $aLoc1[0] = 2 Then
For $np = 1 To $aCoord2[0]
If $aCoord2[$np] = "" Then ContinueLoop
$aLoc2 = StringSplit($aCoord2[$np], ",")
If $aLoc2[0] = 2 Then
If _WinAPI_PtInRectEx($aLoc2[1], $aLoc2[2], $aLoc1[1] - $iDistance, $aLoc1[2] - $iDistance, $aLoc1[1] + $iDistance, $aLoc1[2] + $iDistance) = True Then
SetDebugLog("Duplicate location found, skipping: " & $aLoc2[1] & "," & $aLoc2[2], $COLOR_INFO)
$aCoord2[$np] = ""
EndIf
Else
SetLog("RemoveDuplicatePoints New string value error!", $COLOR_ERROR)
EndIf
Next
Else
SetLog("RemoveDuplicatePoints Existing string value error!", $COLOR_ERROR)
EndIf
Next
For $np = 1 To $aCoord2[0]
If $aCoord2[$np] <> "" Then
$aLoc2 = StringSplit($aCoord2[$np], ",")
If $aLoc2[0] = 2 Then
$sLoc1Coord &= "|" & $aLoc2[1] & "," & $aLoc2[2]
$iPointsAdded += 1
EndIf
If($aCoord1[0] + $iPointsAdded) >= $iReturnpoints Then
If $aCoord2[0] > $np And $aCoord2[$np + 1] <> "" Then
SetLog("AddPoints_RemoveDuplicate found more locatons then requested!", $COLOR_ERROR)
SetLog("Location string truncated to max requested: " & $iReturnpoints, $COLOR_ERROR)
ExitLoop
EndIf
EndIf
EndIf
Next
SetDebugLog("Final $sLoc1Coord= "& $sLoc1Coord, $COLOR_DEBUG)
Else
SetLog("RemoveDuplicatePoints location string paramenter error!", $COLOR_ERROR)
EndIf
Return($aCoord1[0] + $iPointsAdded)
EndFunc
Func CheckHeroesHealth()
If $g_bCheckKingPower Or $g_bCheckQueenPower Or $g_bCheckWardenPower Then
ForceCaptureRegion()
Local $aDisplayTime[$eHeroCount] = [0, 0, 0]
Local $TempKingSlot = $g_iKingSlot
Local $TempQueenSlot = $g_iQueenSlot
Local $TempWardenSlot = $g_iWardenSlot
If $g_iKingSlot >= 11 Or $g_iQueenSlot >= 11 Or $g_iWardenSlot >= 11 Then
If Not $g_bDraggedAttackBar Then DragAttackBar($g_iTotalAttackSlot, False)
ElseIf $g_iKingSlot >= 0 And $g_iQueenSlot >= 0 And $g_iWardenSlot >= 0 And($g_iKingSlot < $g_iTotalAttackSlot - 10 Or $g_iQueenSlot < $g_iTotalAttackSlot - 10 Or $g_iWardenSlot < $g_iTotalAttackSlot - 10) Then
If $g_bDraggedAttackBar Then DragAttackBar($g_iTotalAttackSlot, True)
EndIf
If $g_bDraggedAttackBar Then
$TempKingSlot -= $g_iTotalAttackSlot - 10
$TempQueenSlot -= $g_iTotalAttackSlot - 10
$TempWardenSlot -= $g_iTotalAttackSlot - 10
EndIf
If $g_bDebugSetlog Then
SetDebugLog("CheckHeroesHealth() for Queen started ")
If _Sleep($DELAYRESPOND) Then Return
EndIf
If $g_iActivateQueen = 0 Or $g_iActivateQueen = 2 Then
If $g_bCheckQueenPower And($g_aHeroesTimerActivation[$eHeroArcherQueen] = 0 Or __TimerDiff($g_aHeroesTimerActivation[$eHeroArcherQueen]) > $DELAYCHECKHEROESHEALTH) Then
Local $aQueenHealthCopy = $aQueenHealth
Local $aSlotPosition = GetSlotPosition($TempQueenSlot)
$aQueenHealthCopy[0] = $aSlotPosition[0] + $aQueenHealthCopy[4]
Local $QueenPixelColor = _GetPixelColor($aQueenHealthCopy[0], $aQueenHealthCopy[1], $g_bCapturePixel)
If $g_bDebugSetlog Then SetDebugLog(" Queen _GetPixelColor(" & $aQueenHealthCopy[0] & "," & $aQueenHealthCopy[1] & "): " & $QueenPixelColor, $COLOR_DEBUG)
If Not _CheckPixel2($aQueenHealthCopy, $QueenPixelColor, "Red+Blue") Then
SetLog("Queen is getting weak, Activating Queen's ability", $COLOR_INFO)
SelectDropTroop($TempQueenSlot, 2, Default, False)
$g_iCSVLastTroopPositionDropTroopFromINI = $g_iQueenSlot
$g_bCheckQueenPower = False
EndIf
EndIf
EndIf
If $g_iActivateQueen = 1 Or $g_iActivateQueen = 2 Then
If $g_bCheckQueenPower Then
If $g_aHeroesTimerActivation[$eHeroArcherQueen] <> 0 Then
$aDisplayTime[$eHeroArcherQueen] = Ceiling(__TimerDiff($g_aHeroesTimerActivation[$eHeroArcherQueen]) / 1000)
EndIf
If(Int($g_iDelayActivateQueen) / 1000) <= $aDisplayTime[$eHeroArcherQueen] Then
SetLog("Activating Queen's ability after " & $aDisplayTime[$eHeroArcherQueen] & "'s", $COLOR_INFO)
SelectDropTroop($TempQueenSlot, 2, Default, False)
$g_iCSVLastTroopPositionDropTroopFromINI = $g_iQueenSlot
$g_bCheckQueenPower = False
$g_aHeroesTimerActivation[$eHeroArcherQueen] = 0
EndIf
EndIf
EndIf
If $g_bDebugSetlog Then
SetDebugLog("CheckHeroesHealth() for King started ")
If _Sleep($DELAYRESPOND) Then Return
EndIf
If $g_iActivateKing = 0 Or $g_iActivateKing = 2 Then
If $g_bCheckKingPower And($g_aHeroesTimerActivation[$eHeroBarbarianKing] = 0 Or __TimerDiff($g_aHeroesTimerActivation[$eHeroBarbarianKing]) > $DELAYCHECKHEROESHEALTH) Then
Local $aKingHealthCopy = $aKingHealth
Local $aSlotPosition = GetSlotPosition($TempKingSlot)
$aKingHealthCopy[0] = $aSlotPosition[0] + $aKingHealthCopy[4]
Local $KingPixelColor = _GetPixelColor($aKingHealthCopy[0], $aKingHealthCopy[1], $g_bCapturePixel)
If $g_bDebugSetlog Then SetDebugLog("King _GetPixelColor(" & $aKingHealthCopy[0] & "," & $aKingHealthCopy[1] & "): " & $KingPixelColor, $COLOR_DEBUG)
If Not _CheckPixel2($aKingHealthCopy, $KingPixelColor, "Red+Blue") Then
SetLog("King is getting weak, Activating King's ability", $COLOR_INFO)
SelectDropTroop($TempKingSlot, 2, Default, False)
$g_iCSVLastTroopPositionDropTroopFromINI = $g_iKingSlot
$g_bCheckKingPower = False
EndIf
EndIf
EndIf
If $g_iActivateKing = 1 Or $g_iActivateKing = 2 Then
If $g_bCheckKingPower Then
If $g_aHeroesTimerActivation[$eHeroBarbarianKing] <> 0 Then
$aDisplayTime[$eHeroBarbarianKing] = Ceiling(__TimerDiff($g_aHeroesTimerActivation[$eHeroBarbarianKing]) / 1000)
EndIf
If(Int($g_iDelayActivateKing) / 1000) <= $aDisplayTime[$eHeroBarbarianKing] Then
SetLog("Activating King's ability after " & $aDisplayTime[$eHeroBarbarianKing] & "'s", $COLOR_INFO)
SelectDropTroop($TempKingSlot, 2, Default, False)
$g_iCSVLastTroopPositionDropTroopFromINI = $g_iKingSlot
$g_bCheckKingPower = False
$g_aHeroesTimerActivation[$eHeroBarbarianKing] = 0
EndIf
EndIf
EndIf
If $g_bDebugSetlog Then
SetDebugLog("CheckHeroesHealth() for Warden started ")
If _Sleep($DELAYRESPOND) Then Return
EndIf
If $g_iActivateWarden = 0 Or $g_iActivateWarden = 2 And($g_aHeroesTimerActivation[$eHeroGrandWarden] = 0 Or __TimerDiff($g_aHeroesTimerActivation[$eHeroGrandWarden]) > $DELAYCHECKHEROESHEALTH) Then
If $g_bCheckWardenPower Then
Local $aWardenHealthCopy = $aWardenHealth
Local $aSlotPosition = GetSlotPosition($TempWardenSlot)
$aWardenHealthCopy[0] = $aSlotPosition[0] + $aWardenHealthCopy[4]
Local $WardenPixelColor = _GetPixelColor($aWardenHealthCopy[0], $aWardenHealthCopy[1], $g_bCapturePixel)
If $g_bDebugSetlog Then SetDebugLog(" Grand Warden _GetPixelColor(" & $aWardenHealthCopy[0] & "," & $aWardenHealthCopy[1] & "): " & $WardenPixelColor, $COLOR_DEBUG)
If Not _CheckPixel2($aWardenHealthCopy, $WardenPixelColor, "Red+Blue") Then
SetLog("Grand Warden is getting weak, Activating Warden's ability", $COLOR_INFO)
SelectDropTroop($TempWardenSlot, 2, Default, False)
$g_iCSVLastTroopPositionDropTroopFromINI = $g_iWardenSlot
$g_bCheckWardenPower = False
EndIf
EndIf
EndIf
If $g_iActivateWarden = 1 Or $g_iActivateWarden = 2 Then
If $g_bCheckWardenPower Then
If $g_aHeroesTimerActivation[$eHeroGrandWarden] <> 0 Then
$aDisplayTime[$eHeroGrandWarden] = Ceiling(__TimerDiff($g_aHeroesTimerActivation[$eHeroGrandWarden]) / 1000)
EndIf
If(Int($g_iDelayActivateWarden) / 1000) <= $aDisplayTime[$eHeroGrandWarden] Then
SetLog("Activating Warden's ability after " & $aDisplayTime[$eHeroGrandWarden] & "'s", $COLOR_INFO)
SelectDropTroop($TempWardenSlot, 2, Default, False)
$g_iCSVLastTroopPositionDropTroopFromINI = $g_iWardenSlot
$g_bCheckWardenPower = False
$g_aHeroesTimerActivation[$eHeroGrandWarden] = 0
EndIf
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
EndIf
EndFunc
Func dropCC($iX, $iY, $iCCSlot)
Local $test1 = False
Local $test2 = False
If $g_iMatchMode = $MA And $g_abAttackDropCC[$DB] Then $test1 = True
If $g_iMatchMode <> $MA Then
If($g_iMatchMode <> $DB And $g_iMatchMode <> $LB And $g_iMatchMode <> $MA) Or $g_abAttackDropCC[$g_iMatchMode] Then $test2 = True
EndIf
If $iCCSlot <> -1 And($test1 Or $test2) Then
If $g_bPlannedDropCCHoursEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abPlannedDropCCHours[$hour[0]] = False Then
SetLog("Drop CC not Planned, Skipped..", $COLOR_SUCCESS)
Return
EndIf
EndIf
If $g_bUseCCBalanced = True Then
If Number($g_iTroopsReceived) <> 0 Then
If Number(Number($g_iTroopsDonated) / Number($g_iTroopsReceived)) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
SetLog("Dropping Siege/Clan Castle, donated (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") >= " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
SelectDropTroop($iCCSlot)
If _Sleep($DELAYDROPCC1) Then Return
AttackClick($iX, $iY, 1, 0, 0, "#0087")
Else
SetLog("No Dropping Siege/Clan Castle, donated  (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") < " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
EndIf
Else
If Number(Number($g_iTroopsDonated) / 1) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
SetLog("Dropping Siege/Clan Castle, donated (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") >= " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
SelectDropTroop($iCCSlot)
If _Sleep($DELAYDROPCC1) Then Return
AttackClick($iX, $iY, 1, 0, 0, "#0089")
Else
SetLog("No Dropping Siege/Clan Castle, donated  (" & $g_iTroopsDonated & ") / received (" & $g_iTroopsReceived & ") < " & $g_iCCDonated & "/" & $g_iCCReceived, $COLOR_INFO)
EndIf
EndIf
Else
SetLog("Dropping Siege/Clan Castle", $COLOR_INFO)
SelectDropTroop($iCCSlot)
If _Sleep($DELAYDROPCC1) Then Return
AttackClick($iX, $iY, 1, 0, 0, "#0091")
EndIf
EndIf
EndFunc
Func dropHeroes($iX, $iY, $iKingSlotNumber = -1, $iQueenSlotNumber = -1, $iWardenSlotNumber = -1)
If $g_bDebugSetlog Then SetDebugLog("dropHeroes $iKingSlotNumber " & $iKingSlotNumber & " $iQueenSlotNumber " & $iQueenSlotNumber & " $iWardenSlotNumber " & $iWardenSlotNumber & " matchmode " & $g_iMatchMode, $COLOR_DEBUG)
If _Sleep($DELAYDROPHEROES1) Then Return
Local $bDropKing = False
Local $bDropQueen = False
Local $bDropWarden = False
Local $MatchMode
If $g_iMatchMode = $TS And $g_bDuringMilkingAttack = True Then
$MatchMode = $DB
Else
$MatchMode = $g_iMatchMode
EndIf
If $iKingSlotNumber <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroKing) = $eHeroKing) Then $bDropKing = True
If $iQueenSlotNumber <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroQueen) = $eHeroQueen) Then $bDropQueen = True
If $iWardenSlotNumber <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroWarden) = $eHeroWarden) Then $bDropWarden = True
If $g_bDebugSetlog Then SetDebugLog("drop KING = " & $bDropKing, $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("drop QUEEN = " & $bDropQueen, $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("drop WARDEN = " & $bDropWarden, $COLOR_DEBUG)
If $bDropKing Then
SetLog("Dropping King at " & $iX & ", " & $iY, $COLOR_INFO)
SelectDropTroop($iKingSlotNumber, 1, Default, False)
If _Sleep($DELAYDROPHEROES2) Then Return
AttackClick($iX, $iY, 1, 0, 0, "#0093")
If Not $g_bDropKing Then
$g_bCheckKingPower = True
Else
SetDebugLog("King dropped 2nd time, Check Power flag not changed")
EndIf
$g_bDropKing = True
$g_aHeroesTimerActivation[$eHeroBarbarianKing] = __TimerInit()
If _Sleep($DELAYDROPHEROES1) Then Return
EndIf
If _Sleep($DELAYDROPHEROES1) Then Return
If $bDropQueen Then
SetLog("Dropping Queen at " & $iX & ", " & $iY, $COLOR_INFO)
SelectDropTroop($iQueenSlotNumber, 1, Default, False)
If _Sleep($DELAYDROPHEROES2) Then Return
AttackClick($iX, $iY, 1, 0, 0, "#0095")
If Not $g_bDropQueen Then
$g_bCheckQueenPower = True
Else
SetDebugLog("Queen dropped 2nd time, Check Power flag not changed")
EndIf
$g_bDropQueen = True
$g_aHeroesTimerActivation[$eHeroArcherQueen] = __TimerInit()
If _Sleep($DELAYDROPHEROES1) Then Return
EndIf
If _Sleep($DELAYDROPHEROES1) Then Return
If $bDropWarden Then
SetLog("Dropping Grand Warden at " & $iX & ", " & $iY, $COLOR_INFO)
SelectDropTroop($iWardenSlotNumber, 1, Default, False)
If _Sleep($DELAYDROPHEROES2) Then Return
AttackClick($iX, $iY, 1, 0, 0, "#x999")
If Not $g_bDropWarden Then
$g_bCheckWardenPower = True
Else
SetDebugLog("Warden dropped 2nd time, Check Power flag not changed")
EndIf
$g_bDropWarden = True
$g_aHeroesTimerActivation[$eHeroGrandWarden] = __TimerInit()
If _Sleep($DELAYDROPHEROES1) Then Return
EndIf
EndFunc
Func DropOnEdge($troop, $edge, $number, $slotsPerEdge = 0, $edge2 = -1, $x = -1, $FourFingers = 0)
If isProblemAffect(True) Then Return
If $number = 0 Then Return
If _SleepAttack($DELAYDROPONEDGE1) Then Return
SelectDropTroop($troop)
If _SleepAttack($DELAYDROPONEDGE2) Then Return
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If $number = 1 Or $slotsPerEdge = 1 Then
If $edge2 = -1 Then
AttackClick($edge[2][0], $edge[2][1], $number, $DELAYDROPONEDGE1, $DELAYDROPONEDGE3, "#0102")
Else
AttackClick($edge[2][0], $edge[2][1], $number, $DELAYDROPONEDGE1, 0, "#0102")
AttackClick($edge2[2][0], $edge2[2][1], $number, $DELAYDROPONEDGE1, $DELAYDROPONEDGE3, "#0103")
EndIf
ElseIf $slotsPerEdge = 2 And $FourFingers = 0 Then
Local $half = Ceiling($number / 2)
AttackClick($edge[1][0], $edge[1][1], $half, SetSleep(0), 0, "#0104")
If $edge2 <> -1 Then
AttackClick($edge2[1][0], $edge2[1][1], $half, SetSleep(0), 0, "#0105")
EndIf
AttackClick($edge[3][0], $edge[3][1], $number - $half, SetSleep(0), 0, "#0106")
If $edge2 <> -1 Then
AttackClick($edge2[3][0], $edge2[3][1], $number - $half, SetSleep(0), 0, "#0107")
EndIf
Else
Local $minX = $edge[0][0]
Local $maxX = $edge[4][0]
Local $minY = $edge[0][1]
Local $maxY = $edge[4][1]
If $FourFingers = 5 Then
Local $minXTL = $g_aaiTopLeftDropPoints[0][0]
Local $maxXTL = $g_aaiTopLeftDropPoints[4][0]
Local $minYTL = $g_aaiTopLeftDropPoints[0][1]
Local $maxYTL = $g_aaiTopLeftDropPoints[4][1]
EndIf
If $edge2 <> -1 Then
Local $minX2 = $edge2[0][0]
Local $maxX2 = $edge2[4][0]
Local $minY2 = $edge2[0][1]
Local $maxY2 = $edge2[4][1]
If $FourFingers = 5 Then
Local $minX2TR = $g_aaiTopRightDropPoints[0][0]
Local $maxX2TR = $g_aaiTopRightDropPoints[4][0]
Local $minY2TR = $g_aaiTopRightDropPoints[0][1]
Local $maxY2TR = $g_aaiTopRightDropPoints[4][1]
EndIf
EndIf
Local $nbTroopsLeft = $number
For $i = 0 To $slotsPerEdge - 1
Local $nbtroopPerSlot = Round($nbTroopsLeft /($slotsPerEdge - $i))
If $FourFingers = 5 Then
Local $posX = $minX +(($maxX - $minX) *($slotsPerEdge - $i)) /($slotsPerEdge - 1)
Local $posY = $minY +(($maxY - $minY) *($slotsPerEdge - $i)) /($slotsPerEdge - 1)
AttackClick($posX, $posY, $nbtroopPerSlot, SetSleep(0), 0, "#0108")
Local $posX = $minXTL +(($maxXTL - $minXTL) * $i) /($slotsPerEdge - 1)
Local $posY = $minYTL +(($maxYTL - $minYTL) * $i) /($slotsPerEdge - 1)
Else
Local $posX = Round($minX +(($maxX - $minX) * $i) /($slotsPerEdge - 1))
Local $posY = Round($minY +(($maxY - $minY) * $i) /($slotsPerEdge - 1))
EndIf
AttackClick($posX, $posY, $nbtroopPerSlot, SetSleep(0), 0, "#0108")
If $edge2 <> -1 Then
If $FourFingers = 5 Then
Local $posX2 = $maxX2 -(($maxX2 - $minX2) *($slotsPerEdge - $i)) /($slotsPerEdge - 1)
Local $posY2 = $maxY2 -(($maxY2 - $minY2) *($slotsPerEdge - $i)) /($slotsPerEdge - 1)
AttackClick($posX2, $posY2, $nbtroopPerSlot, SetSleep(0), 0, "#0109")
Local $posX2 = $maxX2TR -(($maxX2TR - $minX2TR) * $i) /($slotsPerEdge - 1)
Local $posY2 = $maxY2TR -(($maxY2TR - $minY2TR) * $i) /($slotsPerEdge - 1)
Else
Local $posX2 = Round($maxX2 -(($maxX2 - $minX2) * $i) /($slotsPerEdge - 1))
Local $posY2 = Round($maxY2 -(($maxY2 - $minY2) * $i) /($slotsPerEdge - 1))
EndIf
AttackClick($posX2, $posY2, $nbtroopPerSlot, SetSleep(0), 0, "#0109")
EndIf
$nbTroopsLeft -= $nbtroopPerSlot
Next
EndIf
EndFunc
Func DropOnEdges($troop, $nbSides, $number, $slotsPerEdge = 0)
If $nbSides = 0 Or $number = 1 Then
OldDropTroop($troop, $g_aaiEdgeDropPoints[0], $number)
Return
EndIf
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
If $nbSides = 4 Then
For $i = 0 To $nbSides - 3
KeepClicks()
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
DropOnEdge($troop, $g_aaiEdgeDropPoints[$i], $nbTroopsPerEdge, $slotsPerEdge, $g_aaiEdgeDropPoints[$i + 2], $i)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
ReleaseClicks()
Next
Return
EndIf
If $nbSides = 5 Then
If $slotsPerEdge = 2 Then
For $i = 0 To $nbSides - 4
KeepClicks()
Local $nbTroopsPerEdge = Round($nbTroopsLeft /(($nbSides - 1) - $i * 2))
DropOnEdge($troop, $g_aaiEdgeDropPoints[$i], $nbTroopsPerEdge, $slotsPerEdge, $g_aaiEdgeDropPoints[$i + 2], $i)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
ReleaseClicks()
Next
Else
For $i = 0 To $nbSides - 5
KeepClicks()
Local $nbTroopsPerEdge = Round($nbTroopsLeft /(($nbSides - 1) - $i * 2))
DropOnEdge($troop, $g_aaiEdgeDropPoints[$i], $nbTroopsPerEdge, $slotsPerEdge, $g_aaiEdgeDropPoints[$i + 2], $i, $nbSides)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
ReleaseClicks()
Next
EndIf
Return
EndIf
For $i = 0 To $nbSides - 1
KeepClicks()
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i))
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] >= 5 Then
DropOnEdge($troop, $g_aaiEdgeDropPoints[$g_iBuildingEdge], $nbTroopsPerEdge, $slotsPerEdge)
Else
DropOnEdge($troop, $g_aaiEdgeDropPoints[$i], $nbTroopsPerEdge, $slotsPerEdge)
EndIf
$nbTroopsLeft -= $nbTroopsPerEdge
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
DropOnEdge($troop, $g_aaiEdgeDropPoints[$i + 3], $nbTroopsPerEdge, $slotsPerEdge, $g_aaiEdgeDropPoints[$i + 1])
$nbTroopsLeft -= $nbTroopsPerEdge * 2
EndIf
ReleaseClicks()
Next
EndFunc
Func MatchTroopDropName($Num)
Switch _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$Num])
Case 0
Return $eBarb
Case 1
Return $eArch
Case 2
Return $eGiant
Case 3
Return $eGobl
Case 4
Return $eWall
Case 5
Return $eBall
Case 6
Return $eWiza
Case 7
Return $eHeal
Case 8
Return $eDrag
Case 9
Return $ePekk
Case 10
Return $eBabyD
Case 11
Return $eMine
Case 12
Return $eEDrag
Case 13
Return $eMini
Case 14
Return $eHogs
Case 15
Return $eValk
Case 16
Return $eGole
Case 17
Return $eWitc
Case 18
Return $eLava
Case 19
Return $eBowl
Case 20
Return $eIceG
Case 21
Return "CC"
Case 22
Return "HEROES"
EndSwitch
EndFunc
Func MatchSlotsPerEdge($Num)
Switch _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$Num])
Case 0
Return 0
Case 1
Return 0
Case 2
Return $g_iSlotsGiants
Case 3
Return 0
Case 4
Return 1
Case 5
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 6 Then
Return 0
Else
Return 2
EndIf
Case 6
Return 0
Case 7
Return 1
Case 8
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 6 Then
Return 0
Else
Return 2
EndIf
Case 9
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 6 Then
Return 1
Else
Return 2
EndIf
Case 10
Return 1
Case 11
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 6 Then
Return 0
Else
Return 1
EndIf
Case 12
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 6 Then
Return 0
Else
Return 2
EndIf
Case 13
Return 0
Case 14
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 6 Then
Return 1
Else
Return 2
EndIf
Case 15
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 6 Then
Return 0
Else
Return 2
EndIf
Case 16
Return 2
Case 17
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 6 Then
Return 1
Else
Return 2
EndIf
Case 18
Return 2
Case 19
Return 0
Case 20
Return 2
Case 21
Return 1
Case 22
Return 1
EndSwitch
EndFunc
Func MatchSidesDrop($Num)
Switch _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$Num])
Case 0 To 20
If $g_aiAttackStdDropSides[$g_iMatchMode] = 0 Then Return 1
If $g_aiAttackStdDropSides[$g_iMatchMode] = 1 Then Return 2
If $g_aiAttackStdDropSides[$g_iMatchMode] = 2 Then Return 3
If $g_aiAttackStdDropSides[$g_iMatchMode] = 3 Then Return 4
If $g_aiAttackStdDropSides[$g_iMatchMode] = 4 Then Return 4
If $g_aiAttackStdDropSides[$g_iMatchMode] = 5 Then Return 1
If $g_aiAttackStdDropSides[$g_iMatchMode] = 6 Then Return 1
Case 21
Return 1
Case 22
Return 1
EndSwitch
EndFunc
Func MatchTroopWaveNb($Num)
Return 1
EndFunc
Func GetSlotIndexFromXPos($xPos)
For $slot = 0 To 11
If $xPos < 68 +($slot * 72) Then
Return $slot
EndIf
Next
EndFunc
Func LaunchTroop($troopKind, $nbSides, $waveNb, $maxWaveNb, $slotsPerEdge = 0)
Local $troop = -1
Local $troopNb = 0
Local $name = ""
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $troopKind Then
If $g_avAttackTroops[$i][1] < 1 Then Return False
$troop = $i
$troopNb = Ceiling($g_avAttackTroops[$i][1] / $maxWaveNb)
$name = GetTroopName($troopKind, $troopNb)
EndIf
Next
If $g_bDebugSetlog Then SetDebugLog("Dropping : " & $troopNb & " " & $name, $COLOR_DEBUG)
If $troop = -1 Or $troopNb = 0 Then
Return False
EndIf
Local $waveName = "first"
If $waveNb = 2 Then $waveName = "second"
If $waveNb = 3 Then $waveName = "third"
If $maxWaveNb = 1 Then $waveName = "only"
If $waveNb = 0 Then $waveName = "last"
SetLog("Dropping " & $waveName & " wave of " & $troopNb & " " & $name, $COLOR_SUCCESS)
DropTroop($troop, $nbSides, $troopNb, $slotsPerEdge)
Return True
EndFunc
Func LaunchTroop2($listInfoDeploy, $iCC, $iKing, $iQueen, $iWarden)
If $g_bDebugSetlog Then SetDebugLog("LaunchTroop2 with CC " & $iCC & ", K " & $iKing & ", Q " & $iQueen & ", W " & $iWarden, $COLOR_DEBUG)
Local $listListInfoDeployTroopPixel[0]
Local $pixelRandomDrop[2]
Local $pixelRandomDropcc[2]
If($g_abAttackStdSmartAttack[$g_iMatchMode]) And($g_aiAttackStdDropSides[$g_iMatchMode] <> 4) Then
For $i = 0 To UBound($listInfoDeploy) - 1
Local $iFoundTroopAt = -1, $iTroopAmount = 0, $sTroopName
Local $vTroopIndex = $listInfoDeploy[$i][0]
Local $iNumberSides = $listInfoDeploy[$i][1]
Local $iNumberWaves = $listInfoDeploy[$i][2]
Local $iMaxNumberWaves = $listInfoDeploy[$i][3]
Local $iSlotsPerEdge = $listInfoDeploy[$i][4]
If $g_bDebugSetlog Then SetDebugLog("**ListInfoDeploy row " & $i & ": Use: " & $vTroopIndex & "|Sides: " & $iNumberSides & "|Wave: " & $iNumberWaves & "|Max Wavess: " & $iMaxNumberWaves & "|Slots per Edge " & $iSlotsPerEdge, $COLOR_DEBUG)
If IsNumber($vTroopIndex) Then
$iFoundTroopAt = _ArraySearch($g_avAttackTroops, $vTroopIndex, 0, 0, 0, 0, 1, 0)
If $iFoundTroopAt <> -1 Then
$iTroopAmount = Ceiling($g_avAttackTroops[$iFoundTroopAt][1] / $iMaxNumberWaves)
$sTroopName = GetTroopName($vTroopIndex, $iTroopAmount)
EndIf
EndIf
If($iFoundTroopAt <> -1 And $iTroopAmount > 0) Or IsString($vTroopIndex) Then
Local $listInfoDeployTroopPixel
If(UBound($listListInfoDeployTroopPixel) < $iNumberWaves) Then
ReDim $listListInfoDeployTroopPixel[$iNumberWaves]
Local $newListInfoDeployTroopPixel[0]
$listListInfoDeployTroopPixel[$iNumberWaves - 1] = $newListInfoDeployTroopPixel
EndIf
$listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$iNumberWaves - 1]
ReDim $listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) + 1]
If(IsString($vTroopIndex)) Then
Local $arrCCorHeroes[1] = [$vTroopIndex]
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $arrCCorHeroes
Else
Local $infoDropTroop = DropTroop2($iFoundTroopAt, $iNumberSides, $iTroopAmount, $iSlotsPerEdge, $sTroopName)
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $infoDropTroop
EndIf
$listListInfoDeployTroopPixel[$iNumberWaves - 1] = $listInfoDeployTroopPixel
EndIf
Next
If(($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] Or $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] Or $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2]) And UBound($g_aiPixelNearCollector) = 0) Then
SetLog("Error, no pixel found near collector => Normal attack near red line")
EndIf
If($g_aiAttackStdSmartDeploy[$g_iMatchMode] = 0) Then
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If(IsString($infoPixelDropTroop[0]) And($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
If $g_aiDeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $g_aiDeployHeroesPosition[0]
$pixelRandomDrop[1] = $g_aiDeployHeroesPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aiDeployHeroesPosition")
Else
$pixelRandomDrop[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDrop[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aaiBottomRightDropPoints")
EndIf
If $g_aiDeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $g_aiDeployCCPosition[0]
$pixelRandomDropcc[1] = $g_aiDeployCCPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aiDeployHeroesPosition")
Else
$pixelRandomDropcc[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDropcc[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aaiBottomRightDropPoints")
EndIf
If($infoPixelDropTroop[0] = "CC") Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $iCC)
$g_bIsCCDropped = True
ElseIf($infoPixelDropTroop[0] = "HEROES") Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $iKing, $iQueen, $iWarden)
$g_bIsHeroesDropped = True
EndIf
Else
If _Sleep($DELAYLAUNCHTROOP21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($DELAYLAUNCHTROOP21) Then Return
Local $waveName = "first"
If $numWave + 1 = 2 Then $waveName = "second"
If $numWave + 1 = 3 Then $waveName = "third"
If $numWave + 1 = 0 Then $waveName = "last"
SetLog("Dropping " & $waveName & " wave of " & $infoPixelDropTroop[5] & " " & $infoPixelDropTroop[4], $COLOR_SUCCESS)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], $infoPixelDropTroop[2], $infoPixelDropTroop[3])
EndIf
If($g_bIsHeroesDropped) Then
If _Sleep($DELAYLAUNCHTROOP22) Then Return
CheckHeroesHealth()
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
Next
Else
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
If(UBound($listInfoDeployTroopPixel) > 0) Then
Local $infoTroopListArrPixel = $listInfoDeployTroopPixel[0]
Local $numberSidesDropTroop = 1
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$i]
If(UBound($infoTroopListArrPixel) > 1) Then
Local $infoListArrPixel = $infoTroopListArrPixel[1]
$numberSidesDropTroop = UBound($infoListArrPixel)
ExitLoop
EndIf
Next
If($numberSidesDropTroop > 0) Then
For $i = 0 To $numberSidesDropTroop - 1
For $j = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$j]
If(IsString($infoTroopListArrPixel[0]) And($infoTroopListArrPixel[0] = "CC" Or $infoTroopListArrPixel[0] = "HEROES")) Then
If $g_aiDeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $g_aiDeployHeroesPosition[0]
$pixelRandomDrop[1] = $g_aiDeployHeroesPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aiDeployHeroesPosition")
Else
$pixelRandomDrop[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDrop[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy Heroes $g_aaiBottomRightDropPoints")
EndIf
If $g_aiDeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $g_aiDeployCCPosition[0]
$pixelRandomDropcc[1] = $g_aiDeployCCPosition[1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aiDeployHeroesPosition")
Else
$pixelRandomDropcc[0] = $g_aaiBottomRightDropPoints[2][0]
$pixelRandomDropcc[1] = $g_aaiBottomRightDropPoints[2][1]
If $g_bDebugSetlog Then SetDebugLog("Deploy CC $g_aaiBottomRightDropPoints")
EndIf
If($g_bIsCCDropped = False And $infoTroopListArrPixel[0] = "CC") Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $iCC)
$g_bIsCCDropped = True
ElseIf($g_bIsHeroesDropped = False And $infoTroopListArrPixel[0] = "HEROES" And $i = $numberSidesDropTroop - 1) Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $iKing, $iQueen, $iWarden)
$g_bIsHeroesDropped = True
EndIf
Else
$infoListArrPixel = $infoTroopListArrPixel[1]
Local $listPixel = $infoListArrPixel[$i]
If _Sleep($DELAYLAUNCHTROOP21) Then Return
SelectDropTroop($infoTroopListArrPixel[0])
If _Sleep($DELAYLAUNCHTROOP23) Then Return
SetLog("Dropping " & $infoTroopListArrPixel[2] & " of " & $infoTroopListArrPixel[5] & " Points Per Side: " & $infoTroopListArrPixel[3] & " (side " & $i + 1 & ")", $COLOR_SUCCESS)
Local $pixelDropTroop[1] = [$listPixel]
DropOnPixel($infoTroopListArrPixel[0], $pixelDropTroop, $infoTroopListArrPixel[2], $infoTroopListArrPixel[3])
EndIf
If($g_bIsHeroesDropped) Then
If _sleep(1000) Then Return
CheckHeroesHealth()
EndIf
Next
Next
EndIf
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
EndIf
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If Not(IsString($infoPixelDropTroop[0]) And($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
Local $numberLeft = ReadTroopQuantity($infoPixelDropTroop[0])
If($numberLeft > 0) Then
If _Sleep($DELAYLAUNCHTROOP21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($DELAYLAUNCHTROOP23) Then Return
SetLog("Dropping last " & $numberLeft & " of " & $infoPixelDropTroop[5], $COLOR_SUCCESS)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], Ceiling($numberLeft / UBound($infoPixelDropTroop[1])), $infoPixelDropTroop[3])
EndIf
EndIf
If _Sleep(SetSleep(0)) Then Return
Next
If _Sleep(SetSleep(1)) Then Return
Next
Else
For $i = 0 To UBound($listInfoDeploy) - 1
If(IsString($listInfoDeploy[$i][0]) And($listInfoDeploy[$i][0] = "CC" Or $listInfoDeploy[$i][0] = "HEROES")) Then
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] >= 5 Then
Local $RandomEdge = $g_aaiEdgeDropPoints[$g_iBuildingEdge]
Local $RandomXY = 2
Else
Local $RandomEdge = $g_aaiEdgeDropPoints[Round(Random(0, 3))]
Local $RandomXY = Round(Random(1, 3))
EndIf
If($listInfoDeploy[$i][0] = "CC") Then
dropCC($RandomEdge[$RandomXY][0], $RandomEdge[$RandomXY][1], $iCC)
ElseIf($listInfoDeploy[$i][0] = "HEROES") Then
dropHeroes($RandomEdge[$RandomXY][0], $RandomEdge[$RandomXY][1], $iKing, $iQueen, $iWarden)
EndIf
Else
If $g_bDuringMilkingAttack = False Then
If LaunchTroop($listInfoDeploy[$i][0], $listInfoDeploy[$i][1], $listInfoDeploy[$i][2], $listInfoDeploy[$i][3], $listInfoDeploy[$i][4]) Then
If _Sleep(SetSleep(1)) Then Return
EndIf
Else
If $listInfoDeploy[$i][0] <> $eGobl Then
If LaunchTroop($listInfoDeploy[$i][0], $listInfoDeploy[$i][1], $listInfoDeploy[$i][2], $listInfoDeploy[$i][3], $listInfoDeploy[$i][4]) Then
If _Sleep(SetSleep(1)) Then Return
EndIf
EndIf
EndIf
EndIf
Next
EndIf
Return True
EndFunc
Func OldDropTroop($troop, $position, $nbperspot)
SelectDropTroop($troop)
If _Sleep($DELAYOLDDROPTROOP1) Then Return
For $i = 0 To 4
Click($position[$i][0], $position[$i][1], $nbperspot, 1, "#0110")
If _Sleep($DELAYOLDDROPTROOP2) Then Return
Next
EndFunc
Func ReadTroopQuantity($iSlotNumber, $bCheckSelectedSlot = False, $bNeedNewCapture = True)
Local $iAmount, $aSlotPosition = GetSlotPosition($iSlotNumber)
Switch $bCheckSelectedSlot
Case False
$iAmount = getTroopCountSmall($aSlotPosition[0], $aSlotPosition[1])
If $iAmount = "" Then
$iAmount = getTroopCountBig($aSlotPosition[0], $aSlotPosition[1] - 3)
EndIf
Case Else
Local $isTheSlotSelected = IsSlotSelected($iSlotNumber, $bNeedNewCapture)
If Not $isTheSlotSelected Then
$iAmount = Number(getTroopCountSmall($aSlotPosition[0], $aSlotPosition[1]))
Else
$iAmount = Number(getTroopCountBig($aSlotPosition[0], $aSlotPosition[1] - 3))
EndIf
EndSwitch
Return Number($iAmount)
EndFunc
Func UpdateTroopQuantity($sTroopName, $bNeedNewCapture = Default)
If Not $bNeedNewCapture Then $bNeedNewCapture = True
If $bNeedNewCapture Then
_CaptureRegion2()
EndIf
Local $iTroopIndex = TroopIndexLookup($sTroopName)
If $iTroopIndex = -1 Then
SetLog("'UpdateTroopQuantity' troop name '" & $sTroopName & "' is unrecognized.")
Return
EndIf
Local $iFoundAt = _ArraySearch($g_avAttackTroops, $iTroopIndex)
If $iFoundAt = -1 Then
SetLog("Couldn't find '" & $sTroopName & "' in $g_avAttackTroops", $COLOR_ERROR)
EndIf
If Not $g_bRunState Then Return
Local $iQuantity = ReadTroopQuantity($iFoundAt, True, Not $bNeedNewCapture)
$g_avAttackTroops[$iFoundAt][1] = $iQuantity
Return $iFoundAt
EndFunc
Func IsSlotSelected($iSlotIndex, $bNeedNewCapture = Default)
If Not $bNeedNewCapture Then $bNeedNewCapture = True
If $bNeedNewCapture Then
ForceCaptureRegion()
_CaptureRegion()
EndIf
Local $iOffset = 73
Local $iStartX = 75
Local $iY = 724
If $bNeedNewCapture Then
Return _ColorCheck(  _GetPixelColor($iStartX +($iOffset * $iSlotIndex), $iY, False), Hex(0xFFFFFF, 6), 20)
Else
Return _ColorCheck( Hex(_GDIPlus_BitmapGetPixel(_GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2),($iStartX +($iOffset * $iSlotIndex)), $iY), 6), Hex(0xFFFFFF, 6), 20)
EndIf
EndFunc
Func SelectDropTroop($iSlotIndex, $iClicks = 1, $iDelay = Default, $bCheckAttackPage = Default)
If $iDelay = Default Then $iDelay = 0
If $bCheckAttackPage = Default Then $bCheckAttackPage = True
If Not $bCheckAttackPage Or IsAttackPage() Then ClickP(GetSlotPosition($iSlotIndex), $iClicks, $iDelay, "#0111")
EndFunc
Func GetSlotPosition($iSlotIndex, $bOCRPosition = False)
Local $aiReturnPosition[2] = [0, 0]
If $iSlotIndex < 0 Or $iSlotIndex > UBound($g_avAttackTroops, 1) - 1 Then
SetDebugLog("GetSlotPosition(" & $iSlotIndex & ", " & $bOCRPosition & "): Invalid slot index: " & $iSlotIndex)
Return $aiReturnPosition
EndIf
If Not $bOCRPosition Then
$aiReturnPosition[0] = $g_avAttackTroops[$iSlotIndex][2]
$aiReturnPosition[1] = $g_avAttackTroops[$iSlotIndex][3]
Else
$aiReturnPosition[0] = $g_avAttackTroops[$iSlotIndex][4]
$aiReturnPosition[1] = $g_avAttackTroops[$iSlotIndex][5]
EndIf
Return $aiReturnPosition
EndFunc
Func SetSleep($type)
If IsKeepClicksActive() = True Then Return 0
Local $factor0 = 10
Local $factor1 = 100
If $g_bAndroidAdbClick = True Then
$factor0 = 10
$factor1 = 100
EndIf
Switch $type
Case 0
If $g_abAttackStdRandomizeDelay[$g_iMatchMode] Then
Return Round(Random(1, 10)) * $factor0
Else
Return($g_aiAttackStdUnitDelay[$g_iMatchMode] + 1) * $factor0
EndIf
Case 1
If $g_abAttackStdRandomizeDelay[$g_iMatchMode] Then
Return Round(Random(1, 10)) * $factor1
Else
Return($g_aiAttackStdWaveDelay[$g_iMatchMode] + 1) * $factor1
EndIf
EndSwitch
EndFunc
Func _SleepAttack($iDelay, $iSleep = True)
If $g_bRunState = False Then
ResumeAndroid()
Return True
EndIf
If IsKeepClicksActive() = True Then Return False
Return _Sleep($iDelay, $iSleep)
EndFunc
Func drillSearch()
Local $aReturnResult[0][5]
Local $pixelerror = 15
Local $Maxpositions = 0
Local $aResult = multiMatches($g_sImgSearchDrill, $Maxpositions, "ECD", "ECD")
For $iResult = 1 To UBound($aResult) - 1
If _Sleep(10) Then Return
Local $aTemp[0][2]
_ArrayAdd($aTemp, $aResult[$iResult][5], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
_ArrayColInsert($aTemp, 2)
_ArrayColInsert($aTemp, 3)
_ArrayColInsert($aTemp, 4)
For $iRow = 0 To UBound($aTemp) - 1
$aTemp[$iRow][2] = $aResult[$iResult][2]
$aTemp[$iRow][4] = 0
Next
_ArrayAdd($aReturnResult, $aTemp, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
Next
Local $iResult = 0
While $iResult < UBound($aReturnResult)
If _Sleep(10) Then Return
Local $jResult = $iResult + 1
While $jResult < UBound($aReturnResult)
If Abs($aReturnResult[$iResult][0] - $aReturnResult[$jResult][0]) <= $pixelerror And Abs($aReturnResult[$iResult][1] - $aReturnResult[$jResult][1]) <= $pixelerror Then
$aReturnResult[$iResult][2] = _Min(Number($aReturnResult[$iResult][2]), Number($aReturnResult[$jResult][2]))
If $g_bDebugSmartZap = True Then
SetLog("Found Duplicate Dark Elixir Drill: [" & $aReturnResult[$jResult][0] & "," & $aReturnResult[$jResult][1] & "], Level: " & $aReturnResult[$jResult][2], $COLOR_DEBUG)
EndIf
_ArrayDelete($aReturnResult, $jResult)
Else
$jResult += 1
EndIf
WEnd
Local $iDrillLevel = CheckDrillLvl($aReturnResult[$iResult][0], $aReturnResult[$iResult][1])
If $iDrillLevel > 0 And $aReturnResult[$iResult][2] <> $iDrillLevel Then
If $g_bDebugSmartZap = True Then SetLog("Correcting Drill Level, old = " & $aReturnResult[$iResult][2] & ", new = " & $iDrillLevel, $COLOR_DEBUG)
$aReturnResult[$iResult][2] = $iDrillLevel
EndIf
$aReturnResult[$iResult][3] = Ceiling(Number($g_aDrillLevelTotal[$aReturnResult[$iResult][2] - 1] * $g_fDarkStealFactor))
If $g_bDebugSmartZap = True Then
SetLog(($iResult + 1) & ". Valid Drill: [" & $aReturnResult[$iResult][0] & "," & $aReturnResult[$iResult][1] & "], Level: " & $aReturnResult[$iResult][2] & ", Hold: " & $aReturnResult[$iResult][3], $COLOR_DEBUG)
EndIf
$iResult += 1
WEnd
Return $aReturnResult
EndFunc
Func CheckDrillLvl($x, $y)
_CaptureRegion2($x - 25, $y - 25, $x + 25, $y + 25)
Local $aResult = multiMatches($g_sImgSearchDrillLevel, 1, "FV", "FV", "", 0, 1000, False)
If $g_bDebugSmartZap = True Then SetLog("CheckDrillLvl: UBound($aresult) = " & UBound($aResult), $COLOR_DEBUG)
If UBound($aResult) > 1 Then
If $g_bDebugSmartZap = True Then SetLog("CheckDrillLvl: $aresult[" &(UBound($aResult) - 1) & "][2] = " & $aResult[UBound($aResult) - 1][2], $COLOR_DEBUG)
Return $aResult[UBound($aResult) - 1][2]
EndIf
Return 0
EndFunc
Func getDrillCluster(Const ByRef $aDarkDrills)
Local $iMaxMedianDist = 26
Local $aBestCluster[4] = [0, 0, 0, -1]
If UBound($aDarkDrills) < 2 Then Return -1
If UBound($aDarkDrills) > 2 Then
Local $iMedianX = Ceiling(Number(($aDarkDrills[0][0] + $aDarkDrills[1][0] + $aDarkDrills[2][0]) / 3))
Local $iMedianY = Ceiling(Number(($aDarkDrills[0][1] + $aDarkDrills[1][1] + $aDarkDrills[2][1]) / 3))
If $g_bDebugSmartZap = True Then SetLog("TripleDrill Unweighted Median Point: x = " & $iMedianX & ", y = " & $iMedianY, $COLOR_DEBUG)
For $i = 0 To 2
If Abs($aDarkDrills[$i][0] - $iMedianX) > $iMaxMedianDist Or Abs($aDarkDrills[$i][1] - $iMedianY) > $iMaxMedianDist Then
$aBestCluster[3] = -1
ExitLoop
Else
Local $aTemp[3] = [0, 1, 2]
$aBestCluster[3] = $aTemp
EndIf
Next
If $g_bDebugSmartZap = True And $aBestCluster[3] <> -1 Then SetLog("TripleDrill Cluster found." & $aBestCluster[3], $COLOR_DEBUG)
EndIf
If $aBestCluster[3] = -1 Then
Local $iMaxHold = 0
For $i = 0 To UBound($aDarkDrills) - 1
Local $iMedianX = Ceiling(Number(($aDarkDrills[$i][0] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][0]) / 2))
Local $iMedianY = Ceiling(Number(($aDarkDrills[$i][1] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][1]) / 2))
If $g_bDebugSmartZap = True Then SetLog("[" & $i & "," & Mod($i + 1, UBound($aDarkDrills)) & "] DoubleDrill Unweighted Median Point: x = " & $iMedianX & ", y = " & $iMedianY, $COLOR_DEBUG)
If $aDarkDrills[$i][3] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][3] > $iMaxHold Then
If Abs($aDarkDrills[$i][0] - $iMedianX) <= $iMaxMedianDist And Abs($aDarkDrills[$i][1] - $iMedianY) <= $iMaxMedianDist And Abs($aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][0] - $iMedianX) <= $iMaxMedianDist And Abs($aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][1] - $iMedianY) <= $iMaxMedianDist Then
$iMaxHold = $aDarkDrills[$i][3] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][3]
Local $aTemp[2] = [$i, Mod($i + 1, UBound($aDarkDrills))]
$aBestCluster[3] = $aTemp
EndIf
EndIf
Next
If $g_bDebugSmartZap = True And $aBestCluster[3] <> -1 Then SetLog("DoubleDrill Cluster found: [" &($aBestCluster[3])[0] & "," &($aBestCluster[3])[1] & "]", $COLOR_DEBUG)
EndIf
If $aBestCluster[3] = -1 Then
Return -1
Else
Local $iWeightedMedianX = 0
Local $iWeightedMedianY = 0
Local $iWeightedMedianDiv = 0
Local $iTotalHold = 0
For $i = 0 To UBound($aBestCluster[3]) - 1
$iWeightedMedianX += $aDarkDrills[($aBestCluster[3])[$i]][0] * $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iWeightedMedianY += $aDarkDrills[($aBestCluster[3])[$i]][1] * $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iWeightedMedianDiv += $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iTotalHold += $aDarkDrills[($aBestCluster[3])[$i]][3]
Next
$aBestCluster[0] = Ceiling(Number($iWeightedMedianX / $iWeightedMedianDiv))
$aBestCluster[1] = Ceiling(Number($iWeightedMedianY / $iWeightedMedianDiv))
$aBestCluster[2] = $iTotalHold
If $g_bDebugSmartZap = True Then SetLog("Best Cluster: weighted x = " & $aBestCluster[0] & ", weighted y = " & $aBestCluster[1] & ", hold = " & $aBestCluster[2], $COLOR_DEBUG)
Return $aBestCluster
EndIf
EndFunc
Func easyPreySearch()
Local $aReturnResult[0][3]
Local $pixelerror = 10, $iMaxCombDist = 60
For $iLoop = 1 To 3
If $iLoop > 1 Then
If _Sleep(5000) Then Return
EndIf
Local $aResult = multiMatches($g_sImgEasyBuildings, 0, "ECD", "ECD")
If $g_bDebugSmartZap = True Then
If UBound($aResult) = 2 Then
SetLog("1 target type found in " & $iLoop & ". searchround.", $COLOR_DEBUG)
Else
SetLog(UBound($aResult) - 1 & " target types found in " & $iLoop & ". searchround.", $COLOR_DEBUG)
EndIf
EndIf
For $iResult = 1 To UBound($aResult) - 1
If _Sleep(10) Then Return
Local $aTemp[0][2]
_ArrayAdd($aTemp, $aResult[$iResult][5], 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
_ArrayColInsert($aTemp, 2)
For $iRow = 0 To UBound($aTemp) - 1
$aTemp[$iRow][2] = 1
Next
_ArrayAdd($aReturnResult, $aTemp, 0, "|", @CRLF, $ARRAYFILL_FORCE_STRING)
Next
Next
Local $iResult = 0
While $iResult < UBound($aReturnResult)
If _Sleep(10) Then Return
Local $jResult = $iResult + 1
While $jResult < UBound($aReturnResult)
If Abs($aReturnResult[$iResult][0] - $aReturnResult[$jResult][0]) <= $pixelerror And Abs($aReturnResult[$iResult][1] - $aReturnResult[$jResult][1]) <= $pixelerror Then
If $g_bDebugSmartZap = True Then
SetLog("Found Duplicate Target: [" & $aReturnResult[$jResult][0] & "," & $aReturnResult[$jResult][1] & "]", $COLOR_DEBUG)
EndIf
_ArrayDelete($aReturnResult, $jResult)
Else
$jResult += 1
EndIf
WEnd
$iResult += 1
WEnd
Local $iResult = 0
While $iResult < UBound($aReturnResult)
If _Sleep(10) Then Return
Local $jResult = $iResult + 1
While $jResult < UBound($aReturnResult)
If Abs($aReturnResult[$iResult][0] - $aReturnResult[$jResult][0]) + Abs($aReturnResult[$iResult][1] - $aReturnResult[$jResult][1]) <= $iMaxCombDist Then
If $g_bDebugSmartZap = True Then
SetLog("Found Targets for consolidation: [" & $aReturnResult[$iResult][0] & "," & $aReturnResult[$iResult][1] & "," & $aReturnResult[$iResult][2] & "] & [" & $aReturnResult[$jResult][0] & "," & $aReturnResult[$jResult][1] & "," & $aReturnResult[$jResult][2] & "]", $COLOR_DEBUG)
EndIf
Local $iNewWeight = $aReturnResult[$iResult][2] + $aReturnResult[$jResult][2]
$aReturnResult[$iResult][0] = Ceiling(Number(($aReturnResult[$iResult][0] * $aReturnResult[$iResult][2] + $aReturnResult[$jResult][0] * $aReturnResult[$jResult][2]) / $iNewWeight))
$aReturnResult[$iResult][1] = Ceiling(Number(($aReturnResult[$iResult][1] * $aReturnResult[$iResult][2] + $aReturnResult[$jResult][1] * $aReturnResult[$jResult][2]) / $iNewWeight))
$aReturnResult[$iResult][2] = $iNewWeight
_ArrayDelete($aReturnResult, $jResult)
ContinueLoop 2
EndIf
$jResult += 1
WEnd
$iResult += 1
WEnd
If UBound($aReturnResult) > 1 Then _ArraySort($aReturnResult, 1, 0, 0, 2)
Return $aReturnResult
EndFunc
Func displayZapLog(Const ByRef $aDarkDrills, Const ByRef $Spells)
Local $drillStealableString = "Drills Lvl/Estimated Amount left: "
Local $spellsLeftString = "Spells left: "
For $i = 0 To UBound($aDarkDrills) - 1
If $i = 0 Then
If $aDarkDrills[$i][3] <> -1 Then $drillStealableString &= "Lvl" & $aDarkDrills[$i][2] & "/" & $aDarkDrills[$i][3]
Else
If $aDarkDrills[$i][3] <> -1 Then $drillStealableString &= ", Lvl" & $aDarkDrills[$i][2] & "/" & $aDarkDrills[$i][3]
EndIf
Next
If $Spells[0][4] + $Spells[1][4] + $Spells[2][4] = 0 Then
$spellsLeftString &= "None"
Else
If $Spells[2][4] > 0 Then $spellsLeftString &= $Spells[2][4] & " " & GetTroopName($Spells[2][1], 2)
If $Spells[2][4] > 0 And $Spells[0][4] + $Spells[1][4] > 0 Then $spellsLeftString &= ", "
If $Spells[0][4] + $Spells[1][4] > 0 Then $spellsLeftString &= $Spells[0][4] + $Spells[1][4] & " " & GetTroopName($Spells[1][1], 2)
EndIf
If $drillStealableString <> "Drills Lvl/Estimated Amount left: " Then
If Not $g_bNoobZap Then
SetLog($drillStealableString, $COLOR_INFO)
Else
If $g_bDebugSmartZap = True Then SetLog($drillStealableString, $COLOR_DEBUG)
EndIf
EndIf
If $spellsLeftString <> "Spells left: " Then
SetLog($spellsLeftString, $COLOR_INFO)
EndIf
EndFunc
Func getDarkElixir()
Local $g_iSearchDark = "", $iCount = 0
If _CheckPixel($aAtkHasDarkElixir, $g_bCapturePixel, Default, "HasDarkElixir") Or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
While $g_iSearchDark = ""
$g_iSearchDark = getDarkElixirVillageSearch(48, 126)
$iCount += 1
If $iCount > 15 Then ExitLoop
If _Sleep($DELAYSMARTZAP1) Then Return
WEnd
Else
$g_iSearchDark = False
If $g_bDebugSmartZap = True Then SetLog(" - No DE detected.", $COLOR_DEBUG)
EndIf
Return $g_iSearchDark
EndFunc
Func getDrillOffset()
Local $result = -1
Switch $g_iTownHallLevel
Case 0 To 7
$result = 2
Case 8
$result = 1
Case Else
$result = 0
EndSwitch
Return $result
EndFunc
Func getSpellOffset()
Local $result = -1
Switch $g_iTownHallLevel
Case 0 To 4
$result = -1
Case 5, 6
$result = -1
Case 7, 8
$result = 2
Case 9
$result = 1
Case Else
$result = 0
EndSwitch
Return $result
EndFunc
Func smartZap($minDE = -1)
Local $strikeOffsets = [0, 14]
Local $drillLvlOffset, $spellAdjust, $numDrills, $testX, $testY, $tempTestX, $tempTestY, $strikeGain, $expectedDE
Local $g_iSearchDark, $oldSearchDark = 0, $performedZap = False, $dropPoint
Local $aSpells[3][5] = [["Own", $eLSpell, -1, -1, 0] , ["Donated", $eLSpell, -1, -1, 0] , ["Donated", $eESpell, -1, -1, 0]]
Local $bZapDrills = True
If $g_bDebugSmartZap = True Then SetLog("$g_bSmartZapEnable = " & $g_bSmartZapEnable & " | $g_bNoobZap = " & $g_bNoobZap, $COLOR_DEBUG)
If $g_bSmartZapEnable = False Then Return $performedZap
If $bZapDrills Then
If $g_bSmartZapEnable = True And $g_bNoobZap = False Then
SetLog("====== You have activated SmartZap Mode ======", $COLOR_ERROR)
ElseIf $g_bNoobZap = True Then
SetLog("====== You have activated NoobZap Mode ======", $COLOR_ERROR)
EndIf
EndIf
If $minDE = -1 Then $minDE = Number($g_iSmartZapMinDE)
If $bZapDrills Then
$g_iSearchDark = getDarkElixirVillageSearch(48, 126)
If Number($g_iSearchDark) = 0 Then
SetLog("No Dark Elixir!", $COLOR_INFO)
If $g_bDebugSmartZap = True Then SetLog("$g_iSearchDark|Current DE value: " & Number($g_iSearchDark), $COLOR_DEBUG)
$bZapDrills = False
Else
If $g_bDebugSmartZap = True Then SetLog("$g_iSearchDark|Current DE value: " & Number($g_iSearchDark), $COLOR_DEBUG)
EndIf
EndIf
If $bZapDrills Then
If isAtkDarkElixirFull() Then
SetLog("No need to zap!", $COLOR_INFO)
If $g_bDebugSmartZap = True Then SetLog("isAtkDarkElixirFull(): True", $COLOR_DEBUG)
$bZapDrills = False
Else
If $g_bDebugSmartZap = True Then SetLog("isAtkDarkElixirFull(): False", $COLOR_DEBUG)
EndIf
EndIf
If $bZapDrills Then
If $g_iTownHallLevel < 2 Then
SetLog("Your Townhalllevel has yet to be determined.", $COLOR_ERROR)
SetLog("It reads as TH" & $g_iTownHallLevel & ".", $COLOR_ERROR)
SetLog("Locate your Townhall manually at Village->Misc.", $COLOR_ERROR)
$bZapDrills = False
ElseIf $g_iTownHallLevel < 7 Then
SetLog("You do not have the ability to store Dark Elixir!", $COLOR_ERROR)
If $g_bDebugSmartZap = True Then SetLog("Your Town Hall Lvl: " & Number($g_iTownHallLevel), $COLOR_DEBUG)
$bZapDrills = False
Else
If $g_bDebugSmartZap = True Then SetLog("Your Town Hall Lvl: " & Number($g_iTownHallLevel), $COLOR_DEBUG)
EndIf
EndIf
If $bZapDrills Then
If $g_bDebugSmartZap = True Then SetLog("$g_bSmartZapDB = " & $g_bSmartZapDB, $COLOR_DEBUG)
If $g_bSmartZapDB = True And $g_iMatchMode <> $DB Then
SetLog("Not a dead base!", $COLOR_INFO)
$bZapDrills = False
EndIf
EndIf
If $bZapDrills Then
$drillLvlOffset = getDrillOffset()
If $g_bDebugSmartZap = True Then SetLog("Drill Level Offset is: " & Number($drillLvlOffset), $COLOR_DEBUG)
$spellAdjust = getSpellOffset()
If $g_bDebugSmartZap = True Then SetLog("Spell Adjust is: " & Number($spellAdjust), $COLOR_DEBUG)
EndIf
Local $iTroops = PrepareAttack($g_iMatchMode, True)
If $iTroops > 0 Then
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eLSpell Then
If $aSpells[0][4] = 0 Then
If $g_bDebugSmartZap Then SetLog(GetTroopName($g_avAttackTroops[$i][0]) & ": " & $g_avAttackTroops[$i][1], $COLOR_DEBUG)
$aSpells[0][2] = $i
$aSpells[0][3] = Number($g_iLSpellLevel)
$aSpells[0][4] = $g_avAttackTroops[$i][1]
Else
If $g_bDebugSmartZap = True Then SetLog("Donated " & GetTroopName($g_avAttackTroops[$i][0]) & ": " & $g_avAttackTroops[$i][1], $COLOR_DEBUG)
$aSpells[1][2] = $i
$aSpells[1][3] = Number($g_iLSpellLevel)
$aSpells[1][4] = $g_avAttackTroops[$i][1]
EndIf
EndIf
If $g_avAttackTroops[$i][0] = $eESpell Then
If $g_bDebugSmartZap = True Then SetLog(GetTroopName($g_avAttackTroops[$i][0]) & ": " & $g_avAttackTroops[$i][1], $COLOR_DEBUG)
$aSpells[2][2] = $i
$aSpells[2][3] = Number($g_iESpellLevel)
$aSpells[2][4] = $g_avAttackTroops[$i][1]
EndIf
Next
EndIf
If $aSpells[0][4] + $aSpells[1][4] = 0 Then
SetLog("No lightning spells trained, time to go home!", $COLOR_ERROR)
Return $performedZap
Else
If $aSpells[0][4] > 0 Then
SetLog(" - Number of " & GetTroopName($aSpells[0][1], 2) & " (Lvl " & $aSpells[0][3] & "): " & Number($aSpells[0][4]), $COLOR_INFO)
EndIf
If $aSpells[1][4] > 0 Then
SetLog(" - Number of Donated " & GetTroopName($aSpells[1][1], 2) & " (Lvl " & $aSpells[1][3] & "): " & Number($aSpells[1][4]), $COLOR_INFO)
EndIf
EndIf
If $aSpells[2][4] > 0 And $g_bEarthQuakeZap = True Then
SetLog(" - Number of " & GetTroopName($aSpells[2][1], 2) & " (Lvl " & $aSpells[2][3] & "): " & Number($aSpells[2][4]), $COLOR_INFO)
Else
$aSpells[2][4] = 0
EndIf
If $bZapDrills Then
If(Number($g_iSearchDark) < Number($minDE)) And $g_bNoobZap = True Then
SetLog("Dark Elixir is below minimum value [" & Number($g_iSmartZapMinDE) & "]!", $COLOR_INFO)
If $g_bDebugSmartZap Then SetLog("$g_iSearchDark|Current DE value: " & Number($g_iSearchDark), $COLOR_DEBUG)
$bZapDrills = False
ElseIf Number($g_iSearchDark) <($g_aDrillLevelTotal[3 - $drillLvlOffset] / $g_aDrillLevelHP[3 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) Then
SetLog("There is less Dark Elixir(" & Number($g_iSearchDark) & ") than", $COLOR_INFO)
SetLog("gain per zap for a single Lvl " & 3 - Number($drillLvlOffset) & " drill(" & Ceiling($g_aDrillLevelTotal[3 - $drillLvlOffset] / $g_aDrillLevelHP[3 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) & ").", $COLOR_INFO)
SetLog("Base is not worth a Zap!", $COLOR_INFO)
$bZapDrills = False
Else
If $g_bDebugSmartZap Then SetLog("$g_iSearchDark = " & Number($g_iSearchDark) & " | $g_iSmartZapMinDE = " & Number($g_iSmartZapMinDE), $COLOR_DEBUG)
EndIf
If $g_bDebugSmartZap Then
SetLog("$g_iSmartZapExpectedDE| Expected DE value:" & Number($g_iSmartZapExpectedDE), $COLOR_DEBUG)
SetLog("$g_abStopAtkNoLoot1Enable[$DB] = " & $g_abStopAtkNoLoot1Enable[$DB] & ", $g_aiStopAtkNoLoot1Time[$DB] = " & $g_aiStopAtkNoLoot1Time[$DB] & "s", $COLOR_DEBUG)
EndIf
EndIf
If $bZapDrills Then
Local $aDarkDrills = drillSearch()
If UBound($aDarkDrills) = 0 Then
SetLog("No drills found!", $COLOR_INFO)
$bZapDrills = False
Else
SetLog(" - Number of Dark Elixir Drills: " & UBound($aDarkDrills), $COLOR_INFO)
EndIf
_ArraySort($aDarkDrills, 1, 0, 0, 3)
Local $itotalStrikeGain = 0
Local $hTempTimer
EndIf
While IsAttackPage() And $bZapDrills And $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] > 0 And UBound($aDarkDrills) > 0 And $spellAdjust <> -1
Local $Spellused = $eLSpell
Local $skippedZap = True
Local $oldSearchDark = $g_iSearchDark
CheckHeroesHealth()
If($g_iSearchDark < Number($g_iSmartZapMinDE)) And $g_bNoobZap = True Then
SetLog("Dark Elixir is below minimum value [" & Number($g_iSmartZapMinDE) & "], Exiting Now!", $COLOR_INFO)
$bZapDrills = False
ExitLoop
EndIf
Local $aCluster = getDrillCluster($aDarkDrills)
If $aCluster <> -1 Then
Local $tLastZap = 0
For $i = 0 To UBound($aCluster[3]) - 1
If $aDarkDrills[($aCluster[3])[$i]][4] <> 0 Then
If $tLastZap = 0 Then
$tLastZap = __TimerDiff($aDarkDrills[($aCluster[3])[$i]][4])
Else
$tLastZap = _Min(__TimerDiff($aDarkDrills[($aCluster[3])[$i]][4]),$tLastZap)
EndIf
EndIf
Next
If $tLastZap > 0 Then
If _Sleep(_Max($DELAYSMARTZAP10 - $tLastZap, 0)) Then Return
Local $sToDelete = ""
Local $iToDelete = 0
For $i = 0 To UBound($aCluster[3]) - 1
If $aDarkDrills[($aCluster[3])[$i]][4] <> 0 Then
If ReCheckDrillExist($aDarkDrills[($aCluster[3])[$i]][0], $aDarkDrills[($aCluster[3])[$i]][1]) Then
$aDarkDrills[($aCluster[3])[$i]][4] = 0
Else
If $sToDelete = "" Then
$sToDelete &=($aCluster[3])[$i]
Else
$sToDelete &= ";" &($aCluster[3])[$i]
EndIf
$iToDelete +=1
EndIf
EndIf
Next
If $iToDelete > 1 Then
SetLog("Removing " & $iToDelete & " destroyed drills from list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, $sToDelete)
ContinueLoop
ElseIf $iToDelete > 0 Then
SetLog("Removing 1 destroyed drill from list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, $sToDelete)
ContinueLoop
EndIf
EndIf
If $g_bDebugSmartZap = True Then SetLog("Cluster Hold: " & $aCluster[2] & ", First Drill Hold: " & $aDarkDrills[0][3], $COLOR_DEBUG)
If $aCluster[2] < $aDarkDrills[0][3] Then $aCluster = -1
EndIf
If $aCluster = -1 And $aDarkDrills[0][4] <> 0 Then
If _Sleep(_Max($DELAYSMARTZAP10 - __TimerDiff($aDarkDrills[0][4]), 0)) Then Return
If ReCheckDrillExist($aDarkDrills[0][0], $aDarkDrills[0][1]) Then
$aDarkDrills[0][4] = 0
Else
SetLog("Removing 1 destroyed drill from list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, 0)
ContinueLoop
EndIf
EndIf
displayZapLog($aDarkDrills, $aSpells)
$hTempTimer = __TimerInit()
If $g_bNoobZap = True Then
SetLog("NoobZap is going to attack any drill.", $COLOR_ACTION)
If $aCluster <> -1 Then
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
Else
$Spellused = zapBuilding($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$aDarkDrills[0][4] = $hTempTimer
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
Else
If $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] >(4 - $spellAdjust) Then
SetLog("First condition: More than " & 4 - $spellAdjust & " Spells so attack any drill.", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
Else
$Spellused = zapBuilding($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$aDarkDrills[0][4] = $hTempTimer
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
ElseIf $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] >(3 - $spellAdjust) And $aDarkDrills[0][2] >(3 - $drillLvlOffset) Then
SetLog("Second condition: Attack Lvl " & 4 - Number($drillLvlOffset) & " and greater drills if you have more than " & 3 - Number($spellAdjust) & " spells", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
Else
$Spellused = zapBuilding($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$aDarkDrills[0][4] = $hTempTimer
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
ElseIf $aDarkDrills[0][2] >(4 - $drillLvlOffset) And($aDarkDrills[0][3] /($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor)) > 0.3 Then
SetLog("Third condition: Attack Lvl " & 5 - Number($drillLvlOffset) & " drills with more then 30% estimated DE left", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
Else
$Spellused = zapBuilding($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$aDarkDrills[0][4] = $hTempTimer
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
ElseIf $aCluster <> -1 Then
If $aCluster[2] >=($g_aDrillLevelTotal[5 - $drillLvlOffset] / $g_aDrillLevelHP[5 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) Then
SetLog("Fourth condition: Attack, when potential left content in cluster is greater than gain for a single Lvl " & 5 - Number($drillLvlOffset) & " drill", $COLOR_INFO)
$Spellused = zapBuilding($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
For $i = 0 To UBound($aCluster[3]) - 1
$aDarkDrills[($aCluster[3])[$i]][4] = $hTempTimer
Next
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DELAYSMARTZAP4) Then Return
Else
$skippedZap = True
SetLog("Drill did not match any attack conditions, so we will remove it from the list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, 0)
EndIf
EndIf
$g_iSearchDark = getDarkElixir()
If Not $g_iSearchDark Or $g_iSearchDark = 0 Then
SetLog("No Dark Elixir left!", $COLOR_INFO)
SetDebugLog("$g_iSearchDark = " & Number($g_iSearchDark))
If $skippedZap = False Then
If $Spellused = $eESpell Then
$g_iNumEQSpellsUsed += 1
Else
$g_iNumLSpellsUsed += 1
EndIf
$g_iSmartZapGain += $oldSearchDark
EndIf
$bZapDrills = False
ExitLoop
Else
If $g_bDebugSmartZap Then SetLog("$g_iSearchDark = " & Number($g_iSearchDark), $COLOR_DEBUG)
EndIf
If Not $skippedZap Then
If $g_bDebugSmartZap Then SetLog("$oldSearchDark = [" & Number($oldSearchDark) & "] - $g_iSearchDark = [" & Number($g_iSearchDark) & "]", $COLOR_DEBUG)
$strikeGain = Number($oldSearchDark - $g_iSearchDark)
If $g_bDebugSmartZap Then SetLog("$strikeGain = " & Number($strikeGain), $COLOR_DEBUG)
$expectedDE = -1
If $Spellused = $eESpell Then
$g_iNumEQSpellsUsed += 1
If $aCluster <> -1 Then
For $i = 0 To UBound($aCluster[3]) - 1
$expectedDE = _Max(Number($expectedDE), Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_fDarkStealFactor * $g_aEQSpellDmg[$aSpells[2][3] - 1] * $g_fDarkFillLevel)))
Next
Else
$expectedDE = Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor * $g_aEQSpellDmg[$aSpells[2][3] - 1] * $g_fDarkFillLevel))
EndIf
Else
$g_iNumLSpellsUsed += 1
If $g_bNoobZap = False Then
If $aCluster <> -1 Then
For $i = 0 To UBound($aCluster[3]) - 1
$expectedDE = _Max(Number($expectedDE), Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] / $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel)))
Next
Else
$expectedDE = Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] / $g_aDrillLevelHP[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel))
EndIf
Else
$expectedDE = $g_iSmartZapExpectedDE
EndIf
EndIf
If $g_bDebugSmartZap Then SetLog("$expectedDE = " & Number($expectedDE), $COLOR_DEBUG)
If $strikeGain < $expectedDE And $expectedDE <> -1 Then
SetLog("Gained: " & $strikeGain & ", Expected: " & $expectedDE, $COLOR_INFO)
If $aCluster <> -1 Then
_ArrayDelete($aDarkDrills, _ArrayToString($aCluster[3], ";"))
SetLog("Last zap gained less DE then expected, removing the drills from the list.", $COLOR_ACTION)
Else
_ArrayDelete($aDarkDrills, 0)
SetLog("Last zap gained less DE then expected, removing the drill from the list.", $COLOR_ACTION)
EndIf
Else
If $aCluster <> -1 Then
Local $iSumTotalHP = 0
Local $sToDelete = ""
If UBound($aCluster[3]) = 2 Then
For $i = 0 To 1
$iSumTotalHP += $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 2)]][2] - 1]
Next
For $i = 0 To 1
Local $iSubGain = Ceiling(Number($strikeGain * $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 2)]][2] - 1] / $iSumTotalHP))
$aDarkDrills[($aCluster[3])[$i]][3] -= $iSubGain
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", adjusting amount left in this drill.", $COLOR_INFO)
Next
Else
For $i = 0 To 2
$iSumTotalHP += $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 3)]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 2, 3)]][2] - 1]
Next
For $i = 0 To 2
Local $iSubGain = Ceiling(Number($strikeGain * $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 3)]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 2, 3)]][2] - 1] / $iSumTotalHP))
$aDarkDrills[($aCluster[3])[$i]][3] -= $iSubGain
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", adjusting amount left in this drill.", $COLOR_INFO)
Next
EndIf
If $sToDelete <> "" Then _ArrayDelete($aDarkDrills, $sToDelete)
Else
$aDarkDrills[0][3] -= $strikeGain
SetLog("Gained: " & Number($strikeGain) & ", adjusting amount left in this drill.", $COLOR_INFO)
EndIf
EndIf
$itotalStrikeGain += $strikeGain
$g_iSmartZapGain += $strikeGain
SetLog("Total DE from SmartZap/NoobZap: " & Number($itotalStrikeGain), $COLOR_INFO)
EndIf
_ArraySort($aDarkDrills, 1, 0, 0, 3)
If $aSpells[0][4] = 0 Then
Local $iTroops = PrepareAttack($g_iMatchMode, True)
If $iTroops > 0 Then
For $i = 0 To UBound($g_avAttackTroops) - 1
If $g_avAttackTroops[$i][0] = $eLSpell Then
If $g_bDebugSmartZap Then SetLog("Donated " & GetTroopName($g_avAttackTroops[$i][0]) & ": " & $g_avAttackTroops[$i][1], $COLOR_DEBUG)
$aSpells[1][2] = $i
$aSpells[1][3] = Number($g_iLSpellLevel)
$aSpells[1][4] = $g_avAttackTroops[$i][1]
EndIf
Next
EndIf
If $aSpells[1][4] > 0 Then
SetLog("Woohoo, found a donated " & GetTroopName($aSpells[1][1]) & " (Lvl " & $aSpells[1][3] & ").", $COLOR_INFO)
EndIf
EndIf
WEnd
If $g_bSmartZapFTW Then
SetLog("====== SmartZap/NoobZap FTW Mode ======", $COLOR_INFO)
Else
Return $performedZap
EndIf
If _CheckPixel($aWonOneStar, True) Then
SetLog("One Star already reached.", $COLOR_INFO)
Return $performedZap
EndIf
If $aSpells[0][4] + $aSpells[1][4] = 0 Then
SetLog("No lightning spells left, time to go home!", $COLOR_ERROR)
Return $performedZap
Else
If $aSpells[0][4] > 0 Then
SetLog(" - Number of " & GetTroopName($aSpells[0][1], 2) & " (Lvl " & $aSpells[0][3] & "): " & Number($aSpells[0][4]), $COLOR_INFO)
EndIf
If $aSpells[1][4] > 0 Then
SetLog(" - Number of Donated " & GetTroopName($aSpells[1][1], 2) & " (Lvl " & $aSpells[1][3] & "): " & Number($aSpells[1][4]), $COLOR_INFO)
EndIf
EndIf
Local $iPercentageNeeded = 50 - getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)
SetLog("Percentage needed: " & $iPercentageNeeded, $COLOR_INFO)
_ArrayDelete($aSpells, 2)
Local $aEasyPrey = easyPreySearch()
If UBound($aEasyPrey) = 0 Then
SetLog("No easy targets found!", $COLOR_INFO)
Return $performedZap
Else
Local $iTargetCount = 0
For $iTargets = 0 To UBound($aEasyPrey) - 1
$iTargetCount += $aEasyPrey[$iTargets][2]
If $g_bDebugSmartZap = True Then
SetLog($iTargets + 1 & ". target: x=" & $aEasyPrey[$iTargets][0] & ",y=" & $aEasyPrey[$iTargets][1] & ",w=" & $aEasyPrey[$iTargets][2], $COLOR_DEBUG)
EndIf
Next
SetLog("Count of easy targets: " & $iTargetCount, $COLOR_INFO)
$iTargetCount = 0
For $iTargets = 0 To _Min(Number(UBound($aEasyPrey) - 1),Number($aSpells[0][4] + $aSpells[1][4]) - 1)
$iTargetCount += $aEasyPrey[$iTargets][2]
Next
SetLog("Easy targets, we can zap: " & $iTargetCount, $COLOR_INFO)
If $iPercentageNeeded > $iTargetCount Then
SetLog("No chance to win!", $COLOR_INFO)
SetLog("Needed percentage (" & $iPercentageNeeded & ") is greater than targets, we can zap (" & $iTargetCount & ")!", $COLOR_INFO)
Return $performedZap
EndIf
EndIf
Local $Spellused = $eLSpell
While IsAttackPage() And $aSpells[0][4] + $aSpells[1][4] > 0 And UBound($aEasyPrey) > 0 And Not _CheckPixel($aWonOneStar, True)
$Spellused = zapBuilding($aSpells, $aEasyPrey[0][0] + 5, $aEasyPrey[0][1] + 5)
_ArrayDelete($aEasyPrey, 0)
If _Sleep(6000) Then Return
Wend
If _CheckPixel($aWonOneStar, True) Then
SetLog("Hooray, One Star reached, we have won!", $COLOR_INFO)
EndIf
Return $performedZap
EndFunc
Func zapBuilding(ByRef $Spells, $x, $y)
Local $iSpell
For $i = 0 To UBound($Spells) - 1
If $Spells[$i][4] > 0 Then
$iSpell = $i
EndIf
Next
If $Spells[$iSpell][2] > -1 Then
SetLog("Dropping " & $Spells[$iSpell][0] & " " & String(GetTroopName($Spells[$iSpell][1])), $COLOR_ACTION)
SelectDropTroop($Spells[$iSpell][2])
If _Sleep($DELAYCASTSPELL1) Then Return
If IsAttackPage() Then Click($x, $y, 1, 0, "#0029")
$Spells[$iSpell][4] -= 1
Else
If $g_bDebugSmartZap = True Then SetLog("No " & String(GetTroopName($Spells[$iSpell][1])) & " Found", $COLOR_DEBUG)
EndIf
Return $Spells[$iSpell][1]
EndFunc
Func ReCheckDrillExist($x, $y)
_CaptureRegion2($x - 25, $y - 25, $x + 25, $y + 25)
Local $aResult = multiMatches($g_sImgSearchDrill, 1, "FV", "FV", "", 0, 1000, False)
If UBound($aResult) > 1 Then
If $g_bDebugSmartZap = True Then SetLog("ReCheckDrillExist: Yes| " & UBound($aResult), $COLOR_SUCCESS)
Return True
Else
If $g_bDebugSmartZap = True Then SetLog("ReCheckDrillExist: No| " & UBound($aResult), $COLOR_ERROR)
EndIf
Return False
EndFunc
Func CheckOverviewFullArmy($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $bOpenArmyWindow Then
ClickP($aAway, 1, 0, "#0346")
If _Sleep($DELAYCHECKFULLARMY1) Then Return
If Not $g_bUseRandomClick Then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0347")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
If _Sleep($DELAYCHECKFULLARMY2) Then Return
Local $j = 0
While Not _ColorCheck(_GetPixelColor(136, 129, True), Hex(0xE8E8E0, 6), 20)
If $g_bDebugSetlogTrain Then SetLog("OverView TabColor=" & _GetPixelColor(136, 129, True), $COLOR_DEBUG)
If _Sleep($DELAYCHECKFULLARMY1) Then Return
$j += 1
If $j > 15 Then ExitLoop
WEnd
If $j > 15 Then
SetLog("Army Window didn't open", $COLOR_ERROR)
Return
EndIf
EndIf
If _sleep($DELAYCHECKFULLARMY2) Then Return
Local $Pixel = _CheckPixel($aIsCampFull, True) And _ColorCheck(_GetPixelColor(37, 177, True), Hex(0x91C030, 6), 20)
If Not $Pixel Then
If _sleep($DELAYCHECKFULLARMY2) Then Return
$Pixel = _CheckPixel($aIsCampFull, True) And _ColorCheck(_GetPixelColor(37, 177, True), Hex(0x91C030, 6), 20)
EndIf
If $g_bDebugSetlogTrain Then SetLog("Checking Overview for full army [!] " & $Pixel & ", " & _GetPixelColor(128, 176, True), $COLOR_DEBUG)
If $Pixel Then
$g_bFullArmy = True
EndIf
$g_bCanRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5])
If $g_bDebugSetlog Then SetDebugLog("Can Request CC: " & $g_bCanRequestCC, $COLOR_DEBUG)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0348")
If _Sleep($DELAYCHECKFULLARMY3) Then Return
EndIf
EndFunc
Func CheckFullBarrack()
If _sleep(200) Then Return
Local $Pixel = _CheckPixel($aBarrackFull, True)
If $g_bDebugSetlogTrain Then SetLog("Check Barrack Full color : " & _GetPixelColor($aBarrackFull[0], $aBarrackFull[1], True) & " Expected if Full : " & Hex($aBarrackFull[2], 6), $COLOR_DEBUG)
If $g_bDebugSetlogTrain Then SetLog("Checking for Full Normal or Dark Barrack [!]" & $Pixel, $COLOR_DEBUG)
If $Pixel Then
Return True
Else
Return False
EndIf
EndFunc
Func checkArmyCamp($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bGetHeroesTime = False, $bSetLog = True)
Local $iStopWatchLevel = StopWatchLevel()
Local $Result = _checkArmyCamp($bOpenArmyWindow, $bCloseArmyWindow, $bGetHeroesTime, $bSetLog)
StopWatchReturn($iStopWatchLevel)
Return $Result
EndFunc
Func _checkArmyCamp($bOpenArmyWindow, $bCloseArmyWindow, $bGetHeroesTime, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStart("checkArmyCamp")
If $g_bDebugSetlogTrain Then SetLog("Begin checkArmyCamp:", $COLOR_DEBUG1)
If $g_bDebugFuncTime Then StopWatchStart("IsTrainPage/openArmyOverview")
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "_checkArmyCamp()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
If $g_bDebugFuncTime Then StopWatchStopLog()
If $g_bDebugFuncTime Then StopWatchStart("getArmyTroopsCapacity")
getArmyTroopCapacity(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyTroops")
getArmyTroops(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyTroopTime")
getArmyTroopTime(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
Local $HeroesRegenTime
If $g_bDebugFuncTime Then StopWatchStart("getArmyHeroCount")
getArmyHeroCount(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $bGetHeroesTime = True Then
If $g_bDebugFuncTime Then StopWatchStart("getArmyHeroTime")
$HeroesRegenTime = getArmyHeroTime("all", $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
EndIf
If $g_bDebugFuncTime Then StopWatchStart("getArmySpellCapacity")
getArmySpellCapacity(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmySpells")
getArmySpells(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmySpellTime")
getArmySpellTime(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmySiegeMachines")
getArmySiegeMachines(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyCCSpellCapacity")
getArmyCCSpellCapacity(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyCCStatus")
getArmyCCStatus(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If $g_bDebugFuncTime Then StopWatchStart("getArmyCCSiegeMachines")
getArmyCCSiegeMachines(False, False, False, $bSetLog)
If $g_bDebugFuncTime Then StopWatchStopLog()
If _Sleep($DELAYCHECKARMYCAMP6) Then Return
If Not $g_bFullArmy Then
If $g_bDebugFuncTime Then StopWatchStart("DeleteExcessTroops")
DeleteExcessTroops()
If $g_bDebugFuncTime Then StopWatchStopLog()
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
If $g_bDebugSetlogTrain Then SetLog("End checkArmyCamp: canRequestCC= " & $g_bCanRequestCC & ", fullArmy= " & $g_bFullArmy, $COLOR_DEBUG)
If $g_bDebugFuncTime Then StopWatchStopLog()
Return $HeroesRegenTime
EndFunc
Func IsTroopToDonateOnly($pTroopType)
If $g_abAttackTypeEnable[$DB] Then
Local $tempArr = $g_aaiTroopsToBeUsed[$g_aiAttackTroopSelection[$DB]]
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
Return False
EndIf
Next
EndIf
If $g_abAttackTypeEnable[$LB] Then
Local $tempArr = $g_aaiTroopsToBeUsed[$g_aiAttackTroopSelection[$LB]]
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
Return False
EndIf
Next
EndIf
Return True
EndFunc
Func DeleteExcessTroops()
Local $SlotTemp, $Delete
Local $IsNecessaryDeleteTroop = 0
Local $CorrectDonation
For $i = 0 To $eTroopCount - 1
$CorrectDonation = 0
If IsTroopToDonateOnly($i) Then
If($g_aiCurrentTroops[$i] * -1) > $g_aiArmyCompTroops[$i] Then
$IsNecessaryDeleteTroop = 1
$g_aiDonateTroops[$i] = 0
EndIf
If($g_aiCurrentTroops[$i] * -1) = $g_aiArmyCompTroops[$i] Then
$g_aiDonateTroops[$i] = 0
EndIf
If($g_aiCurrentTroops[$i] * -1) + $g_aiDonateTroops[$i] >= $g_aiArmyCompTroops[$i] Then
$CorrectDonation = $g_aiCurrentTroops[$i] + $g_aiArmyCompTroops[$i]
$g_aiDonateTroops[$i] = $CorrectDonation
EndIf
EndIf
Next
If $IsNecessaryDeleteTroop = 0 Then Return
If _ColorCheck(_GetPixelColor(670, 485 + $g_iMidOffsetY, True), Hex(0x60B010, 6), 5) Then
Click(670, 485 + $g_iMidOffsetY)
EndIf
SetLog("Troops in excess!...")
If $g_bDebugSetlogTrain Then SetLog("Start-Loop Regular Troops Only To Donate ")
For $i = 0 To $eTroopCount - 1
If IsTroopToDonateOnly($i) Then
If $g_bDebugSetlogTrain Then SetLog("Troop :" & $g_asTroopNames[$i])
If($g_aiCurrentTroops[$i] * -1) > $g_aiArmyCompTroops[$i] Then
$Delete =($g_aiCurrentTroops[$i] * -1) - $g_aiArmyCompTroops[$i]
If $g_bDebugSetlogTrain Then SetLog("$Delete :" & $Delete)
$SlotTemp = $g_aiSlotInArmy[$i]
If $g_bDebugSetlogTrain Then SetLog("$SlotTemp :" & $SlotTemp)
If _Sleep(250) Then Return
If _ColorCheck(_GetPixelColor(170 +(62 * $SlotTemp), 235 + $g_iMidOffsetY, True), Hex(0xD40003, 6), 10) Then
Click(170 +(62 * $SlotTemp), 235 + $g_iMidOffsetY, $Delete, 300)
SetLog("~Deleted " & $Delete & " " & $g_asTroopNames[$i], $COLOR_ERROR)
$g_aiCurrentTroops[$i] += $Delete
EndIf
EndIf
EndIf
Next
If $g_bDebugSetlogTrain Then SetLog("Start-Loop Dark Troops Only To Donate ")
If _ColorCheck(_GetPixelColor(674, 436 + $g_iMidOffsetY, True), Hex(0x60B010, 6), 5) Then
Click(674, 436 + $g_iMidOffsetY)
EndIf
If WaitforPixel(505, 411 + $g_iMidOffsetY, 506, 412 + $g_iMidOffsetY, Hex(0x60B010, 6), 5, 10) Then
Click(505, 411 + $g_iMidOffsetY)
EndIf
EndFunc
Func OpenArmyOverview($bCheckMain = True, $sWhereFrom = "Undefined")
If $bCheckMain Then
If Not IsMainPage() Then
SetLog("Cannot open Army Overview window", $COLOR_ERROR)
SetError(1)
Return False
EndIf
EndIf
If WaitforPixel(23, 505 + $g_iBottomOffsetY, 53, 507 + $g_iBottomOffsetY, Hex(0xEEB344, 6), 5, 10) Then
If $g_bDebugSetlogTrain Then SetLog("Click $aArmyTrainButton" & " (Called from " & $sWhereFrom & ")", $COLOR_SUCCESS)
If Not $g_bUseRandomClick Then
ClickP($aArmyTrainButton, 1, 0, "#0293")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
EndIf
If _Sleep($DELAYRUNBOT6) Then Return
If Not IsTrainPage() Then
SetError(1)
Return False
EndIf
Return True
EndFunc
Func OpenArmyTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Army Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenTroopsTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Train Troops Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenSpellsTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Brew Spells Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenSiegeMachinesTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Build Siege Machines Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenQuickTrainTab($bSetLog = True, $sWhereFrom = "Undefined")
Return OpenTrainTab("Quick Train Tab", $bSetLog, $sWhereFrom)
EndFunc
Func OpenTrainTab($sTab, $bSetLog = True, $sWhereFrom = "Undefined")
If Not IsTrainPage() Then
SetDebugLog("Error in OpenTrainTab: Cannot find the Army Overview Window", $COLOR_ERROR)
SetError(1)
Return False
EndIf
Local $aTabButton = findButton(StringStripWS($sTab, 8), Default, 1, True)
If IsArray($aTabButton) And UBound($aTabButton, 1) = 2 Then
$aIsTabOpen[0] = $aTabButton[0]
If Not _CheckPixel($aIsTabOpen, True) Then
If $bSetLog Or $g_bDebugSetlogTrain Then SetLog("Open " & $sTab &($g_bDebugSetlogTrain ? " (Called from " & $sWhereFrom & ")" : ""), $COLOR_INFO)
ClickP($aTabButton)
If Not _WaitForCheckPixel($aIsTabOpen, True) Then
SetLog("Error in OpenTrainTab: Cannot open " & $sTab & ". Pixel to check did not appear", $COLOR_ERROR)
SetError(1)
Return False
EndIf
EndIf
Else
SetDebugLog("Error in OpenTrainTab: $aTabButton is no valid Array", $COLOR_ERROR)
SetError(1)
Return False
EndIf
If _Sleep(200) Then Return
Return True
EndFunc
Func SmartWait4Train($iTestSeconds = Default)
If Not $g_bRunState Then Return
Static $ichkCloseWaitSpell = 0, $ichkCloseWaitHero = 0
Local $bTest =($iTestSeconds <> Default)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin SmartWait4Train:", $COLOR_DEBUG1)
If Not $g_bCloseWhileTrainingEnable Then Return
Local $iExitCount = 0
If _Sleep($DELAYSMARTWAIT) Then Return
While IsMainPage(2) = False
If _Sleep($DELAYIDLE1) Then Return
$iExitCount += 1
If $iExitCount > 25 Then
SetLog("SmartWait4Train not finding Main Page, skip function!", $COLOR_ERROR)
Return
EndIf
WEnd
If Not $g_bCloseWhileTrainingEnable And Not $g_bCloseWithoutShield Then Return
Local $aResult, $iActiveHero
Local $aHeroResult[3]
Local Const $TRAINWAIT_NOWAIT = 0x00
Local Const $TRAINWAIT_SHIELD = 0x01
Local Const $TRAINWAIT_TROOP = 0x02
Local Const $TRAINWAIT_SPELL = 0x04
Local Const $TRAINWAIT_HERO = 0x08
Local $iTrainWaitCloseFlag = $TRAINWAIT_NOWAIT
Local $sNowTime = "", $sTrainEndTime = ""
Local $iShieldTime = 0, $iDiffDateTime = 0, $iDiffTime = 0
Local $RandomAddPercent = Random(0, $g_iCloseRandomTimePercent / 100)
Local $MinimumTimeClose = Number($g_iCloseMinimumTime * 60)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Random add percent = " & StringFormat("%.4f", $RandomAddPercent), $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("$MinimumTimeClose = " & $MinimumTimeClose & "s", $COLOR_DEBUG)
Local $StopEmulator = False
Local $bFullRestart = False
Local $bSuspendComputer = False
If $g_bCloseRandom Then $StopEmulator = "random"
If $g_bCloseEmulator Then $StopEmulator = True
If $g_bSuspendComputer Then $bSuspendComputer = True
If IsArray($g_asShieldStatus) And(StringInStr($g_asShieldStatus[0], "shield", $STR_NOCASESENSEBASIC) Or StringInStr($g_asShieldStatus[0], "guard", $STR_NOCASESENSEBASIC)) Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Have shield till " & $g_asShieldStatus[2] & ", close game while wait for train)", $COLOR_DEBUG)
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If IsArray($g_asShieldStatus) = 0 Or $g_asShieldStatus[0] = "" Or $g_asShieldStatus[0] = "none" Then
$aResult = getShieldInfo()
If @error Then
SetLog("SmartWait4Train Shield OCR error = " & @error & "Extended = " & @extended, $COLOR_ERROR)
Return False
Else
$g_asShieldStatus = $aResult
EndIf
If IsArray($g_asShieldStatus) And(StringInStr($g_asShieldStatus[0], "shield", $STR_NOCASESENSEBASIC) Or StringInStr($g_asShieldStatus[0], "guard", $STR_NOCASESENSEBASIC)) Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Have shield till " & $g_asShieldStatus[2] & ", close game while wait for train)", $COLOR_DEBUG)
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD)
EndIf
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog And IsArray($g_asShieldStatus) Then SetLog("Shield Status:" & $g_asShieldStatus[0] & ", till " & $g_asShieldStatus[2], $COLOR_DEBUG)
Local $result = OpenArmyOverview(True, "SmartWait4Train()")
If Not $result Then
If $g_bDebugImageSave Or $g_bDebugSetlogTrain Then DebugImageSave("SmartWait4Troop2_")
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $g_bCloseWithoutShield Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$g_bCloseWithoutShield enabled", $COLOR_DEBUG)
getArmyTroopTime()
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmyTroopTime returned: " & $g_aiTimeTrain[0], $COLOR_DEBUG)
If _Sleep($DELAYRESPOND) Then Return
If $g_aiTimeTrain[0] > 0 Then
If $g_bCloseRandomTime Then
$g_aiTimeTrain[0] += $g_aiTimeTrain[0] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_TROOP)
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", troop time = " & StringFormat("%.2f", $g_aiTimeTrain[0]), $COLOR_DEBUG)
EndIf
If($g_bCloseWithoutShield Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD) And IsWaitforSpellsActive() Then
$ichkCloseWaitSpell = 1
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$ichkCloseWaitSpell enabled", $COLOR_DEBUG)
getArmySpellTime()
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmySpellTime returned: " & $g_aiTimeTrain[1], $COLOR_DEBUG)
If _Sleep($DELAYRESPOND) Then Return
If $g_aiTimeTrain[1] > 0 Then
If $g_bCloseRandomTime Then
$g_aiTimeTrain[1] += $g_aiTimeTrain[1] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SPELL)
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", spell time = " & StringFormat("%.2f", $g_aiTimeTrain[1]), $COLOR_DEBUG)
Else
$ichkCloseWaitSpell = 0
EndIf
If($g_bCloseWithoutShield Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD) And IsWaitforHeroesActive() Then
$ichkCloseWaitHero = 1
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$ichkCloseWaitHero enabled", $COLOR_DEBUG)
For $j = 0 To UBound($aResult) - 1
$aHeroResult[$j] = 0
Next
If _Sleep($DELAYRESPOND) Then Return
$aHeroResult = getArmyHeroTime("all")
If @error Then
SetLog("getArmyHeroTime return error: " & @error & ", exit SmartWait!", $COLOR_ERROR)
Return
EndIf
If Not IsArray($aHeroResult) Then
SetLog("getArmyHeroTime OCR fail, exit SmartWait!", $COLOR_ERROR)
Return
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmyHeroTime returned: " & $aHeroResult[0] & ":" & $aHeroResult[1] & ":" & $aHeroResult[2], $COLOR_DEBUG)
If _Sleep($DELAYRESPOND) Then Return
If $aHeroResult[0] > 0 Or $aHeroResult[1] > 0 Or $aHeroResult[2] > 0 Then
For $pTroopType = $eKing To $eWarden
Local $iHeroIdx = $pTroopType - $eKing
For $pMatchMode = $DB To $LB
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then
SetLog("$pTroopType: " & GetTroopName($pTroopType) & ", $pMatchMode: " & $g_asModeText[$pMatchMode], $COLOR_DEBUG)
SetLog("TroopToBeUsed: " & IsUnitUsed($pMatchMode, $pTroopType) & ", Hero Wait Status= " & IsSearchModeActiveMini($pMatchMode) & " & " & IsUnitUsed($pMatchMode, $pTroopType) & " & " &($g_iHeroUpgrading[$iHeroIdx] <> 1) & " & " &($g_iHeroWaitAttackNoBit[$pMatchMode][$iHeroIdx] = 1), $COLOR_DEBUG)
SetLog("$g_aiAttackUseHeroes[" & $pMatchMode & "]= " & $g_aiAttackUseHeroes[$pMatchMode] & ", $g_aiSearchHeroWaitEnable[" & $pMatchMode & "]= " & $g_aiSearchHeroWaitEnable[$pMatchMode] & ", $g_iHeroUpgradingBit=" & $g_iHeroUpgradingBit, $COLOR_DEBUG)
EndIf
$iActiveHero = -1
If IsSearchModeActiveMini($pMatchMode) And IsUnitUsed($pMatchMode, $pTroopType) And $g_iHeroUpgrading[$iHeroIdx] <> 1 And $g_iHeroWaitAttackNoBit[$pMatchMode][$iHeroIdx] = 1 Then
$iActiveHero = $iHeroIdx
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $g_bCloseRandomTime And $g_aiTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$g_aiTimeTrain[2] = $aHeroResult[$iActiveHero] +($aHeroResult[$iActiveHero] * $RandomAddPercent)
ElseIf $g_bCloseExactTime And $g_aiTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$g_aiTimeTrain[2] = $aHeroResult[$iActiveHero]
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_HERO)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then
SetLog("Wait enabled: " & GetTroopName($pTroopType) & ":" & $g_asModeText[$pMatchMode] & ", $iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", Hero Time:" & $aHeroResult[$iActiveHero] & ", Wait Time: " & StringFormat("%.2f", $g_aiTimeTrain[2]), $COLOR_DEBUG)
EndIf
EndIf
Next
If _Sleep($DELAYRESPOND) Then Return
Next
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmyHeroTime return all zero hero wait times", $COLOR_DEBUG)
EndIf
If $g_aiTimeTrain[2] > 0 Then
If $g_bCloseRandomTime Then
$g_aiTimeTrain[2] += $g_aiTimeTrain[2] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_HERO)
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", hero time = " & StringFormat("%.2f", $g_aiTimeTrain[2]), $COLOR_DEBUG)
Else
$ichkCloseWaitHero = 0
$g_aiTimeTrain[2] = 0
EndIf
If $g_iCCRemainTime = 0 And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And Not _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
getArmyCCStatus()
EndIf
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
If $iTrainWaitCloseFlag = $TRAINWAIT_NOWAIT Then Return
Local $iTrainWaitTime
Switch $iTrainWaitCloseFlag
Case 14 To 15
$iTrainWaitTime = _ArrayMax($g_aiTimeTrain, 1, 0, 2, 0)
Case 12 To 13
$iTrainWaitTime = _Max($g_aiTimeTrain[1], $g_aiTimeTrain[2])
Case 10 To 11
$iTrainWaitTime = _Max($g_aiTimeTrain[0], $g_aiTimeTrain[2])
Case 8 To 9
$iTrainWaitTime = $g_aiTimeTrain[2]
Case 6 To 7
$iTrainWaitTime = _Max($g_aiTimeTrain[0], $g_aiTimeTrain[1])
Case 4 To 5
$iTrainWaitTime = $g_aiTimeTrain[1]
Case 2 To 3
$iTrainWaitTime = $g_aiTimeTrain[0]
Case 1
If $g_aiTimeTrain[0] <= 1 And Not $bTest Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
SetLog("No smart troop wait needed", $COLOR_SUCCESS)
Return
Else
$iTrainWaitTime = $g_aiTimeTrain[0]
EndIf
Case Else
SetLog("SmartWait cannot determine time to close CoC!", $COLOR_ERROR)
Return
EndSwitch
If $g_bTrainLogoutMaxTime Then
SetLog("Train time = " & StringFormat("%.2f", $iTrainWaitTime) & " minutes, Max Logout Time enabled = " & Number($g_iTrainLogoutMaxTime) & " mins", $COLOR_SUCCESS)
$iTrainWaitTime = _Min($iTrainWaitTime, Number($g_iTrainLogoutMaxTime) - 0.4)
EndIf
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Or $bTest Then
SetLog("Training time values: " & StringFormat("%.2f", $g_aiTimeTrain[0]) & " : " & StringFormat("%.2f", $g_aiTimeTrain[1]) & " : " & StringFormat("%.2f", $g_aiTimeTrain[2]), $COLOR_DEBUG)
SetLog("$iTrainWaitTime = " & StringFormat("%.2f", $iTrainWaitTime) & " minutes", $COLOR_DEBUG)
SetLog("$iTrainWaitCloseFlag: " & $iTrainWaitCloseFlag)
EndIf
If $g_bRequestTroopsEnable And $g_iCCRemainTime > 0 And $g_iCCRemainTime < $iTrainWaitTime Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Wait time reduced for CC from: " & StringFormat("%.2f", $iTrainWaitTime) & " To " & StringFormat("%.2f", $g_iCCRemainTime), $COLOR_DEBUG)
$iTrainWaitTime = $g_iCCRemainTime
EndIf
$iTrainWaitTime = $iTrainWaitTime * 60
$sNowTime = _NowCalc()
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Train end time: " & _DateAdd("s", Int($iTrainWaitTime), $sNowTime), $COLOR_DEBUG)
If IsArray($g_asShieldStatus) And _DateIsValid($g_asShieldStatus[2]) Then
$iShieldTime = _DateDiff("s", $sNowTime, $g_asShieldStatus[2])
If @error Then _logErrorDateDiff(@error)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Shield time remain: " & $iShieldTime & " seconds", $COLOR_DEBUG)
If $iShieldTime < 45 Then
$iShieldTime = 0
Else
$iShieldTime -= 45
EndIf
EndIf
$iDiffTime = $iShieldTime -($iTrainWaitTime)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Time Train:Shield:Diff " &($iTrainWaitTime) & ":" & $iShieldTime & ":" & $iDiffTime, $COLOR_DEBUG)
If($iTrainWaitTime >= $MinimumTimeClose) Or $bTest Then
If $iShieldTime > 0 Then
If $iDiffTime <= 0 Then
SetLog("Smart wait while shield time = " & StringFormat("%.2f", $iShieldTime / 60) & " Minutes", $COLOR_INFO)
If $g_bNotifyTGEnable And $g_bNotifyAlertSmartWaitTime Then NotifyPushToTelegram($g_sNotifyOrigin & " : " & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_01", "Smart Wait While Shield Time = ") & StringFormat("%.2f", $iShieldTime / 60) & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_02", " Minutes") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_03", "Wait For Troops Ready"))
If $bTest Then $iShieldTime = $iTestSeconds
UniversalCloseWaitOpenCoC($iShieldTime * 1000, "SmartWait4Train_", $StopEmulator, $bFullRestart, $bSuspendComputer)
$g_bRestart = True
ResetTrainTimeArray()
Else
SetLog("Smart wait train time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
If $g_bNotifyTGEnable And $g_bNotifyAlertSmartWaitTime Then NotifyPushToTelegram($g_sNotifyOrigin & " : " & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_04", "Smart Wait Train Time = ") & StringFormat("%.2f", $iTrainWaitTime / 60) & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_02", " Minutes") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_03", "Wait For Troops Ready"))
If $bTest Then $iTrainWaitTime = $iTestSeconds
UniversalCloseWaitOpenCoC($iTrainWaitTime * 1000, "SmartWait4Train_", $StopEmulator, $bFullRestart, $bSuspendComputer)
$g_bRestart = True
ResetTrainTimeArray()
EndIf
ElseIf($g_bCloseWithoutShield And $g_aiTimeTrain[0] > 0) Or($ichkCloseWaitSpell = 1 And $g_aiTimeTrain[1] > 0) Or($ichkCloseWaitHero = 1 And $g_aiTimeTrain[2] > 0) Then
SetLog("Smart Wait time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
If $g_bNotifyTGEnable And $g_bNotifyAlertSmartWaitTime Then NotifyPushToTelegram($g_sNotifyOrigin & " : " & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_05", "Smart Wait Time = ") & StringFormat("%.2f", $iTrainWaitTime / 60) & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_02", " Minutes") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Smart-Wait-Time_Info_03", "Wait For Troops Ready"))
If $bTest Then $iTrainWaitTime = $iTestSeconds
UniversalCloseWaitOpenCoC($iTrainWaitTime * 1000, "SmartWait4TrainNoShield_", $StopEmulator, $bFullRestart, $bSuspendComputer)
$g_bRestart = True
ResetTrainTimeArray()
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$ichkCloseWaitSpell=" & $ichkCloseWaitSpell & ", $g_aiTimeTrain[1]=" & $g_aiTimeTrain[1], $COLOR_DEBUG)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("$ichkCloseWaitHero=" & $ichkCloseWaitHero & ", $g_aiTimeTrain[2]=" & $g_aiTimeTrain[2], $COLOR_DEBUG)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Troop training with time remaining not enabled, skip SmartWait game exit", $COLOR_DEBUG)
EndIf
Else
SetLog("Smart Wait Time < Minimum Time Required To Close [" &($MinimumTimeClose / 60) & " Min]", $COLOR_INFO)
SetLog("Wait Train Time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
SetLog("Remain Shield Time = " & StringFormat("%.2f", $iShieldTime / 60) & " Minutes", $COLOR_INFO)
SetLog("Not Close CoC Just Wait In The Main Screen", $COLOR_INFO)
If($iShieldTime < $iTrainWaitTime) And($g_bCloseWithoutShield = False) Then
_SleepStatus($iShieldTime * 1000)
Else
_SleepStatus($iTrainWaitTime * 1000)
EndIf
ResetTrainTimeArray()
EndIf
EndFunc
Func ResetTrainTimeArray()
For $i = 0 To UBound($g_aiTimeTrain) - 1
$g_aiTimeTrain[$i] = 0
Next
EndFunc
Func TrainClick($iX, $iY, $iTimes, $iSpeed, $aWatchSpot, $sdebugtxt, $TypeTroops)
If IsTrainPage() Then
If $g_bDebugClick Then
Local $txt = _DecodeDebug($sdebugtxt)
SetLog("TrainClick(" & $iX & "," & $iX & "," & $iTimes & "," & $iSpeed & "," & $sdebugtxt & $txt & "," & $TypeTroops & ")", $COLOR_DEBUG)
EndIf
If $iTimes <> 1 Then
KeepClicks()
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("KeepClicks: " & KeepClicks(), $COLOR_DEBUG)
If IsKeepClicksActive() Then
For $i = 0 To($iTimes - 1)
If Not $g_bUseRandomClick Then
PureClick($iX, $iY)
Else
PureClickR($TypeTroops, $iX, $iY)
EndIf
Next
If isProblemAffect(True) Then checkMainScreen(False)
Local $sLogText = Default
If $g_bDebugSetlogTrain Then $sLogText = "TrainClick " & $iX & "," & $iY & "," & $iTimes
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("Camp is FULL", $COLOR_DEBUG)
ClearClicks()
EndIf
Else
If FastCaptureRegion() Then
For $i = 0 To($iTimes - 1)
If isProblemAffect(True) Then checkMainScreen(False)
Local $sLogText = Default
If $g_bDebugSetlogTrain Then $sLogText = "TrainClick " & $iX & "," & $iY & "," & $iTimes
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("Camp is FULL after " & $i & " clicks", $COLOR_DEBUG)
ExitLoop
EndIf
If Not $g_bUseRandomClick Then
PureClick($iX, $iY)
Else
PureClickR($TypeTroops, $iX, $iY)
EndIf
If _Sleep($iSpeed, False) Then ExitLoop
Next
Else
If isProblemAffect(True) Then checkMainScreen(False)
Local $sLogText = Default
If $g_bDebugSetlogTrain Then $sLogText = "TrainClick " & $iX & "," & $iY & "," & $iTimes
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("Camp is full", $COLOR_DEBUG)
Return
EndIf
If Not $g_bUseRandomClick Then
PureClick($iX, $iY, $iTimes, $iSpeed)
Else
PureClickR($TypeTroops, $iX, $iY, $iTimes, $iSpeed)
EndIf
If _Sleep($iSpeed, False) Then Return
EndIf
EndIf
ReleaseClicks()
Else
Local $sLogText = Default
If $g_bDebugSetlogTrain Then $sLogText = "TrainClick " & $iX & "," & $iY & "," & $iTimes
If isProblemAffect(True) Then checkMainScreen(False)
If $g_bDebugSetlogTrain Then SetLog("Full Check=" & _GetPixelColor($aWatchSpot[0], $aWatchSpot[1], False), $COLOR_DEBUG)
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_bDebugClick Or $g_bDebugSetlogTrain Then SetLog("Camp is FULL", $COLOR_DEBUG)
Return
EndIf
If Not $g_bUseRandomClick Then
PureClick($iX, $iY)
Else
PureClickR($TypeTroops, $iX, $iY)
EndIf
If _Sleep($iSpeed, False) Then Return
EndIf
Return True
Else
Return False
EndIf
EndFunc
Func TrainClickP($aPoint, $iHowOften, $iSpeed, $aWatchSpot, $sdebugtxt, $TypeTroops)
Return TrainClick($aPoint[0], $aPoint[1], $iHowOften, $iSpeed, $aWatchSpot, $sdebugtxt, $TypeTroops)
EndFunc
Func TrainSystem()
If Not $g_bTrainEnabled Then
If $g_bDebugSetlogTrain Then SetLog("Halt mode - training disabled", $COLOR_DEBUG)
Return
EndIf
$g_sTimeBeforeTrain = _NowCalc()
StartGainCost()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $g_bIsFullArmywithHeroesAndSpells Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
DoubleTrain($g_bQuickTrainEnable)
Return
EndIf
If $g_abDonateOnly[$g_iCurAccount] And ProfileSwitchAccountEnabled() And $g_bIsFullArmywithHeroesAndSpells Then
SetLog("Donate Only mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
DoubleTrain($g_bQuickTrainEnable)
Return
EndIf
If $g_bDoubleTrain Then
DoubleTrain($g_bQuickTrainEnable)
Return
EndIf
If Not $g_bQuickTrainEnable Then
TrainCustomArmy()
Return
EndIf
If $g_bDebugSetlogTrain Then SetLog(" - Initial Quick train Function")
If $g_bDebugSetlogTrain Then SetLog(" - Line Open Army Window")
CheckIfArmyIsReady()
If Not $g_bRunState Then Return
If $g_bIsFullArmywithHeroesAndSpells Or($g_CurrentCampUtilization = 0 And $g_bFirstStart) Then
If $g_bIsFullArmywithHeroesAndSpells Then SetLog(" - Your Army is Full, let's make troops before Attack!", $COLOR_INFO)
If($g_CurrentCampUtilization = 0 And $g_bFirstStart) Then
SetLog(" - Your Army is Empty, let's make troops before Attack!", $COLOR_ACTION1)
SetLog(" - Go to Train Army Tab and select your Quick Army position!", $COLOR_ACTION1)
EndIf
DeleteQueued("Troops")
If _Sleep(250) Then Return
DeleteQueued("Spells")
If _Sleep(500) Then Return
CheckCamp()
ResetVariables("donated")
If $g_bFirstStart Then $g_bFirstStart = False
If _Sleep(700) Then Return
Else
If $g_bDonationEnabled And $g_bChkDonate Then MakingDonatedTroops()
CheckIsFullQueuedAndNotFullArmy()
If Not $g_bRunState Then Return
If _Sleep($DELAYRESPOND) Then Return
CheckIsEmptyQueuedAndNotFullArmy()
If Not $g_bRunState Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_bFirstStart Then $g_bFirstStart = False
EndIf
TrainSiege()
ClickP($aAway, 2, 0, "#0346")
If _Sleep(1000) Then Return
SetLog("Army Window Closed", $COLOR_INFO)
EndGainCost("Train")
checkAttackDisable($g_iTaBChkIdle)
EndFunc
Func CheckCamp($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $bOpenArmyWindow Then
OpenArmyOverview(True, "CheckCamp()")
If _Sleep(500) Then Return
EndIf
Local $iReturnCamp = TestMaxCamp()
If $iReturnCamp = 1 Then
If Not OpenQuickTrainTab(True, "CheckCamp()") Then Return
If _Sleep(1000) Then Return
TrainArmyNumber($g_bQuickTrainArmy)
If _Sleep(700) Then Return
EndIf
If $iReturnCamp = 0 Then
CheckIsFullQueuedAndNotFullArmy()
CheckIsEmptyQueuedAndNotFullArmy()
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
EndIf
EndFunc
Func TestMaxCamp()
Local $ToReturn = 0
If Not OpenTroopsTab(True, "TestMaxCamp()") Then Return
If _Sleep(250) Then Return
Local $ArmyCamp = GetOCRCurrent(48, 160)
If UBound($ArmyCamp) = 3 Then
If $ArmyCamp[2] = 0 Or $ArmyCamp[0] = 0 Or($ArmyCamp[0] = $ArmyCamp[2]) Then
$ToReturn = 1
Else
If $ArmyCamp[1] > 560 Then SetLog(" Your CoC is outdated!!! ", $COLOR_ERROR)
SetLog(" - Your army is: " & $ArmyCamp[0], $COLOR_ACTION)
$ToReturn = 0
EndIf
EndIf
Return $ToReturn
EndFunc
Func TrainCustomArmy()
If Not $g_bRunState Then Return
If $g_bDebugSetlogTrain Then SetLog(" == Initial Custom Train == ", $COLOR_ACTION)
If $g_iActiveDonate = -1 Then PrepareDonateCC()
CheckIfArmyIsReady()
If ThSnipesSkiptrain() Then Return
If Not $g_bRunState Then Return
Local $rWhatToTrain = WhatToTrain(True, False)
Local $rRemoveExtraTroops = RemoveExtraTroops($rWhatToTrain)
If $rRemoveExtraTroops = 1 Or $rRemoveExtraTroops = 2 Then
CheckIfArmyIsReady()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $g_bIsFullArmywithHeroesAndSpells Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
Return
EndIf
EndIf
If Not $g_bRunState Then Return
If $rRemoveExtraTroops = 2 Then
$rWhatToTrain = WhatToTrain(False, False)
TrainUsingWhatToTrain($rWhatToTrain)
EndIf
If _Sleep($DELAYRESPOND) Then Return
If IsQueueEmpty("Troops") Then
If Not $g_bRunState Then Return
If Not OpenArmyTab(False, "TrainRevampOldStyle()") Then Return
$rWhatToTrain = WhatToTrain(False, False)
TrainUsingWhatToTrain($rWhatToTrain)
Else
If Not $g_bRunState Then Return
If Not OpenArmyTab(False, "TrainRevampOldStyle()") Then Return
EndIf
If _Sleep($DELAYRESPOND) Then Return
$rWhatToTrain = WhatToTrain(False, False)
If DoWhatToTrainContainSpell($rWhatToTrain) Then
If IsQueueEmpty("Spells") Then
TrainUsingWhatToTrain($rWhatToTrain, True)
Else
If Not OpenArmyTab(False, "TrainRevampOldStyle()") Then Return
EndIf
EndIf
TrainSiege()
If _Sleep(250) Then Return
If Not $g_bRunState Then Return
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
EndGainCost("Train")
checkAttackDisable($g_iTaBChkIdle)
EndFunc
Func CheckIfArmyIsReady()
If Not $g_bRunState Then Return
Local $bFullArmyCC = False
Local $iTotalSpellsToBrew = 0
Local $bFullArmyHero = False
Local $bFullSiege = False
$g_bWaitForCCTroopSpell = False
If Not OpenArmyOverview(False, "CheckIfArmyIsReady()") Then Return
If _Sleep(250) Then Return
If Not OpenArmyTab(True, "CheckIfArmyIsReady()") Then Return
If _Sleep(250) Then Return
CheckArmyCamp(False, False, False, True)
If $g_bDebugSetlogTrain Then
SetLog(" - $g_CurrentCampUtilization : " & $g_CurrentCampUtilization)
SetLog(" - $g_iTotalCampSpace : " & $g_iTotalCampSpace)
EndIf
$g_bFullArmySpells = False
For $i = 0 To $eSpellCount - 1
$iTotalSpellsToBrew += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
Next
If Number($g_iCurrentSpells) = Number($g_iTotalTrainSpaceSpell) Or Number($g_iCurrentSpells) >= Number($g_iTotalSpellValue) Or(Number($g_iCurrentSpells) >= Number($iTotalSpellsToBrew) And $g_bQuickTrainEnable = False) Then
$g_bFullArmySpells = True
EndIf
$g_bCheckSpells = CheckSpells()
$bFullArmyHero =(BitAND($g_aiSearchHeroWaitEnable[$DB], $g_iHeroAvailable) = $g_aiSearchHeroWaitEnable[$DB] And $g_abAttackTypeEnable[$DB]) Or(BitAND($g_aiSearchHeroWaitEnable[$LB], $g_iHeroAvailable) = $g_aiSearchHeroWaitEnable[$LB] And $g_abAttackTypeEnable[$LB]) Or($g_aiSearchHeroWaitEnable[$DB] = $eHeroNone And $g_aiSearchHeroWaitEnable[$LB] = $eHeroNone)
If $g_bDebugSetlogTrain Then
Setlog("Heroes are Ready: " & String($bFullArmyHero))
Setlog("Heroes Available Num: " & $g_iHeroAvailable)
Setlog("Search Hero Wait Enable [$DB] Num: " & $g_aiSearchHeroWaitEnable[$DB])
Setlog("Search Hero Wait Enable [$LB] Num: " & $g_aiSearchHeroWaitEnable[$LB])
Setlog("Dead Base BitAND: " & BitAND($g_aiSearchHeroWaitEnable[$DB], $g_iHeroAvailable))
Setlog("Live Base BitAND: " & BitAND($g_aiSearchHeroWaitEnable[$LB], $g_iHeroAvailable))
Setlog("Are you 'not' waiting for Heroes: " & String($g_aiSearchHeroWaitEnable[$DB] = $eHeroNone And $g_aiSearchHeroWaitEnable[$LB] = $eHeroNone))
Setlog("Is Wait for Heroes Active : " & IsWaitforHeroesActive())
EndIf
$bFullArmyCC = IsFullClanCastle()
$bFullSiege = CheckSiegeMachine()
If Not IsWaitforHeroesActive() And $g_bDropTrophyUseHeroes Then $bFullArmyHero = True
If Not IsWaitforHeroesActive() And Not $g_bDropTrophyUseHeroes And Not $bFullArmyHero Then
If $g_iHeroAvailable > 0 Or Number($g_aiCurrentLoot[$eLootTrophy]) <= Number($g_iDropTrophyMax) Then
$bFullArmyHero = True
Else
SetLog("Waiting for Heroes to drop trophies!", $COLOR_ACTION)
EndIf
EndIf
If $g_bFullArmy And $g_bCheckSpells And $bFullArmyHero And $bFullArmyCC And $bFullSiege Then
$g_bIsFullArmywithHeroesAndSpells = True
If $g_bFirstStart Then $g_bFirstStart = False
Else
If $g_bDebugSetlog Then
SetDebugLog(" $g_bFullArmy: " & String($g_bFullArmy), $COLOR_DEBUG)
SetDebugLog(" $g_bCheckSpells: " & String($g_bCheckSpells), $COLOR_DEBUG)
SetDebugLog(" $bFullArmyHero: " & String($bFullArmyHero), $COLOR_DEBUG)
SetDebugLog(" $bFullSiege: " & String($bFullSiege), $COLOR_DEBUG)
SetDebugLog(" $bFullArmyCC: " & String($bFullArmyCC), $COLOR_DEBUG)
EndIf
$g_bIsFullArmywithHeroesAndSpells = False
EndIf
If $g_bFullArmy And $g_bCheckSpells And $bFullArmyHero Then
If Not $bFullArmyCC Then $g_bWaitForCCTroopSpell = True
EndIf
Local $sLogText = ""
If Not $g_bFullArmy Then $sLogText &= " Troops,"
If Not $g_bCheckSpells Then $sLogText &= " Spells,"
If Not $bFullArmyHero Then $sLogText &= " Heroes,"
If Not $bFullSiege Then $sLogText &= " Siege Machine,"
If Not $bFullArmyCC Then $sLogText &= " Clan Castle,"
If StringRight($sLogText, 1) = "," Then $sLogText = StringTrimRight($sLogText, 1)
If $g_bIsFullArmywithHeroesAndSpells Then
If $g_bNotifyTGEnable And $g_bNotifyAlertCampFull Then PushMsg("CampFull")
SetLog("Chief, is your Army ready? Yes, it is!", $COLOR_SUCCESS)
Else
SetLog("Chief, is your Army ready? No, not yet!", $COLOR_ACTION)
If $sLogText <> "" Then SetLog(@TAB & "Waiting for " & $sLogText, $COLOR_ACTION)
EndIf
If Not $bFullArmyCC Then $g_bCanRequestCC = True
If $g_bDebugSetlog Then
SetDebugLog(" $g_bFullArmy: " & String($g_bFullArmy), $COLOR_DEBUG)
SetDebugLog(" $bCheckCC: " & String($bFullArmyCC), $COLOR_DEBUG)
SetDebugLog(" $g_bIsFullArmywithHeroesAndSpells: " & String($g_bIsFullArmywithHeroesAndSpells), $COLOR_DEBUG)
SetDebugLog(" $g_iTownHallLevel: " & Number($g_iTownHallLevel), $COLOR_DEBUG)
EndIf
EndFunc
Func CheckSpells()
If Not $g_bRunState Then Return
Local $bToReturn = False
If(Not $g_abSearchSpellsWaitEnable[$DB] And Not $g_abSearchSpellsWaitEnable[$LB]) Or($g_bFullArmySpells And($g_abSearchSpellsWaitEnable[$DB] Or $g_abSearchSpellsWaitEnable[$LB])) Then
Return True
EndIf
If(($g_abAttackTypeEnable[$DB] And $g_abSearchSpellsWaitEnable[$DB]) Or($g_abAttackTypeEnable[$LB] And $g_abSearchSpellsWaitEnable[$LB])) And $g_iTownHallLevel >= 5 Then
$bToReturn = $g_bFullArmySpells
Else
$bToReturn = True
EndIf
Return $bToReturn
EndFunc
Func CheckSiegeMachine()
If Not $g_bRunState Then Return
Local $bToReturn = True
If IsWaitforSiegeMachine() Then
For $i = $eSiegeWallWrecker To $eSiegeMachineCount - 1
If $g_aiCurrentSiegeMachines[$i] < $g_aiArmyCompSiegeMachine[$i] Then $bToReturn = False
If $g_bDebugSetlogTrain Then
SetLog("$g_aiCurrentSiegeMachines[" & $g_asSiegeMachineNames[$i] & "]: " & $g_aiCurrentSiegeMachines[$i])
SetLog("$g_aiArmyCompSiegeMachine[" & $g_asSiegeMachineNames[$i] & "]: " & $g_aiArmyCompSiegeMachine[$i])
EndIf
Next
Else
$bToReturn = True
EndIf
Return $bToReturn
EndFunc
Func TrainUsingWhatToTrain($rWTT, $bSpellsOnly = False)
If Not $g_bRunState Then Return
If UBound($rWTT) = 1 And $rWTT[0][0] = "Arch" And $rWTT[0][1] = 0 Then
Return True
EndIf
If Not $bSpellsOnly Then
If Not OpenTroopsTab(True, "TrainUsingWhatToTrain()") Then Return
Else
If Not OpenSpellsTab(True, "TrainUsingWhatToTrain()") Then Return
EndIf
Switch $g_bIsFullArmywithHeroesAndSpells
Case False
For $i = 0 To(UBound($rWTT) - 1)
If Not $g_bRunState Then Return
If $rWTT[$i][1] > 0 Then
If IsSpellToBrew($rWTT[$i][0]) Then
If $bSpellsOnly Then BrewUsingWhatToTrain($rWTT[$i][0], $rWTT[$i][1])
ContinueLoop
Else
If $bSpellsOnly Then ContinueLoop
EndIf
Local $NeededSpace = CalcNeededSpace($rWTT[$i][0], $rWTT[$i][1])
Local $LeftSpace = LeftSpace()
If Not $g_bRunState Then Return
If $NeededSpace <= $LeftSpace Then
If Not DragIfNeeded($rWTT[$i][0]) Then
Return False
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0], "TrainUsingWhatToTrain#1")
Local $sTroopName =($rWTT[$i][1] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $rWTT[$i][1]) Then
SetLog("Training " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_SUCCESS)
TrainIt($iTroopIndex, $rWTT[$i][1], $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
Else
Local $CountToTrain = 0
Local $CanAdd = True
Do
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $CountToTrain)
If $NeededSpace <= $LeftSpace Then
$CountToTrain += 1
Else
$CanAdd = False
EndIf
Until $CanAdd = False
If $CountToTrain > 0 Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0], "TrainUsingWhatToTrain#2")
Local $sTroopName =($CountToTrain > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $CountToTrain) Then
SetLog("Training " & $CountToTrain & "x " & $sTroopName, $COLOR_SUCCESS)
TrainIt($iTroopIndex, $CountToTrain, $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $CountToTrain & "x " & $sTroopName, $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
Next
Case True
For $i = 0 To(UBound($rWTT) - 1)
If Not $g_bRunState Then Return
If $rWTT[$i][1] > 0 Then
If IsSpellToBrew($rWTT[$i][0]) Then
If $bSpellsOnly Then BrewUsingWhatToTrain($rWTT[$i][0], $rWTT[$i][1])
ContinueLoop
Else
If $bSpellsOnly Then ContinueLoop
EndIf
Local $NeededSpace = CalcNeededSpace($rWTT[$i][0], $rWTT[$i][1])
Local $LeftSpace = LeftSpace(True)
If Not $g_bRunState Then Return
$LeftSpace =($LeftSpace[1] * 2) - $LeftSpace[0]
If $NeededSpace <= $LeftSpace Then
If Not DragIfNeeded($rWTT[$i][0]) Then
Return False
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0], "TrainUsingWhatToTrain#3")
Local $sTroopName =($rWTT[$i][1] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $rWTT[$i][1]) Then
SetLog("Training " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_SUCCESS)
TrainIt($iTroopIndex, $rWTT[$i][1], $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
Else
Local $CountToTrain = 0
Local $CanAdd = True
Do
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $CountToTrain)
If $NeededSpace <= $LeftSpace Then
$CountToTrain += 1
Else
$CanAdd = False
EndIf
Until $CanAdd = False
If $CountToTrain > 0 Then
If Not DragIfNeeded($rWTT[$i][0]) Then
Return False
EndIf
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0], "TrainUsingWhatToTrain#4")
Local $sTroopName =($CountToTrain > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $CountToTrain) Then
SetLog("Training " & $CountToTrain & "x " & $sTroopName, $COLOR_SUCCESS)
TrainIt($iTroopIndex, $CountToTrain, $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $CountToTrain & "x " & $sTroopName, $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
Next
EndSwitch
Return True
EndFunc
Func BrewUsingWhatToTrain($Spell, $Quantity)
Local $iSpellIndex = TroopIndexLookup($Spell, "BrewUsingWhatToTrain")
Local $sSpellName = $g_asSpellNames[$iSpellIndex - $eLSpell]
If $Quantity <= 0 Then Return False
If $Quantity = 9999 Then
SetLog("Brewing " & $sSpellName & " Spell Cancelled " & @CRLF & "                  Reason: Enough as set in GUI " & @CRLF & "                               This Spell not used in Attack")
Return True
EndIf
If Not $g_bRunState Then Return
If Not OpenSpellsTab(False, "BrewUsingWhatToTrain()") Then Return
Select
Case $g_bIsFullArmywithHeroesAndSpells = False
If Not _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) Then RemoveExtraTroopsQueue()
Local $NeededSpace = CalcNeededSpace($Spell, $Quantity)
Local $LeftSpace = LeftSpace()
If Not $g_bRunState Then Return
If $NeededSpace <= $LeftSpace Then
If CheckValuesCost($Spell, $Quantity) Then
SetLog("Brewing " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_SUCCESS)
TrainIt($iSpellIndex, $Quantity, $g_iTrainClickDelay)
Else
SetLog("No resources to Brew " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
EndIf
Case $g_bIsFullArmywithHeroesAndSpells = True
Local $NeededSpace = CalcNeededSpace($Spell, $Quantity)
Local $LeftSpace = LeftSpace(True)
If Not $g_bRunState Then Return
$LeftSpace =($LeftSpace[1] * 2) - $LeftSpace[0]
If $NeededSpace <= $LeftSpace Then
If CheckValuesCost($Spell, $Quantity) Then
SetLog("Brewing " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_SUCCESS)
TrainIt($iSpellIndex, $Quantity, $g_iTrainClickDelay)
Else
SetLog("No resources to Brew " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_ACTION)
$g_bOutOfElixir = True
EndIf
EndIf
EndSelect
EndFunc
Func TotalSpellsToBrewInGUI()
Local $iTotalSpellsInGUI = 0
If $g_iTotalSpellValue = 0 Then Return $iTotalSpellsInGUI
If Not $g_bRunState Then Return
For $i = 0 To $eSpellCount - 1
$iTotalSpellsInGUI += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
Next
Return $iTotalSpellsInGUI
EndFunc
Func HowManyTimesWillBeUsed($Spell)
Local $ToReturn = -1
If Not $g_bRunState Then Return
If $g_bForceBrewSpells Then
$ToReturn = 2
Return $ToReturn
EndIf
If $g_abAttackTypeEnable[$DB] Then
If $g_aiAttackAlgorithm[$DB] = 1 Then
If IsGUICheckedForSpell($Spell, $DB) Then
$ToReturn = CountCommandsForSpell($Spell, $DB)
If $ToReturn = 0 Then $ToReturn = -1
Else
$ToReturn = -1
EndIf
Else
$ToReturn = -1
EndIf
EndIf
If $g_abAttackTypeEnable[$LB] Then
If $g_aiAttackAlgorithm[$LB] = 1 Then
If IsGUICheckedForSpell($Spell, $LB) Then
$ToReturn = CountCommandsForSpell($Spell, $LB)
If $ToReturn = 0 Then $ToReturn = -1
EndIf
EndIf
EndIf
Return $ToReturn
EndFunc
Func CountCommandsForSpell($Spell, $Mode)
Local $ToReturn = 0
Local $filename = ""
If Not $g_bRunState Then Return
If $Mode = $DB Then
$filename = $g_sAttackScrScriptName[$DB]
Else
$filename = $g_sAttackScrScriptName[$LB]
EndIf
Local $rownum = 0
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
Local $f, $line, $acommand, $command
Local $value1, $Troop
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
$rownum += 1
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
$Troop = StringStripWS(StringUpper($acommand[5]), 2)
If $Troop = $Spell Then $ToReturn += 1
EndIf
WEnd
FileClose($f)
Else
$ToReturn = 0
EndIf
Return $ToReturn
EndFunc
Func IsGUICheckedForSpell($Spell, $Mode)
Local $sSpell = ""
Local $aVal = 0
If Not $g_bRunState Then Return
Switch TroopIndexLookup($Spell, "IsGUICheckedForSpell")
Case $eLSpell
$sSpell = "Lightning"
$aVal = $g_abAttackUseLightSpell
Case $eHSpell
$sSpell = "Heal"
$aVal = $g_abAttackUseHealSpell
Case $eRSpell
$sSpell = "Rage"
$aVal = $g_abAttackUseRageSpell
Case $eJSpell
$sSpell = "Jump"
$aVal = $g_abAttackUseJumpSpell
Case $eFSpell
$sSpell = "Freeze"
$aVal = $g_abAttackUseFreezeSpell
Case $eCSpell
$sSpell = "Clone"
$aVal = $g_abAttackUseCloneSpell
Case $ePSpell
$sSpell = "Poison"
$aVal = $g_abAttackUsePoisonSpell
Case $eESpell
$sSpell = "Earthquake"
$aVal = $g_abAttackUseEarthquakeSpell
Case $eHaSpell
$sSpell = "Haste"
$aVal = $g_abAttackUseHasteSpell
Case $eSkSpell
$sSpell = "Skeleton"
$aVal = $g_abAttackUseSkeletonSpell
Case $eBtSpell
$sSpell = "Bat"
$aVal = $g_abAttackUseBatSpell
EndSwitch
If IsArray($aVal) Then Return $aVal[$Mode]
Return False
EndFunc
Func DragIfNeeded($Troop)
If Not $g_bRunState Then Return
Local $bCheckPixel = False
If IsDarkTroop($Troop) Then
If _ColorCheck(_GetPixelColor(834, 403, True), Hex(0xD3D3CB, 6), 5) Then $bCheckPixel = True
If $g_bDebugSetlogTrain Then SetLog("DragIfNeeded Dark Troops: " & $bCheckPixel)
For $i = 1 To 3
If Not $bCheckPixel Then
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
If _Sleep(1500) Then Return
If _ColorCheck(_GetPixelColor(834, 403, True), Hex(0xD3D3CB, 6), 5) Then $bCheckPixel = True
Else
Return True
EndIf
Next
Else
If _ColorCheck(_GetPixelColor(22, 403, True), Hex(0xD3D3CB, 6), 5) Then $bCheckPixel = True
If $g_bDebugSetlogTrain Then SetLog("DragIfNeeded Normal Troops: " & $bCheckPixel)
For $i = 1 To 3
If Not $bCheckPixel Then
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
If _Sleep(1500) Then Return
If _ColorCheck(_GetPixelColor(22, 403, True), Hex(0xD3D3CB, 6), 5) Then $bCheckPixel = True
Else
Return True
EndIf
Next
EndIf
Local $iIndex = TroopIndexLookup($Troop, "DragIfNeeded")
If $iIndex <> -1 And $iIndex < UBound($g_asTroopNames) Then SetLog("Failed to Verify Troop " & $g_asTroopNames[$iIndex] & " Position or Failed to Drag Successfully", $COLOR_ERROR)
Return False
EndFunc
Func DoWhatToTrainContainSpell($rWTT)
For $i = 0 To(UBound($rWTT) - 1)
If Not $g_bRunState Then Return
If IsSpellToBrew($rWTT[$i][0]) Then
If $rWTT[$i][1] > 0 Then Return True
EndIf
Next
Return False
EndFunc
Func IsElixirTroop($Troop)
Local $iIndex = TroopIndexLookup($Troop, "IsElixirTroop")
If $iIndex >= $eBarb And $iIndex <= $eMine Then Return True
Return False
EndFunc
Func IsDarkTroop($Troop)
Local $iIndex = TroopIndexLookup($Troop, "IsDarkTroop")
If $iIndex >= $eMini And $iIndex <= $eIceG Then Return True
Return False
EndFunc
Func IsElixirSpell($Spell)
Local $iIndex = TroopIndexLookup($Spell, "IsElixirSpell")
If $iIndex >= $eLSpell And $iIndex <= $eCSpell Then Return True
Return False
EndFunc
Func IsDarkSpell($Spell)
Local $iIndex = TroopIndexLookup($Spell, "IsDarkSpell")
If $iIndex >= $ePSpell And $iIndex <= $eBtSpell Then Return True
Return False
EndFunc
Func IsSpellToBrew($sName)
Local $iIndex = TroopIndexLookup($sName, "IsSpellToBrew")
If $iIndex >= $eLSpell And $iIndex <= $eBtSpell Then Return True
Return False
EndFunc
Func CalcNeededSpace($Troop, $Quantity)
If Not $g_bRunState Then Return -1
Local $iIndex = TroopIndexLookup($Troop, "CalcNeededSpace")
If $iIndex = -1 Then Return -1
If $iIndex >= $eBarb And $iIndex <= $eIceG Then
Return Number($g_aiTroopSpace[$iIndex] * $Quantity)
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eBtSpell Then
Return Number($g_aiSpellSpace[$iIndex - $eLSpell] * $Quantity)
EndIf
Return -1
EndFunc
Func RemoveExtraTroops($toRemove)
Local $CounterToRemove = 0, $iResult = 0
If UBound($toRemove) = 1 And $toRemove[0][0] = "Arch" And $toRemove[0][1] = 0 Then Return 3
If $g_bIsFullArmywithHeroesAndSpells Or($g_iCommandStop = 3 Or $g_iCommandStop = 0) = True And Not $g_iActiveDonate Then Return 3
If UBound($toRemove) > 0 Then
Local $rGetSlotNumber = GetSlotNumber()
Local $rGetSlotNumberSpells = GetSlotNumber(True)
If Not IsQueueEmpty("Troops") Then
If Not OpenTroopsTab(True, "RemoveExtraTroops()") Then Return
For $i = 0 To(UBound($toRemove) - 1)
If Not $g_bRunState Then Return
If IsSpellToBrew($toRemove[$i][0]) Then ExitLoop
$CounterToRemove += 1
If IsAlreadyTraining($toRemove[$i][0]) Then
SetLog($g_asTroopNames[TroopIndexLookup($toRemove[$i][0])] & " Is in Train Tab Queue By Mistake!", $COLOR_INFO)
DeleteQueued("Troops")
$iResult = 2
EndIf
Next
EndIf
If Not IsQueueEmpty("Spells") Then
If TotalSpellsToBrewInGUI() > 0 Then
If Not OpenSpellsTab(True, "RemoveExtraTroops()") Then Return
For $i = $CounterToRemove To(UBound($toRemove) - 1)
If Not $g_bRunState Then Return
If IsAlreadyTraining($toRemove[$i][0], True) Then
SetLog($g_asSpellNames[TroopIndexLookup($toRemove[$i][0]) - $eLSpell] & " Is in Spells Tab Queue By Mistake!", $COLOR_INFO)
DeleteQueued("Spells")
$iResult = 2
EndIf
Next
EndIf
EndIf
If Not OpenArmyTab(False, "RemoveExtraTroops()") Then Return
$toRemove = WhatToTrain(True, False)
$rGetSlotNumber = GetSlotNumber()
$rGetSlotNumberSpells = GetSlotNumber(True)
SetLog("Troops To Remove: ", $COLOR_INFO)
$CounterToRemove = 0
For $i = 0 To(UBound($toRemove) - 1)
If IsSpellToBrew($toRemove[$i][0]) Then ExitLoop
$CounterToRemove += 1
SetLog(" - " & $g_asTroopNames[TroopIndexLookup($toRemove[$i][0])] & ": " & $toRemove[$i][1] & "x", $COLOR_SUCCESS)
Next
If TotalSpellsToBrewInGUI() > 0 Then
If $CounterToRemove <= UBound($toRemove) Then
SetLog("Spells To Remove: ", $COLOR_INFO)
For $i = $CounterToRemove To(UBound($toRemove) - 1)
SetLog(" - " & $g_asSpellNames[TroopIndexLookup($toRemove[$i][0]) - $eLSpell] & ": " & $toRemove[$i][1] & "x", $COLOR_SUCCESS)
Next
EndIf
EndIf
If Not _CheckPixel($aButtonEditArmy, True) Then
SetLog("Cannot find/verify 'Edit Army' Button in Army tab", $COLOR_WARNING)
Return False
EndIf
ClickP($aButtonEditArmy, 1)
If _Sleep(500) Then Return
If Not $g_bRunState Then Return
$CounterToRemove = 0
For $j = 0 To(UBound($toRemove) - 1)
If IsSpellToBrew($toRemove[$j][0]) Then ExitLoop
$CounterToRemove += 1
For $i = 0 To(UBound($rGetSlotNumber) - 1)
If $toRemove[$j][0] = $rGetSlotNumber[$i] Then
Local $pos = GetSlotRemoveBtnPosition($i + 1)
ClickRemoveTroop($pos, $toRemove[$j][1], $g_iTrainClickDelay)
EndIf
Next
Next
If TotalSpellsToBrewInGUI() > 0 Then
For $j = $CounterToRemove To(UBound($toRemove) - 1)
For $i = 0 To(UBound($rGetSlotNumberSpells) - 1)
If $toRemove[$j][0] = $rGetSlotNumberSpells[$i] Then
Local $pos = GetSlotRemoveBtnPosition($i + 1, True)
ClickRemoveTroop($pos, $toRemove[$j][1], $g_iTrainClickDelay)
EndIf
Next
Next
EndIf
If _Sleep(400) Then Return
Local $counter = 0
While Not _CheckPixel($aButtonRemoveTroopsOK1, True)
If _Sleep(200) Then Return
$counter += 1
If $counter <= 5 Then ContinueLoop
SetLog("Cannot find/verify 'Okay' Button in Army tab", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(400) Then OpenArmyOverview(True, "RemoveExtraTroops()")
Return False
WEnd
ClickP($aButtonRemoveTroopsOK1, 1)
If _Sleep(400) Then Return
$counter = 0
While Not _CheckPixel($aButtonRemoveTroopsOK2, True)
If _Sleep(200) Then Return
$counter += 1
If $counter <= 5 Then ContinueLoop
SetLog("Cannot find/verify 'Okay #2' Button in Army tab", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#0346")
Return False
WEnd
ClickP($aButtonRemoveTroopsOK2, 1)
SetLog("All Extra troops removed", $COLOR_SUCCESS)
If _Sleep(200) Then Return
If $iResult = 0 Then $iResult = 1
Else
SetLog("No extra troop to remove, great", $COLOR_SUCCESS)
$iResult = 3
EndIf
Return $iResult
EndFunc
Func DeleteInvalidTroopInArray(ByRef $aTroopArray)
Local $iCounter = 0
Switch(UBound($aTroopArray, 2) > 0)
Case True
Local $bIsValid = True, $i2DBound = UBound($aTroopArray, 2)
For $i = 0 To(UBound($aTroopArray) - 1)
If $aTroopArray[$i][0] Then
If TroopIndexLookup($aTroopArray[$i][0], "DeleteInvalidTroopInArray#1") = -1 Or $aTroopArray[$i][0] = "" Then $bIsValid = False
If $bIsValid Then
For $j = 0 To(UBound($aTroopArray, 2) - 1)
$aTroopArray[$iCounter][$j] = $aTroopArray[$i][$j]
Next
$iCounter += 1
EndIf
EndIf
Next
ReDim $aTroopArray[$iCounter][$i2DBound]
Case Else
For $i = 0 To(UBound($aTroopArray) - 1)
If TroopIndexLookup($aTroopArray[$i], "DeleteInvalidTroopInArray#2") = -1 Or $aTroopArray[$i] = "" Then
$aTroopArray[$iCounter] = $aTroopArray[$i]
$iCounter += 1
EndIf
Next
ReDim $aTroopArray[$iCounter]
EndSwitch
EndFunc
Func RemoveExtraTroopsQueue()
If $g_bIsFullArmywithHeroesAndSpells Then Return True
Local Const $y = 186, $yRemoveBtn = 200, $xDecreaseRemoveBtn = 10
Local $bColorCheck = False, $bGotRemoved = False
For $x = 834 To 58 Step -70
If Not $g_bRunState Then Return
$bColorCheck = _ColorCheck(_GetPixelColor($x, $y, True), Hex(0xD7AFA9, 6), 20)
If $bColorCheck Then
$bGotRemoved = True
Do
Click($x - $xDecreaseRemoveBtn, $yRemoveBtn, 2, $g_iTrainClickDelay)
If _Sleep(20) Then Return
$bColorCheck = _ColorCheck(_GetPixelColor($x, $y, True), Hex(0xD7AFA9, 6), 20)
Until $bColorCheck = False
ElseIf Not $bColorCheck And $bGotRemoved Then
ExitLoop
EndIf
Next
Return True
EndFunc
Func IsAlreadyTraining($Troop, $bSpells = False)
If Not $g_bRunState Then Return
If $bSpells Then
If IsQueueEmpty("Troops") Then Return False
Local $QueueTroops = CheckQueueTroops(False, False)
For $i = 0 To(UBound($QueueTroops) - 1)
If $QueueTroops[$i] = $Troop Then Return True
Next
Else
If IsQueueEmpty("Spells", False, $g_bForceBrewSpells = True ? False : True) Then Return False
Local $QueueSpells = CheckQueueSpells(False, False)
For $i = 0 To(UBound($QueueSpells) - 1)
If $QueueSpells[$i] = $Troop Then Return True
Next
EndIf
Return False
EndFunc
Func IsQueueEmpty($sType = "Troops", $bSkipTabCheck = False, $removeExtraTroopsQueue = True)
Local $iArrowX, $iArrowY
If Not $g_bRunState Then Return
If $sType = "Troops" Then
$iArrowX = $aGreenArrowTrainTroops[0]
$iArrowY = $aGreenArrowTrainTroops[1]
ElseIf $sType = "Spells" Then
$iArrowX = $aGreenArrowBrewSpells[0]
$iArrowY = $aGreenArrowBrewSpells[1]
EndIf
If Not _ColorCheck(_GetPixelColor($iArrowX, $iArrowY, True), Hex(0xa0d077, 6), 30) And Not _ColorCheck(_GetPixelColor($iArrowX, $iArrowY + 4, True), Hex(0x6ab320, 6), 30) Then
Return True
ElseIf _ColorCheck(_GetPixelColor($iArrowX, $iArrowY, True), Hex(0xa0d077, 6), 30) And _ColorCheck(_GetPixelColor($iArrowX, $iArrowY + 4, True), Hex(0x6ab320, 6), 30) And Not $removeExtraTroopsQueue Then
If Not WaitforPixel($iArrowX - 11, $iArrowY - 1, $iArrowX - 9, $iArrowY + 1, Hex(0xa0d077, 6), 30, 2) Then Return False
EndIf
If Not $bSkipTabCheck Then
If $sType = "Troops" Then
If Not OpenTroopsTab(True, "IsQueueEmpty()") Then Return
Else
If Not OpenSpellsTab(True, "IsQueueEmpty()") Then Return
EndIf
EndIf
If Not $g_bIsFullArmywithHeroesAndSpells Then
If $removeExtraTroopsQueue Then
If Not _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) Then RemoveExtraTroopsQueue()
EndIf
EndIf
If $removeExtraTroopsQueue Then
If _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 20) Then Return True
Else
If _ColorCheck(_GetPixelColor(820, 208, True), Hex(0xD0D0C8, 6), 20) Then Return True
EndIf
Return False
EndFunc
Func ClickRemoveTroop($pos, $iTimes, $iSpeed)
$pos[0] = Random($pos[0] - 3, $pos[0] + 10, 1)
$pos[1] = Random($pos[1] - 5, $pos[1] + 5, 1)
If Not $g_bRunState Then Return
If _Sleep(400) Then Return
If $iTimes <> 1 Then
If FastCaptureRegion() Then
For $i = 0 To($iTimes - 1)
PureClick($pos[0], $pos[1], 1, $iSpeed)
If _Sleep($iSpeed, False) Then ExitLoop
Next
Else
PureClick($pos[0], $pos[1], $iTimes, $iSpeed)
If _Sleep($iSpeed, False) Then Return
EndIf
Else
PureClick($pos[0], $pos[1], 1, $iSpeed)
If _Sleep($iSpeed, False) Then Return
EndIf
EndFunc
Func GetSlotRemoveBtnPosition($iSlot, $bSpells = False)
Local $iRemoveY = Not $bSpells ? 270 : 417
Local $iRemoveX = Number((74 * $iSlot) - 4)
Local Const $aResult[2] = [$iRemoveX, $iRemoveY]
Return $aResult
EndFunc
Func GetSlotNumber($bSpells = False)
Select
Case $bSpells = False
Local Const $Orders = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eEDrag, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eIceG]
Local $allCurTroops[UBound($Orders)]
For $i = 0 To $eTroopCount - 1
If Not $g_bRunState Then Return
If $g_aiCurrentTroops[$i] > 0 Then
For $j = 0 To(UBound($Orders) - 1)
If TroopIndexLookup($g_asTroopShortNames[$i], "GetSlotNumber#1") = $Orders[$j] Then
$allCurTroops[$j] = $g_asTroopShortNames[$i]
EndIf
Next
EndIf
Next
_ArryRemoveBlanks($allCurTroops)
Return $allCurTroops
Case $bSpells = True
Local Const $SpellsOrders = [$eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell, $eBtSpell]
Local $allCurSpells[UBound($SpellsOrders)]
For $i = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
If $g_aiCurrentSpells[$i] > 0 Then
For $j = 0 To(UBound($SpellsOrders) - 1)
If TroopIndexLookup($g_asSpellShortNames[$i], "GetSlotNumber#2") = $SpellsOrders[$j] Then
$allCurSpells[$j] = $g_asSpellShortNames[$i]
EndIf
Next
EndIf
Next
_ArryRemoveBlanks($allCurSpells)
Return $allCurSpells
EndSelect
EndFunc
Func WhatToTrain($ReturnExtraTroopsOnly = False, $bSetLog = True)
If Not OpenArmyTab(False, "WhatToTrain()") Then Return
Local $ToReturn[1][2] = [["Arch", 0]]
If $g_bIsFullArmywithHeroesAndSpells And Not $ReturnExtraTroopsOnly Then
If $g_iCommandStop = 3 Or $g_iCommandStop = 0 Then
If $g_bFirstStart Then $g_bFirstStart = False
Return $ToReturn
EndIf
SetLog(" - Your Army is Full, let's make troops before Attack!", $COLOR_INFO)
For $i = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$i]
If $g_aiArmyCompTroops[$troopIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompTroops[$troopIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To $eSpellCount - 1
Local $BrewIndex = $g_aiBrewOrder[$i]
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiArmyCompSpells[$BrewIndex] > 0 Then
If HowManyTimesWillBeUsed($g_asSpellShortNames[$BrewIndex]) > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$BrewIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
Else
getArmySpells(False, False, False, False)
If $g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
Else
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = 9999
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
EndIf
Next
Return $ToReturn
EndIf
getArmyTroops(False, False, False, False)
getArmySpells(False, False, False, False)
Switch $ReturnExtraTroopsOnly
Case False
For $ii = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$ii]
If $g_aiArmyCompTroops[$troopIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To $eSpellCount - 1
Local $BrewIndex = $g_aiBrewOrder[$i]
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiArmyCompSpells[$BrewIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
Case Else
For $ii = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$ii]
If $g_aiCurrentTroops[$troopIndex] > 0 Then
If $g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex] < 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = Abs($g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex])
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
Next
For $i = 0 To $eSpellCount - 1
Local $BrewIndex = $g_aiBrewOrder[$i]
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiCurrentSpells[$BrewIndex] > 0 Then
If $g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex] < 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = Abs($g_aiArmyCompSpells[$BrewIndex] - $g_aiCurrentSpells[$BrewIndex])
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
Next
EndSwitch
DeleteInvalidTroopInArray($ToReturn)
Return $ToReturn
EndFunc
Func TestTroopsCoords()
Local $iCount = 3
$g_bRunState = True
For $i = 0 To $eTroopCount - 1
DragIfNeeded($g_asTroopShortNames[$i])
TrainIt(TroopIndexLookup($g_asTroopShortNames[$i], "TestTroopsCoords"), $iCount, $g_iTrainClickDelay)
Next
$g_bRunState = False
EndFunc
Func TestSpellsCoords()
Local $iCount = 1
$g_bRunState = True
For $i = 0 To $eSpellCount - 1
TrainIt(TroopIndexLookup($g_asTroopShortNames[$i]), $iCount, $g_iTrainClickDelay)
Next
$g_bRunState = False
EndFunc
Func LeftSpace($bReturnAll = False)
Local $aRemainTrainSpace = GetOCRCurrent(48, 160)
If Not $g_bRunState Then Return
If Not $bReturnAll Then
Return Number($aRemainTrainSpace[2])
Else
Return $aRemainTrainSpace
EndIf
EndFunc
Func IsArmyWindow($bSetLog = False, $iTabNumber = 0)
Local $i = 0
Local $_TabNumber[4][4] = [[114, 115, 0xF8F8F8, 5], [284, 115, 0xF8F8F8, 5], [460, 115, 0xF8F8F8, 5], [702, 115, 0xF8F8F8, 5]]
Local $CheckIT[4] = [$_TabNumber[$iTabNumber][0], $_TabNumber[$iTabNumber][1], $_TabNumber[$iTabNumber][2], $_TabNumber[$iTabNumber][3]]
Local $txt = ""
Switch $iTabNumber
Case $ArmyTAB
$txt = "Army Window"
Case $TrainTroopsTAB
$txt = "Train Troops Window"
Case $BrewSpellsTAB
$txt = "Brew Spells Window"
Case $QuickTrainTAB
$txt = "Quick Train Window"
EndSwitch
If _CheckPixel($aIsTrainPgChk1, True) Then
While $i < 1
If Not $g_bRunState Then Return
If $g_bDebugSetlogTrain Then SetLog("$CheckIT[0]: " & $CheckIT[0])
If $g_bDebugSetlogTrain Then SetLog("$CheckIT[1]: " & $CheckIT[1])
If $g_bDebugSetlogTrain Then SetLog("$CheckIT[2]: " & Hex($CheckIT[2], 6))
If $g_bDebugSetlogTrain Then SetLog("$CheckIT[3]: " & $CheckIT[3])
If _ColorCheck(_GetPixelColor($CheckIT[0], $CheckIT[1], True), Hex($CheckIT[2], 6), $CheckIT[3]) Then ExitLoop
If _Sleep($DELAYISTRAINPAGE2) Then ExitLoop
$i += 1
WEnd
Else
$i = 1
If $bSetLog Or $g_bDebugSetlogTrain Then SetLog("Cannot find Red X | TAB " & $txt, $COLOR_ERROR)
EndIf
If $i < 1 Then
If($g_bDebugSetlog Or $g_bDebugClick) Or $bSetLog Or $g_bDebugSetlogTrain Then SetLog("**" & $txt & " OK**", $COLOR_DEBUG)
Return True
Else
If $bSetLog Or $g_bDebugSetlogTrain Then SetLog("You are not in " & $txt & " | TAB " & $iTabNumber, $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave("IsTrainPage")
Return False
EndIf
EndFunc
Func CheckQueueTroops($bGetQuantity = True, $bSetLog = True, $x = 839, $bQtyWSlot = False)
Local $aResult[1] = [""]
If $bSetLog Then SetLog("Checking Troops Queue...", $COLOR_INFO)
Local $Dir = @ScriptDir & "\imgxml\ArmyOverview\TroopQueued"
Local $aSearchResult = SearchArmy($Dir, 18, 182, $x, 261, $bGetQuantity ? "Queue" : "")
ReDim $aResult[UBound($aSearchResult)]
If $aSearchResult[0][0] = "" Then
Setlog("No Troops detected!", $COLOR_ERROR)
Return
EndIf
For $i = 0 To(UBound($aSearchResult) - 1)
If Not $g_bRunState Then Return
$aResult[$i] = $aSearchResult[$i][0]
Next
If $bGetQuantity Then
Local $aQuantities[UBound($aResult)][2]
Local $aQueueTroop[$eTroopCount]
For $i = 0 To(UBound($aQuantities) - 1)
$aQuantities[$i][0] = $aSearchResult[$i][0]
$aQuantities[$i][1] = $aSearchResult[$i][3]
Local $iTroopIndex = TroopIndexLookup($aQuantities[$i][0])
If $iTroopIndex >= 0 And $iTroopIndex < $eTroopCount Then
If $bSetLog Then SetLog("  - " & $g_asTroopNames[TroopIndexLookup($aQuantities[$i][0], "CheckQueueTroops")] & ": " & $aQuantities[$i][1] & "x", $COLOR_SUCCESS)
$aQueueTroop[$iTroopIndex] += $aQuantities[$i][1]
Else
SetDebugLog("Unsupport troop index: " & $iTroopIndex)
EndIf
Next
If $bQtyWSlot Then Return $aQuantities
Return $aQueueTroop
EndIf
_ArrayReverse($aResult)
Return $aResult
EndFunc
Func CheckQueueSpells($bGetQuantity = True, $bSetLog = True, $x = 839, $bQtyWSlot = False)
Local $aResult[1] = [""], $sImageDir = "trainwindow-SpellsInQueue-bundle"
If $bSetLog Then SetLog("Checking Spells Queue...", $COLOR_INFO)
Local $aSearchResult = SearchArmy($sImageDir, 18, 215, $x, 230, $bGetQuantity ? "Queue" : "")
ReDim $aResult[UBound($aSearchResult)]
If $aSearchResult[0][0] = "" Then
Setlog("No Spells detected!", $COLOR_ERROR)
Return
EndIf
For $i = 0 To(UBound($aSearchResult) - 1)
If Not $g_bRunState Then Return
$aResult[$i] = $aSearchResult[$i][0]
Next
If $bGetQuantity Then
Local $aQuantities[UBound($aResult)][2]
Local $aQueueSpell[$eSpellCount]
For $i = 0 To(UBound($aQuantities) - 1)
If Not $g_bRunState Then Return
$aQuantities[$i][0] = $aSearchResult[$i][0]
$aQuantities[$i][1] = $aSearchResult[$i][3]
If $bSetLog Then SetLog("  - " & $g_asSpellNames[TroopIndexLookup($aQuantities[$i][0], "CheckQueueSpells") - $eLSpell] & ": " & $aQuantities[$i][1] & "x", $COLOR_SUCCESS)
$aQueueSpell[TroopIndexLookup($aQuantities[$i][0]) - $eLSpell] += $aQuantities[$i][1]
Next
If $bQtyWSlot Then Return $aQuantities
Return $aQueueSpell
EndIf
_ArrayReverse($aResult)
Return $aResult
EndFunc
Func SearchArmy($sImageDir = "", $x = 0, $y = 0, $x1 = 0, $y1 = 0, $sArmyType = "", $bSkipReceivedTroopsCheck = False)
Local $aResult[1][4], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
For $iCount = 0 To 10
If Not $g_bRunState Then Return $aResult
If Not getReceivedTroops(162, 200, $bSkipReceivedTroopsCheck) Then
_CaptureRegion2($x, $y, $x1, $y1)
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $sImageDir, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)][4]
Local $iResultAddDup = 0
For $i = 0 To UBound($aKeys) - 1
$aResult[$i + $iResultAddDup][0] = RetrieveImglocProperty($aKeys[$i], "objectname")
$aValue = RetrieveImglocProperty($aKeys[$i], "objectpoints")
$aCoords = decodeMultipleCoords($aValue, 50)
$aCoordsSplit = $aCoords[0]
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[0][0] = $aCoordsSplit[0] + $x
$aCoordArray[0][1] = $aCoordsSplit[1] + $y
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
$aResult[$i + $iResultAddDup][1] = Number($aCoordArray[0][0])
$aResult[$i + $iResultAddDup][2] = Number($aCoordArray[0][1])
SetDebugLog($aResult[$i + $iResultAddDup][0] & " | $aCoordArray: " & $aCoordArray[0][0] & "-" & $aCoordArray[0][1])
Local $iMultipleCoords = UBound($aCoords)
If $iMultipleCoords > 1 Then
SetDebugLog($aResult[$i + $iResultAddDup][0] & " detected " & $iMultipleCoords & " times!")
For $j = 1 To $iMultipleCoords - 1
Local $aCoordsSplit2 = $aCoords[$j]
If UBound($aCoordsSplit2) = 2 Then
$iResultAddDup += 1
ReDim $aResult[UBound($aKeys) + $iResultAddDup][4]
$aResult[$i + $iResultAddDup][0] = $aResult[$i + $iResultAddDup - 1][0]
$aResult[$i + $iResultAddDup][1] = $aCoordsSplit2[0] + $x
$aResult[$i + $iResultAddDup][2] = $aCoordsSplit2[1]
SetDebugLog($aResult[$i + $iResultAddDup][0] & " | $aCoordArray: " & $aResult[$i + $iResultAddDup][1] & "-" & $aResult[$i + $iResultAddDup][2])
EndIf
Next
EndIf
Next
ExitLoop
EndIf
ExitLoop
Else
If $iCount = 1 Then SetLog("You have received castle troops! Wait 5's...")
If _Sleep($DELAYTRAIN8) Then Return $aResult
EndIf
Next
_ArraySort($aResult, 0, 0, 0, 1)
While 1
If UBound($aResult) < 2 Then ExitLoop
For $i = 1 To UBound($aResult) - 1
If $aResult[$i][0] = $aResult[$i - 1][0] And Abs($aResult[$i][1] - $aResult[$i - 1][1]) <= 50 Then
SetDebugLog("Double detection " & $aResult[$i][0] & " at " & $i - 1 & ": " & $aResult[$i][1] & " & " & $aResult[$i - 1][1])
_ArrayDelete($aResult, $i)
ContinueLoop 2
EndIf
Next
ExitLoop
WEnd
If $sArmyType = "Troops" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "troop"), 196))
Next
EndIf
If $sArmyType = "Spells" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "spells"), 341))
Next
EndIf
If $sArmyType = "CCSpells" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "troop"), 498))
Next
EndIf
If $sArmyType = "Heroes" Then
For $i = 0 To UBound($aResult) - 1
If StringInStr($aResult[$i][0], "Kingqueued") Then
$aResult[$i][3] = getRemainTHero(619, 414)
ElseIf StringInStr($aResult[$i][0], "Queenqueued") Then
$aResult[$i][3] = getRemainTHero(693, 414)
ElseIf StringInStr($aResult[$i][0], "Wardenqueued") Then
$aResult[$i][3] = getRemainTHero(767, 414)
Else
$aResult[$i][3] = 0
EndIf
Next
EndIf
If $sArmyType = "Queue" Then
Local $xSlot
For $i = 0 To UBound($aResult) - 1
$xSlot = Int(Number($aResult[$i][1]) / 71) * 71 - 6
$aResult[$i][3] = Number(getQueueTroopsQuantity($xSlot, 192))
SetDebugLog($aResult[$i][0] & " (" & $xSlot & ") x" & $aResult[$i][3])
Next
EndIf
Return $aResult
EndFunc
Func ResetVariables($sArmyType = "")
If $sArmyType = "troops" Or $sArmyType = "all" Then
For $i = 0 To $eTroopCount - 1
If Not $g_bRunState Then Return
$g_aiCurrentTroops[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
EndIf
If $sArmyType = "Spells" Or $sArmyType = "all" Then
For $i = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
$g_aiCurrentSpells[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
EndIf
If $sArmyType = "SiegeMachines" Or $sArmyType = "all" Then
For $i = 0 To $eSiegeMachineCount - 1
If Not $g_bRunState Then Return
$g_aiCurrentSiegeMachines[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
EndIf
If $sArmyType = "donated" Or $sArmyType = "all" Then
For $i = 0 To $eTroopCount - 1
If Not $g_bRunState Then Return
$g_aiDonateTroops[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
For $i = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
$g_aiDonateSpells[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
For $i = 0 To $eSiegeMachineCount - 1
If Not $g_bRunState Then Return
$g_aiDonateSiegeMachines[$i] = 0
If _Sleep($DELAYTRAIN6) Then Return
Next
EndIf
EndFunc
Func TrainArmyNumber($Army, $iMultiClick = 1)
Local $a_TrainArmy[3][4] = [[784, 368, 0x73BC2F, 10], [784, 486, 0x73BC2F, 10], [784, 602, 0x73BC2F, 10]]
SetLog("Using Quick Train Tab", $COLOR_INFO)
If Not $g_bRunState Then Return
For $Num = 0 To 2
If $Army[$Num] Then
Local $iClick = 2, $sLog = ""
If $Num = 2 Then $iClick = $iMultiClick
If $iClick > 2 Then $sLog = ", Multi-click x" & $iClick & " times"
If _ColorCheck(_GetPixelColor($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], True), Hex($a_TrainArmy[$Num][2], 6), $a_TrainArmy[$Num][3]) Then
Click($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], $iClick)
SetLog(" - Making the Army " & $Num + 1 & $sLog, $COLOR_INFO)
If _Sleep(500) Then Return
Else
SetLog(" - Error Clicking On Army: " & $Num + 1 & "| Pixel was :" & _GetPixelColor($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], True), $COLOR_ACTION)
SetLog(" - Please 'edit' the Army " & $Num + 1 & " before start the BOT!!!", $COLOR_ERROR)
EndIf
EndIf
Next
EndFunc
Func DeleteQueued($sArmyTypeQueued, $iOffsetQueued = 802)
If $sArmyTypeQueued = "Troops" Then
If Not OpenTroopsTab(True, "DeleteQueued()") Then Return
ElseIf $sArmyTypeQueued = "Spells" Then
If Not OpenSpellsTab(True, "DeleteQueued()") Then Return
Else
Return
EndIf
If _Sleep(500) Then Return
Local $x = 0
While Not IsQueueEmpty($sArmyTypeQueued, True, False)
If $x = 0 Then SetLog(" - Delete " & $sArmyTypeQueued & " Queued!", $COLOR_INFO)
If _Sleep(20) Then Return
If Not $g_bRunState Then Return
Click($iOffsetQueued + 24, 202, 2, 50)
$x += 1
If $x = 290 Then ExitLoop
WEnd
EndFunc
Func MakingDonatedTroops($sType = "All")
Local $avDefaultTroopGroup[$eTroopCount][6]
For $i = 0 To $eTroopCount - 1
$avDefaultTroopGroup[$i][0] = $g_asTroopShortNames[$i]
$avDefaultTroopGroup[$i][1] = $i
$avDefaultTroopGroup[$i][2] = $g_aiTroopSpace[$i]
$avDefaultTroopGroup[$i][3] = $g_aiTroopTrainTime[$i]
$avDefaultTroopGroup[$i][4] = 0
$avDefaultTroopGroup[$i][5] = $i >= $eMini ? "d" : "e"
Next
Local $RemainTrainSpace
Local $Plural = 0
Local $areThereDonTroop = 0
Local $areThereDonSpell = 0
Local $areThereDonSiegeMachine = 0
For $j = 0 To $eTroopCount - 1
If $sType <> "Troops" And $sType <> "All" Then ExitLoop
If Not $g_bRunState Then Return
$areThereDonTroop += $g_aiDonateTroops[$j]
Next
For $j = 0 To $eSpellCount - 1
If $sType <> "Spells" And $sType <> "All" Then ExitLoop
If Not $g_bRunState Then Return
$areThereDonSpell += $g_aiDonateSpells[$j]
Next
For $j = 0 To $eSiegeMachineCount - 1
If $sType <> "Siege" And $sType <> "All" Then ExitLoop
If Not $g_bRunState Then Return
$areThereDonSiegeMachine += $g_aiDonateSiegeMachines[$j]
Next
If $areThereDonSpell = 0 And $areThereDonTroop = 0 And $areThereDonSiegeMachine = 0 Then Return
SetLog("  making donated troops", $COLOR_ACTION1)
If $areThereDonTroop > 0 Then
For $i = 0 To UBound($avDefaultTroopGroup) - 1
For $j = 0 To $eTroopCount - 1
If $g_asTroopShortNames[$j] = $avDefaultTroopGroup[$i][0] Then
$avDefaultTroopGroup[$i][4] = $g_aiDonateTroops[$j]
$g_aiDonateTroops[$j] = 0
EndIf
Next
Next
If Not OpenTroopsTab(True, "MakingDonatedTroops()") Then Return
For $i = 0 To UBound($avDefaultTroopGroup, 1) - 1
If Not $g_bRunState Then Return
$Plural = 0
If $avDefaultTroopGroup[$i][4] > 0 Then
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[2] < 0 Then $RemainTrainSpace[2] = $RemainTrainSpace[1] * 2 - $RemainTrainSpace[0]
If $RemainTrainSpace[2] = 0 Then ExitLoop
Local $iTroopIndex = TroopIndexLookup($avDefaultTroopGroup[$i][0], "MakingDonatedTroops")
If $avDefaultTroopGroup[$i][2] * $avDefaultTroopGroup[$i][4] <= $RemainTrainSpace[2] Then
Local $howMuch = $avDefaultTroopGroup[$i][4]
If $avDefaultTroopGroup[$i][5] = "e" Then
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
Else
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
EndIf
If _Sleep($DELAYRESPOND) Then Return
Local $sTroopName =($avDefaultTroopGroup[$i][4] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
SetLog(" - Trained " & $avDefaultTroopGroup[$i][4] & " " & $sTroopName, $COLOR_ACTION)
$avDefaultTroopGroup[$i][4] = 0
If _Sleep(1000) Then Return
Else
For $z = 0 To $RemainTrainSpace[2] - 1
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] = $RemainTrainSpace[1] Then
For $j = 0 To UBound($avDefaultTroopGroup, 1) - 1
$avDefaultTroopGroup[$j][4] = 0
Next
ExitLoop(2)
EndIf
If $avDefaultTroopGroup[$i][2] <= $RemainTrainSpace[2] And $avDefaultTroopGroup[$i][4] > 0 Then
Local $howMuch = 1
If $iTroopIndex >= $eBarb And $iTroopIndex <= $eMine Then
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
Else
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
EndIf
If _Sleep($DELAYRESPOND) Then Return
Local $sTroopName =($avDefaultTroopGroup[$i][4] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
SetLog(" - Trained " & $avDefaultTroopGroup[$i][4] & " " & $sTroopName, $COLOR_ACTION)
$avDefaultTroopGroup[$i][4] -= 1
If _Sleep(1000) Then Return
Else
ExitLoop
EndIf
Next
EndIf
EndIf
Next
If $sType = "All" Then
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] < $RemainTrainSpace[1] Then
Local $howMuch = $RemainTrainSpace[2]
TrainIt($eTroopArcher, $howMuch, $g_iTrainClickDelay)
If $RemainTrainSpace[2] > 0 Then $Plural = 1
SetLog(" - Trained " & $howMuch & " archer(s)!", $COLOR_ACTION)
If _Sleep(1000) Then Return
EndIf
EndIf
EndIf
If $areThereDonSpell > 0 Then
If Not OpenSpellsTab(True, "MakingDonatedTroops()") Then Return
For $i = 0 To $eSpellCount - 1
If Not $g_bRunState Then Return
If $g_aiDonateSpells[$i] > 0 Then
Local $pos = GetTrainPos($i + $eLSpell)
Local $howMuch = $g_aiDonateSpells[$i]
TrainIt($eLSpell + $i, $howMuch, $g_iTrainClickDelay)
If _Sleep($DELAYRESPOND) Then Return
SetLog(" - Brewed " & $howMuch & " " & $g_asSpellNames[$i] &($howMuch > 1 ? " Spells" : " Spell"), $COLOR_ACTION)
$g_aiDonateSpells[$i] -= $howMuch
If _Sleep(1000) Then Return
$RemainTrainSpace = GetOCRCurrent(48, 160)
SetLog(" - Current Capacity: " & $RemainTrainSpace[0] & "/" &($RemainTrainSpace[1]))
EndIf
Next
EndIf
If $areThereDonSiegeMachine > 0 Then
If Not OpenSiegeMachinesTab(True, "MakingDonatedTroops()") Then Return
For $iSiegeIndex = $eSiegeWallWrecker To $eSiegeMachineCount - 1
If Not $g_bRunState Then Return
If $g_aiDonateSiegeMachines[$iSiegeIndex] > 0 Then
Local $aCheckIsAvailableSiege[4] = [58, 556, 0x47717E, 10]
Local $aCheckIsAvailableSiege1[4] = [229, 556, 0x47717E, 10]
Local $aCheckIsAvailableSiege2[4] = [400, 556, 0x47717E, 10]
Local $checkPixel
If $iSiegeIndex = $eSiegeWallWrecker Then $checkPixel = $aCheckIsAvailableSiege
If $iSiegeIndex = $eSiegeBattleBlimp Then $checkPixel = $aCheckIsAvailableSiege1
If $iSiegeIndex = $eSiegeStoneSlammer Then $checkPixel = $aCheckIsAvailableSiege2
Local $HowMany = $g_aiDonateSiegeMachines[$iSiegeIndex]
If _CheckPixel($checkPixel, True, Default, $g_asSiegeMachineNames[$iSiegeIndex]) Then
If _Sleep($DELAYRESPOND) Then Return
PureClick($checkPixel[0], $checkPixel[1], $HowMany, $g_iTrainClickDelay)
SetLog(" - Trained " & $HowMany & " " & $g_asSiegeMachineNames[$iSiegeIndex] &($HowMany > 1 ? " SiegeMachines" : " SiegeMachine"), $COLOR_ACTION)
$g_aiDonateSiegeMachines[$iSiegeIndex] -= $HowMany
EndIf
EndIf
Next
Local $sSiegeInfo = getArmyCapacityOnTrainTroops(57, 160)
If $g_bDebugSetlogTrain Then SetLog("OCR $sSiegeInfo = " & $sSiegeInfo, $COLOR_DEBUG)
Local $aGetSiegeCap = StringSplit($sSiegeInfo, "#", $STR_NOCOUNT)
SetLog("Total Siege Workshop Capacity: " & $aGetSiegeCap[0] & "/" & $aGetSiegeCap[1])
If Number($aGetSiegeCap[0]) = 0 Then Return
EndIf
Return True
EndFunc
Func GetOCRCurrent($x_start, $y_start)
Local $aResult[3] = [0, 0, 0]
If Not $g_bRunState Then Return $aResult
Local $iOCRResult = getArmyCapacityOnTrainTroops($x_start, $y_start)
If StringInStr($iOCRResult, "#") Then
Local $aTempResult = StringSplit($iOCRResult, "#", $STR_NOCOUNT)
$aResult[0] = Number($aTempResult[0])
$aResult[1] = Number($aTempResult[1])
If $aResult[1] <= 22 Then
If $g_bDebugSetlogTrain Then SetLog("$g_iTotalSpellValue: " & $g_iTotalSpellValue, $COLOR_DEBUG)
$aResult[1] = $g_iTotalSpellValue
$aResult[2] = $g_iTotalSpellValue - $aResult[0]
ElseIf $aResult[1] <> $g_iTotalCampSpace Then
If $g_bDebugSetlogTrain Then SetLog("$g_iTotalCampSpace: " & $g_iTotalCampSpace, $COLOR_DEBUG)
$aResult[1] = $g_iTotalCampSpace
$aResult[2] = $g_iTotalCampSpace - $aResult[0]
EndIf
$aResult[2] = $aResult[1] - $aResult[0]
Else
SetLog("DEBUG | ERROR on GetOCRCurrent", $COLOR_ERROR)
EndIf
Return $aResult
EndFunc
Func CheckIsFullQueuedAndNotFullArmy()
SetLog(" - Checking: FULL Queue and Not Full Army", $COLOR_INFO)
Local $CheckTroop[4] = [824, 243, 0x94A522, 20]
If Not $g_bRunState Then Return
If Not OpenTroopsTab(True, "CheckIsFullQueuedAndNotFullArmy()") Then Return
Local $aArmyCamp = GetOCRCurrent(48, 160)
If UBound($aArmyCamp) = 3 And $aArmyCamp[2] < 0 Then
If _ColorCheck(_GetPixelColor($CheckTroop[0], $CheckTroop[1], True), Hex($CheckTroop[2], 6), $CheckTroop[3]) Then
SetLog(" - Conditions met: FULL Queue and Not Full Army")
DeleteQueued("Troops")
If _Sleep(500) Then Return
$aArmyCamp = GetOCRCurrent(48, 160)
Local $ArchToMake = $aArmyCamp[2]
If IsArmyWindow(False, $TrainTroopsTAB) Then TrainIt($eArch, $ArchToMake, $g_iTrainClickDelay)
SetLog("Trained " & $ArchToMake & " archer(s)!")
Else
SetLog(" - Conditions NOT met: FULL queue and Not Full Army")
EndIf
EndIf
EndFunc
Func CheckIsEmptyQueuedAndNotFullArmy()
SetLog(" - Checking: Empty Queue and Not Full Army", $COLOR_ACTION1)
Local $CheckTroop[4] = [825, 204, 0xCFCFC8, 15]
Local $CheckTroop1[2] = [310, 127]
If Not $g_bRunState Then Return
If Not OpenTroopsTab(True, "CheckIsEmptyQueuedAndNotFullArmy()") Then Return
Local $aArmyCamp = GetOCRCurrent(48, 160)
If UBound($aArmyCamp) = 3 And $aArmyCamp[2] > 0 Then
If _ColorCheck(_GetPixelColor($CheckTroop[0], $CheckTroop[1], True), Hex($CheckTroop[2], 6), $CheckTroop[3]) Then
If Not _ColorCheck(_GetPixelColor($CheckTroop1[0], $CheckTroop1[1], True), Hex(0xA0D077, 6), 30) And Not _ColorCheck(_GetPixelColor($CheckTroop1[0], $CheckTroop1[1] + 4, True), Hex(0x6AB320, 6), 30) Then
SetLog(" - Conditions met: Empty Queue and Not Full Army")
If _Sleep(500) Then Return
$aArmyCamp = GetOCRCurrent(48, 160)
Local $ArchToMake = $aArmyCamp[2]
If IsArmyWindow(False, $TrainTroopsTAB) Then TrainIt($eArch, $ArchToMake, $g_iTrainClickDelay)
SetLog(" - Trained " & $ArchToMake & " archer(s)!")
Else
SetLog(" - Conditions NOT met: Empty queue and Not Full Army")
EndIf
EndIf
EndIf
EndFunc
Func getReceivedTroops($x_start, $y_start, $bSkipCheck = False)
If $bSkipCheck Or Not $g_bRunState Then Return False
Local $iOCRResult = ""
$iOCRResult = getOcrAndCapture("coc-DonTroops", $x_start, $y_start, 120, 27, True)
If IsString($iOCRResult) <> "" Or IsString($iOCRResult) <> " " Then
If StringInStr($iOCRResult, "you") Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func TestTrainRevamp2()
$g_bRunState = True
$g_bDebugOcr = True
SetLog("Start......OpenArmy Window.....")
Local $timer = __TimerInit()
getArmyTroops(False, False, False, False)
SetLog("Imgloc Troops Time: " & Round(__TimerDiff($timer) / 1000, 2) & "'s")
SetLog("End......OpenArmy Window.....")
$g_bDebugOcr = False
$g_bRunState = False
EndFunc
Func _ArryRemoveBlanks(ByRef $aArray)
Local $iCounter = 0
For $i = 0 To UBound($aArray) - 1
If $aArray[$i] <> "" Then
$aArray[$iCounter] = $aArray[$i]
$iCounter += 1
EndIf
Next
ReDim $aArray[$iCounter]
EndFunc
Func CheckValuesCost($Troop = "Arch", $troopQuantity = 1, $DebugLogs = 0)
Local $TempColorToCheck = ""
Local $nElixirCurrent = 0, $nDarkCurrent = 0, $bLocalDebugOCR = 0
If _Sleep(1000) Then Return
If Not $g_bRunState Then Return
If $g_bDebugSetlogTrain Or $DebugLogs Then
$bLocalDebugOCR = $g_bDebugOcr
$g_bDebugOcr = True
$TempColorToCheck = _GetPixelColor(223, 594, True)
SetLog("CheckValuesCost|ColorToCheck: " & $TempColorToCheck)
EndIf
If _ColorCheck(_GetPixelColor(223, 594, True), Hex(0xE8E8E0, 6), 20) Then
$nElixirCurrent = getResourcesValueTrainPage(307, 594)
Else
$nElixirCurrent = getResourcesValueTrainPage(232, 594)
$nDarkCurrent = getResourcesValueTrainPage(385, 594)
EndIf
If $g_bDebugSetlogTrain Or $DebugLogs Then
SetLog("- Current resources:")
SetLog(" - Elixir: " & _NumberFormat($nElixirCurrent) & " / Dark Elixir: " & _NumberFormat($nDarkCurrent), $COLOR_INFO)
$g_bDebugOcr = $bLocalDebugOCR
EndIf
Local $troopCost = 0
Local $iTroopIndex = TroopIndexLookup($Troop, "CheckValuesCost")
If $iTroopIndex >= $eBarb And $iTroopIndex <= $eIceG Then
$troopCost = $g_aiTroopCostPerLevel[$iTroopIndex][$g_aiTrainArmyTroopLevel[$iTroopIndex]]
ElseIf $iTroopIndex >= $eLSpell And $iTroopIndex <= $eBtSpell Then
$troopCost = $g_aiSpellCostPerLevel[$iTroopIndex - $eLSpell][$g_aiTrainArmySpellLevel[$iTroopIndex - $eLSpell]]
EndIf
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Individual Cost " & $Troop & "= " & $troopCost)
$troopCost *= $troopQuantity
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Total Cost " & $Troop & "= " & $troopCost)
If IsDarkTroop($Troop) Then
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Dark Troop " & $Troop & " Is Dark Troop")
If $troopCost <= $nDarkCurrent Then
Return True
EndIf
Return False
ElseIf IsElixirSpell($Troop) Then
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Spell " & $Troop & " Is Elixir Spell")
If $troopCost <= $nElixirCurrent Then
Return True
EndIf
Return False
ElseIf IsDarkSpell($Troop) Then
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Dark Spell " & $Troop & " Is Dark Spell")
If $troopCost <= $nDarkCurrent Then
Return True
EndIf
Return False
Else
If $troopCost <= $nElixirCurrent Then
If $g_bDebugSetlogTrain Or $DebugLogs Then SetLog("Troop " & $Troop & " Is Elixir Troop")
Return True
EndIf
Return False
EndIf
EndFunc
Func ThSnipesSkiptrain()
Local $iTemp = 0
If IsSearchModeActive($TS) And $g_bIsFullArmywithHeroesAndSpells Then
For $i = 0 To $eTroopCount - 1
If $g_aiArmyCompTroops[$i] > 0 Then $iTemp += 1
Next
If $iTemp = 1 Then Return False
If $iTemp > 1 Then
SetLog("Skipping Training before Attack due to THSnipes!", $COLOR_INFO)
Return True
EndIf
Else
Return False
EndIf
EndFunc
Func TrainSiege()
If $g_iTotalTrainSpaceSiege < 1 Then Return
If Not $g_bRunState Then Return
If $g_bDebugSetlogTrain Then SetLog("-- TrainSiege --", $COLOR_DEBUG)
If Not OpenSiegeMachinesTab(True, "TrainSiege()") Then Return
Local $aCheckIsOccupied[4] = [822, 206, 0xE00D0D, 10]
Local $aCheckIsFilled[4] = [802, 186, 0xD7AFA9, 10]
Local $aCheckIsAvailableSiege[4] = [58, 556, 0x47717E, 10]
Local $aCheckIsAvailableSiege1[4] = [229, 556, 0x47717E, 10]
Local $aCheckIsAvailableSiege2[4] = [400, 556, 0x47717E, 10]
Local $TextToUse = ["Clan Castle", $g_asSiegeMachineNames[0], $g_asSiegeMachineNames[1], $g_asSiegeMachineNames[2]]
If $g_bDebugSetlogTrain Then
For $iSiegeIndex = $eSiegeWallWrecker To $eSiegeMachineCount - 1
SetDebugLog("-- " & $g_asSiegeMachineNames[$iSiegeIndex] & " --")
SetDebugLog(@TAB & "To Build: " & $g_aiArmyCompSiegeMachine[$iSiegeIndex])
SetDebugLog(@TAB & "Current Army: " & $g_aiCurrentSiegeMachines[$iSiegeIndex])
SetDebugLog(@TAB & "Current CC: " & $g_aiCurrentCCSiegeMachines[$iSiegeIndex])
SetDebugLog(@TAB & "To Use at " & $g_asModeText[$iSiegeIndex] & " " & $TextToUse[$g_aiAttackUseSiege[$iSiegeIndex]])
Next
EndIf
If $g_bIsFullArmywithHeroesAndSpells And($g_iCommandStop = 3 Or $g_iCommandStop = 0) Then Return
If $g_bIsFullArmywithHeroesAndSpells And Not _CheckPixel($aCheckIsFilled, True, Default, "Siege is Filled") And Not _CheckPixel($aCheckIsOccupied, True, Default, "Siege is Queued") Then
For $iSiegeIndex = $eSiegeWallWrecker To $eSiegeMachineCount - 1
If $g_aiArmyCompSiegeMachine[$iSiegeIndex] = 0 Then ContinueLoop
Local $checkPixel
If $iSiegeIndex = $eSiegeWallWrecker Then $checkPixel = $aCheckIsAvailableSiege
If $iSiegeIndex = $eSiegeBattleBlimp Then $checkPixel = $aCheckIsAvailableSiege1
If $iSiegeIndex = $eSiegeStoneSlammer Then $checkPixel = $aCheckIsAvailableSiege2
If _CheckPixel($checkPixel, True, Default, $g_asSiegeMachineNames[$iSiegeIndex]) Then
If($g_aiAttackUseSiege[$DB] = $iSiegeIndex + 1 Or $g_aiAttackUseSiege[$LB] = $iSiegeIndex + 1) And $g_aiCurrentCCSiegeMachines[$iSiegeIndex] = 0 Then
PureClick($checkPixel[0], $checkPixel[1], $g_aiArmyCompSiegeMachine[$iSiegeIndex], $g_iTrainClickDelay)
Local $sSiegeName = $g_aiArmyCompSiegeMachine[$iSiegeIndex] >= 2 ? $g_asSiegeMachineNames[$iSiegeIndex] & "s" : $g_asSiegeMachineNames[$iSiegeIndex] & ""
Setlog("Build " & $g_aiArmyCompSiegeMachine[$iSiegeIndex] & " " & $sSiegeName, $COLOR_SUCCESS)
EndIf
EndIf
If Not $g_bRunState Then Return
Next
Else
If _CheckPixel($aCheckIsFilled, True, Default, "Siege is Filled") Or _CheckPixel($aCheckIsOccupied, True, Default, "Siege is Queued") Then
Local $aSearchResult = SearchArmy("trainwindow-SiegesInQueue-bundle", 520, 210, 840, 220)
If $aSearchResult[0][0] <> "" Then
For $i = 0 To UBound($aSearchResult) - 1
Local $tempSiege = TroopIndexLookup($aSearchResult[$i][0])
Setlog("- " & GetTroopName($tempSiege) & " Queued.", $COLOR_INFO)
Next
EndIf
Local $sResultSpells = getRemainBuildTimer(780, 244, True)
If $sResultSpells <> "" Then
$g_aiTimeTrain[3] = ConvertOCRTime("Siege", $sResultSpells, False)
SetLog("Remaining Siege build time: " & StringFormat("%.2f", $g_aiTimeTrain[3]), $COLOR_INFO)
EndIf
Return
EndIf
If Not OpenArmyTab(False, "TrainSiege()") Then Return
If _sleep(500) Then Return
getArmySiegeMachines(False, False, False, False)
If _sleep(500) Then Return
If Not OpenSiegeMachinesTab(False, "TrainSiege()") Then Return
If _sleep(500) Then Return
For $iSiegeIndex = $eSiegeWallWrecker To $eSiegeMachineCount - 1
If $g_aiArmyCompSiegeMachine[$iSiegeIndex] = 0 Then ContinueLoop
If $g_aiCurrentSiegeMachines[$iSiegeIndex] < $g_aiArmyCompSiegeMachine[$iSiegeIndex] Then
Local $HowMany = $g_aiArmyCompSiegeMachine[$iSiegeIndex] - $g_aiCurrentSiegeMachines[$iSiegeIndex]
Local $checkPixel
If $iSiegeIndex = $eSiegeWallWrecker Then $checkPixel = $aCheckIsAvailableSiege
If $iSiegeIndex = $eSiegeBattleBlimp Then $checkPixel = $aCheckIsAvailableSiege1
If $iSiegeIndex = $eSiegeStoneSlammer Then $checkPixel = $aCheckIsAvailableSiege2
If _CheckPixel($checkPixel, True, Default, $g_asSiegeMachineNames[$iSiegeIndex]) Then
PureClick($checkPixel[0], $checkPixel[1], $HowMany, $g_iTrainClickDelay)
Local $sSiegeName = $HowMany >= 2 ? $g_asSiegeMachineNames[$iSiegeIndex] & "s" : $g_asSiegeMachineNames[$iSiegeIndex] & ""
Setlog("Build " & $HowMany & " " & $sSiegeName, $COLOR_SUCCESS)
EndIf
EndIf
If Not $g_bRunState Then Return
Next
EndIf
EndFunc
Func TrainIt($iIndex, $iQuantity = 1, $iSleep = 400)
If $g_bDebugSetlogTrain Then SetLog("Func TrainIt $iIndex=" & $iIndex & " $howMuch=" & $iQuantity & " $iSleep=" & $iSleep, $COLOR_DEBUG)
Local $bDark =($iIndex >= $eMini And $iIndex <= $eIceG)
For $i = 1 To 5
Local $aTrainPos = GetTrainPos($iIndex)
If IsArray($aTrainPos) And $aTrainPos[0] <> -1 Then
If _ColorCheck(_GetPixelColor($aTrainPos[0], $aTrainPos[1], $g_bCapturePixel), Hex($aTrainPos[2], 6), $aTrainPos[3]) Then
Local $FullName = GetFullName($iIndex, $aTrainPos)
If IsArray($FullName) Then
Local $RNDName = GetRNDName($iIndex, $aTrainPos)
If IsArray($RNDName) Then
TrainClickP($aTrainPos, $iQuantity, $g_iTrainClickDelay, $FullName, "#0266", $RNDName)
If _Sleep($iSleep) Then Return
If $g_bOutOfElixir Then
SetLog("Not enough " &($bDark ? "Dark " : "") & "Elixir to train position " & GetTroopName($iIndex) & " troops!", $COLOR_ERROR)
SetLog("Switching to Halt Attack, Stay Online Mode...", $COLOR_ERROR)
If Not $g_bFullArmy Then $g_bRestart = True
Return
EndIf
Return True
Else
SetLog("TrainIt position " & GetTroopName($iIndex) & " - RNDName did not return array?", $COLOR_ERROR)
Return False
EndIf
Else
SetLog("TrainIt " & GetTroopName($iIndex) & " - FullName did not return array?", $COLOR_ERROR)
Return False
EndIf
Else
ForceCaptureRegion()
Local $sBadPixelColor = _GetPixelColor($aTrainPos[0], $aTrainPos[1], $g_bCapturePixel)
If $g_bDebugSetlogTrain Then SetLog("Positon X: " & $aTrainPos[0] & "| Y : " & $aTrainPos[1] & " |Color get: " & $sBadPixelColor & " | Need: " & $aTrainPos[2])
If StringMid($sBadPixelColor, 1, 2) = StringMid($sBadPixelColor, 3, 2) And StringMid($sBadPixelColor, 1, 2) = StringMid($sBadPixelColor, 5, 2) Then
SetLog("Troop " & GetTroopName($iIndex) & " is not available due to full queue", $COLOR_DEBUG)
Else
If Mod($i, 2) = 0 Then
If $g_bDebugSetlogTrain Then DebugImageSave("BadPixelCheck_" & GetTroopName($iIndex))
SetLog("Bad pixel check on troop position " & GetTroopName($iIndex), $COLOR_ERROR)
If $g_bDebugSetlogTrain Then SetLog("Train Pixel Color: " & $sBadPixelColor, $COLOR_DEBUG)
EndIf
EndIf
If Mod($i, 2) = 1 Then
Local $aEmptyArray[4] = [-1,-1,-1,-1]
$aTrainArmy[$iIndex] = $aEmptyArray
EndIf
EndIf
Else
If UBound($aTrainPos) > 0 And $aTrainPos[0] = -1 Then
If $i < 5 Then
ForceCaptureRegion()
Else
If $g_bDebugSetlogTrain Then DebugImageSave("TroopIconNotFound_" & GetTroopName($iIndex))
SetLog("TrainIt troop position " & GetTroopName($iIndex) & " did not find icon", $COLOR_ERROR)
EndIf
Else
SetLog("Impossible happened? TrainIt troop position " & GetTroopName($iIndex) & " did not return array", $COLOR_ERROR)
EndIf
EndIf
Next
EndFunc
Func GetTrainPos(Const $iIndex)
If $g_bDebugSetlogTrain Then SetLog("GetTrainPos($iIndex=" & $iIndex & ")", $COLOR_DEBUG)
Local $aTrainPos = $aTrainArmy[$iIndex]
If $aTrainPos[0] <> -1 Then
Return $aTrainPos
Else
If $iIndex >= $eBarb And $iIndex <= $eIceG Then
Local $sFilter = String($g_asTroopShortNames[$iIndex]) & "*"
Local $asImageToUse = _FileListToArray($g_sImgTrainTroops, $sFilter, $FLTA_FILES, True)
If $g_bDebugSetlogTrain Then SetLog("$asImageToUse Troops: " & $asImageToUse[1])
$aTrainPos = GetVariable($asImageToUse[1], $iIndex)
$aTrainArmy[$iIndex] = $aTrainPos
Return $aTrainPos
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eBtSpell Then
Local $sFilter = String($g_asSpellShortNames[$iIndex - $eLSpell]) & "*"
Local $asImageToUse = _FileListToArray($g_sImgTrainSpells, $sFilter, $FLTA_FILES, True)
If $g_bDebugSetlogTrain Then SetLog("$asImageToUse Spell: " & $asImageToUse[1])
$aTrainPos = GetVariable($asImageToUse[1], $iIndex)
$aTrainArmy[$iIndex] = $aTrainPos
Return $aTrainPos
EndIf
EndIf
Return 0
EndFunc
Func GetFullName(Const $iIndex, Const $aTrainPos)
If $g_bDebugSetlogTrain Then SetLog("GetFullName($iIndex=" & $iIndex & ")", $COLOR_DEBUG)
If $iIndex >= $eBarb And $iIndex <= $eIceG Then
Local $sTroopType =($iIndex >= $eMini ? "Dark" : "Normal")
Return GetFullNameSlot($aTrainPos, $sTroopType)
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eBtSpell Then
Return GetFullNameSlot($aTrainPos, "Spell")
EndIf
SetLog("Don't know how to find the full name of troop with index " & $iIndex & " yet")
Local $aTempSlot[4] = [-1, -1, -1, -1]
Return $aTempSlot
EndFunc
Func GetRNDName(Const $iIndex, Const $aTrainPos)
If $g_bDebugSetlogTrain Then SetLog("GetRNDName($iIndex=" & $iIndex & ")", $COLOR_DEBUG)
Local $aTrainPosRND[4]
If $iIndex <> -1 Then
Local $aTempCoord = $aTrainPos
$aTrainPosRND[0] = $aTempCoord[0] - 5
$aTrainPosRND[1] = $aTempCoord[1] - 5
$aTrainPosRND[2] = $aTempCoord[0] + 5
$aTrainPosRND[3] = $aTempCoord[1] + 5
Return $aTrainPosRND
EndIf
SetLog("Don't know how to find the RND name of troop with index " & $iIndex & " yet!", $COLOR_ERROR)
Return 0
EndFunc
Func GetVariable(Const $ImageToUse, Const $iIndex)
Local $aTrainPos[4] = [-1, -1, -1, -1]
_CaptureRegion2(25, 375, 840, 548)
Local $asResult = DllCallMyBot("FindTile", "handle", $g_hHBitmap2, "str", $ImageToUse, "str", "FV", "int", 1)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If IsArray($asResult) Then
If $asResult[0] = "0" Then
SetLog("No " & GetTroopName($iIndex) & " Icon found!", $COLOR_ERROR)
ElseIf $asResult[0] = "-1" Then
SetLog("TrainIt.au3 GetVariable(): ImgLoc DLL Error Occured!", $COLOR_ERROR)
ElseIf $asResult[0] = "-2" Then
SetLog("TrainIt.au3 GetVariable(): Wrong Resolution used for ImgLoc Search!", $COLOR_ERROR)
Else
If $g_bDebugSetlogTrain Then SetLog("String: " & $asResult[0])
Local $aResult = StringSplit($asResult[0], "|", $STR_NOCOUNT)
If UBound($aResult) > 1 Then
Local $aCoordinates = StringSplit($aResult[1], ",", $STR_NOCOUNT)
If UBound($aCoordinates) > 1 Then
Local $iButtonX = 25 + Int($aCoordinates[0])
Local $iButtonY = 375 + Int($aCoordinates[1])
Local $sColorToCheck = "0x" & _GetPixelColor($iButtonX, $iButtonY, $g_bCapturePixel)
Local $iTolerance = 40
Local $aTrainPos[4] = [$iButtonX, $iButtonY, $sColorToCheck, $iTolerance]
If $g_bDebugSetlogTrain Then SetLog("Found: [" & $iButtonX & "," & $iButtonY & "]", $COLOR_SUCCESS)
If $g_bDebugSetlogTrain Then SetLog("$sColorToCheck: " & $sColorToCheck, $COLOR_SUCCESS)
If $g_bDebugSetlogTrain Then SetLog("$iTolerance: " & $iTolerance, $COLOR_SUCCESS)
Return $aTrainPos
Else
SetLog("Don't know how to train the troop with index " & $iIndex & " yet.")
EndIf
Else
SetLog("Don't know how to train the troop with index " & $iIndex & " yet..")
EndIf
EndIf
Else
SetLog("Don't know how to train the troop with index " & $iIndex & " yet...")
EndIf
Return $aTrainPos
EndFunc
Func GetFullNameSlot(Const $iTrainPos, Const $sTroopType)
Local $iSlotH, $iSlotV
If $sTroopType = "Spell" Then
Switch $iTrainPos[0]
Case 0 To 101
$iSlotH = 101
Case 105 To 199
$iSlotH = 199
Case 203 To 297
$iSlotH = 297
Case 302 To 395
$iSlotH = 404
Case 400 To 498
$iSlotH = 502
Case 499 To 597
$iSlotH = 597
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
SetLog("GetFullNameSlot(): It seems that there is no Slot for an Spell on: " & $iTrainPos[0] & "," & $iTrainPos[1] & "!", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case 0 To 445
$iSlotV = 387
Case 446 To 550
$iSlotV = 488
EndSwitch
Local $aSlot[4] = [$iSlotH, $iSlotV, 0x9d9d9d, 20]
If $g_bDebugSetlogTrain Then SetLog("GetFullNameSlot(): Spell Icon found on: " & $iSlotH & "," & $iSlotV, $COLOR_DEBUG)
Return $aSlot
EndIf
If $sTroopType = "Normal" Then
Switch $iTrainPos[0]
Case 0 To 101
$iSlotH = 101
Case 105 To 199
$iSlotH = 199
Case 200 To 297
$iSlotH = 297
Case 298 To 395
$iSlotH = 395
Case 396 To 494
$iSlotH = 494
Case 495 To 592
$iSlotH = 592
Case 593 To 690
$iSlotH = 690
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
SetLog("GetFullNameSlot(): It seems that there is no Slot for an Elixir Troop on: " & $iTrainPos[0] & "," & $iTrainPos[1] & "!", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case 0 To 445
$iSlotV = 387
Case 446 To 550
$iSlotV = 488
EndSwitch
Local $aSlot[4] = [$iSlotH, $iSlotV, 0x9F9F9F, 20]
If $g_bDebugSetlogTrain Then SetLog("GetFullNameSlot(): Elixir Troop Icon found on: " & $iSlotH & "," & $iSlotV, $COLOR_DEBUG)
Return $aSlot
EndIf
If $sTroopType = "Dark" Then
Switch $iTrainPos[0]
Case 440 To 517
$iSlotH = 517
Case 518 To 615
$iSlotH = 615
Case 616 To 714
$iSlotH = 714
Case 715 To 812
$iSlotH = 812
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
SetLog("GetFullNameSlot(): It seems that there is no Slot for a Dark Elixir Troop on: " & $iTrainPos[0] & "," & $iTrainPos[1] & "!", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case 0 To 445
$iSlotV = 397
Case 446 To 550
$iSlotV = 498
EndSwitch
Local $aSlot[4] = [$iSlotH, $iSlotV, 0x9f9f9f, 20]
If $g_bDebugSetlogTrain Then SetLog("GetFullNameSlot(): Dark Elixir Troop Icon found on: " & $iSlotH & "," & $iSlotV, $COLOR_DEBUG)
Return $aSlot
EndIf
EndFunc
Func DoubleTrain($bQuickTrain = False, $bSetlog = True)
If Not $g_bDoubleTrain Then Return
Local $bDebug = $g_bDebugSetlogTrain Or $g_bDebugSetlog
If $bDebug Then $bSetlog = True
If $bDebug Then SetLog($bQuickTrain ? " ==  Double Quick Train == " : " ==  Double Train == ", $COLOR_ACTION)
StartGainCost()
CheckIfArmyIsReady()
Local $bNeedReCheckTroopTab = False, $bNeedReCheckSpellTab = False
Local $bHasIncorrectTroop = False, $bHasIncorrectSpell = False
Local $bSavedFullArmyValue = $g_bIsFullArmywithHeroesAndSpells
$g_bIsFullArmywithHeroesAndSpells = False
If $bQuickTrain Then
DoubleQuickTrain($bSetlog, $bDebug)
$g_bIsFullArmywithHeroesAndSpells = $bSavedFullArmyValue
EndGainCost("Train")
Return
EndIf
If $g_bChkPreciseArmy Then
Local $aWrongArmy = WhatToTrain(True)
If IsArray($aWrongArmy) Then
If $bDebug Then SetLog("$aWrongTroops: " & _ArrayToString($aWrongArmy), $COLOR_DEBUG)
If UBound($aWrongArmy) = 1 And $aWrongArmy[0][1] = "Arch" And $aWrongArmy[0][1] = 0 Then
Else
For $i = 0 To UBound($aWrongArmy) - 1
If Not $bHasIncorrectTroop And _ArraySearch($g_asTroopShortNames, $aWrongArmy[$i][0]) >= 0 Then $bHasIncorrectTroop = True
If Not $bHasIncorrectSpell And _ArraySearch($g_asSpellShortNames, $aWrongArmy[$i][0]) >= 0 Then $bHasIncorrectSpell = True
If $bHasIncorrectTroop And $bHasIncorrectSpell Then ExitLoop
Next
If $bDebug Then SetLog("$bNeedReCheckTroopTab: " & $bNeedReCheckTroopTab & "$bNeedReCheckSpellTab: " & $bNeedReCheckSpellTab, $COLOR_DEBUG)
SetLog("Found incorrect " &($bHasIncorrectTroop ? "Troops " &($bHasIncorrectSpell ? "and Spells " : "") : "Spells ") & "in army")
EndIf
EndIf
EndIf
If Not OpenTroopsTab(False, "DoubleTrain()") Then Return
If _Sleep(250) Then Return
Local $Step = 1
While 1
Local $TroopCamp = GetCurrentArmy(48, 160)
If $bSetlog Then SetLog("Checking Troop tab: " & $TroopCamp[0] & "/" & $TroopCamp[1] * 2)
If $TroopCamp[1] = 0 Then ExitLoop
If $bSetlog And $TroopCamp[1] <> $g_iTotalCampSpace Then SetLog("Incorrect Troop combo: " & $g_iTotalCampSpace & " vs Total camp: " & $TroopCamp[1] & @CRLF & "                 Double train may not work well", $COLOR_DEBUG)
If $TroopCamp[0] < $TroopCamp[1] Or $bHasIncorrectTroop Then
If Not $bHasIncorrectTroop And $g_bDonationEnabled And $g_bChkDonate And MakingDonatedTroops("Troops") Then
If $bDebug Then SetLog($Step & ". MakingDonatedTroops('Troops')", $COLOR_DEBUG)
$Step += 1
If $Step = 6 Then ExitLoop
ContinueLoop
EndIf
If Not IsQueueEmpty("Troops", False, False) Then DeleteQueued("Troops")
$bNeedReCheckTroopTab = True
If $bDebug Then SetLog($Step & ". DeleteQueued('Troops'). $bNeedReCheckTroopTab: " & $bNeedReCheckTroopTab, $COLOR_DEBUG)
ElseIf $TroopCamp[0] = $TroopCamp[1] Then
TrainFullQueue()
If $bDebug Then SetLog($Step & ". TrainFullQueue() done!", $COLOR_DEBUG)
ElseIf $TroopCamp[0] <= $TroopCamp[1] * 2 Then
If CheckQueueTroopAndTrainRemain($TroopCamp, $bDebug) Then
If $bDebug Then SetLog($Step & ". CheckQueueAndTrainRemain() done!", $COLOR_DEBUG)
Else
RemoveExtraTroopsQueue()
If _Sleep(500) Then Return
If $bDebug Then SetLog($Step & ". RemoveExtraTroopsQueue()", $COLOR_DEBUG)
$Step += 1
If $Step = 6 Then ExitLoop
ContinueLoop
EndIf
EndIf
ExitLoop
WEnd
Local $TotalSpellsToBrewInGUI = Number(TotalSpellsToBrewInGUI())
If $TotalSpellsToBrewInGUI = 0 Then
If $bDebug Then SetLog("No spell is required, skip checking spell tab", $COLOR_DEBUG)
Else
If Not OpenSpellsTab(False, "DoubleTrain()") Then Return
If _Sleep(250) Then Return
$Step = 1
While 1
Local $SpellCamp = GetCurrentArmy(43, 160)
If $bSetlog Then SetLog("Checking Spell tab: " & $SpellCamp[0] & "/" & $SpellCamp[1] * 2)
If $SpellCamp[1] = 0 Then ExitLoop
Local $TotalSpell = _Min(Number($TotalSpellsToBrewInGUI), Number($g_iTotalSpellValue))
If $bDebug Then SetLog("$TotalSpellsToBrewInGUI = " & $TotalSpellsToBrewInGUI & ", $g_iTotalSpellValue = " & $g_iTotalSpellValue & ", _Min = " & $TotalSpell, $COLOR_DEBUG)
If $SpellCamp[1] <> $TotalSpellsToBrewInGUI Or $SpellCamp[1] <> $g_iTotalSpellValue Then
If $bSetlog And Not $g_bForceBrewSpells Then SetLog("Incorrect Spell combo: " & $TotalSpellsToBrewInGUI & "/" & $g_iTotalSpellValue & " vs Total camp: " & $SpellCamp[1] & @CRLF & "                 Double train may not work well", $COLOR_DEBUG)
If $g_bForceBrewSpells And $SpellCamp[1] > $TotalSpell Then $SpellCamp[1] = $TotalSpell
EndIf
If $SpellCamp[0] < $SpellCamp[1] Or $bHasIncorrectSpell Then
If Not $bHasIncorrectSpell And $g_bDonationEnabled And $g_bChkDonate And MakingDonatedTroops("Spells") Then
If $bDebug Then SetLog($Step & ". MakingDonatedTroops('Spells')", $COLOR_DEBUG)
$Step += 1
If $Step = 6 Then ExitLoop
ContinueLoop
EndIf
If Not IsQueueEmpty("Spells", False, False) Then DeleteQueued("Spells")
$bNeedReCheckSpellTab = True
If $bDebug Then SetLog($Step & ". DeleteQueued('Spells'). $bNeedReCheckSpellTab: " & $bNeedReCheckSpellTab, $COLOR_DEBUG)
ElseIf $SpellCamp[0] = $SpellCamp[1] Then
TrainFullQueue(True)
If $bDebug Then SetLog($Step & ". TrainFullQueue(True) done!", $COLOR_DEBUG)
ElseIf $SpellCamp[0] <= $SpellCamp[1] * 2 Then
If CheckQueueSpellAndTrainRemain($SpellCamp, $bDebug) Then
If $bDebug Then SetLog($Step & ". CheckQueueSpellAndTrainRemain() done!", $COLOR_DEBUG)
Else
RemoveExtraTroopsQueue()
If _Sleep(500) Then Return
If $bDebug Then SetLog($Step & ". RemoveExtraTroopsQueue()", $COLOR_DEBUG)
$Step += 1
If $Step = 6 Then ExitLoop
ContinueLoop
EndIf
EndIf
ExitLoop
WEnd
EndIf
If $bNeedReCheckTroopTab Or $bNeedReCheckSpellTab Then
Local $aWhatToRemove = WhatToTrain(True)
Local $rRemoveExtraTroops = RemoveExtraTroops($aWhatToRemove)
If $bDebug Then SetLog("RemoveExtraTroops(): " & $rRemoveExtraTroops, $COLOR_DEBUG)
If $rRemoveExtraTroops = 1 Or $rRemoveExtraTroops = 2 Then
For $i = 0 To UBound($aWhatToRemove) - 1
If _ArraySearch($g_asTroopShortNames, $aWhatToRemove[$i][0]) >= 0 Then $bNeedReCheckTroopTab = True
If _ArraySearch($g_asSpellShortNames, $aWhatToRemove[$i][0]) >= 0 Then $bNeedReCheckSpellTab = True
If $bNeedReCheckTroopTab And $bNeedReCheckSpellTab Then ExitLoop
Next
If $bDebug Then SetLog("$bNeedReCheckTroopTab: " & $bNeedReCheckTroopTab & "$bNeedReCheckSpellTab: " & $bNeedReCheckSpellTab, $COLOR_DEBUG)
EndIf
Local $aWhatToTrain = WhatToTrain()
If $bNeedReCheckTroopTab Then
TrainUsingWhatToTrain($aWhatToTrain)
TrainFullQueue(False)
If $bDebug Then SetLog("TrainFullQueue() done.", $COLOR_DEBUG)
EndIf
If $bNeedReCheckSpellTab Then
TrainUsingWhatToTrain($aWhatToTrain, True)
TrainFullQueue(True)
If $bDebug Then SetLog("TrainFullQueue('True') done.", $COLOR_DEBUG)
EndIf
EndIf
If _Sleep(250) Then Return
DoubleTrainSiege($bDebug)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
$g_bIsFullArmywithHeroesAndSpells = $bSavedFullArmyValue
If $g_bDonationEnabled And $g_bChkDonate Then ResetVariables("donated")
EndGainCost("Train")
checkAttackDisable($g_iTaBChkIdle)
EndFunc
Func TrainFullQueue($bSpellOnly = False)
Local $ToReturn[1][2] = [["Arch", 0]]
For $i = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$i]
If $g_aiArmyCompTroops[$troopIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompTroops[$troopIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To $eSpellCount - 1
Local $BrewIndex = $g_aiBrewOrder[$i]
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiArmyCompSpells[$BrewIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$BrewIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$BrewIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
If $ToReturn[0][0] = "Arch" And $ToReturn[0][1] = 0 Then Return
Local $bSavedFullArmyValue = $g_bIsFullArmywithHeroesAndSpells
$g_bIsFullArmywithHeroesAndSpells = True
TrainUsingWhatToTrain($ToReturn, $bSpellOnly)
If _Sleep($bSpellOnly ? 1000 : 500) Then Return
$g_bIsFullArmywithHeroesAndSpells = $bSavedFullArmyValue
Local $CampOCR = GetCurrentArmy($bSpellOnly ? 43 : 48, 160)
SetDebugLog("Checking " &($bSpellOnly ? "spell tab: " : "troop tab: ") & $CampOCR[0] & "/" & $CampOCR[1] * 2)
EndFunc
Func DoubleQuickTrain($bSetlog, $bDebug)
Local $bDoubleTrainTroop = False, $bDoubleTrainSpell = False
If Not OpenTroopsTab(False, "DoubleQuickTrain()") Then Return
If _Sleep(250) Then Return
Local $Step = 1
While 1
If $g_bDonationEnabled And $g_bChkDonate Then MakingDonatedTroops("Troops")
Local $TroopCamp = GetCurrentArmy(48, 160)
If $bSetlog Then SetLog("Checking Troop tab: " & $TroopCamp[0] & "/" & $TroopCamp[1] * 2)
If $TroopCamp[0] > $TroopCamp[1] And $TroopCamp[0] < $TroopCamp[1] * 2 Then
RemoveExtraTroopsQueue()
If _Sleep(500) Then Return
If $bDebug Then SetLog($Step & ". RemoveExtraTroopsQueue()", $COLOR_DEBUG)
$Step += 1
If $Step = 6 Then ExitLoop
ContinueLoop
ElseIf $TroopCamp[0] = $TroopCamp[1] * 2 Then
$bDoubleTrainTroop = True
If $bDebug Then SetLog($Step & ". $bDoubleTrainTroop: " & $bDoubleTrainTroop, $COLOR_DEBUG)
EndIf
ExitLoop
WEnd
If Not OpenSpellsTab(False, "DoubleQuickTrain()") Then Return
If _Sleep(250) Then Return
$Step = 1
While 1
If $g_bDonationEnabled And $g_bChkDonate Then MakingDonatedTroops("Spells")
Local $SpellCamp = GetCurrentArmy(43, 160)
If $bSetlog Then SetLog("Checking Spell tab: " & $SpellCamp[0] & "/" & $SpellCamp[1] * 2)
If $SpellCamp[0] > $SpellCamp[1] And $SpellCamp[0] < $SpellCamp[1] * 2 Then
If $g_bChkMultiClick Then ExitLoop
RemoveExtraTroopsQueue()
If _Sleep(500) Then Return
If $bDebug Then SetLog($Step & ". RemoveExtraTroopsQueue()", $COLOR_DEBUG)
$Step += 1
If $Step = 6 Then ExitLoop
ContinueLoop
ElseIf $SpellCamp[0] = $SpellCamp[1] * 2 Then
$bDoubleTrainSpell = True
If $bDebug Then SetLog($Step & ". $bDoubleTrainSpell: " & $bDoubleTrainSpell, $COLOR_DEBUG)
EndIf
ExitLoop
WEnd
If Not $bDoubleTrainTroop Or Not $bDoubleTrainSpell Then
If Not OpenQuickTrainTab(False, "DoubleQuickTrain()") Then Return
If _Sleep(500) Then Return
Local $iMultiClick = 1
If $g_bChkMultiClick Then $iMultiClick = _Max(Ceiling(($SpellCamp[1] * 2 - $SpellCamp[0]) / 2), 1)
TrainArmyNumber($g_bQuickTrainArmy, $iMultiClick)
Else
If $bSetlog Then SetLog("Full queue, skip Double Quick Train")
EndIf
If _Sleep(250) Then Return
DoubleTrainSiege($bDebug)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
If $g_bDonationEnabled And $g_bChkDonate Then ResetVariables("donated")
EndFunc
Func GetCurrentArmy($x_start, $y_start)
Local $aResult[3] = [0, 0, 0]
If Not $g_bRunState Then Return $aResult
Local $iOCRResult = getArmyCapacityOnTrainTroops($x_start, $y_start)
If StringInStr($iOCRResult, "#") Then
Local $aTempResult = StringSplit($iOCRResult, "#", $STR_NOCOUNT)
$aResult[0] = Number($aTempResult[0])
$aResult[1] = Number($aTempResult[1]) / 2
$aResult[2] = $aResult[1] - $aResult[0]
Else
SetLog("DEBUG | ERROR on GetCurrentArmy", $COLOR_ERROR)
EndIf
Return $aResult
EndFunc
Func CheckQueueTroopAndTrainRemain($ArmyCamp, $bDebug)
If $ArmyCamp[0] = $ArmyCamp[1] * 2 And((ProfileSwitchAccountEnabled() And $g_abAccountNo[$g_iCurAccount] And $g_abDonateOnly[$g_iCurAccount]) Or $g_iCommandStop = 0) Then Return True
Local $iTotalQueue = 0
If $bDebug Then SetLog("Checking troop queue: " & $ArmyCamp[0] & "/" & $ArmyCamp[1] * 2, $COLOR_DEBUG)
Local $XQueueStart = 839
For $i = 0 To 10
If _ColorCheck(_GetPixelColor(825 - $i * 70, 186, True), Hex(0xD7AFA9, 6), 20) Then
$XQueueStart -= 70.5 * $i
ExitLoop
EndIf
Next
Local $aiQueueTroops = CheckQueueTroops(True, $bDebug, $XQueueStart)
If Not IsArray($aiQueueTroops) Then Return False
For $i = 0 To UBound($aiQueueTroops) - 1
If $aiQueueTroops[$i] > 0 Then $iTotalQueue += $aiQueueTroops[$i] * $g_aiTroopSpace[$i]
Next
If $ArmyCamp[0] < $ArmyCamp[1] + $iTotalQueue Then
SetLog("A big guy blocks our camp")
Return False
EndIf
For $i = 0 To UBound($aiQueueTroops) - 1
If $aiQueueTroops[$i] - $g_aiArmyCompTroops[$i] > 0 Then
SetLog("Some wrong troops in queue")
Return False
EndIf
Next
If $ArmyCamp[0] < $ArmyCamp[1] * 2 Then
SetLog("Checking troop queue:")
Local $rWTT[1][2] = [["Arch", 0]]
For $i = 0 To UBound($aiQueueTroops) - 1
Local $iIndex = $g_aiTrainOrder[$i]
If $aiQueueTroops[$iIndex] > 0 Then SetLog("  - " & $g_asTroopNames[$iIndex] & ": " & $aiQueueTroops[$iIndex] & "x")
If $g_aiArmyCompTroops[$iIndex] - $aiQueueTroops[$iIndex] > 0 Then
$rWTT[UBound($rWTT) - 1][0] = $g_asTroopShortNames[$iIndex]
$rWTT[UBound($rWTT) - 1][1] = Abs($g_aiArmyCompTroops[$iIndex] - $aiQueueTroops[$iIndex])
SetLog("    missing: " & $g_asTroopNames[$iIndex] & " x" & $rWTT[UBound($rWTT) - 1][1])
ReDim $rWTT[UBound($rWTT) + 1][2]
EndIf
Next
Local $bIsFullArmywithHeroesAndSpells = $g_bIsFullArmywithHeroesAndSpells
$g_bIsFullArmywithHeroesAndSpells = True
TrainUsingWhatToTrain($rWTT)
$g_bIsFullArmywithHeroesAndSpells = $bIsFullArmywithHeroesAndSpells
If _Sleep(1000) Then Return
$ArmyCamp = GetCurrentArmy(48, 160)
SetLog("Checking troop tab: " & $ArmyCamp[0] & "/" & $ArmyCamp[1] * 2 &($ArmyCamp[0] < $ArmyCamp[1] * 2 ? ". Top-up queue failed!" : ""))
If $ArmyCamp[0] < $ArmyCamp[1] * 2 Then Return False
EndIf
Return True
EndFunc
Func CheckQueueSpellAndTrainRemain($ArmyCamp, $bDebug)
If $ArmyCamp[0] = $ArmyCamp[1] * 2 And((ProfileSwitchAccountEnabled() And $g_abAccountNo[$g_iCurAccount] And $g_abDonateOnly[$g_iCurAccount]) Or $g_iCommandStop = 0) Then Return True
Local $iTotalQueue = 0
If $bDebug Then SetLog("Checking spell queue: " & $ArmyCamp[0] & "/" & $ArmyCamp[1] * 2, $COLOR_DEBUG)
Local $XQueueStart = 839
For $i = 0 To 10
If _ColorCheck(_GetPixelColor(825 - $i * 70, 186, True), Hex(0xD7AFA9, 6), 20) Then
$XQueueStart -= 70.5 * $i
ExitLoop
EndIf
Next
Local $aiQueueSpells = CheckQueueSpells(True, $bDebug, $XQueueStart)
If Not IsArray($aiQueueSpells) Then Return False
For $i = 0 To UBound($aiQueueSpells) - 1
If $aiQueueSpells[$i] > 0 Then $iTotalQueue += $aiQueueSpells[$i] * $g_aiSpellSpace[$i]
Next
If $ArmyCamp[0] < $ArmyCamp[1] + $iTotalQueue And Not $g_bForceBrewSpells Then
SetLog("A big guy blocks our camp")
Return False
EndIf
For $i = 0 To UBound($aiQueueSpells) - 1
If $aiQueueSpells[$i] - $g_aiArmyCompSpells[$i] > 0 Then
SetLog("Some wrong spells in queue")
Return False
EndIf
Next
If $ArmyCamp[0] < $ArmyCamp[1] * 2 Then
SetLog("Checking spells queue:")
Local $rWTT[1][2] = [["Arch", 0]]
For $i = 0 To UBound($aiQueueSpells) - 1
Local $iIndex = $g_aiBrewOrder[$i]
If $aiQueueSpells[$iIndex] > 0 Then SetLog("  - " & $g_asSpellNames[$iIndex] & ": " & $aiQueueSpells[$iIndex] & "x")
If $g_aiArmyCompSpells[$iIndex] - $aiQueueSpells[$iIndex] > 0 Then
$rWTT[UBound($rWTT) - 1][0] = $g_asSpellShortNames[$iIndex]
$rWTT[UBound($rWTT) - 1][1] = Abs($g_aiArmyCompSpells[$iIndex] - $aiQueueSpells[$iIndex])
SetLog("    missing: " & $g_asSpellNames[$iIndex] & " x" & $rWTT[UBound($rWTT) - 1][1])
ReDim $rWTT[UBound($rWTT) + 1][2]
EndIf
Next
Local $bIsFullArmywithHeroesAndSpells = $g_bIsFullArmywithHeroesAndSpells
$g_bIsFullArmywithHeroesAndSpells = True
TrainUsingWhatToTrain($rWTT, True)
$g_bIsFullArmywithHeroesAndSpells = $bIsFullArmywithHeroesAndSpells
If _Sleep(1000) Then Return
Local $NewSpellCamp = GetCurrentArmy(43, 160)
SetLog("Checking spell tab: " & $NewSpellCamp[0] & "/" & $NewSpellCamp[1] * 2 &($NewSpellCamp[0] < $ArmyCamp[1] * 2 ? ". Top-up queue failed!" : ""))
If $NewSpellCamp[0] < $ArmyCamp[1] * 2 Then Return False
EndIf
Return True
EndFunc
Func DoubleTrainSiege($bDebug)
If $g_iTotalTrainSpaceSiege < 1 Then Return
If Not OpenSiegeMachinesTab(True, "DoubleTrainSiege()") Then Return
If _Sleep(500) Then Return
Local $checkPixel[4] = [58, 556, 0x47717E, 10]
For $i = $eSiegeWallWrecker To $eSiegeMachineCount - 1
$checkPixel[0] = 58 + $i * 171
If _CheckPixel($checkPixel, True, Default, $g_asSiegeMachineNames[$i]) Then
If $g_aiCurrentSiegeMachines[$i] < $g_aiArmyCompSiegeMachine[$i] Then
Local $HowMany = $g_aiArmyCompSiegeMachine[$i] - $g_aiCurrentSiegeMachines[$i]
PureClick($checkPixel[0], $checkPixel[1], $HowMany, $g_iTrainClickDelay)
Setlog("Build " & $HowMany & " " & $g_asSiegeMachineNames[$i] &($HowMany >= 2 ? "s" : ""), $COLOR_SUCCESS)
If _Sleep(250) Then Return
EndIf
EndIf
Next
Local $iTotalSiegeTypeToBuild = 0, $iSiegeType = -1
For $i = $eSiegeWallWrecker To $eSiegeMachineCount - 1
If $g_aiArmyCompSiegeMachine[$i] > 0 Then
$iTotalSiegeTypeToBuild += 1
$iSiegeType = $i
EndIf
If $iTotalSiegeTypeToBuild >= 2 Then ExitLoop
Next
If $iTotalSiegeTypeToBuild >= 2 Then
If $bDebug Then SetLog("Army has more than 1 type of siege. Double train siege might cause unbalance.", $COLOR_DEBUG)
ElseIf $iSiegeType >= $eSiegeWallWrecker And $iSiegeType <= $eSiegeMachineCount - 1 Then
$checkPixel[0] = 58 + $iSiegeType * 171
Local $iTotalMachineBuilt = 0
For $i = 1 To _Min(Number($g_aiArmyCompSiegeMachine[$iSiegeType]), 3)
If _CheckPixel($checkPixel, True, Default, $g_asSiegeMachineNames[$iSiegeType]) Then
PureClick($checkPixel[0], $checkPixel[1], 1, $g_iTrainClickDelay)
$iTotalMachineBuilt += 1
If _Sleep(250) Then Return
EndIf
Next
If $iTotalMachineBuilt > 0 Then Setlog("Build " & $iTotalMachineBuilt & " " & $g_asSiegeMachineNames[$iSiegeType] &($iTotalMachineBuilt >= 2 ? "s" : ""), $COLOR_SUCCESS)
EndIf
If _Sleep(250) Then Return
EndFunc
Func getArmyTroopTime($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmyTroopTime():", $COLOR_DEBUG1)
$g_aiTimeTrain[0] = 0
If $bCheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyTroopTime()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $sResultTroops = getRemainTrainTimer(495, 169, $bNeedCapture)
$g_aiTimeTrain[0] = ConvertOCRTime("Troops", $sResultTroops, $bSetLog)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyTroopCapacity($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmyTroopsCapacity():", $COLOR_DEBUG1)
If $bCheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyTroopCapacity()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $aGetArmyCap[3] = ["", "", ""]
Local $sArmyInfo = ""
Local $iCount = 0
Local $sInputbox, $iHoldCamp
Local $tmpTotalCamp = 0
Local $tmpCurCamp = 0
$sArmyInfo = getArmyCampCap($aArmyCampSize[0], $aArmyCampSize[1], $bNeedCapture)
While $iCount < 100
$iCount += 1
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
ForceCaptureRegion()
$sArmyInfo = getArmyCampCap($aArmyCampSize[0], $aArmyCampSize[1], $bNeedCapture)
If $g_bDebugSetlogTrain Then SetLog("OCR $sArmyInfo = " & $sArmyInfo, $COLOR_DEBUG)
If StringInStr($sArmyInfo, "#", 0, 1) < 2 Then ContinueLoop
$aGetArmyCap = StringSplit($sArmyInfo, "#")
If IsArray($aGetArmyCap) Then
If $aGetArmyCap[0] > 1 Then
If Number($aGetArmyCap[2]) < 10 Or Mod(Number($aGetArmyCap[2]), 5) <> 0 Then
If $g_bDebugSetlogTrain Then SetLog(" OCR value is not valid camp size", $COLOR_DEBUG)
ContinueLoop
EndIf
$tmpCurCamp = Number($aGetArmyCap[1])
If $g_bDebugSetlogTrain Then SetLog("$tmpCurCamp = " & $tmpCurCamp, $COLOR_DEBUG)
$tmpTotalCamp = Number($aGetArmyCap[2])
If $g_bDebugSetlogTrain Then SetLog("$g_iTotalCampSpace = " & $g_iTotalCampSpace & ", Camp OCR = " & $tmpTotalCamp, $COLOR_DEBUG)
If $iHoldCamp = $tmpTotalCamp Then ExitLoop
$iHoldCamp = $tmpTotalCamp
EndIf
EndIf
WEnd
If $iCount <= 99 Then
$g_CurrentCampUtilization = $tmpCurCamp
If $g_iTotalCampSpace = 0 Then $g_iTotalCampSpace = $tmpTotalCamp
If $g_bDebugSetlogTrain Then SetLog("$g_CurrentCampUtilization = " & $g_CurrentCampUtilization & ", $g_iTotalCampSpace = " & $g_iTotalCampSpace, $COLOR_DEBUG)
Else
SetLog("Army size read error, Troop numbers may not train correctly", $COLOR_ERROR)
$g_CurrentCampUtilization = 0
CheckOverviewFullArmy()
EndIf
If $g_iTotalCampSpace = 0 Or($g_iTotalCampSpace <> $tmpTotalCamp) Then
If $g_bTotalCampForced = False Then
Local $proposedTotalCamp = $tmpTotalCamp
If $g_iTotalCampSpace > $tmpTotalCamp Then $proposedTotalCamp = $g_iTotalCampSpace
$sInputbox = InputBox("Question", "Enter your total Army Camp capacity." & @CRLF & @CRLF & "Please check it matches with total Army Camp capacity" & @CRLF & "you see in Army Overview right now in Android Window:" & @CRLF & $g_sAndroidTitle & @CRLF & @CRLF & "(This window closes in 2 Minutes with value of " & $proposedTotalCamp & ")", $proposedTotalCamp, "", 330, 220, Default, Default, 120, $g_hFrmBot)
Local $error = @error
If $error = 1 Then
SetLog("Army Camp User input cancelled, still using " & $g_iTotalCampSpace, $COLOR_ACTION)
Else
If $error = 2 Then
$g_iTotalCampSpace = $proposedTotalCamp
Else
$g_iTotalCampSpace = Number($sInputbox)
EndIf
If $error = 0 Then
$g_iTotalCampForcedValue = $g_iTotalCampSpace
$g_bTotalCampForced = True
SetLog("Army Camp User input = " & $g_iTotalCampSpace, $COLOR_INFO)
Else
SetLog("Army Camp proposed value = " & $g_iTotalCampSpace, $COLOR_ACTION)
EndIf
EndIf
Else
$g_iTotalCampSpace = Number($g_iTotalCampForcedValue)
EndIf
EndIf
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
If $g_bTotalCampForced = True Then $g_iTotalCampSpace = Number($g_iTotalCampForcedValue)
If $g_iTotalCampSpace > 0 Then
If $bSetLog Then SetLog("Total Army Camp Capacity: " & $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace & " (" & Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) & "%)")
$g_iArmyCapacity = Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
Else
If $bSetLog Then SetLog("Total Army Camp Capacity: " & $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace)
$g_iArmyCapacity = 0
EndIf
If($g_CurrentCampUtilization >=($g_iTotalCampSpace * $g_iTrainArmyFullTroopPct / 100)) Then
$g_bFullArmy = True
Else
$g_bFullArmy = False
$g_bIsFullArmywithHeroesAndSpells = False
EndIf
If $g_CurrentCampUtilization >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$DB] / 100 And $g_abSearchCampsEnable[$DB] And IsSearchModeActive($DB) Then $g_bFullArmy = True
If $g_CurrentCampUtilization >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$LB] / 100 And $g_abSearchCampsEnable[$LB] And IsSearchModeActive($LB) Then $g_bFullArmy = True
If $g_CurrentCampUtilization >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$TS] / 100 And $g_abSearchCampsEnable[$TS] And IsSearchModeActive($TS) Then $g_bFullArmy = True
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyTroops($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = False, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmyTroops():", $COLOR_DEBUG)
If Not $bOpenArmyWindow Then
If $bCheckWindow And Not IsTrainPage() Then
SetError(1)
Return
EndIf
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyTroops()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
If _CheckPixel($aRecievedTroops, $bNeedCapture) Then
If $bSetLog Then SetLog("Detected Clan Castle Message Blocking Troop Images. Waiting until it's gone", $COLOR_INFO)
_CaptureRegion2()
While _CheckPixel($aRecievedTroops, False)
_Sleep($DELAYTRAIN1)
WEnd
EndIf
Local $sTroopDiamond = GetDiamondFromRect("23,215,585,255")
If $g_bDebugFuncTime Then StopWatchStart("findMultiple, \imgxml\ArmyOverview\Troops")
Local $aCurrentTroops = findMultiple(@ScriptDir & "\imgxml\ArmyOverview\Troops", $sTroopDiamond, $sTroopDiamond, 0, 1000, 0, "objectname,objectpoints", $bNeedCapture)
If $g_bDebugFuncTime Then StopWatchStopLog()
Local $aTempTroopArray, $aTroopCoords
Local $sTroopName = ""
Local $iTroopIndex = -1, $iDropTrophyIndex = -1
Local $aCurrentTroopsEmpty[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aTroopsForTropyDropEmpty[8][2] = [["Barb", 0], ["Arch", 0], ["Giant", 0], ["Wall", 0], ["Gobl", 0], ["Mini", 0], ["Ball", 0], ["Wiza", 0]]
Local $aCurrentTroopsLog[$eTroopCount][3]
$g_aiCurrentTroops = $aCurrentTroopsEmpty
$g_avDTtroopsToBeUsed = $aTroopsForTropyDropEmpty
If UBound($aCurrentTroops, 1) >= 1 Then
For $i = 0 To UBound($aCurrentTroops, 1) - 1
$aTempTroopArray = $aCurrentTroops[$i]
$iTroopIndex = TroopIndexLookup($aTempTroopArray[0], "getArmyTroops()")
$aTroopCoords = StringSplit($aTempTroopArray[1], ",", $STR_NOCOUNT)
If $iTroopIndex = -1 Then ContinueLoop
$g_aiCurrentTroops[$iTroopIndex] = Number(getBarracksNewTroopQuantity(Slot($aTroopCoords[0], $aTroopCoords[1]), 196, $bNeedCapture))
$iDropTrophyIndex = _ArraySearch($g_avDTtroopsToBeUsed, $aTempTroopArray[0])
If $iDropTrophyIndex <> -1 Then $g_avDTtroopsToBeUsed[$iDropTrophyIndex][1] += $g_aiCurrentTroops[$iTroopIndex]
$sTroopName = $g_aiCurrentTroops[$iTroopIndex] >= 2 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]
$aCurrentTroopsLog[$iTroopIndex][0] = $sTroopName
$aCurrentTroopsLog[$iTroopIndex][1] = $g_aiCurrentTroops[$iTroopIndex]
$aCurrentTroopsLog[$iTroopIndex][2] = Slot($aTroopCoords[0], $aTroopCoords[1])
Next
EndIf
_ArraySort($aCurrentTroopsLog, 0, 0, 0, 2)
For $index = 0 To UBound($aCurrentTroopsLog) - 1
If $aCurrentTroopsLog[$index][1] > 0 And $bSetLog Then SetLog(" - " & $aCurrentTroopsLog[$index][1] & " " & $aCurrentTroopsLog[$index][0] & " Available", $COLOR_SUCCESS)
Next
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyHeroCount($bOpenArmyWindow = False, $bCloseArmyWindow = False, $CheckWindow = True, $bSetLog = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin getArmyHeroCount:", $COLOR_DEBUG)
If $CheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyHeroCount()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
$g_iHeroAvailable = $eHeroNone
Local $iDebugArmyHeroCount = 0
Local $sResult
Local Const $iHeroes = 3
Local $sMessage = ""
For $i = 0 To $iHeroes - 1
$sResult = ArmyHeroStatus($i)
If $sResult <> "" Then
Select
Case StringInStr($sResult, "king", $STR_NOCASESENSEBASIC)
If $bSetLog Then SetLog(" - Barbarian King Available", $COLOR_SUCCESS)
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroKing)
$g_iHeroUpgrading[0] = 0
$g_iHeroUpgradingBit = BitAND($g_iHeroUpgradingBit, BitOr($eHeroQueen,$eHeroWarden))
Case StringInStr($sResult, "queen", $STR_NOCASESENSEBASIC)
If $bSetLog Then SetLog(" - Archer Queen Available", $COLOR_SUCCESS)
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroQueen)
$g_iHeroUpgrading[1] = 0
$g_iHeroUpgradingBit = BitAND($g_iHeroUpgradingBit, BitOr($eHeroKing,$eHeroWarden))
Case StringInStr($sResult, "warden", $STR_NOCASESENSEBASIC)
If $bSetLog Then SetLog(" - Grand Warden Available", $COLOR_SUCCESS)
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroWarden)
$g_iHeroUpgrading[2] = 0
$g_iHeroUpgradingBit = BitAND($g_iHeroUpgradingBit, BitOr($eHeroKing,$eHeroQueen))
Case StringInStr($sResult, "heal", $STR_NOCASESENSEBASIC)
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then
Switch $i
Case 0
$sMessage = "-Barbarian King"
$g_iHeroUpgrading[0] = 0
$g_iHeroUpgradingBit = BitAND($g_iHeroUpgradingBit, BitOr($eHeroQueen,$eHeroWarden))
Case 1
$sMessage = "-Archer Queen"
$g_iHeroUpgrading[1] = 0
$g_iHeroUpgradingBit = BitAND($g_iHeroUpgradingBit, BitOr($eHeroKing,$eHeroWarden))
Case 2
$sMessage = "-Grand Warden"
$g_iHeroUpgrading[2] = 0
$g_iHeroUpgradingBit = BitAND($g_iHeroUpgradingBit, BitOr($eHeroKing,$eHeroQueen))
Case Else
$sMessage = "-Very Bad Monkey Needs"
EndSwitch
SetLog("Hero slot#" & $i + 1 & $sMessage & " Healing", $COLOR_DEBUG)
EndIf
Case StringInStr($sResult, "upgrade", $STR_NOCASESENSEBASIC)
Switch $i
Case 0
$sMessage = "-Barbarian King"
$g_iHeroUpgrading[0] = 1
$g_iHeroUpgradingBit = BitOR($g_iHeroUpgradingBit, $eHeroKing)
If($g_abAttackTypeEnable[$DB] And BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroKing) = $eHeroKing) Or($g_abAttackTypeEnable[$LB] And BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroKing) = $eHeroKing) Then
If $g_iSearchNotWaitHeroesEnable = 1 Then
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroKing)
Else
SetLog("Warning: King Upgrading & Wait enabled, Disable Wait for King or may never attack!", $COLOR_ERROR)
EndIf
_GUI_Value_STATE("SHOW", $groupKingSleeping)
EndIf
Case 1
$sMessage = "-Archer Queen"
$g_iHeroUpgrading[1] = 1
$g_iHeroUpgradingBit = BitOR($g_iHeroUpgradingBit, $eHeroQueen)
If($g_abAttackTypeEnable[$DB] And BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroQueen) = $eHeroQueen) Or($g_abAttackTypeEnable[$LB] And BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroQueen) = $eHeroQueen) Then
If $g_iSearchNotWaitHeroesEnable = 1 Then
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroQueen)
Else
SetLog("Warning: Queen Upgrading & Wait enabled, Disable Wait for Queen or may never attack!", $COLOR_ERROR)
EndIf
_GUI_Value_STATE("SHOW", $groupQueenSleeping)
EndIf
Case 2
$sMessage = "-Grand Warden"
$g_iHeroUpgrading[2] = 1
$g_iHeroUpgradingBit = BitOR($g_iHeroUpgradingBit, $eHeroWarden)
If($g_abAttackTypeEnable[$DB] And BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroWarden) = $eHeroWarden) Or($g_abAttackTypeEnable[$DB] And BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroWarden) = $eHeroWarden) Then
If $g_iSearchNotWaitHeroesEnable = 1 Then
$g_iHeroAvailable = BitOR($g_iHeroAvailable, $eHeroWarden)
Else
SetLog("Warning: Warden Upgrading & Wait enabled, Disable Wait for Warden or may never attack!", $COLOR_ERROR)
EndIf
_GUI_Value_STATE("SHOW", $groupWardenSleeping)
EndIf
Case Else
$sMessage = "-Need to Feed Code Monkey some bananas"
EndSwitch
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then SetLog("Hero slot#" & $i + 1 & $sMessage & " Upgrade in Process", $COLOR_DEBUG)
Case StringInStr($sResult, "none", $STR_NOCASESENSEBASIC)
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then SetLog("Hero slot#" & $i + 1 & " Empty, stop count", $COLOR_DEBUG)
ExitLoop
Case Else
If $bSetLog Then SetLog("Hero slot#" & $i + 1 & " bad OCR string returned!", $COLOR_ERROR)
EndSelect
Else
If $bSetLog Then SetLog("Hero slot#" & $i + 1 & " status read problem!", $COLOR_ERROR)
EndIf
Next
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then SetLog("Hero Status  K|Q|W : " & BitAND($g_iHeroAvailable, $eHeroKing) & "|" & BitAND($g_iHeroAvailable, $eHeroQueen) & "|" & BitAND($g_iHeroAvailable, $eHeroWarden), $COLOR_DEBUG)
If $g_bDebugSetlogTrain Or $iDebugArmyHeroCount = 1 Then SetLog("Hero Upgrade K|Q|W : " & BitAND($g_iHeroUpgradingBit, $eHeroKing) & "|" & BitAND($g_iHeroUpgradingBit, $eHeroQueen) & "|" & BitAND($g_iHeroUpgradingBit, $eHeroWarden), $COLOR_DEBUG)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func ArmyHeroStatus($i)
Local $sImageDir = "trainwindow-HeroStatus-bundle", $sResult = ""
Local Const $aHeroesRect[3][4] = [[655, 340, 680, 370], [730, 340, 755, 370], [805, 340, 830, 370]]
_CaptureRegion2($aHeroesRect[$i][0], $aHeroesRect[$i][1], $aHeroesRect[$i][2], $aHeroesRect[$i][3])
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $sImageDir, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
If StringInStr($aKeys[0], "xml", $STR_NOCASESENSEBASIC) Then
Local $aResult = StringSplit($aKeys[0], "_", $STR_NOCOUNT)
$sResult = $aResult[0]
Switch $sResult
Case "heal"
GUICtrlSetState($g_hPicHeroGray[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGreen[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRed[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlue[$i], $GUI_SHOW)
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicHeroGrayStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGreenStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRedStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlueStatus[$i][$g_iCurAccount], $GUI_SHOW)
EndIf
Case "upgrade"
GUICtrlSetState($g_hPicHeroGray[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGreen[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlue[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRed[$i], $GUI_SHOW)
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicHeroGrayStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGreenStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlueStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRedStatus[$i][$g_iCurAccount], $GUI_SHOW)
EndIf
Case "king", "queen", "warden"
GUICtrlSetState($g_hPicHeroGray[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRed[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlue[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGreen[$i], $GUI_SHOW)
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicHeroGrayStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRedStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlueStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGreenStatus[$i][$g_iCurAccount], $GUI_SHOW)
EndIf
EndSwitch
Return $sResult
EndIf
Else
GUICtrlSetState($g_hPicHeroGreen[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRed[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlue[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGray[$i], $GUI_SHOW)
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicHeroGreenStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRedStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlueStatus[$i][$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGrayStatus[$i][$g_iCurAccount], $GUI_SHOW)
EndIf
Return "none"
EndIf
EndFunc
Func LabGuiDisplay()
Local Static $iLastTimeChecked[8] = [0, 0, 0, 0, 0, 0, 0, 0]
If _DateIsValid($g_sLabUpgradeTime) And _DateIsValid($iLastTimeChecked[$g_iCurAccount]) Then
Local $iLabTime = _DateDiff('n', _NowCalc(), $g_sLabUpgradeTime)
Local $iLastCheck =_DateDiff('n', $iLastTimeChecked[$g_iCurAccount], _NowCalc())
SetDebugLog("Lab LabUpgradeTime: " & $g_sLabUpgradeTime & ", Lab DateCalc: " & $iLabTime)
SetDebugLog("Lab LastCheck: " & $iLastTimeChecked[$g_iCurAccount] & ", Check DateCalc: " & $iLastCheck)
If $iLabTime > 0 And $iLastCheck <= 360 Then Return
EndIf
ClickP($aAway, 2, 0, "#0346")
If _Sleep(1500) Then Return
Setlog("Checking Lab Status", $COLOR_INFO)
If $g_aiLaboratoryPos[0] <= 0 Or $g_aiLaboratoryPos[1] <= 0 Then
SetLog("Laboratory Location not found!", $COLOR_ERROR)
LocateLab()
If $g_aiLaboratoryPos[0] = 0 Or $g_aiLaboratoryPos[1] = 0 Then
SetLog("Problem locating Laboratory, train laboratory position before proceeding", $COLOR_ERROR)
GUICtrlSetState($g_hPicLabGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGray, $GUI_SHOW)
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicLabGreenStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabRedStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabGrayStatus[$g_iCurAccount], $GUI_SHOW)
EndIf
Return
EndIf
EndIf
BuildingClickP($g_aiLaboratoryPos, "#0197")
If _Sleep(1500) Then Return
$iLastTimeChecked[$g_iCurAccount] = _NowCalc()
Local $aResearchButton = findButton("Research", Default, 1, True)
If IsArray($aResearchButton) And UBound($aResearchButton, 1) = 2 Then
If $g_bDebugImageSave Then DebugImageSave("StarLabUpgrade")
ClickP($aResearchButton)
If _Sleep($DELAYLABORATORY1) Then Return
Else
SetLog("Cannot find the Laboratory Research Button!", $COLOR_ERROR)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
GUICtrlSetState($g_hPicLabGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGray, $GUI_SHOW)
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicLabGreenStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabRedStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabGrayStatus[$g_iCurAccount], $GUI_SHOW)
EndIf
Return
EndIf
If _ColorCheck(_GetPixelColor(730, 200, True), Hex(0xA2CB6C, 6), 20) Then
SetLog("Laboratory is Running", $COLOR_INFO)
GUICtrlSetState($g_hPicLabGray, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGreen, $GUI_SHOW)
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicLabGrayStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabRedStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabGreenStatus[$g_iCurAccount], $GUI_SHOW)
EndIf
If _Sleep($DELAYLABORATORY2) Then Return
Local $sLabTimeOCR = getRemainTLaboratory(270, 257)
Local $iLabFinishTime = ConvertOCRTime("Lab Time", $sLabTimeOCR, False)
SetDebugLog("$sLabTimeOCR: " & $sLabTimeOCR & ", $iLabFinishTime = " & $iLabFinishTime & " m")
If $iLabFinishTime > 0 Then
$g_sLabUpgradeTime = _DateAdd('n', Ceiling($iLabFinishTime), _NowCalc())
SetLog("Research will finish in " & $sLabTimeOCR & " (" & $g_sLabUpgradeTime & ")")
EndIf
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
If ProfileSwitchAccountEnabled() Then SwitchAccountVariablesReload("Save")
Return True
ElseIf _ColorCheck(_GetPixelColor(730, 200, True), Hex(0x8088B0, 6), 20) Then
SetLog("Laboratory has Stopped", $COLOR_INFO)
If $g_bNotifyTGEnable And $g_bNotifyAlertLaboratoryIdle Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Laboratory-Idle_Info_01", "Laboratory Idle") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Laboratory-Idle_Info_02", "Laboratory has Stopped"))
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
GUICtrlSetState($g_hPicLabGray, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_SHOW)
GUICtrlSetData($g_hLblLabTime, "00:00:00")
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicLabGrayStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabGreenStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabRedStatus[$g_iCurAccount], $GUI_SHOW)
GUICtrlSetData($g_hLblLabTimeStatus[$g_iCurAccount], "00:00:00")
EndIf
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
$g_sLabUpgradeTime = ""
If ProfileSwitchAccountEnabled() Then SwitchAccountVariablesReload("Save")
Return
Else
SetLog("Unable to determine Lab Status", $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
GUICtrlSetState($g_hPicLabGreen, $GUI_HIDE)
GUICtrlSetState($g_hPicLabRed, $GUI_HIDE)
GUICtrlSetState($g_hPicLabGray, $GUI_SHOW)
GUICtrlSetData($g_hLblLabTime, "00:00:00")
If ProfileSwitchAccountEnabled() Then
GUICtrlSetState($g_hPicLabGreenStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabRedStatus[$g_iCurAccount], $GUI_HIDE)
GUICtrlSetState($g_hPicLabGrayStatus[$g_iCurAccount], $GUI_SHOW)
GUICtrlSetData($g_hLblLabTimeStatus[$g_iCurAccount], "00:00:00")
EndIf
Return
EndIf
EndFunc
Func getArmyHeroTime($iHeroType, $bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin getArmyHeroTime:", $COLOR_DEBUG)
$g_asHeroHealTime[0] = ""
$g_asHeroHealTime[1] = ""
$g_asHeroHealTime[2] = ""
If $iHeroType <> $eHeroKing And $iHeroType <> $eHeroQueen And $iHeroType <> $eHeroWarden And StringInStr($iHeroType, "all", $STR_NOCASESENSEBASIC) = 0 Then
SetLog("getHeroTime slipped on banana, get doctor, tell him: " & $iHeroType, $COLOR_ERROR)
SetError(1)
Return
EndIf
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(2)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyHeroTime()") Then
SetError(3)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
Local $iRemainTrainHeroTimer = 0, $sResultHeroTime
Local $sResult
Local $aResultHeroes[3] = ["", "", ""]
Local Const $aHeroRemainData[3][4] = [[619, 414, "King", $eHeroKing], [693, 414, "Queen", $eHeroQueen], [767, 414, "Warden", $eHeroWarden]]
For $index = 0 To UBound($aHeroRemainData) - 1
If StringInStr($iHeroType, "all", $STR_NOCASESENSEBASIC) = 0 And $iHeroType <> $aHeroRemainData[$index][3] Then ContinueLoop
$sResult = ArmyHeroStatus($index)
If $sResult <> "" Then
If StringInStr($sResult, "heal", $STR_NOCASESENSEBASIC) = 0 Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then
SetLog("Hero slot#" & $index + 1 & " status: " & $sResult & " :skip time read", $COLOR_PURPLE)
EndIf
ContinueLoop
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Hero slot#" & $index + 1 & " status: " & $sResult, $COLOR_DEBUG)
EndIf
Else
SetLog("Hero slot#" & $index + 1 & " Status read problem!", $COLOR_ERROR)
EndIf
$sResult = getRemainTHero($aHeroRemainData[$index][0], $aHeroRemainData[$index][1])
If $sResult <> "" Then
$aResultHeroes[$index] = ConvertOCRTime($aHeroRemainData[$index][2] & " recover" , $sResult, False)
SetLog("Remaining " & $aHeroRemainData[$index][2] & " recover time: " & StringFormat("%.2f", $aResultHeroes[$index]), $COLOR_INFO)
If $iHeroType = $aHeroRemainData[$index][3] Then
$iRemainTrainHeroTimer = Number($aResultHeroes[$index])
ExitLoop
EndIf
Else
If $iHeroType = $aHeroRemainData[$index][3] Then
SetLog("Can not read remaining " & $aHeroRemainData[$index][2] & " recover time", $COLOR_RED)
Else
For $pMatchMode = $DB To $g_iMatchMode - 1
If IsUnitUsed($pMatchMode, $aHeroRemainData[$index][3]) And BitAND($g_aiAttackUseHeroes[$pMatchMode], $g_aiSearchHeroWaitEnable[$pMatchMode]) = $g_aiSearchHeroWaitEnable[$pMatchMode] Then
SetLog("Can not read remaining " & $aHeroRemainData[$index][2] & " train time", $COLOR_ERROR)
ExitLoop
Else
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Bad read remain " & $aHeroRemainData[$index][2] & " recover time, but not enabled", $COLOR_DEBUG)
EndIf
Next
EndIf
EndIf
Next
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
If $iHeroType = $eHeroKing Or $iHeroType = $eHeroQueen Or $iHeroType = $eHeroWarden Then
Return $iRemainTrainHeroTimer
ElseIf StringInStr($iHeroType, "all", $STR_NOCASESENSEBASIC) > 0 Then
For $i = 0 To 2
If $aResultHeroes[$i] <> "" and $aResultHeroes[$i] > 0 Then $g_asHeroHealTime[$i] = _DateAdd("s", Int($aResultHeroes[$i]) * 60, _NowCalc())
SetDebugLog($aHeroRemainData[$i][2] & " heal time: " & $g_asHeroHealTime[$i])
Next
Return $aResultHeroes
EndIf
EndFunc
Func getArmySpellTime($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmySpellTime():", $COLOR_DEBUG1)
$g_aiTimeTrain[1] = 0
If $bCheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not openArmyOverview(True, "getArmySpellTime()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $sResultSpells = getRemainTrainTimer(495, 315, $bNeedCapture)
$g_aiTimeTrain[1] = ConvertOCRTime("Spells", $sResultSpells, $bSetLog)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmySpells($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = False, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmySpells():", $COLOR_DEBUG)
If Not $bOpenArmyWindow Then
If $bCheckWindow And Not IsTrainPage() Then
SetError(1)
Return
EndIf
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmySpells()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
Local $sSpellDiamond = GetDiamondFromRect("23,366,585,400")
Local $aCurrentSpells = findMultiple(@ScriptDir & "\imgxml\ArmyOverview\Spells", $sSpellDiamond, $sSpellDiamond, 0, 1000, 0, "objectname,objectpoints", $bNeedCapture)
Local $aTempSpellArray, $aSpellCoords
Local $sSpellName = ""
Local $iSpellIndex = -1
Local $aCurrentSpellsEmpty[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $aCurrentSpellsLog[$eSpellCount][3]
$g_aiCurrentSpells = $aCurrentSpellsEmpty
If UBound($aCurrentSpells, 1) >= 1 Then
For $i = 0 To UBound($aCurrentSpells, 1) - 1
$aTempSpellArray = $aCurrentSpells[$i]
$iSpellIndex = TroopIndexLookup($aTempSpellArray[0], "getArmySpells()") - $eLSpell
If $iSpellIndex < 0 Then ContinueLoop
$aSpellCoords = StringSplit($aTempSpellArray[1], ",", $STR_NOCOUNT)
If UBound($aSpellCoords) < 2 Then ContinueLoop
$g_aiCurrentSpells[$iSpellIndex] = Number(getBarracksNewTroopQuantity(Slot($aSpellCoords[0], $aSpellCoords[1]), 341, $bNeedCapture))
$sSpellName = $g_aiCurrentSpells[$iSpellIndex] >= 2 ? $g_asSpellNames[$iSpellIndex] & " Spells" : $g_asSpellNames[$iSpellIndex] & " Spell"
$aCurrentSpellsLog[$iSpellIndex][0] = $sSpellName
$aCurrentSpellsLog[$iSpellIndex][1] = $g_aiCurrentSpells[$iSpellIndex]
$aCurrentSpellsLog[$iSpellIndex][2] = Slot($aSpellCoords[0], $aSpellCoords[1])
Next
EndIf
_ArraySort($aCurrentSpellsLog, 0, 0, 0, 2)
For $index = 0 To UBound($aCurrentSpellsLog) - 1
If $aCurrentSpellsLog[$index][1] > 0 And $bSetLog Then SetLog(" - " & $aCurrentSpellsLog[$index][1] & " " & $aCurrentSpellsLog[$index][0] & " Brewed", $COLOR_SUCCESS)
Next
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmySpellCapacity($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("getArmySpellCapacity():", $COLOR_DEBUG1)
If $bCheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmySpellCapacity()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $g_iTotalSpells = 0
Local $aGetSpellCap[3] = ["", "", ""]
Local $iCount
Local $sSpellsInfo = ""
If $g_iTotalSpellValue > 0 Then
$sSpellsInfo = getArmyCampCap($aArmySpellSize[0], $aArmySpellSize[1], $bNeedCapture)
$iCount = 0
While $sSpellsInfo = ""
$sSpellsInfo = getArmyCampCap($aArmySpellSize[0], $aArmySpellSize[1], $bNeedCapture)
$iCount += 1
If $iCount > 10 Then ExitLoop
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
WEnd
If $g_bDebugSetlogTrain Then SetLog("$sSpellsInfo= " & $sSpellsInfo, $COLOR_DEBUG)
$aGetSpellCap = StringSplit($sSpellsInfo, "#")
If IsArray($aGetSpellCap) Then
If $aGetSpellCap[0] > 1 Then
$g_iTotalSpells = Number($aGetSpellCap[2])
$g_iCurrentSpells = Number($aGetSpellCap[1])
Else
SetLog("Error in getArmySpellCapacity: Couldn't reall all Capacity Values", $COLOR_ERROR)
$g_iCurrentSpells = 0
$g_iTotalSpells = $g_iTotalSpellValue
EndIf
Else
SetLog("Error in getArmySpellCapacity: $aGetCCSpell is not an Array", $COLOR_ERROR)
$g_iCurrentSpells = 0
$g_iTotalSpells = $g_iTotalSpellValue
EndIf
If $bSetLog Then SetLog("Total Spell Factory Capacity: " & $g_iCurrentSpells & "/" & $g_iTotalSpells)
EndIf
If $g_iTotalSpells <> $g_iTotalSpellValue And $bSetLog Then SetLog("Warning: Total Spell Capacity is not the same as in GUI", $COLOR_WARNING)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func GetCurTotalSpell()
Local $iCount = 0
For $i = 0 To $eSpellCount - 1
$iCount += $g_aiCurrentSpells[$i]
Next
Return $iCount
EndFunc
Func GetCurTotalDarkSpell()
Local $iCount = 0
For $i = $eSpellPoison To $eSpellBat - 1
$iCount += $g_aiCurrentSpells[$i]
Next
Return $iCount
EndFunc
Func getArmySiegeMachines($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = False, $bSetLog = True, $bNeedCapture = True)
If $g_iTotalTrainSpaceSiege < 1 Then Return
If $g_bDebugSetlogTrain Then SetLog("getArmySiegeMachines():", $COLOR_DEBUG)
If Not $bOpenArmyWindow Then
If $bCheckWindow And Not IsTrainPage() Then
SetError(1)
Return
EndIf
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmySiegeMachines()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
If _CheckPixel($aRecievedTroops, $bNeedCapture) Then
If $bSetLog Then SetLog("Detected Clan Castle Message Blocking Troop Images. Waiting until it's gone", $COLOR_INFO)
_CaptureRegion2()
While _CheckPixel($aRecievedTroops, False)
_Sleep($DELAYTRAIN1)
WEnd
EndIf
Local $sSiegeDiamond = GetDiamondFromRect("605,215,840,255")
If $g_bDebugFuncTime Then StopWatchStart("findMultiple, \imgxml\ArmyOverview\SiegeMachines")
Local $aCurrentSiegeMachines = findMultiple(@ScriptDir & "\imgxml\ArmyOverview\SiegeMachines", $sSiegeDiamond, $sSiegeDiamond, 0, 1000, 0, "objectname,objectpoints", $bNeedCapture)
If $g_bDebugFuncTime Then StopWatchStopLog()
Local $aTempSiegeArray, $aSiegeCoords
Local $sSiegeName = ""
Local $iSiegeIndex = -1
Local $aCurrentTroopsEmpty[$eSiegeMachineCount] = [0, 0]
Local $sSiegeInfo = getArmyCampCap(758, 164, $bNeedCapture)
If $g_bDebugSetlogTrain Then SetLog("OCR $sSiegeInfo = " & $sSiegeInfo, $COLOR_DEBUG)
Local $aGetSiegeCap = StringSplit($sSiegeInfo, "#", $STR_NOCOUNT)
If Ubound($aGetSiegeCap) = 2 Then
If $bSetLog Then SetLog("Total Siege Workshop Capacity: " & $aGetSiegeCap[0] & "/" & $aGetSiegeCap[1])
$g_aiCurrentSiegeMachines = $aCurrentTroopsEmpty
If Number($aGetSiegeCap[0]) = 0 then Return
Else
Return
EndIf
If UBound($aCurrentSiegeMachines, 1) >= 1 Then
For $i = 0 To UBound($aCurrentSiegeMachines, 1) - 1
$aTempSiegeArray = $aCurrentSiegeMachines[$i]
$iSiegeIndex = TroopIndexLookup($aTempSiegeArray[0], "getArmySiegeMachines()") - $eWallW
$aSiegeCoords = StringSplit($aTempSiegeArray[1], ",", $STR_NOCOUNT)
If $iSiegeIndex < 0 Then ContinueLoop
$g_aiCurrentSiegeMachines[$iSiegeIndex] = Number(getBarracksNewTroopQuantity(Slot($aSiegeCoords[0], $aSiegeCoords[1]), 196, $bNeedCapture))
$sSiegeName = $g_aiCurrentSiegeMachines[$iSiegeIndex] >= 2 ? $g_asSiegeMachineNames[$iSiegeIndex] & "s" : $g_asSiegeMachineNames[$iSiegeIndex] & ""
If $g_bDebugSetlogTrain Then Setlog($sSiegeName & " Coord: (" & $aSiegeCoords[0] & "," & $aSiegeCoords[1] & ") Quant :" & $g_aiCurrentSiegeMachines[$iSiegeIndex])
If $g_bDebugSetlogTrain Then Setlog($sSiegeName & " Slot (" & Slot($aSiegeCoords[0], $aSiegeCoords[1]) & "," & 196 & ")")
If $bSetLog Then SetLog(" - " & $g_aiCurrentSiegeMachines[$iSiegeIndex] & " " & $sSiegeName & " Available", $COLOR_SUCCESS)
Next
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyCCStatus($bOpenArmyWindow = False, $bCloseArmyWindow = False, $CheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin getArmyCCStatus:", $COLOR_DEBUG1)
$g_iCCRemainTime = 0
If $CheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyCCStatus()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
$g_bCanRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, $bNeedCapture), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], $bNeedCapture), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5])
If $g_bDebugSetlogTrain Then SetLog("Can Request CC: " & $g_bCanRequestCC, $COLOR_DEBUG)
If Not $g_bCanRequestCC Then
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, $bNeedCapture), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And Not _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], $bNeedCapture), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
If $bSetLog Then SetLog(" - Clan Castle request already made.", $COLOR_INFO)
EndIf
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, $bNeedCapture), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5]) And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], $bNeedCapture), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
If $bSetLog Then SetLog("Clan Castle Full/No Clan.", $COLOR_INFO)
EndIf
EndIf
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1] + 20, $bNeedCapture), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) And Not _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], $bNeedCapture), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
Local $sResultCC = getRequestRemainTime($aArmyCCRemainTime[0], $aArmyCCRemainTime[1])
If $g_bDebugSetlogTrain Then SetLog("getArmyCampCap returned: " & $sResultCC, $COLOR_DEBUG)
$g_iCCRemainTime = ConvertOCRTime("CC request", $sResultCC, $bSetLog)
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyCCTroops($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = False, $bSetLog = True, $bNeedCapture = True, $bGetSlot = False)
Local $aTroopWSlot[1][3] = [[0, "", 0]]
If $g_bDebugSetlogTrain Then SetLog("getArmyCCTroops():", $COLOR_DEBUG)
If Not $bOpenArmyWindow Then
If $bCheckWindow And Not IsTrainPage() Then
SetError(1)
Return
EndIf
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyCCTroops()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
Local $sTroopDiamond = GetDiamondFromRect("20,495,462,598")
Local $aCurrentCCTroops = findMultiple(@ScriptDir & "\imgxml\ArmyOverview\Troops", $sTroopDiamond, $sTroopDiamond, 0, 1000, 0, "objectname,objectpoints", $bNeedCapture)
Local $aTempTroopArray,$aTroops ,$aTroopCoords
Local $sTroopName = ""
Local $iTroopIndex = -1
Local $aCurrentCCTroopsEmpty[$eTroopCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
$g_aiCurrentCCTroops = $aCurrentCCTroopsEmpty
If UBound($aCurrentCCTroops, 1) >= 1 Then
For $i = 0 To UBound($aCurrentCCTroops, 1) - 1
$aTempTroopArray = $aCurrentCCTroops[$i]
$iTroopIndex = TroopIndexLookup($aTempTroopArray[0], "getArmyTroops()")
If StringInStr($aTempTroopArray[1], "|") Then
$aTroops = StringSplit($aTempTroopArray[1], "|")
For $j = 1 To $aTroops[0]
$aTroopCoords = StringSplit($aTroops[$j], ",", $STR_NOCOUNT)
Local $TempQty = Number(getBarracksNewTroopQuantity(Slot($aTroopCoords[0], $aTroopCoords[1]), 498, $bNeedCapture))
$g_aiCurrentCCTroops[$iTroopIndex] += $TempQty
$aTroopWSlot[UBound($aTroopWSlot) - 1][0] = Slot($aTroopCoords[0], $aTroopCoords[1])
$aTroopWSlot[UBound($aTroopWSlot) - 1][1] = $iTroopIndex
$aTroopWSlot[UBound($aTroopWSlot) - 1][2] = $TempQty
ReDim $aTroopWSlot[UBound($aTroopWSlot) + 1][3]
Next
Else
$aTroopCoords = StringSplit($aTempTroopArray[1], ",", $STR_NOCOUNT)
$g_aiCurrentCCTroops[$iTroopIndex] = Number(getBarracksNewTroopQuantity(Slot($aTroopCoords[0], $aTroopCoords[1]), 498, $bNeedCapture))
$aTroopWSlot[UBound($aTroopWSlot) - 1][0] = Slot($aTroopCoords[0], $aTroopCoords[1])
$aTroopWSlot[UBound($aTroopWSlot) - 1][1] = $iTroopIndex
$aTroopWSlot[UBound($aTroopWSlot) - 1][2] = $g_aiCurrentCCTroops[$iTroopIndex]
ReDim $aTroopWSlot[UBound($aTroopWSlot) + 1][3]
EndIf
$sTroopName = $g_aiCurrentCCTroops[$iTroopIndex] >= 2 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]
If $bSetLog Then SetLog(" - " & $g_aiCurrentCCTroops[$iTroopIndex] & "x " & $sTroopName & " (Clan Castle)", $COLOR_SUCCESS)
Next
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
If $bGetSlot Then
If Ubound($aTroopWSlot) > 1 Then _ArrayDelete($aTroopWSlot, Ubound($aTroopWSlot) - 1)
If UBound($aTroopWSlot) = 1 And $aTroopWSlot[0][0] = 0 And $aTroopWSlot[0][1] = "" Then Return
_ArraySort($aTroopWSlot)
Return $aTroopWSlot
EndIf
EndFunc
Func getArmyCCSpellCapacity($bOpenArmyWindow = False, $bCloseArmyWindow = False, $CheckWindow = True, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("Begin getArmyCCSpellCapacity:", $COLOR_DEBUG1)
If $g_iTownHallLevel < 8 Then Return
If $CheckWindow Then
If Not $bOpenArmyWindow And Not IsTrainPage() Then
SetError(1)
Return
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyCCSpellCapacity()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
EndIf
Local $aGetCCSpellsSize[3] = ["", "", ""]
Local $iCount
Local $sCCSpellsInfo = ""
$sCCSpellsInfo = getArmyCampCap($g_aArmyCCSpellSize[0], $g_aArmyCCSpellSize[1], $bNeedCapture)
$iCount = 0
While $sCCSpellsInfo = ""
$sCCSpellsInfo = getArmyCampCap($g_aArmyCCSpellSize[0], $g_aArmyCCSpellSize[1], $bNeedCapture)
$iCount += 1
If $iCount > 10 Then ExitLoop
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
WEnd
If $g_bDebugSetlogTrain Then SetLog("$sCCSpellsInfo = " & $sCCSpellsInfo, $COLOR_DEBUG)
$aGetCCSpellsSize = StringSplit($sCCSpellsInfo, "#")
If IsArray($aGetCCSpellsSize) Then
If $aGetCCSpellsSize[0] > 1 Then
$g_iTotalCCSpells = Number($aGetCCSpellsSize[2])
$g_iCurrentCCSpells = Number($aGetCCSpellsSize[1])
Else
SetLog("CC Spells size read error.", $COLOR_ERROR)
$g_iTotalCCSpells = 0
$g_iCurrentCCSpells = 0
EndIf
Else
SetLog("CC Spells size read error.", $COLOR_ERROR)
$g_iTotalCCSpells = 0
$g_iCurrentCCSpells = 0
EndIf
If $bSetLog Then SetLog("Total Clan Castle Spells: " & $g_iCurrentCCSpells & "/" & $g_iTotalCCSpells)
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func getArmyCCSpells($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = False, $bSetLog = True, $bNeedCapture = True, $bGetSlot = False)
Local $aSpellWSlot[1][3] = [[0, "", 0]]
If $g_bDebugSetlogTrain Then SetLog("getArmyCCSpells():", $COLOR_DEBUG)
If $g_iTownHallLevel < 8 Then Return
If Not $bOpenArmyWindow Then
If $bCheckWindow And Not IsTrainPage() Then
SetError(1)
Return
EndIf
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyCCSpells()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
Local $sCCSpellDiamond = GetDiamondFromRect("450,495,605,593")
Local $aCurrentCCSpells = findMultiple(@ScriptDir & "\imgxml\ArmyOverview\Spells", $sCCSpellDiamond, $sCCSpellDiamond, 0, 1000, 0,"objectname,objectpoints", $bNeedCapture)
Local $aTempSpellArray, $aSpells, $aSpellCoords
Local $sSpellName = ""
Local $iSpellIndex = -1
Local $aCurrentCCSpellsEmpty[$eSpellCount] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
$g_aiCurrentCCSpells = $aCurrentCCSpellsEmpty
If UBound($aCurrentCCSpells, 1) >= 1 Then
For $i = 0 To UBound($aCurrentCCSpells, 1) - 1
$aTempSpellArray = $aCurrentCCSpells[$i]
$iSpellIndex = TroopIndexLookup($aTempSpellArray[0], "getArmyCCSpells()") - $eLSpell
If $iSpellIndex < 0 Then ContinueLoop
If StringInStr($aTempSpellArray[1], "|") Then
$aSpells = StringSplit($aTempSpellArray[1], "|")
Local $X_Coord
For $i = 1 To $aSpells[0]
$aSpellCoords = StringSplit($aSpells[$i], ",", $STR_NOCOUNT)
If $i >= 1 And Abs($aSpellCoords[0] - $X_Coord) <= 50 Then ContinueLoop
Local $TempQty = Number(getBarracksNewTroopQuantity(Slot($aSpellCoords[0], $aSpellCoords[1]), 498))
$g_aiCurrentCCSpells[$iSpellIndex] += $TempQty
$aSpellWSlot[UBound($aSpellWSlot) - 1][0] = Slot($aSpellCoords[0], $aSpellCoords[1])
$aSpellWSlot[UBound($aSpellWSlot) - 1][1] = $iSpellIndex
$aSpellWSlot[UBound($aSpellWSlot) - 1][2] = $TempQty
ReDim $aSpellWSlot[UBound($aSpellWSlot) + 1][3]
$X_Coord = $aSpellCoords[0]
Next
Else
$aSpellCoords = StringSplit($aTempSpellArray[1], ",", $STR_NOCOUNT)
$g_aiCurrentCCSpells[$iSpellIndex] = Number(getBarracksNewTroopQuantity(Slot($aSpellCoords[0], $aSpellCoords[1]), 498))
$aSpellWSlot[UBound($aSpellWSlot) - 1][0] = Slot($aSpellCoords[0], $aSpellCoords[1])
$aSpellWSlot[UBound($aSpellWSlot) - 1][1] = $iSpellIndex
$aSpellWSlot[UBound($aSpellWSlot) - 1][2] = $g_aiCurrentCCSpells[$iSpellIndex]
ReDim $aSpellWSlot[UBound($aSpellWSlot) + 1][3]
EndIf
$sSpellName = $g_aiCurrentCCSpells[$iSpellIndex] >= 2 ? $g_asSpellNames[$iSpellIndex] & " Spells (Clan Castle)" : $g_asSpellNames[$iSpellIndex] & " Spell (Clan Castle)"
If $bSetLog Then SetLog(" - " & $g_aiCurrentCCSpells[$iSpellIndex] & "x " & $sSpellName, $COLOR_SUCCESS)
Next
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
If $bGetSlot Then
If Ubound($aSpellWSlot) > 1 Then _ArrayDelete($aSpellWSlot, Ubound($aSpellWSlot) - 1)
If UBound($aSpellWSlot) = 1 And $aSpellWSlot[0][0] = 0 And $aSpellWSlot[0][1] = "" Then Return
_ArraySort($aSpellWSlot)
Return $aSpellWSlot
EndIf
EndFunc
Func getArmyCCSiegeMachines($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bCheckWindow = False, $bSetLog = True, $bNeedCapture = True)
If $g_bDebugSetlogTrain Then SetLog("getArmyCCSiegeMachines():", $COLOR_DEBUG)
If $g_iTownHallLevel < 10 Then Return
If Not $bOpenArmyWindow Then
If $bCheckWindow And Not IsTrainPage() Then
SetError(1)
Return
EndIf
ElseIf $bOpenArmyWindow Then
If Not OpenArmyOverview(True, "getArmyCCSiegeMachines()") Then
SetError(2)
Return
EndIf
If _Sleep($DELAYCHECKARMYCAMP5) Then Return
EndIf
Local $sCCSiegeDiamond = GetDiamondFromRect("620,510,710,588")
If $g_bDebugFuncTime Then StopWatchStart("findMultiple, \imgxml\ArmyOverview\SiegeMachines")
Local $aCurrentCCSiegeMachines = findMultiple(@ScriptDir & "\imgxml\ArmyOverview\SiegeMachines", $sCCSiegeDiamond, $sCCSiegeDiamond, 0, 1000, 0, "objectname,objectpoints", $bNeedCapture)
If $g_bDebugFuncTime Then StopWatchStopLog()
Local $aTempCCSiegeArray, $aCCSiegeCoords
Local $sCCSiegeName = ""
Local $iCCSiegeIndex = -1
Local $aCurrentCCSiegeEmpty[$eSiegeMachineCount] = [0, 0, 0]
$g_aiCurrentCCSiegeMachines = $aCurrentCCSiegeEmpty
Local $sSiegeInfo = getArmyCampCap(650, 468, $bNeedCapture)
If $g_bDebugSetlogTrain Then SetLog("OCR $sSiegeInfo = " & $sSiegeInfo, $COLOR_DEBUG)
Local $aGetSiegeCap = StringSplit($sSiegeInfo, "#", $STR_NOCOUNT)
If $bSetLog And Ubound($aGetSiegeCap) = 2 Then
SetLog("Total Siege CC Capacity: " & $aGetSiegeCap[0] & "/" & $aGetSiegeCap[1])
If Number($aGetSiegeCap[0]) = 0 then Return
Else
Return
EndIf
If UBound($aCurrentCCSiegeMachines, 1) >= 1 Then
For $i = 0 To UBound($aCurrentCCSiegeMachines, 1) - 1
$aTempCCSiegeArray = $aCurrentCCSiegeMachines[$i]
$iCCSiegeIndex = TroopIndexLookup($aTempCCSiegeArray[0], "getArmyCCSiegeMachines()") - $eWallW
$aCCSiegeCoords = StringSplit($aTempCCSiegeArray[1], ",", $STR_NOCOUNT)
If $iCCSiegeIndex < 0 Then ContinueLoop
$g_aiCurrentCCSiegeMachines[$iCCSiegeIndex] = Number(getBarracksNewTroopQuantity(650, 498, $bNeedCapture))
$sCCSiegeName = $g_aiCurrentCCSiegeMachines[$iCCSiegeIndex] >= 2 ? $g_asSiegeMachineNames[$iCCSiegeIndex] & "s" : $g_asSiegeMachineNames[$iCCSiegeIndex] & ""
If $g_bDebugSetlogTrain Then Setlog($sCCSiegeName & " Coord: (" & $aCCSiegeCoords[0] & "," & $aCCSiegeCoords[1] & ") Quant :" & $g_aiCurrentCCSiegeMachines[$iCCSiegeIndex])
If $g_bDebugSetlogTrain Then Setlog($sCCSiegeName & " Slot (" & 650 & "," & 498 & ")")
If $bSetLog Then SetLog(" - " & $g_aiCurrentCCSiegeMachines[$iCCSiegeIndex] & " " & $sCCSiegeName & " Available", $COLOR_SUCCESS)
Next
EndIf
If $bCloseArmyWindow Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($DELAYCHECKARMYCAMP4) Then Return
EndIf
EndFunc
Func hasElixirStorage($bForceCapture = False)
Local $has = False
Local $result = findMultiple($g_sImgElixirStorage, "ECD", $g_sImglocRedline, 0, 1000, 0, "objectname,objectpoints,objectlevel", $bForceCapture)
If IsArray($result) Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = UBound($aPoints)
If $found > 0 Then
$has = True
ExitLoop
EndIf
Next
EndIf
Return $has
EndFunc
Func setZombie($RaidedElixir = -1, $AvailableElixir = -1, $Matched = -1, $SearchIdx = -1, $redline = "", $Timestamp = @YEAR & "-" & @MON & "-" & @MDAY & "_" & StringReplace(_NowTime(5), ":", "-"))
If TestCapture() Then Return ""
If $RaidedElixir = -1 And $AvailableElixir = -1 And $Matched = -1 And $SearchIdx = -1 Then
$g_aZombie[0] = ""
$g_aZombie[1] = 0
$g_aZombie[2] = 0
$g_aZombie[3] = 0
$g_aZombie[4] = 0
$g_aZombie[5] = ""
$g_aZombie[6] = ""
Else
If $RaidedElixir >= 0 Then $g_aZombie[1] = Number($RaidedElixir)
If $AvailableElixir >= 0 Then $g_aZombie[2] = Number($AvailableElixir)
If $Matched >= 0 Then $g_aZombie[3] = Number($Matched)
If $SearchIdx >= 0 Then $g_aZombie[4] = Number($SearchIdx)
If $g_aZombie[5] = "" Then $g_aZombie[5] = $Timestamp
If $g_aZombie[6] = "" Then $g_aZombie[6] = $redline
Local $dbFound = $g_aZombie[3] >= $g_iCollectorMatchesMin
Local $path = $g_sProfileTempDebugPath &(($dbFound) ?("Zombies\") :("SkippedZombies\"))
Local $availK = Round($g_aZombie[2] / 1000)
If $g_aZombie[0] = "" And $g_aZombie[4] > 0 Then
Local $create = $g_aZombie[0] = "" And($dbFound = True Or($g_aZombie[8] = -1 And $g_aZombie[9] = -1) Or($availK >= $g_aZombie[8] And hasElixirStorage() = False) Or $availK >= $g_aZombie[9])
If $create = True Then
Local $ZombieFilename = "DebugDB_" & StringFormat("%04i", $availK) & "k_" & $g_sProfileCurrentName & "_search_" & StringFormat("%03i", $g_aZombie[4]) & "_matched_" & $g_aZombie[3] & "_" & $g_aZombie[5] & ".png"
SetDebugLog("Saving enemy village screenshot for deadbase validation: " & $ZombieFilename)
SetDebugLog("Redline was: " & $g_aZombie[6])
$g_aZombie[0] = $ZombieFilename
Local $g_hBitmapZombie = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
_GDIPlus_ImageSaveToFile($g_hBitmapZombie, $path & $g_aZombie[0])
_GDIPlus_BitmapDispose($g_hBitmapZombie)
EndIf
ElseIf $g_aZombie[0] <> "" Then
Local $raidPct = 0
If $g_aZombie[2] > 0 And $g_aZombie[2] >= $g_aZombie[1] Then
$raidPct = Round((100 * $g_aZombie[1]) / $g_aZombie[2])
EndIf
If $g_aZombie[7] <> -1 And $raidPct >= $g_aZombie[7] And($g_aZombie[10] = -1 Or $g_aZombie[2] >= $g_aZombie[10]) Then
SetDebugLog("Delete enemy village screenshot as base seems dead: " & $g_aZombie[0])
FileDelete($path & $g_aZombie[0])
Else
Local $ZombieFilename = "DebugDB_" & StringFormat("%03i", $raidPct) & "%_" & $g_sProfileCurrentName & "_search_" & StringFormat("%03i", $g_aZombie[4]) & "_matched_" & $g_aZombie[3] & "_" & StringFormat("%04i", $availK) & "k_" & StringFormat("%04i", Round($g_aZombie[1] / 1000)) & "k_" & $g_aZombie[5] & ".png"
SetDebugLog("Rename enemy village screenshot as base seems live: " & $ZombieFilename)
FileMove($path & $g_aZombie[0], $path & $ZombieFilename)
EndIf
setZombie()
Else
setZombie()
EndIf
EndIf
Return $g_aZombie[0]
EndFunc
Func checkDeadBaseNew()
If $g_bCollectorFilterDisable Then
Return True
EndIf
Local $minCollectorLevel = 0
Local $maxCollectorLevel = 0
Local $anyFillLevel[2] = [False, False]
If $g_bDebugSetlog Then SetDebugLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
For $i = 6 To 13
If $g_abCollectorLevelEnabled[$i] Then
If $minCollectorLevel = 0 Then $minCollectorLevel = $i
If $i > $maxCollectorLevel Then $maxCollectorLevel = $i
$anyFillLevel[$g_aiCollectorLevelFill[$i]] = True
EndIf
Next
If $maxCollectorLevel = 0 Then
Return True
EndIf
If $g_bDebugSetlog Then SetDebugLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
Local $TotalMatched = 0
Local $Matched[2] = [-1, -1]
Local $aPoints[0]
_CaptureRegion2()
If $anyFillLevel[0] = True Then
$Matched[0] = imglocIsDeadBase($aPoints, 50, $minCollectorLevel, $maxCollectorLevel, True, False)
If $Matched[0] > 0 Then $TotalMatched += $Matched[0]
EndIf
If $TotalMatched < $g_iCollectorMatchesMin Then
$Matched[1] = imglocIsDeadBase($aPoints, 100, $minCollectorLevel, $maxCollectorLevel, True, False)
If $Matched[1] > 0 Then $TotalMatched += $Matched[1]
EndIf
Local $dbFound = $TotalMatched >= $g_iCollectorMatchesMin
If $dbFound Then
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : FOUND DEADBASE !!! Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin & ": " & UBound($aPoints), $COLOR_GREEN)
Else
If $g_bDebugSetlog Then
If $Matched[0] = -1 And $Matched[1] = -1 Then
SetDebugLog("IMGLOC : NOT A DEADBASE!!! ", $COLOR_INFO)
Else
SetDebugLog("IMGLOC : DEADBASE NOT MATCHED Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin, $COLOR_WARNING)
EndIf
EndIf
EndIf
$g_aZombie[3] = $TotalMatched
If $g_bDebugDeadBaseImage Then
setZombie(0, $g_iSearchElixir, $TotalMatched, $g_iSearchCount, $g_sImglocRedline)
EndIf
Return $dbFound
EndFunc
Func checkDeadBase()
Return checkDeadBaseSuperNew(False)
EndFunc
Func GetCollectorIndexByFillLevel($level)
If Number($level) >= 85 Then Return 1
Return 0
EndFunc
Func imglocIsDeadBase(ByRef $aPos, $FillLevel = 100, $minCollectorLevel = 0, $maxCollectorLevel = 1000, $CheckConfig = False, $bForceCapture = True)
Local $sCocDiamond = "ECD"
Local $redLines = $g_sImglocRedline
Local $minLevel = $minCollectorLevel
Local $maxLevel = $maxCollectorLevel
Local $maxReturnPoints = 0
Local $returnProps = "objectname,objectpoints,objectlevel"
Local $sDirectory = @ScriptDir & "\imgxml\deadbase\elix\" & $FillLevel & "\"
Local $matchedValues
Local $TotalMatched = 0
Local $fillIndex = GetCollectorIndexByFillLevel($FillLevel)
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase for FillLevel/MinLevel/MaxLevel: " & $FillLevel & "/" & $minLevel & "/" & $maxLevel & " using " & $sDirectory, $COLOR_INFO)
Local $result = findMultiple($sDirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
If IsArray($result) Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = UBound($aPoints)
If $CheckConfig = True Then
Local $level = Number($matchedValues[2])
If $g_abCollectorLevelEnabled[$level] Then
If $fillIndex < $g_aiCollectorLevelFill[$level] Then
$found = 0
EndIf
Else
$found = 0
EndIf
EndIf
If $found > 0 Then
For $sPoint In $aPoints
Local $aP = StringSplit($sPoint, ",", $STR_NOCOUNT)
Local $bSkipPoint = False
For $bP In $aPos
Local $a = $aP[1] - $bP[1]
Local $b = $aP[0] - $bP[0]
Local $c = Sqrt($a * $a + $b * $b)
If $c < 25 Then
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase ignore duplicate collector " & $matchedValues[0] & " at " & $aP[0] & ", " & $aP[1], $COLOR_INFO)
$bSkipPoint = True
$found -= 1
ExitLoop
EndIf
Next
If $bSkipPoint = False Then
Local $i = UBound($aPos)
ReDim $aPos[$i + 1]
$aPos[$i] = $aP
EndIf
Next
EndIf
$TotalMatched += $found
Next
Else
$TotalMatched = -1
EndIf
Return $TotalMatched
EndFunc
Func checkDeadBaseSuperNew($bForceCapture = True, $sFillDirectory = @ScriptDir & "\imgxml\deadbase\elix\fill\", $sLvlDirectory = @ScriptDir & "\imgxml\deadbase\elix\lvl\")
If $g_bCollectorFilterDisable Then
Return True
EndIf
Local $minCollectorLevel = 0
Local $maxCollectorLevel = 0
Local $anyFillLevel[2] = [False, False]
If $g_bDebugSetlog Then SetDebugLog("Checking Deadbase With IMGLOC START (super new)", $COLOR_WARNING)
For $i = 6 To 13
If $g_abCollectorLevelEnabled[$i] Then
If $minCollectorLevel = 0 Then $minCollectorLevel = $i
If $i > $maxCollectorLevel Then $maxCollectorLevel = $i
$anyFillLevel[$g_aiCollectorLevelFill[$i]] = True
EndIf
Next
If $maxCollectorLevel = 0 Then
Return True
EndIf
If $g_bDebugSetlog Then SetDebugLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
Local $TotalMatched = 0
Local $aPoints[0]
Local $aPos[0]
Local $sCocDiamond = "ECD"
Local $redLines = $g_sImglocRedline
Local $minLevel = 0
Local $maxLevel = 1000
Local $maxReturnPoints = 0
Local $returnProps = "objectname,objectpoints,objectlevel,fillLevel"
Local $matchedValues
Local $TotalMatched = 0
Local $x, $y, $lvl, $fill
Local $result = findMultiple($sFillDirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
Local $bFoundFilledCollectors = IsArray($result) = 1
If $bFoundFilledCollectors Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = UBound($aPoints)
If $found > 0 Then
$lvl = Number($matchedValues[3])
For $sPoint In $aPoints
Local $aP = StringSplit($sPoint, ",", $STR_NOCOUNT)
ReDim $aP[4]
$aP[3] = 0
$aP[2] = $lvl
Local $bSkipPoint = False
For $i = 0 To UBound($aPos) - 1
Local $bP = $aPos[$i]
Local $a = $aP[1] - $bP[1]
Local $b = $aP[0] - $bP[0]
Local $c = Sqrt($a * $a + $b * $b)
If $c < 25 Then
If $aP[2] > $bP[2] Then
$aPos[$i] = $aP
$aP = $bP
EndIf
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase ignore duplicate collector with fill level " & $aP[2] & " at " & $aP[0] & ", " & $aP[1], $COLOR_INFO)
$bSkipPoint = True
$found -= 1
ExitLoop
EndIf
Next
If Not $bSkipPoint Then
Local $i = UBound($aPos)
ReDim $aPos[$i + 1]
$aPos[$i] = $aP
EndIf
Next
EndIf
Next
For $aP In $aPos
$x = $aP[0]
$y = $aP[1]
$fill = $aP[2]
$lvl = $aP[3]
$sCocDiamond =($x - 20) & "," &($y - 25) & "|" &($x + 20) & "," &($y - 25) & "|" &($x + 20) & "," &($y + 15) & "|" &($x - 20) & "," &($y + 15)
$redLines = $sCocDiamond
$result = findMultiple($sLvlDirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
$bForceCapture = False
If IsArray($result) Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
If UBound($aPoints) > 0 Then
$lvl = Number($matchedValues[2])
If $lvl > $aP[3] Then $aP[3] = $lvl
EndIf
Next
EndIf
$lvl = $aP[3]
If $lvl = 0 Then
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase no collector identified with fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIf
If $g_abCollectorLevelEnabled[$lvl] Then
Local $fillIndex = GetCollectorIndexByFillLevel($fill)
If $fillIndex < $g_aiCollectorLevelFill[$lvl] Then
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase collector level " & $lvl & " found but not enough elixir, fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("IMGLOC : Searching Deadbase collector level " & $lvl & " found but not enabled, fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIf
$TotalMatched += 1
Next
EndIf
Local $dbFound = $TotalMatched >= $g_iCollectorMatchesMin
If $g_bDebugSetlog Then
If Not $bFoundFilledCollectors Then
SetDebugLog("IMGLOC : NOT A DEADBASE", $COLOR_INFO)
ElseIf Not $dbFound Then
SetDebugLog("IMGLOC : DEADBASE NOT MATCHED: " & $TotalMatched & "/" & $g_iCollectorMatchesMin, $COLOR_WARNING)
Else
SetDebugLog("IMGLOC : FOUND DEADBASE Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin & ": " & UBound($aPoints), $COLOR_GREEN)
EndIf
EndIf
$g_aZombie[3] = $TotalMatched
If $g_bDebugDeadBaseImage Then
setZombie(0, $g_iSearchElixir, $TotalMatched, $g_iSearchCount, $g_sImglocRedline)
EndIf
Return $dbFound
EndFunc
Func checkDeadBaseFolder($directory, $executeOldCode = "checkDeadBaseNew()", $executeNewCode = "checkDeadBaseSuperNew()")
Local $aFiles = _FileListToArray($directory, "*.png", $FLTA_FILES)
If IsArray($aFiles) = 0 Then Return False
If $aFiles[0] = 0 Then Return False
Local $wasDebugsetlog = $g_bDebugSetlog
$g_bDebugSetlog = True
SetLog("Checking " & $aFiles[0] & " village screenshots for dead base...")
DirCreate($directory & "\better")
DirCreate($directory & "\worse")
DirCreate($directory & "\same")
Local $iTotalMsSuperNew = 0
Local $iTotalMsNew = 0
Local $iSuperNewFound = 0
Local $iNewFound = 0
Local $iBetter = 0
Local $iWorse = 0
Local $iSame = 0
For $i = 1 To $aFiles[0]
Local $sFile = $aFiles[$i]
Local $srcFile = $directory & "\" & $sFile
Local $hBMP = _GDIPlus_BitmapCreateFromFile($directory & "\" & $sFile)
Local $hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
$g_sImglocRedline = ""
SearchRedLines()
SearchZoomOut(False, True, "checkDeadBaseFolder", False, False)
ConvertInternalExternArea()
For $j = 1 To 2
If Mod($i + $j, 2) = 0 Then
Local $hTimer = __TimerInit()
Execute($executeOldCode)
Local $iMsNew = __TimerDiff($hTimer)
$iTotalMsNew += $iMsNew
$iMsNew = Round($iMsNew)
Local $new = $g_aZombie[3]
$iNewFound += $new
Else
$hTimer = __TimerInit()
Execute($executeNewCode)
Local $iMsSuperNew = __TimerDiff($hTimer)
$iTotalMsSuperNew += $iMsSuperNew
$iMsSuperNew = Round($iMsSuperNew)
Local $superNew = $g_aZombie[3]
$iSuperNewFound += $superNew
EndIf
Next
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
Local $result = ""
If $superNew > $new Then
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: BETTER : " & $superNew & " > " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "better"
$iBetter += 1
ElseIf $superNew < $new Then
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: WORSE  : " & $superNew & " < " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "worse"
$iWorse += 1
Else
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: SAME   : " & $superNew & " = " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "same"
$iSame += 1
EndIf
Local $dstFile = $directory & "\" & $result & "\" & $sFile
FileMove($srcFile, $dstFile)
Next
SetLog("Checking dead base completed")
SetLog("Super new image detection BETTER : " & $iBetter)
SetLog("Super new image detection WORSE  : " & $iWorse)
SetLog("Super new image detection SAME   : " & $iSame)
SetLog("Collectos found (Super new/new)  : " & $iSuperNewFound & " / " & $iNewFound)
SetLog("Duration in ms. (Super new/new)  : " & Round($iTotalMsSuperNew) & " / " & Round($iTotalMsNew))
$g_bDebugSetlog = $wasDebugsetlog
Return True
EndFunc
Func CheckTombs()
If Not TestCapture() Then
If Not $g_bChkTombstones Then Return False
If Not $g_abNotNeedAllTime[1] Then Return
EndIf
Local $hTimer = __TimerInit()
Local $return[7] = ["None", "None", 0, 0, 0, "", ""]
Local $TombsXY[2] = [0, 0]
Local $aResult = returnSingleMatchOwnVillage($g_sImgClearTombs)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
$TombsXY = $return[5]
If $g_bDebugSetlog Then SetDebugLog("Filename :" & $return[0])
If $g_bDebugSetlog Then SetDebugLog("Type :" & $return[1])
If $g_bDebugSetlog Then SetDebugLog("Total Objects :" & $return[4])
Local $bRemoved = False
If IsArray($TombsXY) Then
For $j = 0 To UBound($TombsXY) - 1
If isInsideDiamondXY($TombsXY[$j][0], $TombsXY[$j][1]) Then
If $g_bDebugSetlog Then SetDebugLog("Coords :" & $TombsXY[$j][0] & "," & $TombsXY[$j][1])
If IsMainPage() Then
Click($TombsXY[$j][0], $TombsXY[$j][1], 1, 0, "#0430")
If $bRemoved = False Then $bRemoved = IsMainPage()
EndIf
EndIf
Next
EndIf
If $bRemoved Then
SetLog("Tombs removed!", $COLOR_DEBUG1)
$g_abNotNeedAllTime[1] = False
Else
SetLog("Tombs not removed, please do manually!", $COLOR_WARNING)
EndIf
Else
SetLog("No Tombs Found!", $COLOR_SUCCESS)
$g_abNotNeedAllTime[1] = False
EndIf
checkMainScreen(False)
EndFunc
Func CleanYard()
If Not $g_bChkCleanYard And Not $g_bChkGemsBox And Not TestCapture() Then Return
Local $hObstaclesTimer = __TimerInit()
If Not getBuilderCount() Then Return
If _Sleep($DELAYRESPOND) Then Return
Local $Filename = ""
Local $Locate = 0
Local $CleanYardXY
Local $sCocDiamond = $CocDiamondECD
Local $redLines = $sCocDiamond
Local $bNoBuilders = $g_iFreeBuilderCount < 1
If $g_iFreeBuilderCount > 0 And $g_bChkCleanYard = True And Number($g_aiCurrentLoot[$eLootElixir]) > 50000 Then
Local $aResult = findMultiple($g_iDetectedImageType = 1 ? $g_sImgCleanYardSnow : $g_sImgCleanYard, $sCocDiamond, $redLines, 0, 1000, 10, "objectname,objectlevel,objectpoints", True)
If IsArray($aResult) Then
For $matchedValues In $aResult
Local $aPoints = decodeMultipleCoords($matchedValues[2])
$Filename = $matchedValues[0]
For $i = 0 To UBound($aPoints) - 1
$CleanYardXY = $aPoints[$i]
If UBound($CleanYardXY) > 1 And isInsideDiamondXY($CleanYardXY[0], $CleanYardXY[1]) Then
If $g_bDebugSetlog Then SetDebugLog($Filename & " found (" & $CleanYardXY[0] & "," & $CleanYardXY[1] & ")", $COLOR_SUCCESS)
If IsMainPage() Then Click($CleanYardXY[0], $CleanYardXY[1], 1, 0, "#0430")
$Locate = 1
If _Sleep($DELAYCOLLECT3) Then Return
If IsMainPage() Then GemClick($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($DELAYCHECKTOMBS2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($DELAYCHECKTOMBS1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount = 0 Then
SetLog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop(2)
EndIf
EndIf
Next
Next
EndIf
EndIf
Local $return[7] = ["None", "None", 0, 0, 0, "", ""]
Local $GemBoxXY[2] = [0, 0]
If($g_iFreeBuilderCount > 0 And $g_bChkGemsBox And Number($g_aiCurrentLoot[$eLootElixir]) > 50000) Or TestCapture() Then
Local $aResult = multiMatches($g_sImgGemBox, 1, $sCocDiamond, $sCocDiamond)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
$GemBoxXY = $return[5]
If $g_bDebugSetlog Then SetDebugLog("Filename :" & $return[0])
If $g_bDebugSetlog Then SetDebugLog("Type :" & $return[1])
If $g_bDebugSetlog Then SetDebugLog("Total Objects :" & $return[4])
If IsArray($GemBoxXY) Then
For $j = 0 To UBound($GemBoxXY) - 1
If $g_bDebugSetlog Then SetDebugLog("Coords :" & $GemBoxXY[$j][0] & "," & $GemBoxXY[$j][1])
If isInsideDiamondXY($GemBoxXY[$j][0], $GemBoxXY[$j][1]) Then
If IsMainPage() Then Click($GemBoxXY[$j][0], $GemBoxXY[$j][1], 1, 0, "#0430")
If _Sleep($DELAYCHECKTOMBS2) Then Return
$Locate = 1
If _Sleep($DELAYCOLLECT3) Then Return
If IsMainPage() Then Click($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($DELAYCHECKTOMBS2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($DELAYCHECKTOMBS1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount = 0 Then
SetLog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop
EndIf
EndIf
Next
EndIf
SetLog("GemBox removed!", $COLOR_DEBUG1)
Else
SetLog("No GemBox Found!", $COLOR_SUCCESS)
EndIf
EndIf
If $bNoBuilders Then
SetLog("No Builders available to remove Obstacles!")
Else
If $Locate = 0 And $g_bChkCleanYard And Number($g_aiCurrentLoot[$eLootElixir]) > 50000 Then SetLog("No Obstacles found, Yard is clean!", $COLOR_SUCCESS)
If $g_bDebugSetlog Then SetDebugLog("Time: " & Round(__TimerDiff($hObstaclesTimer) / 1000, 2) & "'s", $COLOR_SUCCESS)
EndIf
UpdateStats()
ClickP($aAway, 1, 300, "#0329")
EndFunc
Func decodeMultipleCoords($coords, $iDedupX = -1, $iDedupY = -1, $iSorted = -1)
Local $retCoords
Local $pOff = 0
Local $aCoordsSplit = StringSplit($coords, "|", $STR_NOCOUNT)
If StringInStr($aCoordsSplit[0], ",") > 0 Then
Local $retCoords[UBound($aCoordsSplit)]
Else
$pOff = 1
Local $retCoords[Number($aCoordsSplit[0])]
EndIf
Local $iErr = 0
For $p = 0 To UBound($retCoords) - 1
Local $c = decodeSingleCoord($aCoordsSplit[$p + $pOff])
If UBound($c) > 1 Then
$retCoords[$p - $iErr] = $c
Else
$iErr += 1
EndIf
Next
If $iErr > 0 Then ReDim $retCoords[UBound($retCoords) - $iErr]
If UBound($retCoords) = 0 Then
Local $aEmpty[0]
Return $aEmpty
EndIf
If UBound($retCoords) = 1 Or($iDedupX < 1 And $iDedupY < 1 And $iSorted = -1) Then Return $retCoords
If $iDedupX > 0 Or $iDedupY > 0 Then
Local $aFinalCoords[1] = [$retCoords[0]]
Local $c1, $c2, $k, $inX, $inY
For $i = 1 To UBound($retCoords) - 1
$c1 = $retCoords[$i]
$k = UBound($aFinalCoords) - 1
For $j = 0 To $k
$c2 = $aFinalCoords[$j]
$inX = Abs($c1[0] - $c2[0]) < $iDedupX
$inY = Abs($c1[1] - $c2[1]) < $iDedupY
If($iDedupY < 1 And $inX) Or($iDedupX < 1 And $inY) Or($inX And $inY) Then
ContinueLoop 2
EndIf
Next
ReDim $aFinalCoords[$k + 2]
$aFinalCoords[$k + 1] = $c1
Next
Else
Local $aFinalCoords = $retCoords
EndIf
If $iSorted = 0 Or $iSorted = 1 Then
Local $a[UBound($aFinalCoords)][2]
For $i = 0 To UBound($aFinalCoords) - 1
$c1 = $aFinalCoords[$i]
$a[$i][0] = $c1[0]
$a[$i][1] = $c1[1]
Next
_ArraySort($a, 0, 0, 0, $iSorted)
For $i = 0 To UBound($a) - 1
$c1 = $aFinalCoords[$i]
$c1[0] = $a[$i][0]
$c1[1] = $a[$i][1]
$aFinalCoords[$i] = $c1
Next
EndIf
Return $aFinalCoords
EndFunc
Func decodeSingleCoord($coords)
Local $aCoordsSplit = StringSplit($coords, ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) > 1 Then
$aCoordsSplit[0] = Int($aCoordsSplit[0])
$aCoordsSplit[1] = Int($aCoordsSplit[1])
EndIf
Return $aCoordsSplit
EndFunc
Func RetrieveImglocProperty($key, $property)
Local $aValue = DllCall($g_hLibMyBot, "str", "GetProperty", "str", $key, "str", $property)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If UBound($aValue) = 0 Then
Return ""
EndIf
Return $aValue[0]
EndFunc
Func checkImglocError(ByRef $imglocvalue, $funcName, $sTileSource = "", $sImageArea = "")
If IsArray($imglocvalue) Then
If $imglocvalue[0] = "0" Or $imglocvalue[0] = "" Then
If $g_bDebugSetlog Then SetDebugLog($funcName & " imgloc search returned no results" &($sImageArea ? " in " & $sImageArea : "") &($sTileSource ? " for '" & $sTileSource & "' !" : "!"), $COLOR_WARNING)
Return True
ElseIf StringLeft($imglocvalue[0], 2) = "-1" Then
If $g_bDebugSetlog Then SetDebugLog($funcName & " - Imgloc DLL Error: " & $imglocvalue[0], $COLOR_ERROR)
Return True
ElseIf StringLeft($imglocvalue[0], 2) = "-2" Then
SetLog($funcName & " - Imgloc DLL Critical Error", $COLOR_RED)
SetLog(StringMid($imglocvalue[0], 4), $COLOR_RED)
SetLog("Restart bot in 3 Minutes...", $COLOR_GREEN)
If _SleepStatus(180000) = False Then
RestartBot(False, True)
EndIf
Return True
Else
Return False
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog($funcName & " - Imgloc  Error: Not an Array Result", $COLOR_ERROR)
Return True
EndIf
EndFunc
Func findButton($sButtonName, $buttonTileArrayOrPatternOrFullPath = Default, $maxReturnPoints = 1, $bForceCapture = True)
If $buttonTileArrayOrPatternOrFullPath = Default Then $buttonTileArrayOrPatternOrFullPath = $sButtonName & "*"
Local $error, $extError
Local $searchArea = GetButtonDiamond($sButtonName)
Local $aCoords = ""
Local $aButtons
Local $sButtons = ""
If IsString($buttonTileArrayOrPatternOrFullPath) Then
$sButtons = $buttonTileArrayOrPatternOrFullPath
If StringInStr($buttonTileArrayOrPatternOrFullPath, "*") > 0 Then
Local $aFiles = _FileListToArray($g_sImgImgLocButtons, $sButtons, $FLTA_FILES, True)
If UBound($aFiles) < 2 Or $aFiles[0] < 1 Then
Return SetError(1, 1, "No files in " & $g_sImgImgLocButtons)
EndIf
Local $a[0], $j
$j = 0
For $i = 1 To $aFiles[0]
If StringRegExp($aFiles[$i], ".+[.](xml|png|bmp)$") Then
$j += 1
ReDim $a[$j]
$a[$i - 1] = $aFiles[$i]
EndIf
Next
$aButtons = $a
Else
Local $a[1] = [$sButtons]
$aButtons = $a
EndIf
ElseIf IsArray($buttonTileArrayOrPatternOrFullPath) Then
$aButtons = $buttonTileArrayOrPatternOrFullPath
$sButtons = _ArrayToString($aButtons)
Else
Return SetError(1, 2, "Bad Input Values : " & $buttonTileArrayOrPatternOrFullPath)
EndIf
If Not IsString($sButtonName) Or UBound($aButtons) < 1 Then
Return SetError(1, 3, "Bad Input Values : " & $sButtons)
EndIf
For $buttonTile In $aButtons
If FileExists($buttonTile) = 0 Then
Return SetError(1, 4, "Bad Input Values : Button Image NOT FOUND : " & $buttonTile)
EndIf
If $bForceCapture Then _CaptureRegion2()
If $g_bDebugSetlog Then SetDebugLog(" imgloc searching for: " & $sButtonName & " : " & $buttonTile)
Local $result = DllCallMyBot("FindTile", "handle", $g_hHBitmap2, "str", $buttonTile, "str", $searchArea, "Int", $maxReturnPoints)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
Return SetError(2, 1, $extError)
EndIf
If $result[0] <> "" And checkImglocError($result, "imglocFindButton", $buttonTile) = False Then
If $g_bDebugSetlog Then SetDebugLog($sButtonName & " Button Image Found in: " & $result[0])
$aCoords = StringSplit($result[0], "|", $STR_NOCOUNT)
If $maxReturnPoints = 1 Then
Return StringSplit($aCoords[1], ",", $STR_NOCOUNT)
Else
Return $result[0]
EndIf
EndIf
Next
SetDebugLog($sButtonName & " Button Image(s) NOT FOUND : " & $sButtons, $COLOR_ERROR)
Return $aCoords
EndFunc
Func GetButtonDiamond($sButtonName)
Local $btnDiamond = "FV"
Switch $sButtonName
Case "FindMatch"
$btnDiamond = "133,515|360,515|360,620|133,620"
Case "CloseFindMatch"
$btnDiamond = "780,15|830,15|830,60|780,60"
Case "CloseFindMatch"
$btnDiamond = "780,15|830,15|830,60|780,60"
Case "Attack"
$btnDiamond = "15,620|112,620|112,715|15,715"
Case "OpenTrainWindow"
$btnDiamond = "15,560|65,560|65,610|15,610"
Case "OK"
$btnDiamond = "440,395|587,395|587,460|440,460"
Case "CANCEL"
$btnDiamond = "272,395|420,395|420,460|272,460"
Case "ReturnHome"
$btnDiamond = "357,545|502,545|502,607|357,607"
Case "Next"
$btnDiamond = "697,542|850,542|850,610|697,610"
Case "ObjectButtons", "BoostOne", "BoostCT", "Upgrade", "Research", "MagicItems", "Boostleft", "Treasury"
$btnDiamond = GetDiamondFromRect("140,590,720,670")
Case "GEM", "BOOSTBtn"
$btnDiamond = GetDiamondFromRect("359,412(148,66)")
Case "EnterShop"
$btnDiamond = GetDiamondFromRect("359,392(148,66)")
Case "EndBattleSurrender"
$btnDiamond = "12,577|125,577|125,615|12,615"
Case "ExpandChat"
$btnDiamond = "2,330|35,350|35,410|2,430"
Case "CollapseChat"
$btnDiamond = "315,334|350,350|350,410|315,430"
Case "ChatOpenRequestPage"
$btnDiamond = "5,688|65,688|65,615|5,725"
Case "Profile"
$btnDiamond = "172,15|205,15|205,48|172,48"
Case "DonateWindow"
$btnDiamond = "310,0|360,0|360,732|310,732"
Case "DonateButton"
$btnDiamond = "200,85|305,85|305,680|200,680"
Case "UpDonation"
$btnDiamond = "282,85|306,85|306,130|282,130"
Case "DownDonation"
$btnDiamond = "282,635|306,635|306,680|282,680"
Case "Collect"
$btnDiamond = "350,450|505,450|505,521|350,521"
Case "BoostBarrack", "BarrackBoosted"
$btnDiamond = GetDiamondFromRect("630,280,850,360")
Case "ArmyTab", "TrainTroopsTab", "BrewSpellsTab", "BuildSiegeMachinesTab", "QuickTrainTab"
$btnDiamond = GetDiamondFromRect("18,100,800,150")
Case "BoostTrainingPotionBtn", "BoostResourcePotionBtn"
$btnDiamond = GetDiamondFromRect("420,395(85,60)")
Case Else
$btnDiamond = "FV"
EndSwitch
Return $btnDiamond
EndFunc
Func UpdateImgeTile(ByRef $sImageTile, $AndroidTag = Default)
Local $iMinimumAndroidVersion = Int($AndroidTag)
If $iMinimumAndroidVersion > 1 And $g_iAndroidVersionAPI < $iMinimumAndroidVersion Then
Return False
EndIf
If Not IsBool($AndroidTag) Then
If $iMinimumAndroidVersion > 0 Then
$AndroidTag = True
Else
$AndroidTag = False
EndIf
EndIf
If $AndroidTag Then
$sImageTile = StringReplace($sImageTile, "[Android]", GetAndroidCodeName())
If $iMinimumAndroidVersion > 1 And @extended = 0 Then
SetDebugLog("Android Code Name cannot be added to title: " & $sImageTile, $COLOR_ERROR)
EndIf
EndIf
Return True
EndFunc
Func findImage($sImageName, $sImageTile, $sImageArea, $maxReturnPoints = 1, $bForceCapture = True, $AndroidTag = Default)
If $AndroidTag = Default Then $AndroidTag = True
Local $aCoords = ""
Local $iPattern = StringInStr($sImageTile, "*")
If Not UpdateImgeTile($sImageTile, $AndroidTag) Then Return $aCoords
If $iPattern > 0 Then
Local $dir = ""
Local $pat = $sImageTile
Local $iLastBS = StringInStr($sImageTile, "\", 0, -1)
If $iLastBS > 0 Then
$dir = StringLeft($sImageTile, $iLastBS)
$pat = StringMid($sImageTile, $iLastBS + 1)
EndIf
Local $files = _FileListToArray($dir, $pat, $FLTA_FILES, True)
If @error Or UBound($files) < 2 Then
If $g_bDebugSetlog Then SetDebugLog("findImage files not found : " & $sImageTile, $COLOR_ERROR)
SetError(1, 0, $aCoords)
Return
EndIf
For $i = 1 To $files[0]
$aCoords = findImage($sImageName, $files[$i], $sImageArea, $maxReturnPoints, $bForceCapture)
If UBound(decodeSingleCoord($aCoords)) > 1 Then Return $aCoords
Next
Return $aCoords
EndIf
Local $error, $extError
If Not FileExists($sImageTile) Then
If $g_bDebugSetlog Then SetDebugLog("findImage file not found : " & $sImageTile, $COLOR_ERROR)
SetError(1, 1, $aCoords)
Return
EndIf
If $bForceCapture Then _CaptureRegion2()
Local $result = DllCallMyBot("FindTile", "handle", $g_hHBitmap2, "str", $sImageTile, "str", $sImageArea, "Int", $maxReturnPoints)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, $aCoords)
Return
EndIf
If checkImglocError($result, "findImage", $sImageTile, $sImageArea) Then
If $g_bDebugSetlog And $g_bDebugImageSave Then DebugImageSave("findImage_" & $sImageName, True)
Return $aCoords
EndIf
If $result[0] <> "" Then
If $g_bDebugSetlog Then SetDebugLog("findImage : " & $sImageName & " Found in: " & $result[0])
$aCoords = StringSplit($result[0], "|", $STR_NOCOUNT)
If $maxReturnPoints = 1 Then
Return $aCoords[1]
Else
Return $result[0]
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("findImage : " & $sImageName & " NOT FOUND " & $sImageTile)
If $g_bDebugSetlog And $g_bDebugImageSave Then DebugImageSave("findImage_" & $sImageName, True)
Return $aCoords
EndIf
EndFunc
Func GetDeployableNextTo($sPoints, $distance = 3, $redlineoverride = "")
Local $result = DllCall($g_hLibMyBot, "str", "GetDeployableNextTo", "str", $sPoints, "int", $distance, "str", $redlineoverride)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, "")
Return ""
EndIf
If UBound($result) = 0 Then Return ""
If $g_bDebugSetlog Then SetDebugLog("GetDeployableNextTo : " & $sPoints & ", dist. = " & $distance & " : " & $result[0], $COLOR_ORANGE)
Return $result[0]
EndFunc
Func GetOffsetRedline($sArea = "TL", $distance = 3)
Local $result = DllCall($g_hLibMyBot, "str", "GetOffSetRedline", "str", $sArea, "int", $distance)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, "")
Return ""
EndIf
If UBound($result) = 0 Then Return ""
If $g_bDebugSetlog Then SetDebugLog("GetOffSetRedline : " & $sArea & ", dist. = " & $distance & " : " & $result[0], $COLOR_ORANGE)
Return $result[0]
EndFunc
Func findMultiple($directory, $sCocDiamond, $redLines, $minLevel = 0, $maxLevel = 1000, $maxReturnPoints = 0, $returnProps = "objectname,objectlevel,objectpoints", $bForceCapture = True)
If $g_bDebugSetlog Then
SetDebugLog("******** findMultiple *** START ***", $COLOR_ORANGE)
SetDebugLog("findMultiple : directory : " & $directory, $COLOR_ORANGE)
SetDebugLog("findMultiple : sCocDiamond : " & $sCocDiamond, $COLOR_ORANGE)
SetDebugLog("findMultiple : redLines : " & $redLines, $COLOR_ORANGE)
SetDebugLog("findMultiple : minLevel : " & $minLevel, $COLOR_ORANGE)
SetDebugLog("findMultiple : maxLevel : " & $maxLevel, $COLOR_ORANGE)
SetDebugLog("findMultiple : maxReturnPoints : " & $maxReturnPoints, $COLOR_ORANGE)
SetDebugLog("findMultiple : returnProps : " & $returnProps, $COLOR_ORANGE)
SetDebugLog("******** findMultiple *** START ***", $COLOR_ORANGE)
EndIf
Local $error, $extError
Local $aCoords = ""
Local $returnData = StringSplit($returnProps, ",", $STR_NOCOUNT)
Local $returnLine[UBound($returnData)]
Local $returnValues[0]
If $bForceCapture Then _CaptureRegion2()
Local $result = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", $sCocDiamond, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error : " & $error & " --- " & $extError)
SetError(2, $extError, $aCoords)
Return ""
EndIf
If checkImglocError($result, "findMultiple", $directory) = True Then
If $g_bDebugSetlog Then SetDebugLog("findMultiple Returned Error or No values : ", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return ""
Else
If $g_bDebugSetlog Then SetDebugLog("findMultiple found : " & $result[0])
EndIf
If $result[0] <> "" Then
Local $resultArr = StringSplit($result[0], "|", $STR_NOCOUNT)
ReDim $returnValues[UBound($resultArr)]
Local $iErr = 0
For $rs = 0 To UBound($resultArr) - 1
For $rD = 0 To UBound($returnData) - 1
$returnLine[$rD] = RetrieveImglocProperty($resultArr[$rs], $returnData[$rD])
If $returnData[$rD] = "objectpoints" Then
If StringInStr($returnLine[$rD], ",") = 0 Then
If $g_bDebugSetlog Then SetDebugLog("findMultiple : Invalid objectpoint in result in " & $rD & ": " & $result[0])
$iErr += 1
ContinueLoop 2
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog("findMultiple : " & $resultArr[$rs] & "->" & $returnData[$rD] & " -> " & $returnLine[$rD])
Next
$returnValues[$rs - $iErr] = $returnLine
Next
If $iErr Then ReDim $returnValues[UBound($resultArr) - $iErr]
If $redLines = "" Then
$g_sImglocRedline = RetrieveImglocProperty("redline", "")
If $g_bDebugSetlog Then SetDebugLog("findMultiple : Redline argument is emty, setting global Redlines")
EndIf
If $g_bDebugSetlog Then SetDebugLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return $returnValues
Else
If $g_bDebugSetlog Then SetDebugLog(" ***  findMultiple has no result **** ", $COLOR_ORANGE)
If $g_bDebugSetlog Then SetDebugLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return ""
EndIf
EndFunc
Func GetRectArray($rect, $bLogError = True)
Local $a = []
Local $RectValues = StringSplit($rect, ",", $STR_NOCOUNT)
If UBound($RectValues) = 3 Then
ReDim $RectValues[4]
$i = StringInStr($RectValues[2], ")")
If $i = 0 Then
If $bLogError Then SetDebugLog("GetRectArray : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 1, $a)
EndIf
$RectValues[3] = $RectValues[1] + StringLeft($RectValues[2], $i - 1)
$i = StringInStr($RectValues[1], "(")
If $i = 0 Then
If $bLogError Then SetDebugLog("GetRectArray : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 2, $a)
EndIf
$RectValues[2] = $RectValues[0] + StringMid($RectValues[1], $i + 1)
$RectValues[1] = StringLeft($RectValues[1], $i - 1)
EndIf
If UBound($RectValues) < 4 Then
If $bLogError Then SetDebugLog("GetRectArray : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 3, $a)
EndIf
Return SetError(0, 0, $RectValues)
EndFunc
Func GetDiamondFromRect($rect)
SetError(0)
Local $returnvalue = "", $i
Local $RectValues = IsArray($rect) ? $rect : GetRectArray($rect, False)
Local $error = @error, $extended = @extended
If UBound($RectValues) < 4 Then
If $error = 0 Then $error = 1
SetDebugLog("GetDiamondFromRect : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError($error, $extended, $returnvalue)
EndIf
Local $DiamdValues[4]
Local $X = Number($RectValues[0])
Local $Y = Number($RectValues[1])
Local $Ex = Number($RectValues[2])
Local $Ey = Number($RectValues[3])
$DiamdValues[0] = $X & "," & $Y
$DiamdValues[1] = $Ex & "," & $Y
$DiamdValues[2] = $Ex & "," & $Ey
$DiamdValues[3] = $X & "," & $Ey
$returnvalue = $DiamdValues[0] & "|" & $DiamdValues[1] & "|" & $DiamdValues[2] & "|" & $DiamdValues[3]
Return $returnvalue
EndFunc
Func FindImageInPlace($sImageName, $sImageTile, $place, $bForceCaptureRegion = True, $AndroidTag = Default)
If $g_bDebugSetlog Then SetDebugLog("FindImageInPlace : > " & $sImageName & " - " & $sImageTile & " - " & $place, $COLOR_INFO)
Local $returnvalue = ""
Local $aPlaces = GetRectArray($place)
Local $sImageArea = GetDiamondFromRect($aPlaces)
If $bForceCaptureRegion = True Then
$sImageArea = "FV"
_CaptureRegion2(Number($aPlaces[0]), Number($aPlaces[1]), Number($aPlaces[2]), Number($aPlaces[3]))
EndIf
Local $coords = findImage($sImageName, $sImageTile, $sImageArea, 1, False, $AndroidTag)
Local $aCoords = decodeSingleCoord($coords)
If UBound($aCoords) < 2 Then
If $g_bDebugSetlog Then SetDebugLog("FindImageInPlace : " & $sImageName & " NOT Found", $COLOR_INFO)
Return ""
EndIf
If $bForceCaptureRegion Then
$returnvalue = Number($aCoords[0]) + Number($aPlaces[0]) & "," & Number($aCoords[1]) + Number($aPlaces[1])
Else
$returnvalue = Number($aCoords[0]) & "," & Number($aCoords[1])
EndIf
If $g_bDebugSetlog Then SetDebugLog("FindImageInPlace : < " & $sImageName & " Found in " & $returnvalue, $COLOR_INFO)
Return $returnvalue
EndFunc
Func SearchRedLines($sCocDiamond = "ECD")
If $g_sImglocRedline <> "" Then Return $g_sImglocRedline
Local $result = DllCallMyBot("SearchRedLines", "handle", $g_hHBitmap2, "str", $sCocDiamond)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error : " & $error & " --- " & $extError)
SetError(2, $extError)
Return ""
EndIf
If checkImglocError($result, "SearchRedLines") = True Then
If $g_bDebugSetlog Then SetDebugLog("SearchRedLines Returned Error or No values : ", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("******** SearchRedLines *** END ***", $COLOR_ORANGE)
Return ""
Else
If $g_bDebugSetlog Then SetDebugLog("SearchRedLines found : " & $result[0])
EndIf
$g_sImglocRedline = $result[0]
Return $g_sImglocRedline
EndFunc
Func SearchRedLinesMultipleTimes($sCocDiamond = "ECD", $iCount = 3, $iDelay = 300)
Local $bHBitmap_synced =($g_hHBitmap = $g_hHBitmap2)
Local $g_hHBitmap2_old = $g_hHBitmap2
Local $g_sImglocRedline_old
SearchRedLines($sCocDiamond)
Local $iRedlinePoints = [UBound(StringSplit($g_sImglocRedline, "|", $STR_NOCOUNT)), 0]
SetDebugLog("Initial # of redline points: " & $iRedlinePoints[0])
$g_hHBitmap2 = 0
Local $iCaptureTime = 0
Local $iRedlineTime = 0
Local $aiTotals = [0, 0]
Local $iBest = 0
For $i = 1 To $iCount
$g_sImglocRedline_old = $g_sImglocRedline
Local $hTimer = __TimerInit()
ForceCaptureRegion()
_CaptureRegion2()
$iCaptureTime = __TimerDiff($hTimer)
$g_sImglocRedline = ""
SearchRedLines($sCocDiamond)
$iRedlineTime = __TimerDiff($hTimer) - $iCaptureTime
$aiTotals[0] += $iCaptureTime
$aiTotals[1] += $iRedlineTime
$iRedlinePoints[1] = UBound(StringSplit($g_sImglocRedline, "|", $STR_NOCOUNT))
SetDebugLog($i & ". # of redline points: " & $iRedlinePoints[1])
If $iRedlinePoints[1] > $iRedlinePoints[0] Then
$iRedlinePoints[0] = $iRedlinePoints[1]
$iBest = $i
Else
$g_sImglocRedline = $g_sImglocRedline_old
EndIf
If $i < $iCount Then
Local $iDelayCompensated = $iDelay - __TimerDiff($hTimer)
If $iDelayCompensated >= 10 Then Sleep($iDelayCompensated)
EndIf
Next
If $iBest = 0 Then
SetDebugLog("Using initial redline with " & $iRedlinePoints[0] & " points")
Else
SetDebugLog("Using " & $iBest & ". redline with " & $iRedlinePoints[0] & " points (capture/redline avg. time: " & Int($aiTotals[0] / $iCount) & "/" & Int($aiTotals[1] / $iCount) & ")")
EndIf
GdiDeleteHBitmap($g_hHBitmap2)
If $bHBitmap_synced Then
_CaptureRegion2Sync()
Else
$g_hHBitmap2 = $g_hHBitmap2_old
EndIf
Return $g_sImglocRedline
EndFunc
Func decodeTroopEnum($tEnum)
Switch $tEnum
Case $eBarb
Return "Barbarian"
Case $eArch
Return "Archer"
Case $eBall
Return "Balloon"
Case $eDrag
Return "Dragon"
Case $eGiant
Return "Giant"
Case $eGobl
Return "Goblin"
Case $eGole
Return "Golem"
Case $eHeal
Return "Healer"
Case $eHogs
Return "HogRider"
Case $eKing
Return "King"
Case $eLava
Return "LavaHound"
Case $eMini
Return "Minion"
Case $ePekk
Return "Pekka"
Case $eQueen
Return "Queen"
Case $eValk
Return "Valkyrie"
Case $eWall
Return "WallBreaker"
Case $eWarden
Return "Warden"
Case $eWitc
Return "Witch"
Case $eWiza
Return "Wizard"
Case $eBabyD
Return "BabyDragon"
Case $eMine
Return "Miner"
Case $eEDrag
Return "ElectroDragon"
Case $eBowl
Return "Bowler"
Case $eIceG
Return "IceGolem"
Case $eESpell
Return "EarthquakeSpell"
Case $eFSpell
Return "FreezeSpell"
Case $eHaSpell
Return "HasteSpell"
Case $eHSpell
Return "HealSpell"
Case $eJSpell
Return "JumpSpell"
Case $eLSpell
Return "LightningSpell"
Case $ePSpell
Return "PoisonSpell"
Case $eRSpell
Return "RageSpell"
Case $eSkSpell
Return "SkeletonSpell"
Case $eBtSpell
Return "BatSpell"
Case $eCSpell
Return "CloneSpell"
Case $eCastle
Return "Castle"
EndSwitch
EndFunc
Func decodeTroopName($sName)
Switch $sName
Case "Barbarian"
Return $eBarb
Case "Archer"
Return $eArch
Case "Balloon"
Return $eBall
Case "Dragon"
Return $eDrag
Case "Giant"
Return $eGiant
Case "Goblin"
Return $eGobl
Case "Golem"
Return $eGole
Case "Healer"
Return $eHeal
Case "HogRider"
Return $eHogs
Case "King"
Return $eKing
Case "LavaHound"
Return $eLava
Case "Minion"
Return $eMini
Case "Pekka"
Return $ePekk
Case "Queen"
Return $eQueen
Case "Valkyrie"
Return $eValk
Case "WallBreaker"
Return $eWall
Case "Warden"
Return $eWarden
Case "Witch"
Return $eWitc
Case "Wizard"
Return $eWiza
Case "BabyDragon"
Return $eBabyD
Case "Miner"
Return $eMine
Case "ElectroDragon"
Return $eEDrag
Case "Bowler"
Return $eBowl
Case "IceGolem"
Return $eIceG
Case "EarthquakeSpell"
Return $eESpell
Case "FreezeSpell"
Return $eFSpell
Case "HasteSpell"
Return $eHaSpell
Case "HealSpell"
Return $eHSpell
Case "JumpSpell"
Return $eJSpell
Case "LightningSpell"
Return $eLSpell
Case "PoisonSpell"
Return $ePSpell
Case "RageSpell"
Return $eRSpell
Case "SkeletonSpell"
Return $eSkSpell
Case "BatSpell"
Return $eBtSpell
Case "CloneSpell"
Return $eCSpell
Case "Castle"
Return $eCastle
EndSwitch
EndFunc
Func Slot($iX, $iY)
If $iY < 490 Then
Switch $iX
Case 0 To 94
If $iY < 315 Then Return 35
If $iY > 315 Then Return 40
Case 95 To 170
If $iY < 315 Then Return 111
If $iY > 315 Then Return 120
Case 171 To 243
If $iY < 315 Then Return 184
If $iY > 315 Then Return 195
Case 244 To 314
If $iY < 315 Then Return 255
If $iY > 315 Then Return 272
Case 315 To 387
If $iY < 315 Then Return 330
If $iY > 315 Then Return 341
Case 388 To 460
If $iY < 315 Then Return 403
If $iY > 315 Then Return 415
Case 461 To 533
If $iY < 315 Then Return 477
If $iY > 315 Then Return 485
Case 605 To 677
Return 620
Case 678 To 752
Return 693
Case 754 To 826
Return 769
EndSwitch
Else
Switch $iX
Case 0 To 94
Return 35
Case 95 To 170
Return 111
Case 171 To 243
Return 184
Case 244 To 307
Return 255
Case 308 To 392
Return 330
Case 393 To 435
Return 403
Case 450 To 510
Return 475
Case 511 To 535
Return 510
Case 536 To 605
Return 555
Case 625 To 700
Return 650
EndSwitch
EndIf
EndFunc
Func GetDummyRectangle($sCoords, $ndistance)
Local $aCoords = StringSplit($sCoords, ",", $STR_NOCOUNT)
Return Number($aCoords[0]) - $ndistance & "," & Number($aCoords[1]) - $ndistance & "," & Number($aCoords[0]) + $ndistance & "," & Number($aCoords[1]) + $ndistance
EndFunc
Func imglocCheckWall()
Local $iXClickOffset = 0
Local $iYClickOffset = 0
Local $iXRange = 16
Local $iYRange = 14
Local $iLastGoodWallx = $g_aiLastGoodWallPos[0]
Local $iLastGoodWally = $g_aiLastGoodWallPos[1]
ConvertToVillagePos($iLastGoodWallx, $iLastGoodWally)
If _Sleep(500) Then Return
Local $levelWall = $g_iCmbUpgradeWallsLevel + 4
Switch $levelWall
Case 10
$iXClickOffset = 2
$iYClickOffset = 2
Case 11
$iXClickOffset = 1
$iYClickOffset = -2
EndSwitch
SetLog("Searching for Wall(s) level: " & $levelWall & ". Using imgloc: ", $COLOR_SUCCESS)
Local $FoundWalls[1]
$FoundWalls[0] = ""
If($g_aiLastGoodWallPos[0] > 0) And($g_aiLastGoodWallPos[1] > 0) Then
_CaptureRegion2($iLastGoodWallx - $iXRange, $iLastGoodWally - $iYRange, $iLastGoodWallx + $iXRange, $iLastGoodWally + $iYRange)
$FoundWalls = imglocFindWalls($levelWall, "FV", "FV", 4)
If $g_bDebugImageSave Then DebugImageSave("WallUpgrade", False)
EndIf
If($FoundWalls[0] = "") Then
$g_aiLastGoodWallPos[0] = -1
$g_aiLastGoodWallPos[1] = -1
SetLog("No wall(s) next to previously upgraded found.", $COLOR_ERROR)
SetLog("Looking further away.", $COLOR_SUCCESS)
_CaptureRegion2()
$FoundWalls = imglocFindWalls($levelWall, "ECD", "ECD", 10)
EndIf
ClickP($aAway, 1, 0, "#0505")
If($FoundWalls[0] = "") Then
SetLog("No wall(s) level: " & $levelWall & " found.", $COLOR_ERROR)
Else
For $i = 0 To UBound($FoundWalls) - 1
Local $WallCoordsArray = decodeMultipleCoords($FoundWalls[$i])
SetLog("Found: " & UBound($WallCoordsArray) & " possible Wall position: " & $FoundWalls[$i], $COLOR_SUCCESS)
If($g_aiLastGoodWallPos[0] > 0) And($g_aiLastGoodWallPos[1] > 0) Then
SetLog("relative to " &($iLastGoodWallx - $iXRange) & ", " &($iLastGoodWally - $iYRange) & ".", $COLOR_SUCCESS)
EndIf
For $fc = 0 To UBound($WallCoordsArray) - 1
Local $aCoord = $WallCoordsArray[$fc]
If($g_aiLastGoodWallPos[0] > 0) And($g_aiLastGoodWallPos[1] > 0) Then
$aCoord[0] = $aCoord[0] + $iLastGoodWallx - $iXRange
$aCoord[1] = $aCoord[1] + $iLastGoodWally - $iYRange
EndIf
$aCoord[0] = $aCoord[0] + $iXClickOffset
$aCoord[1] = $aCoord[1] + $iYClickOffset
SetLog("Checking if found position is a Wall and of desired level.", $COLOR_SUCCESS)
GemClick($aCoord[0], $aCoord[1])
If _Sleep(500) Then Return
Local $aResult = BuildingInfo(245, 491 + $g_iBottomOffsetY)
If $aResult[0] = 2 Then
If StringInStr($aResult[1], "wall") = True And Number($aResult[2]) = $levelWall Then
SetLog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is a Wall Level: " & $levelWall & ".")
$g_aiLastGoodWallPos[0] = $aCoord[0]
$g_aiLastGoodWallPos[1] = $aCoord[1]
ConvertFromVillagePos($g_aiLastGoodWallPos[0],$g_aiLastGoodWallPos[1])
Return True
Else
ClickP($aAway, 1, 0, "#0931")
If $g_bDebugSetlog Then
SetDebugLog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is not a Wall Level: " & $levelWall & ". It was: " & $aResult[1] & ", " & $aResult[2] & " !", $COLOR_DEBUG)
Else
SetLog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is not a Wall Level: " & $levelWall & ".", $COLOR_ERROR)
SetDebugLog("It was: " & $aResult[1] & ", " & $aResult[2], $COLOR_DEBUG, True)
EndIf
EndIf
Else
ClickP($aAway, 1, 0, "#0932")
EndIf
Next
Next
$g_aiLastGoodWallPos[0] = -1
$g_aiLastGoodWallPos[1] = -1
EndIf
Return False
EndFunc
Func imglocFindWalls($walllevel, $searcharea = "DCD", $redline = "", $maxreturn = 0)
Local $FoundWalls[1] = [""]
Local $redLines = $redline
Local $minLevel =(IsNumber($walllevel) ? $walllevel : 1)
Local $maxLevel =(IsNumber($walllevel) ? $walllevel : 13)
Local $maxReturnPoints = $maxreturn
Local $result = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $g_sImgCheckWallDir, "str", $searcharea, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibMyBotPath, $error)
SetLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError, $COLOR_RED)
SetError(2, $extError, $error)
Return $FoundWalls
EndIf
If checkImglocError($result, "imglocFindWalls", $g_sImgCheckWallDir) = True Then
Return $FoundWalls
EndIf
If $result[0] <> "" Then
If $g_bDebugSetlog Then SetDebugLog(" imglocFindMyWall search returned : " & $result[0])
Local $aKeys = StringSplit($result[0], "|", $STR_NOCOUNT)
ReDim $FoundWalls[UBound($aKeys)]
For $i = 0 To UBound($aKeys) - 1
Local $aCoords = RetrieveImglocProperty($aKeys[$i], "objectpoints")
$FoundWalls[$i] = $aCoords
Next
EndIf
Return $FoundWalls
EndFunc
Global $IMGLOCTHLOCATION
Global $IMGLOCTHNEAR
Global $IMGLOCTHFAR
Global $IMGLOCTHRDISTANCE
Func imglocTHSearch($bReTest = False, $myVillage = False, $bForceCapture = True)
Local $xdirectorya = "imglocth-bundle"
Local $xdirectoryb = "imglocth2-bundle"
Local $xdirectory
Local $sCocDiamond = "ECD"
Local $redLines = ""
Local $minLevel = 6
Local $maxLevel = 100
Local $maxReturnPoints = 1
Local $returnProps = "objectname,objectlevel,objectpoints,nearpoints,farpoints,redlinedistance"
Local $iFindTime = 0
If $myVillage = False Then
ResetTHsearch()
$redLines = "ECD"
Else
$redLines = "ECD"
EndIf
Local $propsNames = StringSplit($returnProps, ",", $STR_NOCOUNT)
If $g_bDebugSetlog Then SetDebugLog("imgloc TH search Start", $COLOR_DEBUG)
Local $numRetry = 1
If $g_iDetectedImageType = 1 Then
$numRetry = 3
EndIf
For $retry = 0 To $numRetry
Local $iLvlFound = 0
If Mod($retry, 2) = 0 Then
$xdirectory = $xdirectorya
Else
$xdirectory = $xdirectoryb
EndIf
If $g_iDetectedImageType = 1 And $retry < 2 Then
$xdirectory = "snow-" & $xdirectory
EndIf
If $retry > 0 And $g_sImglocRedline <> "" Then
EndIf
Local $hTimer = __TimerInit()
Local $result = findMultiple($xdirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
If IsArray($result) Then
If $g_sImglocRedline <> "" Then
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS", $g_sImglocRedline)
If @error Then _ObjErrMsg("_ObjPutValue $g_oBldgAttackInfo imglocTHSearch", @error)
Local $aCoordsSplit = StringSplit($g_sImglocRedline, "|")
Local $redlinesCount = $aCoordsSplit[0]
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT", $redlinesCount)
If @error Then _ObjErrMsg("_ObjPutValue $g_oBldgAttackInfo imglocTHSearch", @error)
EndIf
Local $iBestResult = 0
If UBound($result) > 1 Then
If $g_bDebugSetlog Then SetDebugLog("imgloc Found Multiple TH : " & UBound($result), $COLOR_INFO)
Local $iHighestLvl = 0
For $iResult = 0 To UBound($result) - 1
Local $propsValues = $result[$iResult]
For $pv = 0 To UBound($propsValues) - 1
Switch $propsNames[$pv]
Case "objectlevel"
Local $iLvl = Number($propsValues[$pv])
If $iLvl > $iHighestLvl Then
$iHighestLvl = $iLvl
$iBestResult = $iResult
EndIF
EndSwitch
Next
Next
If $g_bDebugSetlog Then SetDebugLog("imgloc Found Multiple TH : Using index " & $iBestResult, $COLOR_INFO)
EndIf
If UBound($result) > 0 Then
If $g_bDebugSetlog Then SetDebugLog("imgloc Found TH : ", $COLOR_INFO)
Local $propsValues = $result[$iBestResult]
For $pv = 0 To UBound($propsValues) - 1
If $g_bDebugSetlog Then SetDebugLog("imgloc Found : " & $propsNames[$pv] & " - " & $propsValues[$pv], $COLOR_INFO)
Switch $propsNames[$pv]
Case "objectname"
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_NAMEFOUND", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_NAMEFOUND", @error)
Local $PathFile = $propsValues[$pv]
Case "objectlevel"
$iLvlFound = Number($propsValues[$pv])
If $myVillage = False Then
$g_iImglocTHLevel = $iLvlFound
$g_aiTownHallDetails[2] = Number($propsValues[$pv])
$g_iSearchTH = Number($propsValues[$pv])
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_MAXLEVELFOUND", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_MAXLEVELFOUND", @error)
Else
$g_iTownHallLevel = $iLvlFound
EndIf
Case "objectpoints"
If $propsValues[$pv] = "0" Then
DebugImageSave("imglocTHSearch_NoTHFound_", True)
ResetTHsearch()
Return
EndIf
If $myVillage = False Then
$IMGLOCTHLOCATION = decodeSingleCoord($propsValues[$pv])
$g_aiTownHallDetails[0] = Number($IMGLOCTHLOCATION[0])
$g_aiTownHallDetails[1] = Number($IMGLOCTHLOCATION[1])
$g_iTHx = Number($IMGLOCTHLOCATION[0])
$g_iTHy = Number($IMGLOCTHLOCATION[1])
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_OBJECTPOINTS", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_OBJECTPOINTS", @error)
Local $aTHLoc = decodeMultipleCoords($propsValues[$pv])
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_LOCATION", $aTHLoc)
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_LOCATION", @error)
If $g_bDebugImageSave And $retry > 0 Then
_CaptureRegion()
Local $editedImage = $g_hBitmap
Local $subDirectory = $g_sProfileTempDebugPath & "\Thdetection\"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = "Thdetection_" & $retry & "_" & $Date & "_" & $Time & ".png"
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
addInfoToDebugImage($hGraphic, $hPen, String($PathFile & "_" & $g_iImglocTHLevel), $g_iTHx, $g_iTHy)
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
Else
$g_aiTownHallPos = decodeSingleCoord($propsValues[$pv])
ConvertFromVillagePos($g_aiTownHallPos[0], $g_aiTownHallPos[1])
EndIf
Case "nearpoints"
If $myVillage = False Then
$IMGLOCTHNEAR = $propsValues[$pv]
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_NEARPOINTS", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_NEARPOINTS", @error)
EndIf
Case "farpoints"
If $myVillage = False Then
$IMGLOCTHFAR = $propsValues[$pv]
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_FARPOINTS", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_FARPOINTS", @error)
EndIf
Case "redlinedistance"
If $myVillage = False Then
$IMGLOCTHRDISTANCE = $propsValues[$pv]
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_REDLINEDISTANCE", $propsValues[$pv])
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_REDLINEDISTANCE", @error)
EndIf
EndSwitch
If $myVillage = False Then
$g_aiTownHallDetails[3] = 1
EndIf
Next
If $iLvlFound > 0 Then
ExitLoop
EndIf
EndIf
Else
If $g_bDebugSetlog And $retry > 0 Then SetLog("imgloc Could not find TH", $COLOR_WARNING)
If $g_bDebugSetlog And $retry > 0 Then SetLog("imgloc THSearch Calculated  (in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds) :")
EndIf
If $iLvlFound > 0 Then
$iFindTime += __TimerDiff($hTimer)
If $g_bDebugSetlog Then SetDebugLog("imgloc THSearch Calculated  (in " & Round($iFindTime / 1000, 2) & " seconds) :")
ExitLoop
Else
If $g_bDebugImageSave And $retry > 0 Then DebugImageSave("imglocTHSearch_NoTHFound_", True)
If $g_bDebugSetlog Then SetDebugLog("imgloc THSearch Notfound, Retry:  " & $retry)
EndIf
Next
If $iFindTime <> 0 Then
_ObjPutValue($g_oBldgAttackInfo, $eBldgTownHall & "_FINDTIME", $iFindTime * 0.001)
If @error Then _ObjErrMsg("$g_oBldgAttackInfo imglocTHSearch " & $g_sBldgNames[$eBldgTownHall] & "_FINDTIME", @error)
EndIf
EndFunc
Func ResetTHsearch()
$g_sImglocRedline = ""
$g_iImglocTHLevel = 0
$IMGLOCTHLOCATION = StringSplit(",", ",", $STR_NOCOUNT)
$IMGLOCTHNEAR = ""
$IMGLOCTHFAR = ""
$IMGLOCTHRDISTANCE = ""
$g_aiTownHallDetails[0] = -1
$g_aiTownHallDetails[1] = -1
$g_aiTownHallDetails[2] = -1
$g_aiTownHallDetails[3] = -1
$g_iTHx = 0
$g_iTHy = 0
$g_iSearchTH = "-"
Local $string
Local $iKeys = $g_oBldgAttackInfo.Keys
For $string In $iKeys
If StringInStr($string, $eBldgTownHall & "_", $STR_NOCASESENSEBASIC) > 0 Then $g_oBldgAttackInfo.Remove($string)
Next
EndFunc
Func imgloccheckTownHallADV2($limit = 0, $tolerancefix = 0, $captureRegion = True)
imglocTHSearch(True, False, $captureRegion)
If $g_iImglocTHLevel = 0 Then
Return "-"
Else
Return $g_iImglocTHLevel
EndIf
EndFunc
Func QuickMIS($ValueReturned, $directory, $Left = 0, $Top = 0, $Right = $g_iGAME_WIDTH, $Bottom = $g_iGAME_HEIGHT, $bNeedCapture = True, $Debug = False, $OcrDecode = 3, $OcrSpace = 12)
If($ValueReturned <> "BC1") And($ValueReturned <> "CX") And($ValueReturned <> "N1") And($ValueReturned <> "NX") And($ValueReturned <> "Q1") And($ValueReturned <> "QX") And($ValueReturned <> "OCR") Then
SetLog("Bad parameters during QuickMIS call for MultiSearch...", $COLOR_RED)
Return
EndIf
If $bNeedCapture Then _CaptureRegion2($Left, $Top, $Right, $Bottom)
Local $Res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If $g_bDebugImageSave Then DebugImageSave("QuickMIS_" & $ValueReturned, False)
If IsArray($Res) Then
If $g_bDebugSetlog Then SetDebugLog("DLL Call succeeded " & $Res[0], $COLOR_PURPLE)
If $Res[0] = "" Or $Res[0] = "0" Then
If $g_bDebugSetlog Then SetDebugLog("No Button found")
Switch $ValueReturned
Case "BC1"
Return False
Case "CX"
Return -1
Case "N1"
Return "none"
Case "NX"
Return "none"
Case "Q1"
Return 0
Case "QX"
Return 0
Case "OCR"
Return "none"
EndSwitch
ElseIf StringInStr($Res[0], "-1") <> 0 Then
SetLog("DLL Error", $COLOR_RED)
Else
Switch $ValueReturned
Case "BC1"
Local $Result = "" , $Name = ""
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
Local $DLLRes = DllCallMyBot("GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
If UBound(decodeSingleCoord($DLLRes[0])) > 1 Then $Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
Local $aCords = decodeMultipleCoords($Result, 60, 10, 1)
If UBound($aCords) = 0 Then Return False
Local $aCord = $aCords[0]
If UBound($aCord) < 2 Then Return False
$g_iQuickMISX = $aCord[0]
$g_iQuickMISY = $aCord[1]
$Name = RetrieveImglocProperty($KeyValue[0], "objectname")
If $g_bDebugSetlog Or $Debug Then
SetDebugLog($ValueReturned & " Found: " & $Result & ", using " & $g_iQuickMISX & "," & $g_iQuickMISY, $COLOR_PURPLE)
If $g_bDebugImageSave Then DebugQuickMIS($Left, $Top, "BC1_detected[" & $Name & "_" & $g_iQuickMISX + $Left & "x" & $g_iQuickMISY + $Top & "]")
EndIf
Return True
Case "CX"
Local $Result = ""
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
Local $DLLRes = DllCallMyBot("GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
If UBound(decodeSingleCoord($DLLRes[0])) > 1 Then $Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
If $g_bDebugSetlog Then SetDebugLog($ValueReturned & " Found: " & $Result, $COLOR_PURPLE)
Local $CoordsInArray = StringSplit($Result, "|", $STR_NOCOUNT)
Return $CoordsInArray
Case "N1"
Local $MultiImageSearchResult = StringSplit($Res[0], "|")
Local $FilenameFound = StringSplit($MultiImageSearchResult[1], "_")
Return $FilenameFound[1]
Case "NX"
Local $AllFilenamesFound = ""
Local $MultiImageSearchResult = StringSplit($Res[0], "|")
For $i = 1 To $MultiImageSearchResult[0]
Local $FilenameFound = StringSplit($MultiImageSearchResult[$i], "_")
$AllFilenamesFound &= $FilenameFound[1] & "|"
Next
If StringRight($AllFilenamesFound, 1) = "|" Then $AllFilenamesFound = StringLeft($AllFilenamesFound,(StringLen($AllFilenamesFound) - 1))
Return $AllFilenamesFound
Case "Q1"
Local $Result = ""
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
Local $DLLRes = DllCallMyBot("GetProperty", "str", $KeyValue[$i], "str", "totalobjects")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
If $g_bDebugSetlog Then SetDebugLog($ValueReturned & " Found: " & $Result, $COLOR_PURPLE)
Local $QuantityInArray = StringSplit($Result, "|", $STR_NOCOUNT)
Return $QuantityInArray[0]
Case "QX"
Local $MultiImageSearchResult = StringSplit($Res[0], "|", $STR_NOCOUNT)
Return UBound($MultiImageSearchResult)
Case "OCR"
Local $sOCRString = ""
Local $aResults[1][2] = [[-1, ""]]
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
Local $DLLRes = DllCallMyBot("GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
Local $Name = RetrieveImglocProperty($KeyValue[$i], "objectname")
Local $aCoords = StringSplit($DLLRes[0], "|", $STR_NOCOUNT)
For $j = 0 To UBound($aCoords) - 1
Local $aXY = StringSplit($aCoords[$j], ",", $STR_NOCOUNT)
ReDim $aResults[UBound($aResults) + 1][2]
$aResults[UBound($aResults) - 2][0] = Number($aXY[0])
$aResults[UBound($aResults) - 2][1] = $Name
Next
Next
_ArrayDelete($aResults, UBound($aResults) - 1)
_ArraySort($aResults)
For $i = 0 To UBound($aResults) - 1
If $g_bDebugSetlog Then SetDebugLog($i & ". $Name = " & $aResults[$i][1] & ", Coord = " & $aResults[$i][0])
If $i >= 1 Then
If $aResults[$i][1] = $aResults[$i - 1][1] And Abs($aResults[$i][0] - $aResults[$i - 1][0]) <= $OcrDecode Then ContinueLoop
If Abs($aResults[$i][0] - $aResults[$i - 1][0]) > $OcrSpace Then $sOCRString &= " "
EndIf
$sOCRString &= $aResults[$i][1]
Next
If $g_bDebugSetlog Then SetDebugLog("QuickMIS " & $ValueReturned & ", $sOCRString: " & $sOCRString)
Return $sOCRString
EndSwitch
EndIf
EndIf
EndFunc
Func DebugQuickMIS($x, $y, $DebugText)
_CaptureRegion2()
Local $subDirectory = $g_sProfileTempDebugPath & "QuickMIS"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = String($Date & "_" & $Time & "_" & $DebugText & "_.png")
Local $editedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 3)
_GDIPlus_GraphicsDrawRect($hGraphic, $g_iQuickMISX - 5 + $x, $g_iQuickMISY - 5 + $y, 10, 10, $hPenRED)
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $filename)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($editedImage)
EndFunc
Func checkMainScreen($bSetLog = Default, $bBuilderBase = Default)
FuncEnter(checkMainScreen)
Return FuncReturn(_checkMainScreen($bSetLog, $bBuilderBase))
EndFunc
Func _checkMainScreen($bSetLog = Default, $bBuilderBase = Default)
If $bSetLog = Default Then $bSetLog = True
If $bBuilderBase = Default Then $bBuilderBase = False
Local $i, $iErrorCount, $iCheckBeforeRestartAndroidCount, $bObstacleResult, $bContinue
Local $aPixelToCheck = $aIsMain
If $bSetLog Then
SetLog("Trying to locate Main Screen")
EndIf
If Not TestCapture() Then
If CheckAndroidRunning(False) = False Then Return False
getBSPos()
WinGetAndroidHandle()
If Not $g_bChkBackgroundMode And $g_hAndroidWindow <> 0 Then
AndroidToFront(Default, "checkMainScreen")
EndIf
If $g_bAndroidAdbScreencap = False And _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
EndIf
$i = 0
$iErrorCount = 0
$iCheckBeforeRestartAndroidCount = 3
If $bBuilderBase Then $aPixelToCheck = $aIsOnBuilderBase
Local $bLocated
While _CaptureRegions() And Not _checkMainScreenImage($bLocated, $aPixelToCheck)
$i += 1
If TestCapture() Then
SetLog("Main Screen not Located", $COLOR_ERROR)
ExitLoop
EndIf
WinGetAndroidHandle()
$bObstacleResult = checkObstacles($bBuilderBase)
SetDebugLog("CheckObstacles[" & $i & "] Result = " & $bObstacleResult, $COLOR_DEBUG)
$bContinue = False
If Not $bObstacleResult Then
If $g_bMinorObstacle Then
$g_bMinorObstacle = False
$bContinue = True
Else
If $i > $iCheckBeforeRestartAndroidCount Then
DebugImageSave("checkMainScreen_RestartCoC", False)
RestartAndroidCoC()
$bContinue = True
EndIf
EndIf
Else
$g_bRestart = True
$bContinue = True
EndIf
If $bContinue Then
waitMainScreen()
If Not $g_bRunState Then Return False
If @extended Then Return SetError(1, 1, False)
If @error Then $iErrorCount += 1
If $iErrorCount > 2 Then
SetLog("Unable to fix the window error", $COLOR_ERROR)
CloseCoC(True)
ExitLoop
EndIf
Else
If _Sleep($DELAYCHECKMAINSCREEN1) Then Return
EndIf
WEnd
If $bLocated Then ZoomOut()
If Not $g_bRunState Then Return False
If $bSetLog Then
If $bLocated Then
SetLog("Main Screen located", $COLOR_SUCCESS)
Else
SetLog("Main Screen not located", $COLOR_ERROR)
EndIf
EndIf
DisposeWindows()
NotifyPendingActions()
Return $bLocated
EndFunc
Func _checkMainScreenImage(ByRef $bLocated, $aPixelToCheck)
$bLocated = _CheckPixel($aPixelToCheck, $g_bNoCapturePixel) And Not checkObstacles_Network(False, False)
Return $bLocated
EndFunc
Func checkObstacles($bBuilderBase = Default)
FuncEnter(checkObstacles)
If $bBuilderBase = Default Then $bBuilderBase = False
Static $iRecursive = 0
If TestCapture() = False And WinGetAndroidHandle() = 0 Then
Return FuncReturn(True)
EndIf
Local $offColors[3][3] = [[0x535353, 140, 0], [0xFFFFFF, 55, 20], [0xFDC671, 55, 10]]
Local $ButtonPixel = _MultiPixelSearch(270, 372 + $g_iMidOffsetY, 422, 404 + $g_iMidOffsetY, 1, 1, Hex(0x535353, 6), $offColors, 20)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 140, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 55, $ButtonPixel[1] + 20, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 55, $ButtonPixel[1] + 10, True), $COLOR_DEBUG)
EndIf
SetLog("Found Switch Account dialog...!", $COLOR_INFO)
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "Click Cancel")
EndIf
Local $wasForce = OcrForceCaptureRegion(False)
$iRecursive += 1
Local $Result = _checkObstacles($bBuilderBase, $iRecursive > 5)
OcrForceCaptureRegion($wasForce)
$iRecursive -= 1
Return FuncReturn($Result)
EndFunc
Func _checkObstacles($bBuilderBase = False, $bRecursive = False)
Local $msg, $x, $y, $Result
$g_bMinorObstacle = False
_CaptureRegions()
If Not $bRecursive Then
If checkObstacles_Network() Then Return True
If checkObstacles_GfxError() Then Return True
EndIf
Local $bIsOnBuilderIsland = isOnBuilderBase()
If $bBuilderBase = False And $bIsOnBuilderIsland = True Then
SetLog("Detected Builder Base, trying to switch back to Main Village")
If SwitchBetweenBases() Then
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
EndIf
If $g_sAndroidGameDistributor <> $g_sGoogle Then
Local $aXButton = FindAdsXButton()
If IsArray($aXButton) Then
SetDebugLog("checkObstacles: Found " & $g_sAndroidGameDistributor & " ADS X button to close")
PureClickP($aXButton)
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
EndIf
Local $aMessage = _PixelSearch($aIsReloadError[0], $aIsReloadError[1], $aIsReloadError[0] + 3, $aIsReloadError[1] + 11, Hex($aIsReloadError[2], 6), $aIsReloadError[3], $g_bNoCapturePixel)
If IsArray($aMessage) Or(UBound(decodeSingleCoord(FindImageInPlace("Error", $g_sImgError, "680,300(2,20)", False, $g_iAndroidLollipop))) > 1) Then
If $g_bDebugSetlog Then SetDebugLog("(DC=" & _GetPixelColor($aIsConnectLost[0], $aIsConnectLost[1]) & ")(OoS=" & _GetPixelColor($aIsCheckOOS[0], $aIsCheckOOS[1]) & ")", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("(Maintenance=" & _GetPixelColor($aIsMaintenance[0], $aIsMaintenance[1]) & ")(RateCoC=" & ")", $COLOR_DEBUG)
If $g_bDebugSetlog Then SetDebugLog("33B5E5=>true, 282828=>false", $COLOR_DEBUG)
$Result = getOcrMaintenanceTime(184, 325 + $g_iMidOffsetY, "Another Device OCR:")
Local $sRegion = "220,330(80,60)"
If StringInStr($Result, "device", $STR_NOCASESENSEBASIC) Or UBound(decodeSingleCoord(FindImageInPlace("Device", $g_sImgAnotherDevice, $sRegion, False))) > 1 Then
If TestCapture() Then Return "Another Device has connected"
If $g_iAnotherDeviceWaitTime > 3600 Then
SetLog("Another Device has connected, waiting " & Floor(Floor($g_iAnotherDeviceWaitTime / 60) / 60) & " hours " & Floor(Mod(Floor($g_iAnotherDeviceWaitTime / 60), 60)) & " minutes " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice3600")
ElseIf $g_iAnotherDeviceWaitTime > 60 Then
SetLog("Another Device has connected, waiting " & Floor(Mod(Floor($g_iAnotherDeviceWaitTime / 60), 60)) & " minutes " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice60")
Else
SetLog("Another Device has connected, waiting " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice")
EndIf
If _SleepStatus($g_iAnotherDeviceWaitTime * 1000) Then Return
checkObstacles_ReloadCoC($aReloadButton, "#0127", $bRecursive)
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
checkObstacles_ResetSearch()
Return True
EndIf
If UBound(decodeSingleCoord(FindImageInPlace("Break", $g_sImgPersonalBreak, "165,287,335,335", False))) > 1 Then
SetLog("Village must take a break, wait ...", $COLOR_ERROR)
If TestCapture() Then Return "Village must take a break"
PushMsg("TakeBreak")
If _SleepStatus($DELAYCHECKOBSTACLES4) Then Return
Local $point =($g_iAndroidVersionAPI >= $g_iAndroidLollipop) ? $aReloadButton51 : $aReloadButton
SetDebugLog("Break - Using ReloadButton to " & GetAndroidCodeName($g_iAndroidVersionAPI))
checkObstacles_ReloadCoC($point, "#0128", $bRecursive)
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
checkObstacles_ResetSearch()
Return True
EndIf
Select
Case UBound(decodeSingleCoord(FindImageInPlace("AnyoneThere", $g_sImgAnyoneThere, "440,340,580,390", False))) > 1
SetLog("Village was Inactive, Reloading CoC...", $COLOR_ERROR)
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
Case _CheckPixel($aIsConnectLost, $g_bNoCapturePixel)
$Result = getOcrMaintenanceTime(171, 358 + $g_iMidOffsetY, "Check Obstacles OCR 'policy at super'=")
If StringInStr($Result, "policy", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
$Result = getOcrMaintenanceTime(171, 337 + $g_iMidOffsetY, "Check Obstacles OCR 'prohibited 3rd'= ")
If StringInStr($Result, "3rd", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
SetLog("Connection lost, Reloading CoC...", $COLOR_ERROR)
If($g_bChkSharedPrefs Or $g_bUpdateSharedPrefs) And HaveSharedPrefs() Then
SetLog("Please wait for loading CoC...!")
PushSharedPrefs()
If Not $bRecursive Then OpenCoC()
Return True
EndIf
Case _CheckPixel($aIsCheckOOS, $g_bNoCapturePixel) Or(UBound(decodeSingleCoord(FindImageInPlace("OOS", $g_sImgOutOfSync, "355,335,435,395", False, $g_iAndroidLollipop))) > 1)
SetLog("Out of Sync Error, Reloading CoC...", $COLOR_ERROR)
Case _CheckPixel($aIsMaintenance, $g_bNoCapturePixel)
$Result = getOcrMaintenanceTime(171, 345 + $g_iMidOffsetY, "Check Obstacles OCR Maintenance Break=")
Local $iMaintenanceWaitTime = 0
Select
Case $Result = ""
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES4
Case StringInStr($Result, "few", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES4
Case StringInStr($Result, "10", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES6
Case StringInStr($Result, "15", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES6
Case StringInStr($Result, "20", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES7
Case StringInStr($Result, "30", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES8
Case StringInStr($Result, "45", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES9
Case StringInStr($Result, "hour", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES10
Case Else
$iMaintenanceWaitTime = $DELAYCHECKOBSTACLES4
SetLog("Error reading Maintenance Break time?", $COLOR_ERROR)
EndSelect
SetLog("Maintenance Break, waiting: " & $iMaintenanceWaitTime / 60000 & " minutes....", $COLOR_ERROR)
If $g_bNotifyTGEnable And $g_bNotifyAlertMaintenance = True Then NotifyPushToTelegram("Maintenance Break, waiting: " & $iMaintenanceWaitTime / 60000 & " minutes....")
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
If _SleepStatus($iMaintenanceWaitTime) Then Return
checkObstacles_ResetSearch()
Case Else
If $g_bDebugImageSave Then DebugImageSave("ChkObstaclesReloadMsg_", False)
Local $sRegion = "220,420(60,25)"
If $g_iAndroidVersionAPI >= $g_iAndroidLollipop Then
$sRegion = "555,400(60,25)"
EndIf
$Result = decodeSingleCoord(FindImageInPlace("RateNever", $g_sImgAppRateNever, $sRegion, False, True))
If UBound($Result) > 1 Then
SetLog("Clash feedback window found, permanently closed!", $COLOR_ERROR)
PureClick($Result[0] + 5, $Result[1] + 5, 1, 0, "#9999")
$g_bMinorObstacle = True
Return True
EndIf
$Result = getOcrMaintenanceTime(171, 325 + $g_iMidOffsetY, "Check Obstacles OCR 'Good News!'=")
If StringInStr($Result, "new", $STR_NOCASESENSEBASIC) Then
If Not $g_bAutoUpdateGame Then
$msg = "Game Update is required, Bot must stop!!"
Return checkObstacles_StopBot($msg)
Else
Switch UpdateGame()
Case True, Default
If Not $bRecursive Then Return checkObstacles_ReloadCoC()
Case False
$msg = "Game Update failed, Bot must stop!!"
Return checkObstacles_StopBot($msg)
EndSwitch
EndIf
ElseIf StringInStr($Result, "rate", $STR_NOCASESENSEBASIC) Then
SetLog("Clash feedback window found, permanently closed!", $COLOR_ERROR)
PureClick(248, 408 + $g_iMidOffsetY, 1, 0, "#9999")
$g_bMinorObstacle = True
Return True
EndIf
$Result = getOcrMaintenanceTime(171, 358 + $g_iMidOffsetY, "Check Obstacles OCR 'policy at super'=")
If StringInStr($Result, "policy", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
$Result = getOcrMaintenanceTime(171, 337 + $g_iMidOffsetY, "Check Obstacles OCR 'prohibited 3rd'= ")
If StringInStr($Result, "3rd", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
SetLog("Warning: Cannot find type of Reload error message", $COLOR_ERROR)
EndSelect
If TestCapture() Then Return "Village is out of sync or inactivity or connection lost or maintenance"
Return checkObstacles_ReloadCoC($aReloadButton, "#0131", $bRecursive)
EndIf
If TestCapture() = 0 And GetAndroidProcessPID() = 0 Then
Return checkObstacles_ReloadCoC(Default, "", $bRecursive)
EndIf
Local $bHasTopBlackBar = _ColorCheck(_GetPixelColor(10, 3), Hex(0x000000, 6), 1) And _ColorCheck(_GetPixelColor(300, 6), Hex(0x000000, 6), 1) And _ColorCheck(_GetPixelColor(600, 9), Hex(0x000000, 6), 1)
If _ColorCheck(_GetPixelColor(235, 209 + $g_iMidOffsetY), Hex(0x9E3826, 6), 20) Then
SetDebugLog("checkObstacles: Found Window to close")
PureClick(429, 493 + $g_iMidOffsetY, 1, 0, "#0132")
$g_abNotNeedAllTime[0] = True
$g_abNotNeedAllTime[1] = True
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If Not $bHasTopBlackBar And _CheckPixel($aIsMainGrayed, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found gray Window to close")
PureClickP($aAway, 1, 0, "#0133")
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If _ColorCheck(_GetPixelColor(792, 39), Hex(0xDC0408, 6), 20) Then
SetDebugLog("checkObstacles: Found Window with Close Button to close")
PureClick(792, 39, 1, 0, "#0134")
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If _CheckPixel($aCancelFight, $g_bNoCapturePixel) Or _CheckPixel($aCancelFight2, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found Cancel Fight to close")
PureClickP($aCancelFight, 1, 0, "#0135")
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If _CheckPixel($aChatTab, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found Chat Tab to close")
PureClickP($aChatTab, 1, 0, "#0136")
$g_bMinorObstacle = True
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
Return False
EndIf
If _CheckPixel($aEndFightSceneBtn, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found End Fight Scene to close")
PureClickP($aEndFightSceneBtn, 1, 0, "#0137")
Return True
EndIf
If _CheckPixel($aSurrenderButton, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found End Battle to close")
ReturnHome(False, False)
Return True
EndIf
If _CheckPixel($aNoCloudsAttack, $g_bNoCapturePixel) Then
$aMessage = _PixelSearch(23, 566 + $g_iBottomOffsetY, 36, 580 + $g_iBottomOffsetY, Hex(0xF4F7E3, 6), 10, False)
If IsArray($aMessage) Then
SetDebugLog("checkObstacles: Found Return Home button")
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($DELAYCHECKOBSTACLES2) Then Return
Return True
EndIf
EndIf
If IsPostDefenseSummaryPage(False) Then
$aMessage = _PixelSearch(23, 566 + $g_iBottomOffsetY, 36, 580 + $g_iBottomOffsetY, Hex(0xE0E1CE, 6), 10, False)
If IsArray($aMessage) Then
SetDebugLog("checkObstacles: Found Post Defense Summary to close")
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($DELAYCHECKOBSTACLES2) Then Return
Return True
EndIf
EndIf
Local $CSFoundCoords = decodeSingleCoord(FindImageInPlace("CocStopped", $g_sImgCocStopped, "250,358,618,432", False))
If UBound($CSFoundCoords) > 1 Then
SetLog("CoC Has Stopped Error .....", $COLOR_ERROR)
If TestCapture() Then Return "CoC Has Stopped Error ....."
PushMsg("CoCError")
If _Sleep($DELAYCHECKOBSTACLES1) Then Return
PureClick($CSFoundCoords[0], $CSFoundCoords[1], 1, 0, "#0129")
If _Sleep($DELAYCHECKOBSTACLES2) Then Return
Return checkObstacles_ReloadCoC(Default, "", $bRecursive)
EndIf
If $bHasTopBlackBar Then
SetDebugLog("checkObstacles: Found Black Android Screen")
EndIf
If $g_bOnlySCIDAccounts Then
SetDebugLog("check Log in with Supercell ID login by Clicks")
CheckLoginWithSupercellIDScreen()
EndIf
If Not CheckGoogleSelectAccount() Then
SetDebugLog("check Log in with Supercell ID login by shared_prefs")
If CheckLoginWithSupercellID() Then Return True
EndIf
Return False
EndFunc
Func checkObstacles_ReloadCoC($point = Default, $debugtxt = "", $bRecursive = False)
If TestCapture() Then Return "Reload CoC"
ForceCaptureRegion(True)
OcrForceCaptureRegion(True)
If $point = Default Then
If Not $bRecursive Then CloseCoC(True)
Else
If UBound($point) > 1 Then
PureClickP($point, 1, 0, $debugtxt)
EndIf
If Not $bRecursive Then OpenCoC()
EndIf
If _Sleep($DELAYCHECKOBSTACLES3) Then Return
Return True
EndFunc
Func checkObstacles_RebootAndroid()
If TestCapture() Then Return "Reboot Android"
ForceCaptureRegion(True)
OcrForceCaptureRegion(True)
$g_bGfxError = True
CheckAndroidReboot()
Return True
EndFunc
Func checkObstacles_StopBot($msg)
SetLog($msg, $COLOR_ERROR)
If TestCapture() Then Return $msg
If $g_bNotifyTGEnable And $g_bNotifyAlertMaintenance Then NotifyPushToTelegram($msg)
OcrForceCaptureRegion(True)
Btnstop()
Return True
EndFunc
Func checkObstacles_ResetSearch()
$g_bIsClientSyncError = False
$g_bIsSearchLimit = False
$g_abNotNeedAllTime[0] = True
$g_abNotNeedAllTime[1] = True
$g_bRestart = True
EndFunc
Func BanMsgBox()
Local $MsgBox
Local $stext = "Sorry, your account is banned!!" & @CRLF & "Bot will stop now..."
If TestCapture() Then Return $stext
While 1
PushMsg("BAN")
_ExtMsgBoxSet(4, 1, 0x004080, 0xFFFF00, 20, "Comic Sans MS", 600)
$MsgBox = _ExtMsgBox(48, "Ok", "Banned", $stext, 1)
If $MsgBox = 1 Then Return
_ExtMsgBoxSet(4, 1, 0xFFFF00, 0x004080, 20, "Comic Sans MS", 600)
$MsgBox = _ExtMsgBox(48, "Ok", "Banned", $stext, 1)
If $MsgBox = 1 Then Return
WEnd
EndFunc
Func checkObstacles_Network($bForceCapture = False, $bReloadCoC = True)
Static $hCocReconnectingTimer = 0
If UBound(decodeSingleCoord(FindImageInPlace("CocReconnecting", $g_sImgCocReconnecting, "420,355,440,375", $bForceCapture))) > 1 Then
If $hCocReconnectingTimer = 0 Then
SetLog("Network Connection lost...", $COLOR_ERROR)
$hCocReconnectingTimer = __TimerInit()
ElseIf __TimerDiff($hCocReconnectingTimer) > $g_iCoCReconnectingTimeout Then
SetLog("Network Connection really lost, Reloading CoC...", $COLOR_ERROR)
$hCocReconnectingTimer = 0
If $bReloadCoC = True Then Return checkObstacles_ReloadCoC()
Return True
Else
SetLog("Network Connection lost, waiting...", $COLOR_ERROR)
EndIf
Else
$hCocReconnectingTimer = 0
EndIf
Return False
EndFunc
Func checkObstacles_GfxError($bForceCapture = False, $bRebootAndroid = True)
Local $aResult = decodeMultipleCoords(FindImage("GfxError", $g_sImgGfxError, "ECD", 100, $bForceCapture), 100, 100)
If UBound($aResult) >= 8 Then
SetLog(UBound($aResult) & " Gfx Errors detected, Reloading Android...", $COLOR_ERROR)
DebugImageSave("GfxError", False)
If $bRebootAndroid Then Return checkObstacles_RebootAndroid()
Return True
EndIf
Return False
EndFunc
Func UpdateGame()
SetLog("Open Play Store for Game Update...")
OpenPlayStoreGame()
EndFunc
Global Const $g_iDPI_Ratio = 1
Func GUISetFont_DPI($isize, $iweight = "", $iattribute = "", $sfontname = "")
GUISetFont($isize / $g_iDPI_Ratio, $iweight, $iattribute, $sfontname)
EndFunc
Func SetDPI()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = "My Bot needs to change your DPI settinng to continue!" & @CRLF & @CRLF & "You will be required to reboot your PC when done" & @CRLF & @CRLF & "Please close other programs and save you work NOW!" & @CRLF & @CRLF & "Hit OK to change settings and reboot, or cancel to exit bot"
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Settings_Error", "Display Settings Error"), $stext, 120)
If $MsgBox = 1 Then
Local $aRet = DllCall("syssetup.dll", "int", "SetupChangeFontSize", "int_ptr", 0, "wstr", "96")
If @error Then Return SetError(2, @extended, 0)
If $aRet = 0 Then
SetLog("Your Display DPI has been changed!!  Must logoff or restart to complete the chamge!", $COLOR_WARNING)
_Sleep(5000)
Shutdown($SD_REBOOT)
Else
SetLog("Your DPI has not been changed due some unknown error, Return= " & $aRet, $COLOR_WARNING)
EndIf
EndIf
EndFunc
Func isGemOpen($bNeedCaptureRegion = False)
_Sleep($DELAYISGEMOPEN1)
If _CheckPixel($aIsGemWindow1, $bNeedCaptureRegion) Then
If $g_bDebugSetlog Then SetDebugLog("Gemclick Red X detect", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0140")
Return True
ElseIf _CheckPixel($aIsGemWindow2, $bNeedCaptureRegion) And  _CheckPixel($aIsGemWindow3, $bNeedCaptureRegion) And  _CheckPixel($aIsGemWindow4, $bNeedCaptureRegion) Then
If $g_bDebugSetlog Then SetDebugLog("Gemclick Red Line detect", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0141")
Return True
EndIf
Return False
EndFunc
Func isNoUpgradeLoot($bNeedCaptureRegion = False)
If _ColorCheck(_GetPixelColor(460, 492 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) And  _ColorCheck(_GetPixelColor(460, 494 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) And  _ColorCheck(_GetPixelColor(460, 498 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) Then
If $g_bDebugSetlog Then SetDebugLog("isNoUpgradeLoot Red Zero found", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0142")
Return True
ElseIf _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) And  _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xFF887F, 6), 20) Then
If $g_bDebugSetlog Then SetDebugLog("IsNoUpgradeLoot Hero Red Zero Found", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0143")
Return True
EndIf
Return False
EndFunc
Func isProblemAffect($bNeedCaptureRegion = False)
Local $iGray = 0x282828
If $g_iAndroidVersionAPI >= $g_iAndroidLollipop Then $iGray = 0x424242
If Not _ColorCheck(_GetPixelColor(253, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(373, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(473, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(283, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(320, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(594, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex($iGray, 6), 10) Then
Return False
ElseIf _ColorCheck(_GetPixelColor(823, 32, $bNeedCaptureRegion), Hex(0xF8FCFF, 6), 10) Then
Return False
Else
Return True
EndIf
EndFunc
Func checkAttackDisable($iSource, $Result = "")
Local $i = 0, $iCount = 0
Local $iModSource
If $g_bDisableBreakCheck = True Then Return
If $g_bForceSinglePBLogoff And _DateIsValid($g_sPBStartTime) Then
Local $iTimeTillPBTstartSec = Int(_DateDiff('s', $g_sPBStartTime, _NowCalc()))
If $g_bDebugSetlog Then SetDebugLog("PB starts in: " & $iTimeTillPBTstartSec & " Seconds", $COLOR_DEBUG)
If $iTimeTillPBTstartSec >= 0 Then
$iModSource = $g_iTaBChkTime
Else
$g_abPBActive[$g_iCurAccount] = False
Return
EndIf
Else
$iModSource = $iSource
EndIf
Switch $iModSource
Case $g_iTaBChkAttack
While $Result = "" Or(StringLen($Result) < 3)
$i += 1
If _Sleep($DELAYATTACKDISABLE100) Then Return
$Result = getAttackDisable(346, 182)
If $i >= 3 Then ExitLoop
WEnd
If $g_bDebugSetlog Then SetDebugLog("Attack Personal Break OCR result = " & $Result, $COLOR_DEBUG)
If $Result <> "" Then
If StringInStr($Result, "disable") <> 0 Or StringInStr($Result, "for") <> 0 Or StringInStr($Result, "after") <> 0 Or StringInStr($Result, "have") <> 0 Then
SetLog("Attacking disabled, Personal Break detected...", $COLOR_ERROR)
If _CheckPixel($aSurrenderButton, $g_bCapturePixel) Then
If TestCapture() Then
SetLog("checkAttackDisable: ReturnHome")
Else
ReturnHome(False, False)
EndIf
Else
If TestCapture() Then
SetLog("checkAttackDisable: CloseCoC")
Else
CloseCoC()
EndIf
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("wrong text string", $COLOR_DEBUG)
If TestCapture() Then Return "wrong text string"
Return
EndIf
Else
If TestCapture() Then Return "take a break text not found"
Return
EndIf
Case $g_iTaBChkIdle
If $Result = "" Then $Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If _Sleep($DELAYATTACKDISABLE500) Then Return
If $Result = "" Or(StringLen($Result) < 3) Then $Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If $g_bDebugSetlog Then SetDebugLog("Personal Break OCR result = " & $Result, $COLOR_DEBUG)
If $Result <> "" Then
If StringInStr($Result, "been") <> 0 Or StringInStr($Result, "after") <> 0 Or StringInStr($Result, "have") <> 0 Then
SetLog("Online too long, Personal Break detected....", $COLOR_ERROR)
checkMainScreen()
Else
If $g_bDebugSetlog Then SetDebugLog("wrong text string", $COLOR_DEBUG)
If TestCapture() Then Return "wrong text string #2"
$g_abPBActive[$g_iCurAccount] = False
Return
EndIf
Else
If TestCapture() Then Return "take a break text not found #2"
$g_abPBActive[$g_iCurAccount] = False
Return
EndIf
Case $g_iTaBChkTime
If $iSource = $g_iTaBChkAttack Then
While _CheckPixel($aIsAttackPage, $g_bCapturePixel) = False
If _Sleep($DELAYATTACKDISABLE500) Then Return
$iCount += 1
If $g_bDebugSetlog Then SetDebugLog("wait end battle button " & $iCount, $COLOR_DEBUG)
If $iCount > 40 Or isProblemAffect(True) Then
checkObstacles()
ExitLoop
EndIf
If Not $g_bRunState Then ExitLoop
WEnd
If _CheckPixel($aIsAttackPage, $g_bCapturePixel) Then
If TestCapture() Then
SetLog("checkAttackDisable: ReturnHome #2")
Else
ReturnHome(False, False)
EndIf
EndIf
EndIf
If $iSource = $g_iTaBChkIdle Then
While _CheckPixel($aIsMain, $g_bCapturePixel) = False
If _Sleep($DELAYATTACKDISABLE500) Then Return
ClickP($aAway, 1, 0, "#0000")
$iCount += 1
If $g_bDebugSetlog Then SetDebugLog("wait main page" & $iCount, $COLOR_DEBUG)
If $iCount > 5 Or isProblemAffect(True) Then
checkObstacles()
ExitLoop
EndIf
WEnd
If _Sleep($DELAYATTACKDISABLE500) Then Return
EndIf
If $g_asShieldStatus[0] = "guard" Then
SetLog("Unable to Force PB, Guard shield present", $COLOR_INFO)
Else
SetLog("Forcing Early Personal Break Now!!", $COLOR_SUCCESS)
EndIf
Case Else
SetLog("Misformed $sSource parameter, silly programmer made a mistake!", $COLOR_DEBUG)
Return False
EndSwitch
SetLog("Prepare base before Personal Break..", $COLOR_INFO)
CheckBaseQuick(True)
$g_bIsClientSyncError = False
$g_bIsSearchLimit = False
$g_bRestart = True
If ProfileSwitchAccountEnabled() Then
SetLog("Adding the PB time to remain time of the current account.", $COLOR_INFO)
If _DateIsValid($g_asTrainTimeFinish[$g_iCurAccount]) Then
If _DateDiff("n", _NowCalc(), $g_asTrainTimeFinish[$g_iCurAccount]) < $g_iSinglePBForcedLogoffTime Then
$g_asTrainTimeFinish[$g_iCurAccount] = _DateAdd("n", $g_iSinglePBForcedLogoffTime, _NowCalc())
$g_abPBActive[$g_iCurAccount] = True
EndIf
EndIf
Local $iAllcounts = 0, $iAllAccountsPBactive = 0
For $i = 0 To $g_iTotalAcc
If $g_abAccountNo[$i] = True Then
If SwitchAccountEnabled($i) Then
$iAllcounts +=1
If $g_abPBActive[$i] = True Then $iAllAccountsPBactive+=1
EndIf
EndIf
Next
If $iAllcounts <> $iAllAccountsPBactive Then
checkSwitchAcc()
Return
Else
SetLog("All Accounts are in PB Time!!", $COLOR_INFO)
EndIf
EndIf
SetLog("Time for break, exit now..", $COLOR_INFO)
If TestCapture() Then
SetLog("checkAttackDisable: PoliteCloseCoC")
Else
PoliteCloseCoC("AttackDisable_")
EndIf
If _Sleep(1000) Then Return
PushMsg("TakeBreak")
If $iModSource = $g_iTaBChkTime And $g_asShieldStatus[0] <> "guard" Then
SetLog("Personal Break Reset log off: " & $g_iSinglePBForcedLogoffTime & " Minutes", $COLOR_INFO)
If TestCapture() Then
SetLog("checkAttackDisable: WaitnOpenCoC")
Else
WaitnOpenCoC($g_iSinglePBForcedLogoffTime * 60 * 1000, True)
EndIf
Else
If TestCapture() Then
SetLog("checkAttackDisable: WaitnOpenCoC")
Else
WaitnOpenCoC(20000, True)
EndIf
EndIf
$g_sPBStartTime = ""
For $i = 0 To UBound($g_asShieldStatus) - 1
$g_asShieldStatus[$i] = ""
Next
For $i = 0 To $g_iTotalAcc
If $g_abAccountNo[$i] = True Then
If SwitchAccountEnabled($i) Then
$g_abPBActive[$i] = False
EndIf
EndIF
Next
EndFunc
Func RemoveGhostTrayIcons($IconTextPart_notUsedAnymore = "")
Local $iGhostCount = 0
Local $i, $handle, $pid
Local $count = _SysTrayIconCount()
For $i = $count - 1 To 0 Step -1
$handle = _SysTrayIconHandle($i)
$pid = WinGetProcess($handle)
If $pid = -1 Then
$iGhostCount += 1
_SysTrayIconRemove($i)
EndIf
Next
If _FindTrayToolbarWindow(2) <> -1 Then
Local $countwin7 = _SysTrayIconCount(2)
For $i = $countwin7 - 1 To 0 Step -1
$handle = _SysTrayIconHandle($i, 2)
$pid = WinGetProcess($handle)
If $pid = -1 Then
$iGhostCount += 1
_SysTrayIconRemove($i, 2)
EndIf
Next
EndIf
If $iGhostCount > 0 And $g_bDebugSetlog Then SetLog("Removed " & $iGhostCount & " Ghost icon successfully", $COLOR_SUCCESS)
EndFunc
Func _SysTrayIconCount($iWin = 1)
Local Const $TB_BUTTONCOUNT = 1048
Local $hWnd = _FindTrayToolbarWindow($iWin)
If $hWnd = -1 Then Return -1
Local $count = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $TB_BUTTONCOUNT, "wparam", 0, "lparam", 0)
If @error Then Return -1
Return $count[0]
EndFunc
Func _SysTrayIconTitles($iWin = 1)
Local $count = _SysTrayIconCount($iWin)
If $count <= 0 Then Return -1
Local $titles[$count]
For $i = 0 To $count - 1
$titles[$i] = WinGetTitle(_SysTrayIconHandle($i, $iWin))
Next
Return $titles
EndFunc
Func _SysTrayIconPids($iWin = 1)
Local $count = _SysTrayIconCount($iWin)
If $count <= 0 Then Return -1
Local $processes[$count]
For $i = 0 To $count - 1
$processes[$i] = WinGetProcess(_SysTrayIconHandle($i, $iWin))
Next
Return $processes
EndFunc
Func _SysTrayIconProcesses($iWin = 1)
Local $pids = _SysTrayIconPids($iWin)
If Not IsArray($pids) Then Return -1
Local $processes[UBound($pids)]
Local $list = ProcessList()
For $i = 0 To UBound($pids) - 1
For $j = 1 To $list[0][0]
If $pids[$i] = $list[$j][1] Then
$processes[$i] = $list[$j][0]
ExitLoop
EndIf
Next
Next
Return $processes
EndFunc
Func _SysTrayIconIndex($test, $mode = 0, $iWin = 1)
Local $ret = -1, $compare = -1
If $mode < 0 Or $mode > 2 Or Not IsInt($mode) Then Return -1
Switch $mode
Case 0
$compare = _SysTrayIconProcesses($iWin)
Case 1
$compare = _SysTrayIconTitles($iWin)
Case 2
$compare = _SysTrayIconPids($iWin)
EndSwitch
If Not IsArray($compare) Then Return -1
For $i = 0 To UBound($compare) - 1
If $compare[$i] = $test Then
$ret = $i
ExitLoop
EndIf
Next
Return $ret
EndFunc
Func _SysTrayGetButtonInfo($iIndex, $iWin = 1, $iInfo = 1)
Local Const $TB_GETBUTTON = 1047
Local Const $TB_GETITEMRECT = 1053
Local Const $ACCESS = BitOR(0x0008, 0x0010, 0x0400)
Local $TBBUTTON
If @OSArch = "X86" Then
$TBBUTTON = DllStructCreate("int iBitmap;int idCommand;byte fsState;byte fsStyle;byte bReserved[2];dword dwData;int iString")
Else
$TBBUTTON = DllStructCreate("int iBitmap;int idCommand;byte fsState;byte fsStyle;byte bReserved[6];uint64 dwData;int64 iString")
EndIf
Local $TRAYDATA
If @OSArch = "X86" Then
$TRAYDATA = DllStructCreate("hwnd hwnd;uint uID;uint uCallbackMessage;dword Reserved[2];handle hIcon")
Else
$TRAYDATA = DllStructCreate("uint64 hwnd;uint uID;uint uCallbackMessage;dword Reserved[2];uint64 hIcon")
EndIf
Local $trayHwnd = _FindTrayToolbarWindow($iWin)
If $trayHwnd = -1 Then Return SetError(1, 0, -1)
Local $return, $err = 0
Local $ret = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $trayHwnd, "dword*", 0)
If @error Or Not $ret[2] Then SetError(2, 0, -1)
Local $pid = $ret[2]
Local $procHandle = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $ACCESS, "bool", False, "dword", $pid)
If @error Or Not $procHandle[0] Then Return SetError(3, 0, -1)
Local $lpData = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $procHandle[0], "ptr", 0, "ulong", DllStructGetSize($TBBUTTON), "dword", 0x1000, "dword", 0x04)
If Not @error And $lpData[0] Then
$ret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $trayHwnd, "uint", $TB_GETBUTTON, "wparam", $iIndex, "lparam", $lpData[0])
If Not @error And $ret[0] Then
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", $lpData[0], "struct*", $TBBUTTON, "ulong", DllStructGetSize($TBBUTTON), "ulong*", 0)
Switch $iInfo
Case 2
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", DllStructGetData($TBBUTTON, 6), "struct*", $TRAYDATA, "ulong", DllStructGetSize($TRAYDATA), "ulong*", 0)
$return = $TRAYDATA
Case 3
$return = ""
If BitShift(DllStructGetData($TBBUTTON, 7), 16) <> 0 Then
Local $intTip = DllStructCreate("wchar[1024]")
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", DllStructGetData($TBBUTTON, 7), "struct*", $intTip, "ulong", DllStructGetSize($intTip), "ulong*", 0)
$return = DllStructGetData($intTip, 1)
$intTip = 0
EndIf
Case 4
If Not BitAND(DllStructGetData($TBBUTTON, 3), 8) Then
Local $pos[2], $RECT = DllStructCreate("int;int;int;int")
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $trayHwnd, "uint", $TB_GETITEMRECT, "wparam", $iIndex, "lparam", $lpData[0])
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", $lpData[0], "struct*", $RECT, "ulong", DllStructGetSize($RECT), "ulong*", 0)
$ret = DllCall("user32.dll", "int", "MapWindowPoints", "hwnd", $trayHwnd, "ptr", 0, "struct*", $RECT, "uint", 2)
$pos[0] = DllStructGetData($RECT, 1)
$pos[1] = DllStructGetData($RECT, 2)
$return = $pos
$RECT = 0
Else
$return = -1
EndIf
Case Else
$return = $TBBUTTON
EndSwitch
Else
$err = 5
EndIf
DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $procHandle[0], "ptr", $lpData[0], "ulong", 0, "dword", 0x8000)
Else
$err = 4
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $procHandle[0])
If $err Then
Return SetError($err, 0, -1)
Else
Return $return
EndIf
EndFunc
Func _SysTrayIconHandle($iIndex, $iWin = 1)
Local $TRAYDATA = _SysTrayGetButtonInfo($iIndex, $iWin, 2)
If @error Then
Return SetError(@error, 0, -1)
Else
Return Ptr(DllStructGetData($TRAYDATA, 1))
EndIf
EndFunc
Func _SysTrayIconTooltip($iIndex, $iWin = 1)
Local $ret = _SysTrayGetButtonInfo($iIndex, $iWin, 3)
If @error Then
Return SetError(@error, 0, -1)
Else
Return $ret
EndIf
EndFunc
Func _SysTrayIconPos($iIndex, $iWin = 1)
Local $ret = _SysTrayGetButtonInfo($iIndex, $iWin, 4)
If @error Then
Return SetError(@error, 0, -1)
Else
If $ret = -1 Then
Return SetError(-1, 0, -1)
Else
Return $ret
EndIf
EndIf
EndFunc
Func _SysTrayIconVisible($iIndex, $iWin = 1)
Local $TBBUTTON = _SysTrayGetButtonInfo($iIndex, $iWin, 1)
If @error Then
Return SetError(@error, 0, -1)
Else
Return Not BitAND(DllStructGetData($TBBUTTON, 3), 8)
EndIf
EndFunc
Func _SysTrayIconHide($index, $iFlag, $iWin = 1)
Local $TBBUTTON = _SysTrayGetButtonInfo($index, $iWin, 1)
If @error Then Return SetError(@error, 0, -1)
Local $visible = Not BitAND(DllStructGetData($TBBUTTON, 3), 8)
If($iFlag And Not $visible) Or(Not $iFlag And $visible) Then
Return 0
Else
Local $TRAYDATA = _SysTrayGetButtonInfo($index, $iWin, 2)
If @error Then Return SetError(@error, 0, -1)
Local $NOTIFYICONDATA = DllStructCreate("dword cbSize;hwnd hWnd;uint uID;uint uFlags;uint uCallbackMessage;handle hIcon;wchar szTip[128];" & "dword dwState;dword dwStateMask;wchar szInfo[256];uint uVersion;wchar szInfoTitle[64];dword dwInfoFlags;" & "STRUCT;ulong;ushort;ushort;byte[8];ENDSTRUCT;handle hBalloonIcon")
DllStructSetData($NOTIFYICONDATA, 1, DllStructGetSize($NOTIFYICONDATA))
DllStructSetData($NOTIFYICONDATA, 2, Ptr(DllStructGetData($TRAYDATA, 1)))
DllStructSetData($NOTIFYICONDATA, 3, DllStructGetData($TRAYDATA, 2))
DllStructSetData($NOTIFYICONDATA, 4, 8)
DllStructSetData($NOTIFYICONDATA, 8, $iFlag)
DllStructSetData($NOTIFYICONDATA, 9, 1)
Local $ret = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", 0x1, "struct*", $NOTIFYICONDATA)
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", WinGetHandle("[CLASS:Shell_TrayWnd]"), "uint", 0x001A, "wparam", 0, "lparam", 0)
$NOTIFYICONDATA = 0
If IsArray($ret) And $ret[0] Then
Return 1
Else
Return 0
EndIf
EndIf
EndFunc
Func _SysTrayIconMove($curPos, $newPos, $iWin = 1)
Local Const $TB_MOVEBUTTON = 0x0452
Local $iconCount = _SysTrayIconCount($iWin)
If $curPos < 0 Or $newPos < 0 Or $curPos > $iconCount - 1 Or $newPos > $iconCount - 1 Or Not IsInt($curPos) Or Not IsInt($newPos) Then Return SetError(1, 0, -1)
Local $hWnd = _FindTrayToolbarWindow($iWin)
If $hWnd = -1 Then Return SetError(2, 0, -1)
Local $ret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $TB_MOVEBUTTON, "wparam", $curPos, "lparam", $newPos)
If @error Or Not $ret[0] Then
Return 0
Else
Return 1
EndIf
EndFunc
Func _SysTrayIconRemove($index, $iWin = 1)
Local $TRAYDATA = _SysTrayGetButtonInfo($index, $iWin, 2)
If @error Then Return SetError(@error, 0, -1)
Local $NOTIFYICONDATA = DllStructCreate("dword cbSize;hwnd hWnd;uint uID;uint uFlags;uint uCallbackMessage;handle hIcon;wchar szTip[128];" & "dword dwState;dword dwStateMask;wchar szInfo[256];uint uVersion;wchar szInfoTitle[64];dword dwInfoFlags;" & "STRUCT;ulong;ushort;ushort;byte[8];ENDSTRUCT;handle hBalloonIcon")
DllStructSetData($NOTIFYICONDATA, 1, DllStructGetSize($NOTIFYICONDATA))
DllStructSetData($NOTIFYICONDATA, 2, Ptr(DllStructGetData($TRAYDATA, 1)))
DllStructSetData($NOTIFYICONDATA, 3, DllStructGetData($TRAYDATA, 2))
Local $ret = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", 0x2, "struct*", $NOTIFYICONDATA)
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", WinGetHandle("[CLASS:Shell_TrayWnd]"), "uint", 0x001A, "wparam", 0, "lparam", 0)
$NOTIFYICONDATA = 0
If IsArray($ret) And $ret[0] Then
Return 1
Else
Return 0
EndIf
EndFunc
Func _FindTrayToolbarWindow($iWin = 1)
Local $hWnd, $ret = -1
If $iWin = 1 Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindow", "str", "Shell_TrayWnd", "ptr", 0)
If @error Then Return -1
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "TrayNotifyWnd", "ptr", 0)
If @error Then Return -1
If @OSVersion <> "WIN_2000" Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "SysPager", "ptr", 0)
If @error Then Return -1
EndIf
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "ToolbarWindow32", "ptr", 0)
If @error Then Return -1
$ret = $hWnd[0]
ElseIf $iWin = 2 Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindow", "str", "NotifyIconOverflowWindow", "ptr", 0)
If @error Then Return -1
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "ToolbarWindow32", "ptr", 0)
If @error Then Return -1
$ret = $hWnd[0]
EndIf
Return $ret
EndFunc
Func waitMainScreen()
If Not $g_bRunState Then Return
Local $iCount
SetLog("Waiting for Main Screen")
$iCount = 0
For $i = 0 To 105
If Not $g_bRunState Then Return
If $g_bDebugSetlog Then SetDebugLog("waitMainScreen ChkObstl Loop = " & $i & ", ExitLoop = " & $iCount, $COLOR_DEBUG)
$iCount += 1
Local $hWin = $g_hAndroidWindow
If TestCapture() = False Then
If WinGetAndroidHandle() = 0 Then
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
Return
EndIf
getBSPos()
EndIf
_CaptureRegion()
If _CheckPixel($aIsMain, $g_bNoCapturePixel) Then
If $g_bDebugSetlog Then SetDebugLog("Screen cleared, WaitMainScreen exit", $COLOR_DEBUG)
Return
Else
If Not TestCapture() And _Sleep($DELAYWAITMAINSCREEN1) Then Return
If checkObstacles() Then $i = 0
EndIf
If Mod($i, 5) = 0 Then
If $g_bDebugImageSave Then DebugImageSave("WaitMainScreen_", False)
EndIf
If($i > 105) Or($iCount > 120) Then ExitLoop
If TestCapture() Then
Return "Main screen not available"
EndIf
Next
CloseCoC(True)
If _CheckPixel($aIsMain, True) Then Return
$iCount = 0
While 1
If Not $g_bRunState Then Return
SetLog("Unable to load CoC, attempt to fix it...", $COLOR_ERROR)
If $g_bDebugSetlog Then SetDebugLog("Restart Loop = " & $iCount, $COLOR_DEBUG)
CloseAndroid("waitMainScreen")
If _Sleep(1000) Then Return
OpenAndroid(True)
If @extended Then
SetError(1, 1, -1)
Return
EndIf
If _CheckPixel($aIsMain, $g_bCapturePixel) = True Then ExitLoop
CheckObstacles()
$iCount += 1
If $iCount > 2 Then
SetLog("Stuck trying to Restart " & $g_sAndroidEmulator & "...", $COLOR_ERROR)
SetError(1, 0, 0)
Return
EndIf
If _CheckPixel($aIsMain, $g_bCapturePixel) = True Then ExitLoop
WEnd
EndFunc
Func waitMainScreenMini()
If Not $g_bRunState Then Return
Local $iCount = 0
Local $hTimer = __TimerInit()
SetDebugLog("waitMainScreenMini")
If TestCapture() = False Then getBSPos()
SetLog("Waiting for Main Screen after " & $g_sAndroidEmulator & " restart", $COLOR_INFO)
If $g_bChkAutoDock Then
If Not $g_bAndroidEmbedded Then
SetLog("Auto use Dock Android Window", $COLOR_INFO)
btnEmbed()
EndIf
ElseIf $g_bChkAutoHideEmulator Then
If Not $g_bIsHidden Then
SetLog("Auto hidden the Emulator", $COLOR_INFO)
btnHide()
$g_bIsHidden = True
EndIf
EndIf
For $i = 0 To 60
If Not $g_bRunState Then Return
If Not TestCapture() And WinGetAndroidHandle() = 0 Then ExitLoop
If $g_bDebugSetlog Then SetDebugLog("waitMainScreenMini ChkObstl Loop = " & $i & " ExitLoop = " & $iCount, $COLOR_DEBUG)
$iCount += 1
_CaptureRegion()
If Not _CheckPixel($aIsMain, $g_bNoCapturePixel) Then
If Not TestCapture() And _Sleep(1000) Then Return
If CheckObstacles() Then $i = 0
Else
SetLog("CoC main window took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_SUCCESS)
Return
EndIf
_StatusUpdateTime($hTimer, "Main Screen")
If($i > 60) Or($iCount > 80) Then ExitLoop
If TestCapture() Then
Return "Main screen not available"
EndIf
Next
Return SetError(1, 0, -1)
EndFunc
Func isOnBuilderBase($bNeedCaptureRegion = False)
_Sleep($DELAYISBUILDERBASE)
Local $aSearchResult = decodeSingleCoord(findImage("isOnBuilderBase", $g_sImgIsOnBB, GetDiamondFromRect("260,0,406,54"), 1, $bNeedCaptureRegion))
If IsArray($aSearchResult) And UBound($aSearchResult) = 2 Then
SetDebugLog("Builder Base Builder detected", $COLOR_DEBUG)
Return True
Else
Return False
EndIf
EndFunc
Func AndroidBackButton($bCheckRunState = True)
If(IsDeclared("bCheckRunState") <> 0 And $bCheckRunState) And Not $g_bRunState Then Return False
AndroidAdbSendShellCommand("input keyevent 4")
If $g_bDebugAndroid Then SetDebugLog("Used Adb to press back button", $COLOR_INFO)
Return True
EndFunc
Func AndroidHomeButton($bCheckRunState = True)
If(IsDeclared("bCheckRunState") <> 0 And $bCheckRunState) And Not $g_bRunState Then Return False
AndroidAdbSendShellCommand("input keyevent 3")
If $g_bDebugAndroid Then SetDebugLog("Used Adb to press home button", $COLOR_INFO)
Return True
EndFunc
Func CloseCoC($ReOpenCoC = False, $bCheckRunState = True)
FuncEnter(CloseCoC)
$g_bSkipFirstZoomout = False
ResumeAndroid()
If $bCheckRunState And Not $g_bRunState Then Return FuncReturn()
If $ReOpenCoC Then
SetLog("Please wait for CoC restart......", $COLOR_ERROR)
Else
SetLog("Closing CoC......", $COLOR_ERROR)
EndIf
WinGetAndroidHandle()
If $bCheckRunState And Not $g_bRunState Then Return FuncReturn()
AndroidAdbSendShellCommand("am force-stop " & $g_sAndroidGamePackage, Default, Default, False)
ResetAndroidProcess()
_Sleep($DELAYCLOSEOPEN3000)
If $bCheckRunState And Not $g_bRunState Then Return FuncReturn()
If $ReOpenCoC Then
OpenCoC()
$g_bRestart = True
EndIf
FuncReturn()
EndFunc
Func OpenCoC()
FuncEnter(OpenCoC)
ResumeAndroid()
If Not $g_bRunState Then Return FuncReturn()
Local $RunApp = "", $iCount = 0
WinGetAndroidHandle()
If _Sleep($DELAYCLOSEOPEN500) Then Return FuncReturn()
If Not $g_bRunState Then Return FuncReturn()
If Not StartAndroidCoC() Then Return FuncReturn()
While _CheckPixel($aIsMain, True) = False
$iCount += 1
If _Sleep($DELAYCLOSEOPEN500) Then Return FuncReturn()
If checkObstacles() Then $iCount += 1
If $iCount > 50 Then ExitLoop
If Not $g_bRunState Then ExitLoop
WEnd
FuncReturn()
EndFunc
Func WaitnOpenCoC($iWaitTime, $bFullRestart = False, $bSuspendComputer = False, $bLockBotSlot = False)
FuncEnter(WaitnOpenCoC)
Return FuncReturn(_WaitnOpenCoC($iWaitTime, $bFullRestart, $bSuspendComputer, $bLockBotSlot))
EndFunc
Func _WaitnOpenCoC($iWaitTime, $bFullRestart = False, $bSuspendComputer = False, $bLockBotSlot = False)
ResumeAndroid()
If Not $g_bRunState Then Return
Local $sWaitTime = ""
Local $iMin, $iSec, $iHour, $iWaitSec
WinGetAndroidHandle()
$iWaitSec = Round($iWaitTime / 1000)
$iHour = Floor(Floor($iWaitSec / 60) / 60)
$iMin = Floor(Mod(Floor($iWaitSec / 60), 60))
$iSec = Floor(Mod($iWaitSec, 60))
If $iHour > 0 Then $sWaitTime &= $iHour & " hours "
If $iMin > 0 Then $sWaitTime &= $iMin & " minutes "
If $iSec > 0 Then $sWaitTime &= $iSec & " seconds "
SetLog("Waiting " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
ReduceBotMemory()
Local $hTimer = __TimerInit()
If $bSuspendComputer Then SuspendComputer($iWaitTime)
If _SleepStatus($iWaitTime, True, True, True, $hTimer) Then Return False
If $bLockBotSlot = True Then
LockBotSlot(True)
EndIf
If Not $g_bRunState Then Return
If Not StartAndroidCoC() Then Return
If Not $g_bRunState Then Return
If $g_bDebugSetlog Then SetDebugLog("CoC Restarted, Waiting for completion", $COLOR_DEBUG)
If $bFullRestart Then
checkMainScreen()
$g_bRestart = True
Else
waitMainScreen()
EndIf
EndFunc
Func PoliteCloseCoC($sSource = "Unknown_", $bPoliteCloseCoC = $g_bPoliteCloseCoC)
$g_bSkipFirstZoomout = False
If $bPoliteCloseCoC Then
If $g_sAndroidGameDistributor = $g_sGoogle Then
Local $i = 0
While 1
checkObstacles()
AndroidBackButton()
If _Sleep($DELAYCLOSEOPEN1000) Then Return
If ClickOkay("ExitOkay_" & $sSource, True) = True Then ExitLoop
If $i > 10 Then
SetLog("Can not find Okay button to exit CoC, Forcefully Closing CoC", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndIf
$i += 1
If Not $g_bRunState Then ExitLoop
WEnd
Else
Local $btnExit
Local $i = 0
While 1
checkObstacles()
AndroidBackButton()
If _Sleep($DELAYCLOSEOPEN1000) Then Return
Switch $g_sAndroidGameDistributor
Case "Kunlun", "Huawei", "Kaopu", "Microvirt", "Yeshen", "Qihoo", "Baidu", "OPPO", "Anzhi", "Lenovo", "Aiyouxi"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
ExitLoop
EndIf
Case "9game"
If _Sleep($DELAYCLOSEOPEN2000) Then Return
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0] + 71, $btnExit[1] + 64)
If $g_bDebugSetlog Then SetDebugLog($g_sAndroidGameDistributor & " Click offset X|Y = 71|64", $COLOR_DEBUG)
ExitLoop
EndIf
Case "VIVO", "Xiaomi"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1], 2, $DELAYCLOSEOPEN3000)
ExitLoop
EndIf
Case "Guopan"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
EndIf
If _Sleep($DELAYCLOSEOPEN2000) Then Return
$btnExit = FindExitButton("Kunlun")
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
ExitLoop
EndIf
Case "Wandoujia/Downjoy", "Haimawan", "Leshi", "Tencent"
ContinueCase
Case Else
SetLog("Polite Close Unsupported - " & $g_sAndroidGameDistributor & ", Forcefully Closing CoC", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndSwitch
If $i > 10 Then
SetLog("Can not find exit button: " & $g_sAndroidGameDistributor & ", Forcefully Closing CoC", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndIf
$i += 1
If Not $g_bRunState Then ExitLoop
WEnd
EndIf
Else
CloseCoC()
EndIf
ResetAndroidProcess()
ReduceBotMemory()
EndFunc
Global $g_aiSearchZoomOutCounter[2] = [0, 1]
Func ZoomOut()
$g_aiSearchZoomOutCounter[0] = 0
$g_aiSearchZoomOutCounter[1] = 1
ResumeAndroid()
WinGetAndroidHandle()
getBSPos()
If Not $g_bRunState Then
SetDebugLog("Exit ZoomOut, bot not running")
Return
EndIf
Local $Result
If($g_iAndroidZoomoutMode = 0 Or $g_iAndroidZoomoutMode = 3) And($g_bAndroidEmbedded = False Or $g_iAndroidEmbedMode = 1) Then
$Result = Execute("ZoomOut" & $g_sAndroidEmulator & "()")
If $Result = "" And @error <> 0 Then
$Result = AndroidOnlyZoomOut()
EndIf
$g_bSkipFirstZoomout = True
Return $Result
EndIf
$Result = AndroidOnlyZoomOut()
$g_bSkipFirstZoomout = True
Return $Result
EndFunc
Func ZoomOutBlueStacks()
Return ZoomOutCtrlClick(False, False, False, 250)
EndFunc
Func ZoomOutBlueStacks2()
If $__BlueStacks2Version_2_5_or_later = False Then
Return ZoomOutCtrlClick(False, False, False, 250)
Else
Return DefaultZoomOut("{DOWN}", 0,($g_iAndroidZoomoutMode <> 3))
EndIf
EndFunc
Func ZoomOutMEmu()
Return DefaultZoomOut("{F3}", 0,($g_iAndroidZoomoutMode <> 3))
EndFunc
Func ZoomOutDroid4X()
Return ZoomOutCtrlWheelScroll(True, True, True,($g_iAndroidZoomoutMode <> 3), Default, -5, 250)
EndFunc
Func ZoomOutNox()
Return ZoomOutCtrlWheelScroll(True, True, True,($g_iAndroidZoomoutMode <> 3), Default, -5, 250)
EndFunc
Func DefaultZoomOut($ZoomOutKey = "{DOWN}", $tryCtrlWheelScrollAfterCycles = 40, $bAndroidZoomOut = True)
Local $sFunc = "DefaultZoomOut"
Local $result0, $result1, $i = 0
Local $exitCount = 80
Local $delayCount = 20
ForceCaptureRegion()
Local $aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
If StringInStr($aPicture[0], "zoomou") = 0 Then
If $g_bDebugSetlog Then
SetDebugLog("Zooming Out (" & $sFunc & ")", $COLOR_INFO)
Else
SetLog("Zooming Out", $COLOR_INFO)
EndIf
If _Sleep($DELAYZOOMOUT1) Then Return True
If $bAndroidZoomOut Then
AndroidZoomOut(0, Default,($g_iAndroidZoomoutMode <> 2))
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
EndIf
Local $tryCtrlWheelScroll = False
While StringInStr($aPicture[0], "zoomou") = 0 and Not $tryCtrlWheelScroll
AndroidShield("DefaultZoomOut")
If $bAndroidZoomOut Then
AndroidZoomOut($i, Default,($g_iAndroidZoomoutMode <> 2))
If @error <> 0 Then $bAndroidZoomOut = False
EndIf
If Not $bAndroidZoomOut Then
If $g_bDebugSetlog Then SetDebugLog("Index = "&$i, $COLOR_DEBUG)
If _Sleep($DELAYZOOMOUT2) Then Return True
If $g_bChkBackgroundMode = False And $g_bNoFocusTampering = False Then
$Result0 = ControlFocus($g_hAndroidWindow, "", "")
Else
$Result0 = 1
EndIf
$Result1 = ControlSend($g_hAndroidWindow, "", "", $ZoomOutKey)
If $g_bDebugSetlog Then SetDebugLog("ControlFocus Result = "&$Result0 & ", ControlSend Result = "&$Result1& "|" & "@error= " & @error, $COLOR_DEBUG)
If $Result1 = 1 Then
$i += 1
Else
SetLog("Warning ControlSend $Result = "&$Result1, $COLOR_DEBUG)
EndIf
EndIF
If $i > $delayCount Then
If _Sleep($DELAYZOOMOUT3) Then Return True
EndIf
If $tryCtrlWheelScrollAfterCycles > 0 And $i > $tryCtrlWheelScrollAfterCycles Then $tryCtrlWheelScroll = True
If $i > $exitCount Then Return
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
SetLog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then SetLog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
WEnd
If $tryCtrlWheelScroll Then
SetLog($g_sAndroidEmulator & " zoom-out with key " & $ZoomOutKey & " didn't work, try now Ctrl+MouseWheel...", $COLOR_INFO)
Return ZoomOutCtrlWheelScroll(False, False, False, False)
EndIf
Return True
EndIf
Return False
EndFunc
Func ZoomOutCtrlWheelScroll($CenterMouseWhileZooming = True, $GlobalMouseWheel = True, $AlwaysControlFocus = False, $AndroidZoomOut = True, $hWin = Default, $ScrollSteps = -5, $ClickDelay = 250)
Local $sFunc = "ZoomOutCtrlWheelScroll"
Local $exitCount = 80
Local $delayCount = 20
Local $result[4], $i = 0, $j
Local $ZoomActions[4] = ["ControlFocus", "Ctrl Down", "Mouse Wheel Scroll Down", "Ctrl Up"]
If $hWin = Default Then $hWin =($g_bAndroidEmbedded = False ? $g_hAndroidWindow : $g_aiAndroidEmbeddedCtrlTarget[1])
ForceCaptureRegion()
Local $aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
If StringInStr($aPicture[0], "zoomou") = 0 Then
If $g_bDebugSetlog Then
SetDebugLog("Zooming Out (" & $sFunc & ")", $COLOR_INFO)
Else
SetLog("Zooming Out", $COLOR_INFO)
EndIf
AndroidShield("ZoomOutCtrlWheelScroll")
If _Sleep($DELAYZOOMOUT1) Then Return True
If $AndroidZoomOut Then
AndroidZoomOut(0, Default,($g_iAndroidZoomoutMode <> 2))
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
EndIf
Local $aMousePos = MouseGetPos()
While StringInStr($aPicture[0], "zoomou") = 0
If $AndroidZoomOut Then
AndroidZoomOut($i, Default,($g_iAndroidZoomoutMode <> 2))
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If Not $AndroidZoomOut Then
If $g_bDebugSetlog Then SetDebugLog("Index = " & $i, $COLOR_DEBUG)
If _Sleep($DELAYZOOMOUT2) Then ExitLoop
If($g_bChkBackgroundMode = False And $g_bNoFocusTampering = False) Or $AlwaysControlFocus Then
$Result[0] = ControlFocus($hWin, "", "")
Else
$Result[0] = 1
EndIf
$Result[1] = ControlSend($hWin, "", "", "{CTRLDOWN}")
If $CenterMouseWhileZooming Then MouseMove($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2), $g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2), 0)
If $GlobalMouseWheel Then
$Result[2] = MouseWheel(($ScrollSteps < 0 ? "down" : "up"), Abs($ScrollSteps))
Else
Local $WM_WHEELMOUSE = 0x020A, $MK_CONTROL = 0x0008
Local $wParam = BitOR($ScrollSteps * 0x10000, BitAND($MK_CONTROL, 0xFFFF))
Local $lParam = BitOR(($g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2)) * 0x10000, BitAND(($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2)), 0xFFFF))
_WinAPI_PostMessage($hWin, $WM_WHEELMOUSE, $wParam, $lParam)
$Result[2] =(@error = 0 ? 1 : 0)
EndIf
If _Sleep($ClickDelay) Then ExitLoop
$Result[3] = ControlSend($hWin, "", "", "{CTRLUP}{SPACE}")
If $g_bDebugSetlog Then SetDebugLog("ControlFocus Result = " & $Result[0] & ", " & $ZoomActions[1] & " = " & $Result[1] & ", " & $ZoomActions[2] & " = " & $Result[2] & ", " & $ZoomActions[3] & " = " & $Result[3] & " | " & "@error= " & @error, $COLOR_DEBUG)
For $j = 1 To 3
If $Result[$j] = 1 Then
$i += 1
ExitLoop
EndIf
Next
For $j = 1 To 3
If $Result[$j] = 0 Then
SetLog("Warning " & $ZoomActions[$j] & " = " & $Result[1], $COLOR_DEBUG)
EndIf
Next
EndIf
If $i > $delayCount Then
If _Sleep($DELAYZOOMOUT3) Then ExitLoop
EndIf
If $i > $exitCount Then ExitLoop
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
SetLog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then SetLog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
WEnd
If $CenterMouseWhileZooming And $AndroidZoomOut = False Then MouseMove($aMousePos[0], $aMousePos[1], 0)
Return True
EndIf
Return False
EndFunc
Func ZoomOutCtrlClick($CenterMouseWhileZooming = False, $AlwaysControlFocus = False, $AndroidZoomOut = True, $ClickDelay = 250)
Local $sFunc = "ZoomOutCtrlClick"
Local $exitCount = 80
Local $delayCount = 20
Local $result[4], $i, $j
Local $SendCtrlUp = False
Local $ZoomActions[4] = ["ControlFocus", "Ctrl Down", "Click", "Ctrl Up"]
ForceCaptureRegion()
Local $aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
If StringInStr($aPicture[0], "zoomou") = 0 Then
If $g_bDebugSetlog Then
SetDebugLog("Zooming Out (" & $sFunc & ")", $COLOR_INFO)
Else
SetLog("Zooming Out", $COLOR_INFO)
EndIf
AndroidShield("ZoomOutCtrlClick")
If _Sleep($DELAYZOOMOUT1) Then Return True
Local $aMousePos = MouseGetPos()
$i = 0
While StringInStr($aPicture[0], "zoomou") = 0
If $AndroidZoomOut Then
AndroidZoomOut($i, Default,($g_iAndroidZoomoutMode <> 2))
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If Not $AndroidZoomOut Then
If $g_bDebugSetlog Then SetDebugLog("Index = " & $i, $COLOR_DEBUG)
If _Sleep($DELAYZOOMOUT2) Then ExitLoop
If($g_bChkBackgroundMode = False And $g_bNoFocusTampering = False) Or $AlwaysControlFocus Then
$Result[0] = ControlFocus($g_hAndroidWindow, "", "")
Else
$Result[0] = 1
EndIf
$Result[1] = ControlSend($g_hAndroidWindow, "", "", "{CTRLDOWN}")
$SendCtrlUp = True
If $CenterMouseWhileZooming Then MouseMove($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2), $g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2), 0)
$Result[2] = _ControlClick(Int($g_iDEFAULT_WIDTH / 2), 600)
If _Sleep($ClickDelay) Then ExitLoop
$Result[3] = ControlSend($g_hAndroidWindow, "", "", "{CTRLUP}{SPACE}")
$SendCtrlUp = False
If $g_bDebugSetlog Then SetDebugLog("ControlFocus Result = " & $Result[0] & ", " & $ZoomActions[1] & " = " & $Result[1] & ", " & $ZoomActions[2] & " = " & $Result[2] & ", " & $ZoomActions[3] & " = " & $Result[3] & " | " & "@error= " & @error, $COLOR_DEBUG)
For $j = 1 To 3
If $Result[$j] = 1 Then
ExitLoop
EndIf
Next
For $j = 1 To 3
If $Result[$j] = 0 Then
SetLog("Warning " & $ZoomActions[$j] & " = " & $Result[1], $COLOR_DEBUG)
EndIf
Next
EndIf
If $i > $delayCount Then
If _Sleep($DELAYZOOMOUT3) Then ExitLoop
EndIf
If $i > $exitCount Then ExitLoop
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
SetLog($g_sAndroidEmulator & " Error window detected", $COLOR_RED)
If checkObstacles() = True Then SetLog("Error window cleared, continue Zoom out", $COLOR_BLUE)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
WEnd
If $SendCtrlUp Then ControlSend($g_hAndroidWindow, "", "", "{CTRLUP}{SPACE}")
If $CenterMouseWhileZooming Then MouseMove($aMousePos[0], $aMousePos[1], 0)
Return True
EndIf
Return False
EndFunc
Func AndroidOnlyZoomOut()
Local $sFunc = "AndroidOnlyZoomOut"
Local $i = 0
Local $exitCount = 80
ForceCaptureRegion()
Local $aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
If StringInStr($aPicture[0], "zoomout") = 0 Then
If $g_bDebugSetlog Then
SetDebugLog("Zooming Out (" & $sFunc & ")", $COLOR_INFO)
Else
SetLog("Zooming Out", $COLOR_INFO)
EndIf
AndroidZoomOut(0, Default,($g_iAndroidZoomoutMode <> 2))
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
While StringInStr($aPicture[0], "zoomout") = 0
AndroidShield("AndroidOnlyZoomOut")
AndroidZoomOut($i, Default,($g_iAndroidZoomoutMode <> 2))
If $i > $exitCount Then Return
If Not $g_bRunState Then ExitLoop
If IsProblemAffect(True) Then
SetLog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() Then SetLog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut($aCenterHomeVillageClickDrag, True, "", True, False)
WEnd
Return True
EndIf
Return False
EndFunc
Func SearchZoomOut($CenterVillageBoolOrScrollPos = $aCenterHomeVillageClickDrag, $UpdateMyVillage = True, $sSource = "", $CaptureRegion = True, $DebugLog = $g_bDebugSetlog)
If $sSource <> "" Then $sSource = " (" & $sSource & ")"
Local $bCenterVillage = $CenterVillageBoolOrScrollPos
If $bCenterVillage = Default Or $g_bDebugDisableVillageCentering Then $bCenterVillage =(Not $g_bDebugDisableVillageCentering)
Local $aScrollPos[2] = [0, 0]
If UBound($CenterVillageBoolOrScrollPos) >= 2 Then
$aScrollPos[0] = $CenterVillageBoolOrScrollPos[0]
$aScrollPos[1] = $CenterVillageBoolOrScrollPos[1]
$bCenterVillage =(Not $g_bDebugDisableVillageCentering)
EndIf
Local $x, $y, $z, $stone[2]
Local $villageSize = 0
If $CaptureRegion Then _CaptureRegion2()
Local $aResult = ["", 0, 0, 0, 0]
Local $village
If $g_aiSearchZoomOutCounter[0] = 10 Then SetLog("Try secondary village measuring...", $COLOR_INFO)
If $g_aiSearchZoomOutCounter[0] < 10 Then
$village = GetVillageSize($DebugLog, "stone", "tree")
Else
$village = GetVillageSize($DebugLog, "2stone", "2tree")
EndIf
If $g_aiSearchZoomOutCounter[0] > 0 Then
If _Sleep(1000) Then Return $aResult
EndIf
If IsArray($village) = 1 Then
$villageSize = $village[0]
If $villageSize < 500 Or $g_bDebugDisableZoomout Then
$z = $village[1]
$x = $village[2]
$y = $village[3]
$stone[0] = $village[4]
$stone[1] = $village[5]
$aResult[0] = "zoomout:" & $village[6]
$aResult[1] = $x
$aResult[2] = $y
If $bCenterVillage And($x <> 0 Or $y <> 0) And($UpdateMyVillage = False Or $x <> $g_iVILLAGE_OFFSET[0] Or $y <> $g_iVILLAGE_OFFSET[1]) Then
If $DebugLog Then SetDebugLog("Center Village" & $sSource & " by: " & $x & ", " & $y)
If $aScrollPos[0] = 0 And $aScrollPos[1] = 0 Then
$aScrollPos[0] = $aCenterHomeVillageClickDrag[0]
$aScrollPos[1] = $aCenterHomeVillageClickDrag[1]
EndIf
ClickP($aAway, 1, 0, "#0000")
ClickDrag($aScrollPos[0], $aScrollPos[1], $aScrollPos[0] - $x, $aScrollPos[1] - $y)
If _Sleep(250) Then Return $aResult
Local $aResult2 = SearchZoomOut(False, $UpdateMyVillage, "SearchZoomOut:" & $sSource, True, $DebugLog)
$aResult2[3] = $aResult2[1] - $aResult[1]
$aResult2[4] = $aResult2[2] - $aResult[2]
If $DebugLog Then SetDebugLog("Centered Village Offset" & $sSource & ": " & $aResult2[1] & ", " & $aResult2[2] & ", change: " & $aResult2[3] & ", " & $aResult2[4])
Return $aResult2
EndIf
If $UpdateMyVillage Then
If $x <> $g_iVILLAGE_OFFSET[0] Or $y <> $g_iVILLAGE_OFFSET[1] Or $z <> $g_iVILLAGE_OFFSET[2] Then
If $DebugLog Then SetDebugLog("Village Offset" & $sSource & " updated to " & $x & ", " & $y & ", " & $z)
EndIf
setVillageOffset($x, $y, $z)
ConvertInternalExternArea()
EndIf
EndIf
EndIf
If $UpdateMyVillage Then
If $aResult[0] = "" Then
If $g_aiSearchZoomOutCounter[0] > 20 Then
$g_aiSearchZoomOutCounter[0] = 0
Static $iCallCount = 0
$iCallCount += 1
If $iCallCount <= 2 Then
SetLog("Restart CoC to reset zoom" & $sSource & "...", $COLOR_INFO)
PoliteCloseCoC("Zoomout" & $sSource)
If _Sleep(1000) Then Return $aResult
CloseCoC()
OpenCoC()
Else
SetLog("Restart Android to reset zoom" & $sSource & "...", $COLOR_INFO)
$iCallCount = 0
RebootAndroid()
If _Sleep(1000) Then Return $aResult
EndIf
Return SearchZoomOut($CenterVillageBoolOrScrollPos, $UpdateMyVillage, "SearchZoomOut:" & $sSource, True, $DebugLog)
Else
$g_aiSearchZoomOutCounter[0] += 1
EndIf
Else
If Not $g_bDebugDisableZoomout And $villageSize > 480 Then
If Not $g_bSkipFirstZoomout Then
$aResult[0] = ""
ElseIf $g_aiSearchZoomOutCounter[1] > 0 And $g_aiSearchZoomOutCounter[0] > 0 Then
$g_aiSearchZoomOutCounter[1] -= 1
$aResult[0] = ""
EndIf
EndIf
EndIf
$g_bSkipFirstZoomout = True
EndIf
Return $aResult
EndFunc
Func InitAndroidTimeLag($bResetProblemCounter = True)
$g_aiAndroidTimeLag[0] = 0
$g_aiAndroidTimeLag[1] = 0
$g_aiAndroidTimeLag[2] = 0
$g_aiAndroidTimeLag[3] = 0
If $bResetProblemCounter = True Then
$g_aiAndroidTimeLag[4] = 0
$g_aiAndroidTimeLag[5] = 0
EndIf
EndFunc
Func CheckAndroidTimeLag($bRebootAndroid = True)
SetError(0, 0)
If $g_bAndroidCheckTimeLagEnabled = False Then Return SetError(1, 0, False)
Local $androidUTC = $g_aiAndroidTimeLag[1]
Local $hostTimer = $g_aiAndroidTimeLag[2]
If $hostTimer <> 0 And __TimerDiff($hostTimer) / 1000 < 60 Then
Return SetError(3, 0, False)
EndIf
If $g_aiAndroidTimeLag[4] > 0 And $g_aiAndroidTimeLag[5] <> 0 And __TimerDiff($g_aiAndroidTimeLag[5]) > $g_iAndroidTimeLagResetProblemCountMinutes * 60000 Then
SetDebugLog("Time lag problems count of " & $g_aiAndroidTimeLag[4] & " reset to 0 due to " & Round(__TimerDiff($g_aiAndroidTimeLag[5]) / 1000, 0) & " Seconds with an incident")
$g_aiAndroidTimeLag[4] = 0
$g_aiAndroidTimeLag[5] = 0
EndIf
Local $s = AndroidAdbSendShellCommand("date +%s")
If @error <> 0 Then Return SetError(4, 0, False)
Local $curr_androidUTC = Number($s)
Local $curr_hostTimer = __TimerInit()
If $curr_androidUTC < 1 Then
InitAndroidTimeLag(False)
Return SetError(5, 0, False)
EndIf
If $androidUTC = 0 Or $hostTimer = 0 Then
$g_aiAndroidTimeLag[1] = $curr_androidUTC
$g_aiAndroidTimeLag[2] = $curr_hostTimer
$g_aiAndroidTimeLag[3] = 0
Return SetError(2, 0, False)
EndIf
Local $hostSeconds = Int(__TimerDiff($hostTimer) / 1000)
Local $hostMinutes = $hostSeconds / 60
Local $androidSeconds = $curr_androidUTC - $androidUTC
Local $lagTotal = $hostSeconds - $androidSeconds
Local $lagComp = Int($g_aiAndroidTimeLag[3] / 1000)
$lagTotal -= $lagComp
Local $lagPerMin = Int($lagTotal / $hostMinutes)
SetDebugLog($g_sAndroidEmulator & " time lag is " &($lagPerMin > 0 ? "> " : "") & $lagPerMin & " sec/min (avg for " & $hostSeconds & " sec, Android suspend time was " & $lagComp & " sec)")
If $androidSeconds <= 0 Then
InitAndroidTimeLag(False)
Return SetError(6, 0, False)
EndIf
If $lagPerMin < 0 Then $lagPerMin = 0
$g_aiAndroidTimeLag[0] = $lagPerMin
$g_aiAndroidTimeLag[1] = $curr_androidUTC
$g_aiAndroidTimeLag[2] = $curr_hostTimer
$g_aiAndroidTimeLag[3] = 0
If $lagPerMin > $g_iAndroidTimeLagThreshold Then
$g_aiAndroidTimeLag[4] += 1
$g_aiAndroidTimeLag[5] = __TimerInit()
SetLog($g_aiAndroidTimeLag[4] & ". Time lag detected of " & $lagPerMin & " sec/min for " & $g_sAndroidEmulator, $COLOR_ERROR)
InitAndroidTimeLag(False)
EndIf
Local $bReboot = False
If $bRebootAndroid And $g_aiAndroidTimeLag[4] >= $g_iAndroidTimeLagRebootThreshold Then
SetLog("Rebooting " & $g_sAndroidEmulator & " due to " & $g_aiAndroidTimeLag[4] & " time lag problems", $COLOR_ERROR)
$bReboot = True
EndIf
Return SetError(0, $lagPerMin, $bReboot)
EndFunc
Global $g_aiAndroidPageError[2] = [0, 0]
Func InitAndroidPageError()
$g_aiAndroidPageError[0] = 0
$g_aiAndroidPageError[1] = 0
EndFunc
Func CheckAndroidPageError($bRebootAndroid = True)
If $g_aiAndroidPageError[1] = 0 Then Return False
Local $bResetTimer = __TimerDiff($g_aiAndroidPageError[1]) > $g_iAndroidRebootPageErrorPerMinutes * 60 * 1000
If $g_aiAndroidPageError[0] >= $g_iAndroidRebootPageErrorCount And $bResetTimer = False Then
Local $sMin = Round(__TimerDiff($g_aiAndroidPageError[1]) /(60 * 1000), 1) & " Minutes"
If $bRebootAndroid = True Then
SetLog("Reboot " & $g_sAndroidEmulator & " due to " & $g_aiAndroidPageError[0] & " page errors in " & $sMin, $COLOR_ERROR)
DebugImageSave("page_error", False, Default, Default, "current-hbitmap-")
DebugImageSave("page_error", True, Default, Default, "new-hbitmap-")
Else
SetLog($g_sAndroidEmulator & " had " & $g_aiAndroidPageError[0] & " page errors in " & $sMin, $COLOR_ERROR)
EndIf
InitAndroidPageError()
If $bRebootAndroid = True Then
Return True
EndIf
Return False
EndIf
If $bResetTimer = True Then
If $g_aiAndroidPageError[0] > 0 Then
SetDebugLog("Cleared " & $g_aiAndroidPageError[0] & " " & $g_sAndroidEmulator & " page errors")
EndIf
InitAndroidPageError()
EndIf
Return False
EndFunc
Func AndroidPageError($sSource)
$g_aiAndroidPageError[0] += 1
SetDebugLog("Page error count increased to " & $g_aiAndroidPageError[0] & ", source: " & $sSource)
If $g_aiAndroidPageError[1] = 0 Then $g_aiAndroidPageError[1] = __TimerInit()
Return $g_aiAndroidPageError[0]
EndFunc
Func InitAndroidRebootCondition($bLaunched = True)
If $bLaunched = False Then
$g_hAndroidLaunchTime = 0
Return False
EndIf
$g_hAndroidLaunchTime = __TimerInit()
Return True
EndFunc
Func CheckAndroidRebootCondition($bRebootAndroid = True, $bLogOnly = False)
If $g_hAndroidLaunchTime = 0 Then InitAndroidRebootCondition(True)
If $g_bGfxError Then
$g_bGfxError = False
SetLog("Reboot " & $g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") due to detected Gfx Errors")
Return True
EndIF
If $g_iAndroidRebootHours <= 0 Then Return False
Local $iLaunched = __TimerDiff($g_hAndroidLaunchTime)
If $bLogOnly = True Then
Local $day = 0, $hour = 0, $min = 0, $sec = 0, $sTime
_TicksToDay($g_iAndroidRebootHours * 60 * 60 * 1000 - $iLaunched, $day, $hour, $min, $sec)
$sTime = StringFormat("%id %ih %im", $day, $hour, $min)
SetLog($g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") will be automatically rebooted in " & $sTime)
Return True
EndIf
If $g_bIdleState = False Then Return False
Local $iRunTimeHrs = $iLaunched /(60 * 60 * 1000)
If $iRunTimeHrs >= $g_iAndroidRebootHours Then
SetLog("Reboot " & $g_sAndroidEmulator & " (" & $g_sAndroidInstance & ") due to configured run-time of " & $g_iAndroidRebootHours & "h")
Return True
EndIf
Return False
EndFunc
Func OpenBS($bRestart = False)
Return OpenAndroid($bRestart)
EndFunc
Func OpenBlueStacksX($bRestart = False)
SetLog("Starting BlueStacks and Clash Of Clans", $COLOR_SUCCESS)
If Not InitAndroid() Then Return False
If $g_sAndroidEmulator = "BlueStacks" Then
Return _OpenBlueStacks($bRestart)
EndIf
Return _OpenBlueStacks2($bRestart)
EndFunc
Func OpenBlueStacks($bRestart = False)
Return OpenBlueStacksX($bRestart)
EndFunc
Func OpenBlueStacks2($bRestart = False)
Return OpenBlueStacksX($bRestart)
EndFunc
Func _OpenBlueStacks($bRestart = False)
Local $hTimer, $iCount = 0, $cmdPar
Local $PID, $ErrorResult, $connected_to, $process_killed
LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "start-server", $process_killed)
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
$ErrorResult = ControlGetHandle("BlueStacks Error", "", "")
If $g_bDebugAndroid Then SetDebugLog("$PID= " & $PID & ", $ErrorResult = " & $ErrorResult, $COLOR_DEBUG)
If $PID = 0 Or $ErrorResult <> 0 Then
SetError(1, 1, -1)
Return False
EndIf
WinGetAndroidHandle()
$hTimer = __TimerInit()
While $g_hAndroidControl = 0
If _Sleep(3000) Then ExitLoop
_StatusUpdateTime($hTimer, $g_sAndroidEmulator & " Starting")
If __TimerDiff($hTimer) > $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog("BlueStacks refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnstop()
SetError(1, 1, -1)
Return False
EndIf
WinGetAndroidHandle()
WEnd
If $g_hAndroidControl Then
$connected_to = ConnectAndroidAdb(False, 3000)
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return
If Not $g_bRunState Then Return False
SetLog("BlueStacks Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func _OpenBlueStacks2($bRestart = False)
Local $hTimer, $iCount = 0, $cmdOutput, $process_killed, $i, $connected_to, $PID, $cmdPar
CloseUnsupportedBlueStacks2()
LaunchConsole($g_sAndroidAdbPath, AddSpace($g_sAndroidAdbGlobalOptions) & "start-server", $process_killed)
$hTimer = __TimerInit()
WinGetAndroidHandle()
Local $bStopIfLaunchFails = False
While $g_hAndroidControl = 0
If Not $g_bRunState Then Return False
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath, Default, $bStopIfLaunchFails)
If $PID > 0 Then $PID = ProcessExists2($g_sAndroidProgramPath, $g_sAndroidInstance)
If $PID <= 0 Then
CloseAndroid("OpenBlueStacks2")
$bStopIfLaunchFails = True
If _Sleep(1000) Then Return False
EndIf
_StatusUpdateTime($hTimer)
If __TimerDiff($hTimer) > $g_iAndroidLaunchWaitSec * 1000 Or($PID = 0 And $bStopIfLaunchFails = True) Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
If _Sleep(3000) Then Return False
_StatusUpdateTime($hTimer, $g_sAndroidEmulator & " Starting")
WinGetAndroidHandle()
WEnd
WinGetAndroidHandle()
Local $aWin = WinGetPos($g_hAndroidWindow)
Local $lCurStyle = _WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_STYLE)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, BitOR($lCurStyle, $WS_CAPTION, $WS_SYSMENU))
Local $iCaptionHeight = _WinAPI_GetSystemMetrics($SM_CYCAPTION)
If BitAND($lCurStyle, BitOR($WS_CAPTION, $WS_SYSMENU)) <> BitOR($WS_CAPTION, $WS_SYSMENU) And UBound($aWin) > 3 Then
WinMove2($g_hAndroidWindow, "", $aWin[0], $aWin[1], $aWin[2], $aWin[3] + $iCaptionHeight)
EndIf
If $g_hAndroidControl Then
$connected_to = ConnectAndroidAdb(False, 3000)
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return
If Not $g_bRunState Then Return False
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
AndroidAdbLaunchShellInstance()
If Not $g_bRunState Then Return False
ConfigBlueStacks2WindowManager()
Return True
EndIf
Return False
EndFunc
Func GetBlueStacksXAdbPath()
Local $adbPath = $__BlueStacks_Path & "HD-Adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func GetBlueStacksAdbPath()
Return GetBlueStacksXAdbPath()
EndFunc
Func GetBlueStacks2AdbPath()
Return GetBlueStacksXAdbPath()
EndFunc
Func InitBlueStacksX($bCheckOnly = False, $bAdjustResolution = False, $bLegacyMode = False)
Local $plusMode = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "Engine") = "plus" And $bLegacyMode = False
Local $frontend_exe = ["HD-Frontend.exe", "HD-Player.exe"]
If $plusMode = True Then
Local $frontend_exe = "HD-Plus-Frontend.exe"
EndIf
Local $i, $aFiles = [$frontend_exe, "HD-Adb.exe", "HD-Quit.exe"]
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth, $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth, $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight, $g_iAndroidWindowHeight] ]
Local $bChanged = False
$__BlueStacks_Version = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "Version")
$__BlueStacks_Path = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "InstallDir")
If @error <> 0 Then
$__BlueStacks_Path = @ProgramFilesDir & "\BlueStacks\"
SetError(0, 0, 0)
EndIf
$__BlueStacks_Path = StringReplace($__BlueStacks_Path, "\\", "\")
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB Then _ArrayDelete($aFiles, 1)
For $i = 0 To UBound($aFiles) - 1
Local $File
Local $bFileFound = False
Local $aFiles2 = $aFiles[$i]
If Not IsArray($aFiles2) Then Local $aFiles2 = [$aFiles[$i]]
For $j = 0 To UBound($aFiles2) - 1
$File = $__BlueStacks_Path & $aFiles2[$j]
$bFileFound = FileExists($File)
If $bFileFound Then
If $i = 0 And IsArray($frontend_exe) Then $frontend_exe = $aFiles2[$j]
ExitLoop
EndIf
Next
If Not $bFileFound Then
If $plusMode And Not $bLegacyMode And $i = 0 Then
SetDebugLog("Cannot find " & $g_sAndroidEmulator & " file:" & $File, $COLOR_ACTION)
SetDebugLog("Try legacy mode", $COLOR_ACTION)
Return InitBlueStacksX($bCheckOnly, $bAdjustResolution, True)
EndIf
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($File, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Next
If Not $bCheckOnly Then
Local $sAndroidEmulator = $g_sAndroidEmulator
Local $bIsVersion1 = GetVersionNormalized($__BlueStacks_Version) > GetVersionNormalized("0.8") And GetVersionNormalized($__BlueStacks_Version) < GetVersionNormalized("2.0")
If $bIsVersion1 And $g_sAndroidEmulator = "BlueStacks2" Then
$sAndroidEmulator = "BlueStacks"
EndIf
Local $bIsVersion2 = GetVersionNormalized($__BlueStacks_Version) > GetVersionNormalized("2.0") And GetVersionNormalized($__BlueStacks_Version) < GetVersionNormalized("5.0")
If $bIsVersion2 And $g_sAndroidEmulator = "BlueStacks" Then
$sAndroidEmulator = "BlueStacks2"
EndIf
If $sAndroidEmulator <> $g_sAndroidEmulator Then
SetLog("Changing Android Emulator config from " & $g_sAndroidEmulator & " to " & $sAndroidEmulator, $COLOR_WARNING)
UpdateAndroidConfig($g_sAndroidInstance, $sAndroidEmulator)
Return InitBlueStacksX($bCheckOnly, $bAdjustResolution, $bLegacyMode)
EndIf
$g_iAndroidAdbSuCommand = "/system/xbin/bstk/su"
Local $BootParameter = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\", "BootParameters")
Local $OEMFeatures
Local $aRegExResult = StringRegExp($BootParameter, "OEMFEATURES=(\d+)", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$OEMFeatures = $aRegExResult[UBound($aRegExResult) - 1]
$g_bAndroidHasSystemBar = BitAND($OEMFeatures, 0x000001) = 0
EndIf
$g_sAndroidPath = $__BlueStacks_Path
$g_sAndroidProgramPath = $__BlueStacks_Path & $frontend_exe
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $__BlueStacks_Path & "HD-Adb.exe"
$g_sAndroidVersion = $__BlueStacks_Version
ConfigureSharedFolderBlueStacksX(0)
SetDebugLog($g_sAndroidEmulator & " Engine 'Plus'-Mode: " & $plusMode)
SetDebugLog($g_sAndroidEmulator & " OEM Features: " & $OEMFeatures)
SetDebugLog($g_sAndroidEmulator & " System Bar is " &($g_bAndroidHasSystemBar ? "" : "not ") & "available")
For $i = 0 To UBound($Values) - 1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
WinGetAndroidHandle()
EndIf
Return True
EndFunc
Func ConfigureSharedFolderBlueStacks($iMode = 0, $bSetLog = Default)
ConfigureSharedFolderBlueStacksX($iMode, $bSetLog)
EndFunc
Func ConfigureSharedFolderBlueStacks2($iMode = 0, $bSetLog = Default)
ConfigureSharedFolderBlueStacksX($iMode, $bSetLog)
EndFunc
Func ConfigureSharedFolderBlueStacksX($iMode = 0, $bSetLog = Default)
If $bSetLog = Default Then $bSetLog = True
Local $bResult = False
Switch $iMode
Case 0
For $i = 0 To 5
If RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\SharedFolder\" & $i & "\", "Name") = "BstSharedFolder" Then
$bResult = True
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesPath = "/storage/sdcard/windows/BstSharedFolder/"
$g_sAndroidPicturesHostPath = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\SharedFolder\" & $i & "\", "Path")
ExitLoop
EndIf
Next
Case 1
Case 2
EndSwitch
Return SetError(0, 0, $bResult)
EndFunc
Func InitBlueStacks($bCheckOnly = False)
Local $bInstalled = InitBlueStacksX($bCheckOnly)
If $bInstalled And(GetVersionNormalized($__BlueStacks_Version) < GetVersionNormalized("0.8") Or GetVersionNormalized($__BlueStacks_Version) > GetVersionNormalized("2.0")) Then
If Not $bCheckOnly Then
SetLog("BlueStacks version is " & $__BlueStacks_Version & " but support version 0.8.x - 1.x not found", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
$g_bAndroidHasSystemBar = True
EndIf
Return $bInstalled
EndFunc
Func InitBlueStacks2($bCheckOnly = False)
Local $bInstalled = InitBlueStacksX($bCheckOnly, True)
If $bInstalled And StringInStr($__BlueStacks_Version, "2.") <> 1 And StringInStr($__BlueStacks_Version, "3.") <> 1 And StringInStr($__BlueStacks_Version, "4.") <> 1 Then
If Not $bCheckOnly Then
SetLog("BlueStacks supported version 2.x, 3.x or 4.x not found", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If $bInstalled And Not $bCheckOnly Then
$__VBoxManage_Path = $__BlueStacks_Path & "BstkVMMgr.exe"
Local $bsNow = GetVersionNormalized($__BlueStacks_Version)
If $bsNow > GetVersionNormalized("4.0") Then
$g_sAndroidAdbShellOptions = " /data/anr/../../system/xbin/bstk/su root"
$g_iAndroidAdbMinitouchMode = 1
EndIf
CheckBlueStacksVersionMod()
Local $BstAdbPort = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\Config\", "BstAdbPort")
If $BstAdbPort Then
$g_sAndroidAdbDevice = "127.0.0.1:" & $BstAdbPort
Else
$g_sAndroidAdbDevice = $g_avAndroidAppConfig[$__BS2_Idx][10]
EndIf
EndIf
Return $bInstalled
EndFunc
Func CheckBlueStacksVersionMod()
Local $bsNow = GetVersionNormalized($__BlueStacks_Version)
Local $aOff = [0, 13]
Local $bs3 = GetVersionNormalized("2.50.0.0")
Local $bs3WithFrame = GetVersionNormalized("2.56.75")
Local $bs3NNoFrame = GetVersionNormalized("4.0.0.0")
Local $bs3NWithFrame = GetVersionNormalized("4.3.28.0")
If($bsNow >= $bs3 And $bsNow < $bs3WithFrame) Or($bsNow > $bs3NNoFrame And $bsNow < $bs3NWithFrame) Then
If $g_aiMouseOffsetWindowOnly[0] <> $aOff[0] Or $g_aiMouseOffsetWindowOnly[1] <> $aOff[1] Then
$g_aiMouseOffsetWindowOnly = $aOff
SetDebugLog("BlueStacks " & $__BlueStacks_Version & ": Adjust mouse clicks when running undocked by: " & $aOff[0] & ", " & $aOff[1])
EndIf
EndIf
If $bsNow >= $bs3NWithFrame Or($bsNow >= $bs3WithFrame And $bsNow < $bs3NNoFrame) Then
SetDebugLog("BlueStacks " & $__BlueStacks_Version & " adjustment on ZoomOut")
$__BlueStacks2Version_2_5_or_later = True
EndIf
EndFunc
Func GetBlueStacksBackgroundMode()
Return $g_iAndroidBackgroundModeDirectX
EndFunc
Func GetBlueStacks2BackgroundMode()
Local $GlRenderMode = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\Config\", "GlRenderMode")
Switch $GlRenderMode
Case 4
Return $g_iAndroidBackgroundModeDirectX
Case 1
Return $g_iAndroidBackgroundModeOpenGL
Case Else
SetLog($g_sAndroidEmulator & " unsupported render mode " & $GlRenderMode, $COLOR_WARNING)
Return 0
EndSwitch
EndFunc
Func RestartBlueStacksXCoC()
If Not $g_bRunState Then Return False
Local $cmdOutput
If Not InitAndroid() Then Return False
If WinGetAndroidHandle() = 0 Then Return False
$cmdOutput = AndroidAdbSendShellCommand("am start -W -n " & $g_sAndroidGamePackage & "/" & $g_sAndroidGameClass, 60000)
SetLog("Please wait for CoC restart......", $COLOR_INFO)
Return True
EndFunc
Func RestartBlueStacksCoC()
Return RestartBlueStacksXCoC()
EndFunc
Func RestartBlueStacks2CoC()
Return RestartBlueStacksXCoC()
EndFunc
Func CheckScreenBlueStacksX($bSetLog = True)
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\FrameBuffer\0"
Local $aValues[5][2] = [ ["FullScreen", 0], ["GuestHeight", $g_iAndroidClientHeight], ["GuestWidth", $g_iAndroidClientWidth], ["WindowHeight", $g_iAndroidClientHeight], ["WindowWidth", $g_iAndroidClientWidth] ]
Local $i, $Value, $iErrCnt = 0
For $i = 0 To UBound($aValues) - 1
$Value = RegRead($REGISTRY_KEY_DIRECTORY, $aValues[$i][0])
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
$iErrCnt += 1
EndIf
Next
Local $DPI = 0
Local $BootParameter = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\", "BootParameters")
Local $aRegExResult = StringRegExp($BootParameter, "DPI=(\d+)", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$DPI = $aRegExResult[UBound($aRegExResult) - 1]
If $DPI <> 160 Then
SetDebugLog("DPI is " & $DPI & " and will be changed to 160", $COLOR_ERROR)
$iErrCnt += 1
EndIf
Else
SetDebugLog("DPI is missing and will be set to 160", $COLOR_ERROR)
$iErrCnt += 1
EndIf
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func CheckScreenBlueStacks($bSetLog = True)
Return CheckScreenBlueStacksX($bSetLog)
EndFunc
Func CheckScreenBlueStacks2($bSetLog = True)
Return CheckScreenBlueStacksX($bSetLog)
EndFunc
Func SetScreenBlueStacks()
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\FrameBuffer\0"
RegWrite($REGISTRY_KEY_DIRECTORY, "FullScreen", "REG_DWORD", "0")
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestWidth", "REG_DWORD", $g_iAndroidClientWidth)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowWidth", "REG_DWORD", $g_iAndroidClientWidth)
$REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance
Local $BootParameter = RegRead($REGISTRY_KEY_DIRECTORY, "BootParameters")
$BootParameter = StringRegExpReplace($BootParameter, "DPI=\d+", "DPI=160")
If @error = 0 And @extended > 0 Then
RegWrite($REGISTRY_KEY_DIRECTORY, "BootParameters", "REG_SZ", $BootParameter)
Else
RegWrite($REGISTRY_KEY_DIRECTORY, "BootParameters", "REG_SZ", $BootParameter & " DPI=160")
EndIf
EndFunc
Func SetScreenBlueStacks2()
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\FrameBuffer\0"
RegWrite($REGISTRY_KEY_DIRECTORY, "FullScreen", "REG_DWORD", "0")
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestWidth", "REG_DWORD", $g_iAndroidClientWidth)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowWidth", "REG_DWORD", $g_iAndroidClientWidth)
$REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance & "\Config"
RegWrite($REGISTRY_KEY_DIRECTORY, "FEControlBar", "REG_DWORD", "0")
$REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\" & $g_sAndroidInstance
Local $BootParameter = RegRead($REGISTRY_KEY_DIRECTORY, "BootParameters")
$BootParameter = StringRegExpReplace($BootParameter, "DPI=\d+", "DPI=160")
If @error = 0 And @extended > 0 Then
RegWrite($REGISTRY_KEY_DIRECTORY, "BootParameters", "REG_SZ", $BootParameter)
Else
RegWrite($REGISTRY_KEY_DIRECTORY, "BootParameters", "REG_SZ", $BootParameter & " DPI=160")
EndIf
EndFunc
Func RebootBlueStacksSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func ConfigBlueStacks2WindowManager()
If Not $g_bRunState Then Return
Local $cmdOutput
$cmdOutput = AndroidAdbSendShellCommand("wm size reset", Default, Default, False)
$cmdOutput = AndroidAdbSendShellCommand("wm density 160", Default, Default, False)
AndroidSetFontSizeNormal()
EndFunc
Func RebootBlueStacks2SetScreen($bOpenAndroid = True)
If Not InitAndroid() Then Return False
ConfigBlueStacks2WindowManager()
CloseAndroid("RebootBlueStacks2SetScreen")
If _Sleep(1000) Then Return False
SetScreenAndroid()
If Not $g_bRunState Then Return False
If $bOpenAndroid Then
OpenAndroid(True)
EndIf
Return True
EndFunc
Func GetBlueStacksRunningInstance($bStrictCheck = True)
WinGetAndroidHandle()
Local $a[2] = [$g_hAndroidWindow, ""]
Return $a
EndFunc
Func GetBlueStacks2RunningInstance($bStrictCheck = True)
WinGetAndroidHandle()
Local $a[2] = [$g_hAndroidWindow, ""]
If $g_hAndroidWindow <> 0 Then Return $a
If $bStrictCheck Then Return False
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $h = WinGetHandle("Bluestacks App Player", "")
If @error = 0 Then
$a[0] = $h
EndIf
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Return $a
EndFunc
Func GetBlueStacksProgramParameter($bAlternative = False)
Return $g_sAndroidInstance
EndFunc
Func GetBlueStacks2ProgramParameter($bAlternative = False)
Return $g_sAndroidInstance
EndFunc
Func BlueStacksBotStartEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Disable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
DisableBS($g_hAndroidWindow, $SC_MINIMIZE)
DisableBS($g_hAndroidWindow, $SC_MAXIMIZE)
EndIf
Return AndroidCloseSystemBar()
EndFunc
Func BlueStacksBotStopEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Enable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
EnableBS($g_hAndroidWindow, $SC_MINIMIZE)
EnableBS($g_hAndroidWindow, $SC_MAXIMIZE)
EndIf
Return AndroidOpenSystemBar()
EndFunc
Func BlueStacks2BotStartEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Disable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
DisableBS($g_hAndroidWindow, $SC_MINIMIZE)
DisableBS($g_hAndroidWindow, $SC_MAXIMIZE)
EndIf
If $g_bAndroidHasSystemBar Then Return AndroidCloseSystemBar()
Return False
EndFunc
Func BlueStacks2BotStopEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Enable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
EnableBS($g_hAndroidWindow, $SC_MINIMIZE)
EnableBS($g_hAndroidWindow, $SC_MAXIMIZE)
EndIf
If $g_bAndroidHasSystemBar Then Return AndroidOpenSystemBar()
Return False
EndFunc
Func BlueStacksAdjustClickCoordinates(ByRef $x, ByRef $y)
$x = Round(32767.0 / $g_iAndroidClientWidth * $x)
$y = Round(32767.0 / $g_iAndroidClientHeight * $y)
EndFunc
Func BlueStacks2AdjustClickCoordinates(ByRef $x, ByRef $y)
$x = Round(32767.0 / $g_iAndroidClientWidth * $x)
$y = Round(32767.0 / $g_iAndroidClientHeight * $y)
EndFunc
Func DisableBS($HWnD, $iButton)
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, 0)
_GUICtrlMenu_RemoveMenu($hSysMenu, $iButton, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
EndFunc
Func EnableBS($HWnD, $iButton)
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, 1)
_GUICtrlMenu_RemoveMenu($hSysMenu, $iButton, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
EndFunc
Func GetBlueStacksSvcPid()
Local $PID = ProcessExists2("HD-Service.exe")
Return $PID
EndFunc
Func CloseBlueStacks()
Local $iIndex, $bOops = False
Local $aServiceList[4] = ["BstHdAndroidSv", "BstHdLogRotatorSvc", "BstHdUpdaterSvc", "bthserv"]
If Not InitAndroid() Then Return
SetDebugLog("Closing BlueStacks: " & $__BlueStacks_Path & "HD-Quit.exe")
RunWait($__BlueStacks_Path & "HD-Quit.exe")
If @error <> 0 Then
SetLog($g_sAndroidEmulator & " failed to quit", $COLOR_ERROR)
EndIf
If _Sleep(2000) Then Return
$bOops = ProcessExists("HD-Frontend.exe") <> 0
If $bOops Then
$bOops = False
SetDebugLog("Failed to terminate HD-Frontend.exe with HD-Quit.exe, fallback to taskkill", $COLOR_ERROR)
KillBSProcess()
If _Sleep(1000) Then Return
SetLog("Please wait for full BS shutdown....", $COLOR_SUCCESS)
For $iIndex = 0 To UBound($aServiceList) - 1
ServiceStop($aServiceList[$iIndex])
If @error Then
$bOops = True
If $g_bDebugAndroid Then SetDebugLog($aServiceList[$iIndex] & "errored trying to stop", $COLOR_WARNING)
EndIf
Next
If $bOops Then
If $g_bDebugAndroid Then SetDebugLog("Service Stop issues, Stopping BS 2nd time", $COLOR_WARNING)
KillBSProcess()
If _SleepStatus(5000) Then Return
EndIf
EndIf
If $g_bDebugAndroid And $bOops Then
SetLog("BS Kill Failed to stop service", $COLOR_ERROR)
EndIf
If $bOops Then
SetError(1, @extended, -1)
EndIf
EndFunc
Func CloseBlueStacks2()
Local $bOops = False
If Not InitAndroid() Then Return
If Not CloseUnsupportedBlueStacksX(False) And GetVersionNormalized($g_sAndroidVersion) > GetVersionNormalized("2.10") Then
Local $aFiles = ["HD-Frontend.exe", "HD-Plus-Service.exe", "HD-Service.exe"]
For $sFile In $aFiles
Local $PID
$PID = ProcessExists2($sFile, $g_sAndroidInstance)
If $PID Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -f -t -pid " & $PID, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return
EndIf
Next
If _Sleep(1000) Then Return
For $sFile In $aFiles
Local $PID
$PID = ProcessExists2($sFile, $g_sAndroidInstance)
If $PID Then
SetLog($g_sAndroidEmulator & " failed to kill " & $sFile, $COLOR_ERROR)
EndIf
Next
Else
SetDebugLog("Closing BlueStacks: " & $__BlueStacks_Path & "HD-Quit.exe")
RunWait($__BlueStacks_Path & "HD-Quit.exe")
If @error <> 0 Then
SetLog($g_sAndroidEmulator & " failed to quit", $COLOR_ERROR)
EndIf
EndIf
If _Sleep(2000) Then Return
If $bOops Then
SetError(1, @extended, -1)
EndIf
EndFunc
Func KillBSProcess()
Local $aBS_FileNames[8][2] = [['HD-Agent.exe', 0], ['HD-BlockDevice.exe', 0], ['HD-Frontend.exe', 0], ['HD-Network.exe', 0], ['HD-Service.exe', 0], ['HD-SharedFolder.exe', 0], ['HD-UpdaterService.exe', 0], ['HD-Adb.exe', 0]]
For $iIndex = 0 To UBound($aBS_FileNames) - 1
$aBS_FileNames[$iIndex][1] = ProcessExists($aBS_FileNames[$iIndex][0])
If $g_bDebugAndroid Then SetDebugLog($aBS_FileNames[$iIndex][0] & " PID = " & $aBS_FileNames[$iIndex][1], $COLOR_DEBUG)
If $aBS_FileNames[$iIndex][1] > 0 Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -t -pid " & $aBS_FileNames[$iIndex][1], "", Default, @SW_HIDE)
If _Sleep(1000) Then Return
EndIf
If ProcessExists($aBS_FileNames[$iIndex][1]) Then
If $g_bDebugAndroid Then SetDebugLog($aBS_FileNames[$iIndex][0] & " 1st Kill failed, trying again", $COLOR_DEBUG)
ShellExecute(@WindowsDir & "\System32\taskkill.exe", "-f -t -pid " & $aBS_FileNames[$iIndex][1], "", Default, @SW_HIDE)
If _Sleep(500) Then Return
EndIf
Next
EndFunc
Func ServiceStop($sServiceName)
Local $ServiceRunning, $svcWaitIterations, $data, $PID, $hTimer, $bFailed, $Result
$hTimer = __TimerInit()
$Result = RunWait(@ComSpec & " /c " & 'net stop ' & $sServiceName, "", @SW_HIDE)
If @error Then
SetLog("net stop service failed on " & $sServiceName & ", Result= " & $Result, $COLOR_ERROR)
SetError(1, @extended, -1)
Return
EndIf
$ServiceRunning = True
$svcWaitIterations = 0
While $ServiceRunning
_StatusUpdateTime($hTimer, "BS Service Stop")
$data = ""
$PID = Run(@WindowsDir & '\System32\sc.exe query ' & $sServiceName, '', @SW_HIDE, 2)
Do
$data &= StdoutRead($PID)
Until @error
StdioClose($PID)
$Result = StringInStr($data, "stopped")
$bFailed = StringInStr($data, "failed")
If $Result Then
$ServiceRunning = False
EndIf
$svcWaitIterations = $svcWaitIterations + 1
If $svcWaitIterations > 15 Or $bFailed Then
SetError(1, @extended, -1)
$ServiceRunning = False
EndIf
If _Sleep(1000) Then Return
WEnd
If $g_bDebugAndroid And $svcWaitIterations > 15 Then
SetLog("Failed to stop service " & $sServiceName, $COLOR_ERROR)
Else
If $g_bDebugAndroid Then SetDebugLog($sServiceName & "Service stopped successfully", $COLOR_SUCCESS)
EndIf
EndFunc
Func CloseUnsupportedBlueStacks2()
Return CloseUnsupportedBlueStacksX()
EndFunc
Func CloseUnsupportedBlueStacksX($bClose = True)
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $sPartnerExePath = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Config\", "PartnerExePath")
If IsArray(ControlGetPos("Bluestacks App Player", "", "")) Or($sPartnerExePath And ProcessExists2($sPartnerExePath)) Then
Opt("WinTitleMatchMode", $WinTitleMatchMode)
If $bClose = True Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " App Player", $COLOR_ERROR)
SetLog("Please let MyBot start " & $g_sAndroidEmulator & " automatically", $COLOR_INFO)
RebootBlueStacks2SetScreen(False)
EndIf
Return True
EndIf
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Return False
EndFunc
Func OpenDroid4X($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $launchAndroid, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
$launchAndroid = WinGetAndroidHandle() = 0
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = __TimerInit()
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If Not $g_bRunState Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func GetDroid4XProgramParameter($bAlternative = False)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-o " &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return ""
EndFunc
Func GetDroid4XPath()
Local $droid4xPath = RegRead($g_sHKLM & "\SOFTWARE\Droid4X\", "InstallDir")
If @error <> 0 Then
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Droid4X\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1)
$droid4xPath = StringLeft($DisplayIcon, $iLastBS)
EndIf
EndIf
If @error <> 0 Then
$droid4xPath = @ProgramFilesDir & "\Droid4X\"
SetError(0, 0, 0)
EndIf
Return StringReplace($droid4xPath, "\\", "\")
EndFunc
Func GetDroid4XAdbPath()
Local $adbPath = GetDroid4XPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func GetDroid4XBackgroundMode()
Return $g_iAndroidBackgroundModeOpenGL
EndFunc
Func InitDroid4X($bCheckOnly = False)
Local $process_killed, $aRegExResult, $VirtualBox_Path, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
$__Droid4X_Version = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Droid4X\", "DisplayVersion")
$__Droid4X_Path = GetDroid4XPath()
$VirtualBox_Path = RegRead($g_sHKLM & "\SOFTWARE\Oracle\VirtualBox\", "InstallDir")
If @error <> 0 Then
$VirtualBox_Path = @ProgramFilesDir & "\Oracle\VirtualBox\"
SetError(0, 0, 0)
EndIf
$VirtualBox_Path = StringReplace($VirtualBox_Path, "\\", "\")
If FileExists($__Droid4X_Path & "Droid4X.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($__Droid4X_Path & "Droid4X.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists($__Droid4X_Path & "adb.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($__Droid4X_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($VirtualBox_Path & "VBoxManage.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find VirtualBox:", $COLOR_ERROR)
SetLog($VirtualBox_Path & "VBoxManage.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxManage_Path = $VirtualBox_Path & "VBoxManage.exe"
If Not GetAndroidVMinfo($__VBoxVMinfo, $__VBoxManage_Path) Then Return False
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidProgramPath = $__Droid4X_Path & "Droid4X.exe"
$g_sAndroidPath = $__Droid4X_Path
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $__Droid4X_Path & "adb.exe"
$g_sAndroidVersion = $__Droid4X_Version
If $g_sAndroidInstance = "" Or StringCompare($g_sAndroidInstance, $g_avAndroidAppConfig[$g_iAndroidConfig][1]) = 0 Then
Else
If $g_sAndroidTitle = $g_avAndroidAppConfig[$g_iAndroidConfig][2] Then
$g_sAndroidTitle = StringReplace($g_avAndroidAppConfig[$g_iAndroidConfig][2], "Droid4X", $g_sAndroidInstance)
EndIf
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/picture/"
$g_sAndroidSharedFolderName = "picture"
ConfigureSharedFolder(0)
WinGetAndroidHandle()
UpdateDroid4XConfig()
EndIf
Return True
EndFunc
Func SetScreenDroid4X()
If Not $g_bRunState Then Return False
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
ConfigureSharedFolder(1, True)
ConfigureSharedFolder(2, True)
Return True
EndFunc
Func RebootDroid4XSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CheckScreenDroid4X($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult, $properties
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
If ConfigureSharedFolder(1, $bSetLog) Then $iErrCnt += 1
Return True
EndFunc
Func UpdateDroid4XConfig()
Return UpdateDroid4XWindowState()
EndFunc
Func UpdateDroid4XWindowState()
WinGetAndroidHandle()
ControlGetPos($g_hAndroidWindow, $g_sAppPaneName, $g_sAppClassInstance)
If @error = 1 Then
SetError(0, 0, 0)
Return False
EndIf
Local $acw = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
Local $ach = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
Local $aww = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
Local $awh = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
Local $v = GetVersionNormalized($g_sAndroidVersion)
For $i = 0 To UBound($__Droid4X_Window) - 1
Local $v2 = GetVersionNormalized($__Droid4X_Window[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Window sizes of " & $g_sAndroidEmulator & " " & $__Droid4X_Window[$i][0])
$aww = $__Droid4X_Window[$i][1]
$awh = $__Droid4X_Window[$i][2]
ExitLoop
EndIf
Next
Local $i
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth, $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth, $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight, $g_iAndroidWindowHeight] ]
Local $bChanged = False, $ok = False
$Values[0][2] = $acw
$Values[1][2] = $ach
$Values[2][2] = $aww
$Values[3][2] = $awh
$g_iAndroidClientWidth = $Values[0][2]
$g_iAndroidClientHeight = $Values[1][2]
$g_iAndroidWindowWidth = $Values[2][2]
$g_iAndroidWindowHeight = $Values[3][2]
For $i = 0 To UBound($Values) - 1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
Return $bChanged
EndFunc
Func CloseDroid4X()
Return CloseVboxAndroidSvc()
EndFunc
Func OpenMEmu($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = __TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func GetMEmuProgramParameter($bAlternative = False)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return ""
EndFunc
Func GetMEmuPath()
Local $MEmu_Path = EnvGet("MEmu_Path") & "\MEmu\"
If FileExists($MEmu_Path & "MEmu.exe") = 0 Then
Local $InstallLocation = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "InstallLocation")
If @error = 0 And FileExists($InstallLocation & "\MEmu\MEmu.exe") = 1 Then
$MEmu_Path = $InstallLocation & "\MEmu\"
Else
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1)
$MEmu_Path = StringLeft($DisplayIcon, $iLastBS)
If StringLeft($MEmu_Path, 1) = """" Then $MEmu_Path = StringMid($MEmu_Path, 2)
Else
$MEmu_Path = @ProgramFilesDir & "\Microvirt\MEmu\"
SetError(0, 0, 0)
EndIf
EndIf
EndIf
$MEmu_Path = StringReplace($MEmu_Path, "\\", "\")
Return $MEmu_Path
EndFunc
Func GetMEmuAdbPath()
Local $adbPath = GetMEmuPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func GetMEmuBackgroundMode()
Local $iDirectX = $g_iAndroidBackgroundModeDirectX
Local $iOpenGL = $g_iAndroidBackgroundModeOpenGL
If @OSBuild >= 16299 And @OSBuild < 17134 Then
SetDebugLog("DirectX/OpenGL Fix applied for Windows Build 16299")
$iDirectX = $g_iAndroidBackgroundModeOpenGL
$iOpenGL = $g_iAndroidBackgroundModeDirectX
EndIf
Local $aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: graphics_render_mode, value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
Local $graphics_render_mode = $aRegExResult[0]
SetDebugLog($g_sAndroidEmulator & " instance " & $g_sAndroidInstance & " rendering mode is " & $graphics_render_mode)
Switch $graphics_render_mode
Case "1"
Return $iDirectX
Case "2"
Return $iDirectX
Case Else
Return $iOpenGL
EndSwitch
EndIf
Return $iOpenGL
EndFunc
Func InitMEmu($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $MEmuVersion = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "DisplayVersion")
SetError(0, 0, 0)
Local $MEmu_Path = GetMEmuPath()
Local $MEmu_Manage_Path = EnvGet("MEmuHyperv_Path") & "\MEmuManage.exe"
If FileExists($MEmu_Manage_Path) = 0 Then
$MEmu_Manage_Path = $MEmu_Path & "..\MEmuHyperv\MEmuManage.exe"
EndIf
If FileExists($MEmu_Path & "MEmu.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($MEmu_Path & "MEmu.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists($MEmu_Path & "adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($MEmu_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($MEmu_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find MEmu-Hyperv:", $COLOR_ERROR)
SetLog($MEmu_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
local $memuCurr = GetVersionNormalized($MEmuVersion)
Local $memu6 = GetVersionNormalized("6.0")
If $memuCurr > $memu6 Then
EndIf
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $MEmu_Manage_Path) Then Return False
$g_bAndroidAdbPortPerInstance = False
$g_sAndroidProgramPath = $MEmu_Path & "MEmu.exe"
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $MEmu_Path & "adb.exe"
$g_sAndroidVersion = $MEmuVersion
$__MEmu_Path = $MEmu_Path
$g_sAndroidPath = $__MEmu_Path
$__VBoxManage_Path = $MEmu_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = ADB.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = ADB.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "/mnt/shell/emulated/0/Pictures/"
$g_sAndroidSharedFolderName = "picture"
ConfigureSharedFolder(0)
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
UpdateMEmuConfig()
EndIf
Return SetError($oops, 0, True)
EndFunc
Func SetScreenMEmu()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " resolution_width " & $g_iAndroidClientWidth, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " resolution_height " & $g_iAndroidClientHeight, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " is_full_screen 0", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " is_customed_resolution 1", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
ConfigureSharedFolder(1, True)
ConfigureSharedFolder(2, True)
Return True
EndFunc
Func RebootMEmuSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseMEmu()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenMEmu($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[4][2] = [ ["is_full_screen", "0"], ["vbox_dpi", "160"], ["resolution_height", $g_iAndroidClientHeight], ["resolution_width", $g_iAndroidClientWidth] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If ConfigureSharedFolder(1, $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func UpdateMEmuConfig()
Local $aRegExResult
Local $iSizeConfig = FindMEmuWindowConfig()
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: phone_layout, value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$__MEmu_PhoneLayout = $aRegExResult[0]
If $iSizeConfig > -1 And $__MEmu_Window[$iSizeConfig][4] = "-1" Then
SetDebugLog($g_sAndroidEmulator & " phone_layout is " & $__MEmu_PhoneLayout & ", but set to -1 to disable screen compensation")
$__MEmu_PhoneLayout = $__MEmu_Window[$iSizeConfig][4]
Else
SetDebugLog($g_sAndroidEmulator & " phone_layout is " & $__MEmu_PhoneLayout)
EndIf
Else
SetDebugLog("Cannot read " & $g_sAndroidEmulator & " guestproperty phone_layout!", $COLOR_ERROR)
If $iSizeConfig > -1 Then
$__MEmu_PhoneLayout = $__MEmu_Window[$iSizeConfig][4]
SetDebugLog("Using phone_layout " & $__MEmu_PhoneLayout)
EndIf
EndIf
SetError(0, 0, 0)
Return UpdateMEmuWindowState()
EndFunc
Func FindMEmuWindowConfig()
Local $v = GetVersionNormalized($g_sAndroidVersion)
For $i = 0 To UBound($__MEmu_Window) - 1
Local $v2 = GetVersionNormalized($__MEmu_Window[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Window sizes of " & $g_sAndroidEmulator & " " & $__MEmu_Window[$i][0])
Return $i
EndIf
Next
SetDebugLog("Cannot find Window sizes of " & $g_sAndroidEmulator & " " & $g_sAndroidVersion)
Return -1
EndFunc
Func UpdateMEmuWindowState()
WinGetAndroidHandle()
ControlGetPos($g_hAndroidWindow, $g_sAppPaneName, $g_sAppClassInstance)
If @error = 1 Then
SetError(0, 0, 0)
EndIf
Local $acw = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
Local $ach = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
Local $aww = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
Local $awh = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
Local $tbw = $__MEmu_ToolBar_Width
Local $iSizeConfig = FindMEmuWindowConfig()
If $iSizeConfig > -1 Then
$aww = $__MEmu_Window[$iSizeConfig][1]
$awh = $__MEmu_Window[$iSizeConfig][2]
$tbw = $__MEmu_Window[$iSizeConfig][3]
EndIf
Local $bToolBarVisible = True
Local $i
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth, $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth, $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight, $g_iAndroidWindowHeight] ]
Local $bChanged = False, $ok = False
Local $toolBarPos = ControlGetPos($g_hAndroidWindow, "", "Qt5QWindowIcon3")
If UBound($toolBarPos) = 4 Then
Local $tbw_using = $tbw
If $toolBarPos[2] > 20 And $toolBarPos[2] < 60 Then $tbw_using = $toolBarPos[2]
SetDebugLog($g_sAndroidEmulator & " Tool Bar found, width = " & $toolBarPos[2] & ", height = " & $toolBarPos[3] & ", expected width = " & $tbw & ", using width = " & $tbw_using)
$tbw = $tbw_using
$bToolBarVisible = ControlCommand($g_hAndroidWindow, "", "Qt5QWindowIcon3", "IsVisible", "") = 1
SetDebugLog($g_sAndroidEmulator & " Tool Bar is " &($bToolBarVisible ? "visible" : "hidden"))
$ok = True
EndIf
If Not $ok Then
SetDebugLog($g_sAndroidEmulator & " Tool Bar state is undetermined as treated as " &($bToolBarVisible ? "visible" : "hidden"), $COLOR_ERROR)
EndIf
Local $w =($bToolBarVisible ? 0 : $tbw)
Switch $__MEmu_PhoneLayout
Case "0"
$Values[0][2] = $acw
$Values[1][2] = $ach + $__MEmu_SystemBar
$Values[2][2] = $aww - $w
$Values[3][2] = $awh + $__MEmu_SystemBar
Case "1"
$Values[0][2] = $acw + $__MEmu_SystemBar
$Values[1][2] = $ach
$Values[2][2] = $aww + $__MEmu_SystemBar - $w
$Values[3][2] = $awh
Case "2", "-1"
$Values[0][2] = $acw
$Values[1][2] = $ach
$Values[2][2] = $aww - $w
$Values[3][2] = $awh
Case Else
SetDebugLog("Unsupported " & $g_sAndroidEmulator & " guestproperty phone_layout = " & $__MEmu_PhoneLayout, $COLOR_ERROR)
EndSwitch
$g_iAndroidClientWidth = $Values[0][2]
$g_iAndroidClientHeight = $Values[1][2]
$g_iAndroidWindowWidth = $Values[2][2]
$g_iAndroidWindowHeight = $Values[3][2]
For $i = 0 To UBound($Values) - 1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
Return $bChanged
EndFunc
Func OpenLeapDroid($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = __TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsLeapDroidCommandLine($CommandLine)
SetDebugLog("Check LeapDroid command line instance: " & $CommandLine)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
$CommandLine = StringReplace($CommandLine, GetLeapDroidPath(), "")
If StringRegExp($CommandLine, "-s " & $sInstance & "\b") = 1 Then Return True
Return False
EndFunc
Func GetLeapDroidProgramParameter($bAlternative = False)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-vfiber -novtcheck -w " & $g_iAndroidClientWidth & " -h " & $g_iAndroidClientHeight & " -s " & $sInstance
EndIf
Return "-s " & $sInstance
EndFunc
Func GetLeapDroidPath()
Local $LeapDroid_Path = RegRead($g_sHKLM & "\SOFTWARE\Leapdroid\Leapdroid VM\", "InstallDir")
If $LeapDroid_Path <> "" And FileExists($LeapDroid_Path & "\LeapdroidVM.exe") = 0 Then
$LeapDroid_Path = ""
EndIf
Local $InstallLocation = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\LeapdroidVM\", "InstallLocation")
If $LeapDroid_Path = "" And FileExists($InstallLocation & "\leapdroidvm.ini") = 1 Then
$LeapDroid_Path = IniRead($InstallLocation & "\leapdroidvm.ini", "main", "install_path", "")
If FileExists($LeapDroid_Path & "\LeapdroidVM.exe") = 0 Then
$LeapDroid_Path = ""
EndIf
EndIf
If $LeapDroid_Path = "" And FileExists($InstallLocation & "\LeapdroidVM.exe") = 1 Then
$LeapDroid_Path = $InstallLocation
EndIf
If $LeapDroid_Path = "" And FileExists(@ProgramFilesDir & "\Leapdroid\VM\LeapdroidVM.exe") = 1 Then
$LeapDroid_Path = @ProgramFilesDir & "\Leapdroid\VM"
EndIf
SetError(0, 0, 0)
If $LeapDroid_Path <> "" And StringRight($LeapDroid_Path, 1) <> "\" Then $LeapDroid_Path &= "\"
Return StringReplace($LeapDroid_Path, "\\", "\")
EndFunc
Func GetLeapDroidAdbPath()
Local $adbPath = GetLeapDroidPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitLeapDroid($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $LeapDroidVersion = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\LeapDroid\", "DisplayVersion")
SetError(0, 0, 0)
Local $LeapDroid_Path = GetLeapDroidPath()
Local $LeapDroid_Manage_Path = GetLeapDroidPath() & "VBoxManage.exe"
If FileExists($LeapDroid_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator, $COLOR_ERROR)
SetLog("installation directory", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find installation directory")
EndIf
Return False
EndIf
If FileExists($LeapDroid_Path & "LeapdroidVM.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Path & "LeapdroidVM.exe", $COLOR_ERROR)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Path & "LeapdroidVM.exe")
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists($LeapDroid_Path & "adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Path & "adb.exe")
EndIf
Return False
EndIf
If FileExists($LeapDroid_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Manage_Path)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $LeapDroid_Manage_Path) Then Return False
$g_bAndroidAdbPortPerInstance = False
$__VBoxGuestProperties = LaunchConsole($LeapDroid_Manage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
$g_sAndroidProgramPath = $LeapDroid_Path & "LeapdroidVM.exe"
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $LeapDroid_Path & "adb.exe"
If Not $LeapDroidVersion Then
Local $pAndroidFileVersionInfo
If _WinAPI_GetFileVersionInfo($g_sAndroidProgramPath, $pAndroidFileVersionInfo) Then
$g_avAndroidProgramFileVersionInfo = _WinAPI_VerQueryValue($pAndroidFileVersionInfo, "FileVersion")
If UBound($g_avAndroidProgramFileVersionInfo) > 1 Then $LeapDroidVersion = $g_avAndroidProgramFileVersionInfo[1][1]
EndIf
EndIf
$g_sAndroidVersion = $LeapDroidVersion
$__LeapDroid_Path = $LeapDroid_Path
$g_sAndroidPath = $__LeapDroid_Path
$__VBoxManage_Path = $LeapDroid_Manage_Path
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: adb_port, value: (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = "127.0.0.1"
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("InitLeapDroid: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = "emulator-" &($g_sAndroidAdbDevicePort - 1)
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
If GetVersionNormalized($g_sAndroidVersion) >= GetVersionNormalized("1.7.0") Then
$g_sAndroidPicturesPath = "/mnt/shared/LeapDroidShared/"
$g_sAndroidSharedFolderName = "LeapDroidShared"
Else
$g_sAndroidPicturesPath = "/mnt/shared/yw_shared/"
$g_sAndroidSharedFolderName = "yw_shared"
EndIf
ConfigureSharedFolder(0)
$g_bUpdateAndroidWindowTitle = True
EndIf
Return SetError($oops, 0, True)
EndFunc
Func UpdateLeapdroidSettings(ByRef $fileContent, $param, $value)
$fileContent = StringRegExpReplace($fileContent, "^(" & $param & "=.*)", $param & "=" & $value)
Return @extended
EndFunc
Func SetScreenLeapDroid()
If Not InitAndroid() Then Return False
Local $files[2] = [@MyDocumentsDir & "\Leapdroid\Leapdroid Emulator\leapdroid.settings", GetLeapDroidPath() & "Leapdroid Emulator\leapdroid.settings"]
Local $f, $p, $h
For $f In $files
$p = StringMid($f, 1, StringInStr($f, "\", 0, -1))
If FileExists($p) Then
If FileExists($f) = 0 Then
$h = FileOpen($f, $FO_OVERWRITE)
If $h = -1 Then
SetLog("Cannot write " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
FileWrite($h, "RESOLUTION=" & $g_iGAME_WIDTH & "x" & $g_iGAME_HEIGHT & @CRLF & "DPI=160")
FileClose($h)
Else
Local $i
$h = FileOpen($f, $FO_READ)
If $h = -1 Then
SetLog("Cannot read " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
Local $s = FileRead($h)
FileClose($h)
$i = UpdateLeapdroidSettings($s, "RESOLUTION", $g_iGAME_WIDTH & "x" & $g_iGAME_HEIGHT)
If $i < 1 Then SetDebugLog("Cannot update " & $g_sAndroidEmulator & " screen resolution in file:" & @CRLF & $f, $COLOR_ERROR)
$i = UpdateLeapdroidSettings($s, "DPI", "160")
If $i < 1 Then SetDebugLog("Cannot update " & $g_sAndroidEmulator & " screen DPI in file:" & @CRLF & $f, $COLOR_ERROR)
$h = FileOpen($f, $FO_OVERWRITE)
If $h = -1 Then
SetLog("Cannot write " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
FileWrite($h, $s)
FileClose($h)
EndIf
EndIf
Next
ConfigureSharedFolder(1, True)
ConfigureSharedFolder(2, True)
Return True
EndFunc
Func RebootLeapDroidSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseLeapDroid()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenLeapDroid($bSetLog = True)
If Not InitAndroid() Then Return False
Local $iErrCnt = 0
If ConfigureSharedFolder(1, $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func EmbedLeapDroid($bEmbed = Default, $hHWndAfter = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "QTool" Then
$hToolbar = $h
ExitLoop
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): QTool Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
If $bEmbed Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hToolbar,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
If Not $bEmbed Then
WinMove2($hToolbar, "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndIf
EndIf
EndFunc
Func LeapDroidBotStartEvent()
Return AndroidCloseSystemBar()
EndFunc
Func LeapDroidBotStopEvent()
EndFunc
Func OpenNox($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
$hTimer = __TimerInit()
$g_bInitAndroid = True
InitAndroid()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsNoxCommandLine($CommandLine)
Local $aRegexResult = StringRegExp($CommandLine, "-clone:(\b.+\b)", $STR_REGEXPARRAYMATCH)
If Not @error Then
Local $sInstance = $aRegexResult[0]
If $sInstance = $g_sAndroidInstance Or($g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1] And $sInstance = 'Nox_0') Then
SetDebugLog("IsNoxCommandLine, instance " & $g_sAndroidInstance & ", returns True for: " & $CommandLine)
Return True
EndIf
Else
If $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
SetDebugLog("IsNoxCommandLine, instance " & $g_sAndroidInstance & ", returns True for: " & $CommandLine)
Return True
EndIf
EndIf
SetDebugLog("IsNoxCommandLine, instance " & $g_sAndroidInstance & ", returns False for: " & $CommandLine)
Return False
EndFunc
Func GetNoxProgramParameter($bAlternative = False)
Local $customScreen = "-resolution:" & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & " -dpi:160"
Local $clone = """-clone:" &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance) & """"
If $bAlternative = False Then
Return $customScreen & " " & $clone
EndIf
If $g_sAndroidInstance = "" Or $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then Return ""
Return $clone
EndFunc
Func GetNoxRtPath()
Local $path = RegRead($g_sHKLM & "\SOFTWARE\BigNox\VirtualBox\", "InstallDir")
If @error = 0 Then
If StringRight($path, 1) <> "\" Then $path &= "\"
EndIf
If FileExists($path) = 0 Then
$path = @ProgramFilesDir & "\Bignox\BigNoxVM\RT\"
EndIf
If FileExists($path) = 0 Then
$path = EnvGet("ProgramFiles(x86)") & "\Bignox\BigNoxVM\RT\"
EndIf
If FileExists($path) = 0 Then
$path = EnvGet("ProgramFiles") & "\Bignox\BigNoxVM\RT\"
EndIf
SetError(0, 0, 0)
Return StringReplace($path, "\\", "\")
EndFunc
Func GetNoxPath()
Local $path = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\DuoDianOnline\SetupInfo\", "InstallPath")
If @error = 0 Then
If StringRight($path, 1) <> "\" Then $path &= "\"
$path &= "bin\"
Else
$path = ""
SetError(0, 0, 0)
EndIf
Return StringReplace($path, "\\", "\")
EndFunc
Func GetNoxAdbPath()
Local $adbPath = GetNoxPath() & "nox_adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func GetNoxBackgroundMode()
Local $iDirectX = $g_iAndroidBackgroundModeDirectX
Local $iOpenGL = $g_iAndroidBackgroundModeOpenGL
If @OSBuild >= 16299 And @OSBuild < 17134 Then
SetDebugLog("DirectX/OpenGL Fix applied for Windows Build 16299")
$iDirectX = $g_iAndroidBackgroundModeOpenGL
$iOpenGL = $g_iAndroidBackgroundModeDirectX
EndIf
Local $sConfig = GetNoxConfigFile()
If $sConfig Then
Local $graphic_engine_type = IniRead($sConfig, "setting", "graphic_engine_type", "")
Switch $graphic_engine_type
Case "0", ""
Return $iOpenGL
Case "1"
Return $iDirectX
Case Else
SetLog($g_sAndroidEmulator & " unsupported Graphics Engine Type " & $graphic_engine_type, $COLOR_WARNING)
EndSwitch
EndIf
Return 0
EndFunc
Func InitNox($bCheckOnly = False)
Local $process_killed, $aRegexResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $Version = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Nox\", "DisplayVersion")
SetError(0, 0, 0)
Local $path = GetNoxPath()
Local $RtPath = GetNoxRtPath()
Local $NoxFile = $path & "Nox.exe"
Local $AdbFile = $path & "nox_adb.exe"
Local $VBoxFile = $RtPath & "BigNoxVMMgr.exe"
Local $Files = [$NoxFile, $AdbFile, $VBoxFile]
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB Then _ArrayDelete($Files, 1)
For $File In $Files
If FileExists($File) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & " file:", $COLOR_ERROR)
SetLog($File, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Next
If Not $bCheckOnly Then
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $VBoxFile) Then Return False
$g_sAndroidProgramPath = $NoxFile
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = GetNoxAdbPath()
$g_sAndroidVersion = $Version
$__Nox_Path = $path
$g_sAndroidPath = $__Nox_Path
$__VBoxManage_Path = $VBoxFile
$aRegexResult = StringRegExp($__VBoxVMinfo, ".*host ip = ([^,]+), .* guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegexResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegexResult = StringRegExp($__VBoxVMinfo, "name = .*host port = (\d{3,5}), .* guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegexResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
Local $v = GetVersionNormalized($g_sAndroidVersion)
For $i = 0 To UBound($__Nox_Config) - 1
Local $v2 = GetVersionNormalized($__Nox_Config[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Android Config of " & $g_sAndroidEmulator & " " & $__Nox_Config[$i][0])
$g_sAppClassInstance = $__Nox_Config[$i][1]
$g_bAndroidControlUseParentPos = $__Nox_Config[$i][2]
$g_avAndroidAppConfig[$g_iAndroidConfig][3] = $g_sAppClassInstance
ExitLoop
EndIf
Next
$g_sAndroidSharedFolderName = "Other"
ConfigureSharedFolderNox(0)
UpdateHWnD($g_hAndroidWindow, False)
EndIf
Return True
EndFunc
Func GetNoxConfigFile()
Local $sLocalAppData = EnvGet("LOCALAPPDATA")
Local $sPre = ""
If $g_sAndroidInstance <> "nox" Then $sPre = "clone_" & $g_sAndroidInstance & "_"
Local $sConfig = $sLocalAppData & "\Nox\" & $sPre & "conf.ini"
If FileExists($sConfig) Then Return $sConfig
Return ""
EndFunc
Func ConfigureSharedFolderNox($iMode = 0, $bSetLog = Default)
If $bSetLog = Default Then $bSetLog = True
Local $bResult = False
Switch $iMode
Case 0
$g_sAndroidPicturesPath = "(/mnt/shared/Other|/mnt/shell/emulated/0/Download/other|/mnt/shell/emulated/0/Others)"
Local $aRegexResult = StringRegExp($__VBoxVMinfo, "Name: '" & $g_sAndroidSharedFolderName & "', Host path: '(.*)'.*", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$bResult = True
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = $aRegexResult[UBound($aRegexResult) - 1] & "\"
Else
If FileExists(@HomeDrive & @HomePath & "\Nox_share\OtherShare\") Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = @HomeDrive & @HomePath & "\Nox_share\OtherShare\"
ElseIf FileExists(@HomeDrive & @HomePath & "\Nox_share\") Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = @HomeDrive & @HomePath & "\Nox_share\"
ElseIf FileExists(@MyDocumentsDir & "\Nox_share\Other\") Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = @MyDocumentsDir & "\Nox_share\Other\"
Else
$g_bAndroidSharedFolderAvailable = False
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
EndIf
EndIf
Case 1
$bResult = AndroidPicturePathAutoConfig(@MyDocumentsDir, "\Nox_share\Other", $bSetLog)
Case Else
Return SetError(1, 0, "")
EndSwitch
Return SetError(0, 0, $bResult)
EndFunc
Func SetScreenNox()
If Not InitAndroid() Then Return False
ConfigureSharedFolder(1, True)
ConfigureSharedFolder(2, True)
Local $sConfig = GetNoxConfigFile()
If $sConfig Then
SetDebugLog("Configure Nox screen config: " & $sConfig)
IniWrite($sConfig, "setting", "h_resolution", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight)
IniWrite($sConfig, "setting", "h_dpi", "160")
IniWrite($sConfig, "setting", "fixsize", "true")
IniWrite($sConfig, "setting", "is_save_pos_and_size", "false")
IniWrite($sConfig, "setting", "last_player_width", "864")
IniWrite($sConfig, "setting", "last_player_height", "770")
Else
SetDebugLog("Cannot find Nox config to cnfigure screen: " & $sConfig, $COLOR_ERROR)
EndIf
Return True
EndFunc
Func RebootNoxSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseNox()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenNox($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegexResult
For $i = 0 To UBound($aValues) - 1
$aRegexResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$Value = $aRegexResult[0]
Else
If StringInStr($__VBoxGuestProperties, "error:") = 0 Then
If $bSetLog Then
SetLog("Cannot validate " & $g_sAndroidEmulator & " property " & $aValues[$i][0], $COLOR_ERROR)
Else
SetDebugLog("Cannot validate " & $g_sAndroidEmulator & " property " & $aValues[$i][0], $COLOR_ERROR)
EndIF
Else
$Value = $aValues[$i][1]
If $bSetLog Then
SetLog("Cannot validate " & $g_sAndroidEmulator & " property " & $aValues[$i][0] & ", assuming " & $Value, $COLOR_ERROR)
Else
SetDebugLog("Cannot validate " & $g_sAndroidEmulator & " property " & $aValues[$i][0] & ", assuming " & $Value, $COLOR_ERROR)
EndIF
EndIf
EndIf
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If ConfigureSharedFolder(1, $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func GetNoxRunningInstance($bStrictCheck = True)
Local $a[2] = [0, ""]
SetDebugLog("GetAndroidRunningInstance: Try to find """ & $g_sAndroidProgramPath & """")
For $PID In ProcessesExist($g_sAndroidProgramPath, "", 1)
Local $currentInstance = $g_sAndroidInstance
Local $CommandLine = ProcessGetCommandLine($PID)
SetDebugLog("GetNoxRunningInstance: Found """ & $CommandLine & """ by PID=" & $PID)
Local $aRegexResult = StringRegExp($CommandLine, ".*""-clone:([^""]+)"".*|.*-clone:([\S]+).*", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$g_sAndroidInstance = $aRegexResult[0]
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $aRegexResult[1]
SetDebugLog("Running " & $g_sAndroidEmulator & " instance is """ & $g_sAndroidInstance & """")
EndIf
If WinGetAndroidHandle() <> 0 Then
$a[0] = $g_hAndroidWindow
$a[1] = $g_sAndroidInstance
Return $a
Else
$g_sAndroidInstance = $currentInstance
EndIf
Next
Return $a
EndFunc
Func RedrawNoxWindow()
Return SetError(1)
Local $aPos = WinGetPos($g_hAndroidWindow)
Local $aMousePos = MouseGetPos()
MouseClickDrag("left", $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 3, $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 53, 0)
MouseClickDrag("left", $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 53, $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 3, 0)
MouseMove($aMousePos[0], $aMousePos[1], 0)
$aPos = WinGetPos($g_hAndroidWindow)
ControlClick($g_hAndroidWindow, "", "", "left", 1, $aPos[2] - 46, 18)
If _Sleep(500) Then Return False
$aPos = WinGetPos($g_hAndroidWindow)
ControlClick($g_hAndroidWindow, "", "", "left", 1, $aPos[2] - 46, 18)
EndFunc
Func HideNoxWindow($bHide = True, $hHWndAfter = Default)
Return EmbedNox($bHide, $hHWndAfter)
EndFunc
Func EmbedNox($bEmbed = Default, $hHWndAfter = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "Qt5QWindowToolSaveBits" Then
Local $aPos = WinGetPos($h)
If UBound($aPos) > 3 Then
If $hToolbar = 0 And(($aPos[2] >= $g_iAndroidClientWidth And $aPos[3] > 7) Or($aPos[2] > 7 And $aPos[3] >= $g_iAndroidClientHeight)) Then
$hToolbar = $h
ElseIf $aPos[2] = 7 Or $aPos[3] = 7 Then
WinMove2($h, "", -1, -1, -1, -1, $HWND_NOTOPMOST, $SWP_HIDEWINDOW, False)
EndIf
EndIf
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbedNox(" & $bEmbed & "): toolbar Window not found, list of windows:" & $c)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
Local $aPos = WinGetPos($h)
If UBound($aPos) > 3 Then
SetDebugLog("EmbedNox(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c & ", width=" & $aPos[2] & ", height=" & $aPos[3])
Else
SetDebugLog("EmbedNox(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c)
EndIf
Next
Else
SetDebugLog("EmbedNox(" & $bEmbed & "): $hToolbar=" & $hToolbar)
If $bEmbed Then
WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, $SWP_HIDEWINDOW, False, False)
Else
WinMove2($hToolbar, "", -1, -1, -1, -1, $hHWndAfter, $SWP_SHOWWINDOW, False, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, $SWP_SHOWWINDOW, False, False)
EndIf
EndIf
EndFunc
Func OpenKOPLAYER($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_GREEN)
If Not InitAndroid() Then Return
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter() & " -t " & $g_sAndroidInstance
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_GREEN)
$hTimer = __TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_RED)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_RED)
SetError(1, @extended, False)
Return
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_GREEN)
EndFunc
Func GetKOPLAYERProgramParameter($bAlternative = False)
Local $bVer2 =(GetVersionNormalized($g_sAndroidVersion) >= GetVersionNormalized("2.0"))
If $bVer2 Then
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Local $a = FindAvaiableInstances()
Local $i = _ArraySearch($a,($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance))
If $i < 0 Then $i = 0
Return "-n " & $i
EndIf
Return "-n 0"
Else
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-n " &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return "-n default"
EndIf
EndFunc
Func IsKOPLAYERCommandLine($CommandLine)
SetDebugLog("IsKOPLAYERCommandLine: " & $CommandLine)
Local $param1 = GetKOPLAYERProgramParameter()
Local $param2 = GetKOPLAYERProgramParameter(True)
If StringInStr($CommandLine, $param1 & " ") > 0 Or StringRight($CommandLine, StringLen($param1)) = $param1 Then Return True
If StringInStr($CommandLine, $param2 & " ") > 0 Or StringRight($CommandLine, StringLen($param2)) = $param2 Then Return True
If $g_sAndroidInstance = "KOPLAYER" And StringStripWS($CommandLine, 3) = $g_sAndroidProgramPath Then Return True
Return False
EndFunc
Func GetKOPLAYERPath()
Local $KOPLAYER_Path = RegRead($g_sHKLM & "\SOFTWARE\KOPLAYER\SETUP\", "InstallPath")
If $KOPLAYER_Path = "" Then
$KOPLAYER_Path = @ProgramFilesDir & "\KOPLAYER\"
Else
If StringRight($KOPLAYER_Path, 1) <> "\" Then $KOPLAYER_Path &= "\"
EndIf
Return StringReplace($KOPLAYER_Path, "\\", "\")
EndFunc
Func GetKOPLAYERAdbPath()
Local $adbPath = GetKOPLAYERPath() & "Tools\adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitKOPLAYER($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $KOPLAYERVersion = RegRead($g_sHKLM & "\SOFTWARE\KOPLAYER\SETUP\", "Version")
SetError(0, 0, 0)
Local $KOPLAYER_Path = GetKOPLAYERPath()
Local $KOPLAYER_Manage_Path = $KOPLAYER_Path & "vbox\VBoxManage.exe"
If FileExists($KOPLAYER_Path & "KOPLAYER.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_RED)
SetLog($KOPLAYER_Path & "KOPLAYER.exe", $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists(GetKOPLAYERAdbPath()) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_RED)
SetLog($KOPLAYER_Path & "adb.exe", $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($KOPLAYER_Manage_Path) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find KOPLAYER-VBoxManage:", $COLOR_RED)
SetLog($KOPLAYER_Manage_Path, $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$g_bAndroidAdbPortPerInstance = False
If Not GetAndroidVMinfo($__VBoxVMinfo, $KOPLAYER_Manage_Path) Then Return False
$g_sAndroidProgramPath = $KOPLAYER_Path & "KOPLAYER.exe"
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = GetKOPLAYERAdbPath()
$g_sAndroidVersion = $KOPLAYERVersion
$__KOPLAYER_Path = $KOPLAYER_Path
$g_sAndroidPath = $__KOPLAYER_Path
$__VBoxManage_Path = $KOPLAYER_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host ip = ([^,]*),.*guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_sAndroidAdbDeviceHost = "" Then $g_sAndroidAdbDeviceHost = "127.0.0.1"
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_PURPLE)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_RED)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host port = (\d{3,5}),.*guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_PURPLE)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_RED)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_RED)
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/UserData/"
$g_sAndroidSharedFolderName = "UserData"
ConfigureSharedFolder(0)
EndIf
Return True
EndFunc
Func GetKOPLAYERBackgroundMode()
Local $aRegExResult = StringRegExp($__VBoxExtraData, "Key: GUI/RenderMode, Value: (.*)", $STR_REGEXPARRAYMATCH)
Local $sRenderMode = "Unknown"
If Not @error Then
$sRenderMode = $aRegExResult[0]
Switch $sRenderMode
Case "DirectX", "DirectXPlus"
Return $g_iAndroidBackgroundModeDirectX
Case "Opengl", "OpenglPlus"
Return $g_iAndroidBackgroundModeOpenGL
Case Else
SetLog($g_sAndroidEmulator & " unsupported Render Mode " & $sRenderMode, $COLOR_WARNING)
EndSwitch
EndIf
Return 0
EndFunc
Func SetScreenKOPLAYER()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "setextradata " & $g_sAndroidInstance & " RenderWindowProp " & $g_iAndroidClientWidth & "*" & $g_iAndroidClientHeight & "*160", $process_killed)
ConfigureSharedFolder(1, True)
ConfigureSharedFolder(2, True)
Return True
EndFunc
Func RebootKOPLAYERSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseKOPLAYER()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenKOPLAYER($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_RED)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_RED)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_RED)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_RED)
EndIf
$iErrCnt += 1
EndIf
Next
If ConfigureSharedFolder(1, $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func EmbedKOPLAYER($bEmbed = Default, $hHWndAfter = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "Qt5QWindowToolSaveBits" Then
$hToolbar = $h
ExitLoop
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): Qt5QWindowToolSaveBits Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
If $bEmbed Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hToolbar,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
If Not $bEmbed Then
WinMove2($hToolbar, "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndIf
EndIf
EndFunc
Func OpeniTools($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
$PID = LaunchAndroid($g_sAndroidProgramPath, $cmdPar, $g_sAndroidPath)
If $PID = 0 Then
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = __TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - __TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If __TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsiToolsCommandLine($CommandLine)
SetDebugLog("Check iTools command line instance: " & $CommandLine)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
$CommandLine = StringReplace($CommandLine, GetiToolsPath(), "")
If StringRegExp($CommandLine, "/start " & $sInstance & "\b") = 1 Then Return True
If StringRegExp($CommandLine, "/restart .*\b" & $sInstance & "\b") = 1 Then Return True
Return False
EndFunc
Func GetiToolsProgramParameter($bAlternative = False)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "/start " & $sInstance
EndIf
Return ""
EndFunc
Func GetiToolsPath()
Local $iTools_Path = ""
If $iTools_Path <> "" And FileExists($iTools_Path & "\iToolsAVM.exe") = 0 Then
$iTools_Path = ""
EndIf
Local $InstallLocation = ""
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\iToolsAVM\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1) - 1
$InstallLocation = StringLeft($DisplayIcon, $iLastBS)
EndIf
If $iTools_Path = "" And FileExists($InstallLocation & "\iToolsAVM.exe") = 1 Then
$iTools_Path = $InstallLocation
EndIf
If $iTools_Path = "" And FileExists(@ProgramFilesDir & "\iToolsAVM\iToolsAVM.exe") = 1 Then
$iTools_Path = @ProgramFilesDir & "\iToolsAVM"
EndIf
SetError(0, 0, 0)
If $iTools_Path <> "" And StringRight($iTools_Path, 1) <> "\" Then $iTools_Path &= "\"
Return StringReplace($iTools_Path, "\\", "\")
EndFunc
Func GetiToolsAdbPath()
Local $adbPath = GetiToolsPath() & "tools\adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitiTools($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
SetError(0, 0, 0)
Local $VirtualBox_Path = RegRead($g_sHKLM & "\SOFTWARE\Oracle\VirtualBox\", "InstallDir")
If @error <> 0 And FileExists(@ProgramFilesDir & "\Oracle\VirtualBox\") Then
$VirtualBox_Path = @ProgramFilesDir & "\Oracle\VirtualBox\"
SetError(0, 0, 0)
EndIf
$VirtualBox_Path = StringReplace($VirtualBox_Path, "\\", "\")
Local $iTools_Path = GetiToolsPath()
Local $iTools_Manage_Path = $VirtualBox_Path & "VBoxManage.exe"
If FileExists($iTools_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator, $COLOR_ERROR)
SetLog("installation directory", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find installation directory")
EndIf
Return False
EndIf
If FileExists($iTools_Path & "iToolsAVM.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Path & "iToolsAVM.exe", $COLOR_ERROR)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Path & "iToolsAVM.exe")
SetError(1, @extended, False)
EndIf
Return False
EndIf
Local $sPreferredADB = FindPreferredAdbPath()
If $sPreferredADB = "" And FileExists($iTools_Path & "tools\adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Path & "tools\adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Path & "tools\adb.exe")
EndIf
Return False
EndIf
If FileExists($iTools_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Manage_Path)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
If Not GetAndroidVMinfo($__VBoxVMinfo, $iTools_Manage_Path) Then Return False
$g_sAndroidProgramPath = $iTools_Path & "iToolsAVM.exe"
$g_sAndroidAdbPath = $sPreferredADB
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $iTools_Path & "tools\adb.exe"
$g_sAndroidVersion = ""
Local $pAndroidFileVersionInfo
If _WinAPI_GetFileVersionInfo($g_sAndroidProgramPath, $pAndroidFileVersionInfo) Then
$g_avAndroidProgramFileVersionInfo = _WinAPI_VerQueryValue($pAndroidFileVersionInfo, "FileVersion")
If UBound($g_avAndroidProgramFileVersionInfo) > 1 Then $g_sAndroidVersion = $g_avAndroidProgramFileVersionInfo[1][1]
EndIf
$__iTools_Path = $iTools_Path
$g_sAndroidPath = $__iTools_Path
$__VBoxManage_Path = $iTools_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_bDebugAndroid Then SetDebugLog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/picture/"
$g_sAndroidSharedFolderName = "picture"
ConfigureSharedFolder(0)
$g_bUpdateAndroidWindowTitle = True
EndIf
Return SetError($oops, 0, True)
EndFunc
Func SetScreeniTools()
If Not $g_bRunState Then Return False
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
ConfigureSharedFolder(1, True)
ConfigureSharedFolder(2, True)
Return True
EndFunc
Func RebootiToolsSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseiTools()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreeniTools($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult, $properties
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
SetGuiLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR, $bSetLog)
EndIf
SetGuiLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR, $bSetLog)
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
If ConfigureSharedFolder(1, $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func HideiToolsWindow($bHide = True, $hHWndAfter = Default)
Return EmbediTools($bHide, $hHWndAfter)
EndFunc
Func EmbediTools($bEmbed = Default, $hHWndAfter = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
If $hHWndAfter = Default Then $hHWndAfter = $HWND_TOPMOST
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
Local $hAddition = []
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "CHWindow" Then
Local $aPos = WinGetPos($h)
If UBound($aPos) > 2 Then
If($aPos[2] = 38 Or $aPos[2] = 21) Then
$hToolbar = $h
EndIf
If $aPos[2] = 10 Or $aPos[3] = 10 Then
ReDim $hAddition[UBound($hAddition) + 1]
$hAddition[UBound($hAddition) - 1] = $h
EndIf
EndIf
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbediTools(" & $bEmbed & "): toolbar Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbediTools(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbediTools(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
If $bEmbed Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hToolbar,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
If Not $bEmbed Then
WinMove2($hToolbar, "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndIf
For $i = 0 To UBound($hAddition) - 1
If $bEmbed Then WinMove2($hAddition[$i], "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hAddition[$i],($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
If Not $bEmbed Then
WinMove2($hAddition[$i], "", -1, -1, -1, -1, $hHWndAfter, 0, False)
If $hHWndAfter = $HWND_TOPMOST Then WinMove2($hAddition[$i], "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndIf
Next
EndIf
EndFunc
Func getBSPos()
Local $SuspendMode = ResumeAndroid()
Local $Changed = False, $aOldValues[4]
Local $hWin = $g_hAndroidWindow
WinGetAndroidHandle()
If $g_bAndroidBackgroundLaunched = False Then
getAndroidPos(True)
Else
SetError($g_hAndroidWindow = 0 ? 1 : 0)
EndIf
If @error = 1 Then
If Not $g_bRunState Then Return
SetError(0, 0, 0)
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
If $g_bAndroidBackgroundLaunched = False Then
getAndroidPos(True)
Else
SetError($g_hAndroidWindow = 0 ? 1 : 0)
EndIf
If Not $g_bRunState Then Return
If @error = 1 Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslatedFileIni("MBR Popups", "sText_01", "MyBot has experienced a serious error") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "sText_02", "Unable to find or start up ") & $g_sAndroidEmulator & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "sText_03", "Reboot PC and try again,") & GetTranslatedFileIni("MBR Popups", "sText_04", "and search www.mybot.run forums for more help") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "sText_05", "Close MyBot!"), GetTranslatedFileIni("MBR Popups", "sText_06", "Okay - Must Exit Program"), $stext, 15, $g_hFrmBot)
If $MsgBox = 1 Then
BotClose()
EndIf
EndIf
EndIf
If @error = 1 Then
If Not $g_bRunState Then Return
SetError(0, 0, 0)
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
Return
EndIf
If $g_bAndroidBackgroundLaunched = True Then
SuspendAndroid($SuspendMode, False)
Return
EndIf
$aOldValues[0] = $g_aiBSpos[0]
$aOldValues[1] = $g_aiBSpos[1]
$aOldValues[2] = $g_aiBSrpos[0]
$aOldValues[3] = $g_aiBSrpos[1]
Local $aPos = getAndroidPos()
If Not IsArray($aPos) Then
If Not $g_bRunState Then Return
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
$aPos = getAndroidPos(True)
If Not $g_bRunState Then Return
If @error = 1 Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = @CRLF & GetTranslatedFileIni("MBR Popups", "sText_01", "MyBot has experienced a serious error") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "sText_02", "Unable to find or start up") & " " & $g_sAndroidEmulator & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "sText_03", "Reboot PC and try again,") & GetTranslatedFileIni("MBR Popups", "sText_04", "and search www.mybot.run forums for more help") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "sText_05", "Close MyBot!"), GetTranslatedFileIni("MBR Popups", "sText_06", "Okay - Must Exit Program"), $stext, 15, $g_hFrmBot)
If $MsgBox = 1 Then
BotClose()
Return
EndIf
EndIf
EndIf
If IsArray($aPos) Then
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", $aPos[0])
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
DllStructSetData($tPoint, "Y", $aPos[1])
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
_WinAPI_ClientToScreen(GetCurrentAndroidHWnD(), $tPoint)
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
$g_aiBSpos[0] = DllStructGetData($tPoint, "X")
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
$g_aiBSpos[1] = DllStructGetData($tPoint, "Y")
If @error <> 0 Then
$tPoint = 0
Return SetError(0, 0, 0)
EndIf
$g_aiBSrpos[0] = $aPos[0]
$g_aiBSrpos[1] = $aPos[1]
$tPoint = 0
$Changed = Not($aOldValues[0] = $g_aiBSpos[0] And $aOldValues[1] = $g_aiBSpos[1] And $aOldValues[2] = $g_aiBSrpos[0] And $aOldValues[3] = $g_aiBSrpos[1])
If $g_bDebugClick Or $g_bDebugSetlog And $Changed Then SetLog("$g_aiBSpos X,Y = " & $g_aiBSpos[0] & "," & $g_aiBSpos[1] & "; $g_aiBSrpos X,Y = " & $g_aiBSrpos[0] & "," & $g_aiBSrpos[1], $COLOR_ERROR, "Verdana", "7.5", 0)
EndIf
SuspendAndroid($SuspendMode, False)
EndFunc
Func getAndroidPos($FastCheck = False, $RetryCount1 = 0, $RetryCount2 = 0, $bWidthFirst = Default)
Static $asControlSize[6][4]
If $g_bAndroidControlUseParentPos Then
Local $hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, GetAndroidControlClass(True))
Local $hCtrlParent = _WinAPI_GetParent($hCtrl)
Local $aControlSize = ControlGetPos(GetCurrentAndroidHWnD(), "", $hCtrlParent)
Else
Local $aControlSize = ControlGetPos(GetCurrentAndroidHWnD(), $g_sAppPaneName, GetAndroidControlClass(True))
EndIf
If $FastCheck Then Return $aControlSize
If AndroidMakeDpiAware() Then AndroidDpiAwareness()
Local $sPre = "(" & $RetryCount1 & "/" & $RetryCount2 & ") "
Local $bResizedOk = False
If IsArray($aControlSize) Then
If($aControlSize[2] <> $g_iAndroidClientWidth Or $aControlSize[3] <> $g_iAndroidClientHeight) And $RetryCount1 = 0 And $RetryCount2 = 0 Then
UpdateAndroidWindowState()
If $RetryCount1 = 0 Then
For $i = 0 To 5
For $j = 0 To 3
$asControlSize[$i][$j] = 0
Next
Next
EndIf
EndIf
If $aControlSize[2] <> $g_iAndroidClientWidth Or $aControlSize[3] <> $g_iAndroidClientHeight Then
If $RetryCount1 < 6 Then
For $i = 0 To 3
$asControlSize[$RetryCount1][$i] = $aControlSize[$i]
Next
EndIf
SetDebugLog($sPre & "Unsupported " & $g_sAndroidEmulator & " screen size of " & $aControlSize[2] & " x " & $aControlSize[3] & " at " & $aControlSize[0] & ", " & $aControlSize[1] & " (expect " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight & ")", $COLOR_ACTION)
Local $aAdj0 = [0, 0]
If $RetryCount1 = 0 And $RetryCount2 = 0 Then
Local $aWin = WinGetPos($g_hAndroidWindow)
If UBound($aWin) > 2 Then
Local $hCtrl = ControlGetHandle($g_hAndroidWindow, $g_sAppPaneName, $g_sAppClassInstance)
Local $fZoom =($g_iAndroidClientWidth / $aControlSize[2] + $g_iAndroidClientHeight / $aControlSize[3]) / 2
$aAdj0[0] = Int($aWin[2] * $fZoom) - $aWin[2]
$aAdj0[1] = Int($aWin[3] * $fZoom) - $aWin[3]
WinMove2($g_hAndroidWindow, "", $aWin[0], $aWin[1], $aWin[2] + $aAdj0[0], $aWin[3] + $aAdj0[1])
RedrawAndroidWindow()
$aControlSize = getAndroidPosWait($aControlSize)
EndIf
EndIf
Local $bExpectControlResize = True
Local $AndroidWinPos = WinGetPos($g_hAndroidWindow)
If UBound($AndroidWinPos) < 4 Then
Return
EndIf
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
Local $aAndroidWindow[2] = [$WinWidth, $WinHeight]
Local $aAdj = [$g_iAndroidClientWidth - $aControlSize[2], $g_iAndroidClientHeight - $aControlSize[3]]
Switch $RetryCount1
Case 0
Local $tRECT = _WinAPI_GetClientRect($g_hAndroidWindow)
If @error = 0 Then
$aAndroidWindow[0] = $g_iAndroidWindowWidth
$aAndroidWindow[1] = $g_iAndroidWindowHeight
$aAdj[0] = $WinWidth -(DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left"))
$aAdj[1] = $WinHeight -(DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))
Else
SetDebugLog($sPre & "WARNING: Cannot determine " & $g_sAndroidEmulator & " Window Client Area!", $COLOR_ERROR)
EndIf
Case 1
Case 2
$bExpectControlResize = False
If Abs($aControlSize[3] - $g_iAndroidClientHeight) = 0 Or Abs($aControlSize[2] - $g_iAndroidClientWidth) > 0 Then
$aAdj[1] = 0
$bWidthFirst = False
Else
$aAdj[0] = 0
$bWidthFirst = True
EndIf
Case 3
If $bWidthFirst = True Then
$aAdj[1] = 0
ElseIf $bWidthFirst = False Then
$aAdj[0] = 0
EndIf
Case 4
If CheckDpiAwareness(True) = False Then
CheckDpiAwareness(False, True)
AndroidDpiAwareness()
EndIf
Case 5
EndSwitch
$aAndroidWindow[0] += $aAdj[0]
$aAndroidWindow[1] += $aAdj[1]
SetDebugLog($sPre & $g_sAndroidTitle & " Adjusted Window Size: " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1] & " (by " & $aAdj[0] + $aAdj0[0] & ", " & $aAdj[1] + $aAdj0[1] & ")", $COLOR_INFO)
If $bExpectControlResize And $RetryCount1 < 6 Then
WinMove($g_hAndroidWindow, "", $AndroidWinPos[0], $AndroidWinPos[1], $aAndroidWindow[0] - 2, $aAndroidWindow[1] - 2)
$AndroidWinPos = WinGetPos($g_hAndroidWindow)
If UBound($AndroidWinPos) > 3 Then
$WinWidth = $AndroidWinPos[2]
$WinHeight = $AndroidWinPos[3]
EndIf
EndIf
If UBound($AndroidWinPos) > 3 Then
WinMove2($g_hAndroidWindow, "", $AndroidWinPos[0], $AndroidWinPos[1], $aAndroidWindow[0], $aAndroidWindow[1])
Local $aNewControlSize = getAndroidPos(True)
If UBound($aNewControlSize) > 2 Then
SetDebugLog($sPre & $g_sAndroidEmulator & " window resized to " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_SUCCESS)
RedrawAndroidWindow()
If $bExpectControlResize Then
$aNewControlSize = getAndroidPosWait($aControlSize, $aNewControlSize)
EndIf
If UBound($aNewControlSize) > 2 Then
$aControlSize = $aNewControlSize
If $aControlSize[2] <> $g_iAndroidClientWidth Or $aControlSize[3] <> $g_iAndroidClientHeight Then
If $bExpectControlResize = True Then
If $g_bDebugSetlog Then
SetDebugLog($sPre & $g_sAndroidEmulator & " window resize didn't work, screen is " & $aControlSize[2] & " x " & $aControlSize[3], $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " window resize didn't work, screen is " & $aControlSize[2] & " x " & $aControlSize[3], $COLOR_ERROR)
EndIf
If $RetryCount1 > 0 And $RetryCount1 < 6 And $RetryCount2 = 0 Then
Local $bXinc = $aControlSize[0] > $asControlSize[$RetryCount1][0] And $asControlSize[$RetryCount1][0] > $asControlSize[$RetryCount1 - 1][0]
Local $bYinc = $aControlSize[1] > $asControlSize[$RetryCount1][1] And $asControlSize[$RetryCount1][1] > $asControlSize[$RetryCount1 - 1][1]
If($bXinc And Not $bYinc) Or(Not $bXinc And $bYinc) Or($aControlSize[2] < $g_iAndroidClientWidth / 2 Or $aControlSize[2] > $g_iAndroidClientWidth * 1.5 Or $aControlSize[3] < $g_iAndroidClientHeight / 2 Or $aControlSize[3] > $g_iAndroidClientHeight * 1.5) Then
SetLog($g_sAndroidEmulator & " window cannot be resized, abort", $COLOR_ERROR)
Return $aControlSize
EndIf
EndIf
EndIf
If $RetryCount1 < 6 Then
Sleep(250)
Return getAndroidPos($FastCheck, $RetryCount1 + 1, $RetryCount2, $bWidthFirst)
EndIf
Else
$bResizedOk = True
EndIf
Else
If $RetryCount2 < 5 Then
Sleep(250)
Return getAndroidPos($FastCheck, $RetryCount1, $RetryCount2 + 1, $bWidthFirst)
EndIf
EndIf
Else
SetDebugLog($sPre & "WARNING: Cannot resize " & $g_sAndroidEmulator & " window to " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_ERROR)
EndIf
Else
If $RetryCount2 < 5 Then
Sleep(250)
Return getAndroidPos($FastCheck, $RetryCount1, $RetryCount2 + 1, $bWidthFirst)
EndIf
EndIf
ElseIf $RetryCount1 > 0 Or $RetryCount2 > 0 Then
$bResizedOk = True
EndIf
Else
SetDebugLog($sPre & "WARNING: Cannot resize " & $g_sAndroidEmulator & " window, control '" & $g_sAppClassInstance & "' not available", $COLOR_ERROR)
EndIf
If $bResizedOK Then
If $g_bDebugSetlog Then
SetDebugLog($sPre & $g_sAndroidEmulator & " window resized to work with MyBot", $COLOR_SUCCESS)
Else
SetLog($g_sAndroidEmulator & " window resized to work with MyBot", $COLOR_SUCCESS)
EndIf
EndIf
Return $aControlSize
EndFunc
Func getAndroidPosWait(ByRef $aControlSize, $aNewControlSize = 0)
If UBound($aNewControlSize) < 4 Then $aNewControlSize = getAndroidPos(True)
Local $hTimer = __TimerInit()
While __TimerDiff($hTimer) < 3000 And UBound($aNewControlSize) > 2 And($aControlSize[2] = $aNewControlSize[2] Or $aControlSize[3] = $aNewControlSize[3]) And $aNewControlSize[2] <> $g_iAndroidClientWidth And $aNewControlSize[3] <> $g_iAndroidClientHeight
Sleep($DELAYSLEEP)
$aNewControlSize = getAndroidPos(True)
WEnd
Return $aNewControlSize
EndFunc
Func UniversalCloseWaitOpenCoC($iWaitTime = 0, $sSource = "Unknown", $StopEmulator = False, $bFullRestart = False, $bSuspendComputer = False)
If $g_bDebugSetlog Then SetDebugLog("Begin UniversalCloseWaitOpenCoC:", $COLOR_DEBUG1)
Local $sWaitTime = ""
Local $iMin, $iSec, $iHour, $iWaitSec, $StopAndroidFlag
If $iWaitTime > 0 Then
$iWaitSec = Round($iWaitTime / 1000)
$iHour = Floor(Floor($iWaitSec / 60) / 60)
$iMin = Floor(Mod(Floor($iWaitSec / 60), 60))
$iSec = Floor(Mod($iWaitSec, 60))
If $iHour > 0 Then $sWaitTime &= $iHour & " hours "
If $iMin > 0 Then $sWaitTime &= $iMin & " minutes "
If $iSec > 0 Then $sWaitTime &= $iSec & " seconds "
EndIf
Local $msg = ""
Select
Case StringInStr($StopEmulator, "rand", $STR_NOCASESENSEBASIC)
$StopAndroidFlag = Random(0, 2, 1)
Switch $StopAndroidFlag
Case 0
$msg = " =Time out"
Case 1
$msg = " =Close CoC"
Case 2
$msg = " =Close Android"
Case Else
$msg = "One Bad Monkey Error!"
EndSwitch
SetLog("Random close option= " & $StopAndroidFlag & $msg, $COLOR_SUCCESS)
Case StringInStr($StopEmulator, "idle", $STR_NOCASESENSEBASIC)
$StopAndroidFlag = 0
Case $StopEmulator = False
$StopAndroidFlag = 1
Case $StopEmulator = True
$StopAndroidFlag = 2
Case Else
$StopAndroidFlag = 1
SetLog("Code Monkey provided bad stop emulator flag value", $COLOR_ERROR)
EndSelect
If $g_bDebugSetlog Then SetDebugLog("Stop Android flag : Input flag " & $StopAndroidFlag & " : " & $StopEmulator, $COLOR_DEBUG)
If _Sleep($DELAYRESPOND) Then Return False
Switch $StopAndroidFlag
Case 0
If $iWaitTime > 0 Then
SetLog("Going idle for " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
Local $hTimer = __TimerInit()
LockBotSlot(False)
If $bSuspendComputer Then SuspendComputer($iWaitTime)
If _SleepStatus($iWaitTime, True, True, True, $hTimer) Then Return False
LockBotSlot(True)
Else
If _SleepStatus($DELAYWAITNOPENCOC10000) Then Return False
EndIf
If _Sleep($DELAYRESPOND) Then Return False
OpenCoC()
Case 1
Local $bSendHome = False
If $bSendHome Then
AndroidHomeButton()
Else
PoliteCloseCoC($sSource)
EndIf
If _Sleep(3000) Then Return False
If $iWaitTime > 0 Then
If $iWaitTime > 30000 Then
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
EndIf
LockBotSlot(False)
WaitnOpenCoC($iWaitTime, $bFullRestart, $bSuspendComputer, True)
AndroidShieldForceDown(False)
If $g_bRunState = False Then Return False
Else
WaitnOpenCoC($DELAYWAITNOPENCOC10000, $bFullRestart)
EndIf
If _Sleep($DELAYRESPOND) Then Return False
If $iWaitTime > 30000 Then
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndIf
Case 2
PoliteCloseCoC($sSource)
If _Sleep(3000) Then Return False
CloseAndroid("UniversalCloseWaitOpenCoC")
ReduceBotMemory()
If $iWaitTime > 0 Then
SetLog("Waiting " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
If $iWaitTime > 30000 Then
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
EndIf
Local $hTimer = __TimerInit()
LockBotSlot(False)
If $bSuspendComputer Then SuspendComputer($iWaitTime)
If _SleepStatus($iWaitTime, True, True, True, $hTimer) Then Return False
LockBotSlot(True)
If $iWaitTime > 30000 Then
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndIf
Else
If _SleepStatus($DELAYWAITNOPENCOC10000) Then Return False
EndIf
StartAndroidCoC()
Case Else
SetLog("Code Monkey is drinking banana liqueur again!", $COLOR_ERROR)
EndSwitch
EndFunc
Func SuspendComputer($iMilliseconds)
SetDebugLog("Trying to suspend computer")
If $g_BotInstanceCount > 1 Then
SetLog($g_BotInstanceCount & " bot instances detected, will not suspend computer", $COLOR_ERROR)
Return False
EndIf
If SetWakeUpSeconds(Round($iMilliseconds / 1000, 0)) Then
AndroidAdbTerminateShellInstance()
KillAdbDaemon()
InitAndroidTimeLag()
SetLog("Suspend computer now", $COLOR_INFO)
CheckPostponedLog(True)
If SetSuspend() Then
Return True
EndIf
SetLog("Cannot suspend computer, error: " & @error & ", extended: " & @extended, $COLOR_ERROR)
Return False
EndIf
SetLog("Cannot set computer wakeup time, error: " & @error & ", extended: " & @extended, $COLOR_ERROR)
Return False
EndFunc
Global $g_aiAndroidEmbeddedGraphics[0][2]
Func GetCurrentAndroidHWnD()
Local $h =(($g_bAndroidEmbedded = False Or $g_iAndroidEmbedMode = 1) ? $g_hAndroidWindow : $g_hFrmBot)
Return $h
EndFunc
Func GetAndroidDisplayHWnD()
Local $h =(($g_bAndroidEmbedded = False) ? $g_hAndroidWindow : $g_hFrmBot)
Return $h
EndFunc
Func AndroidEmbed($Embed = True, $CallWinGetAndroidHandle = True, $bForceEmbed = False, $bNoAndroidScreenSizeCheck = False)
If $g_iGuiMode <> 1 Then Return False
If $g_bAndroidEmbed = False Then Return False
Return _AndroidEmbed($Embed, $CallWinGetAndroidHandle, $bForceEmbed, $bNoAndroidScreenSizeCheck)
EndFunc
Func _AndroidEmbed($Embed = True, $CallWinGetAndroidHandle = True, $bForceEmbed = False, $bNoAndroidScreenSizeCheck = False)
If($CallWinGetAndroidHandle = False And $g_hAndroidWindow = 0) Or($CallWinGetAndroidHandle = True And WinGetAndroidHandle() = 0) Then
SetDebugLog("Android Emulator not launched", $COLOR_ERROR)
If $g_bAndroidEmbedded = False Then
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Docked Android Window not available, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
If $g_bAndroidBackgroundLaunched = True Then
If $g_bAndroidEmbedded = False Then
SetDebugLog("Android Emulator launched in background mode", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Emulator launched in background mode, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $aPos = WinGetPos($g_hAndroidWindow)
If IsArray($aPos) = 0 Or @error <> 0 Then
If $g_bAndroidEmbedded = False Then
SetDebugLog("Android Window not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Window not accessible, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $hTimer = __TimerInit()
Do
Local $hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, GetAndroidControlClass())
Local $hCtrlTarget = _WinAPI_GetParent($hCtrl)
If $hCtrlTarget = 0 Then Sleep(10)
Until $hCtrlTarget <> 0 Or __TimerDiff($hTimer) > 3000
If $hCtrlTarget = 0 Then
If $g_bAndroidEmbedded = False Then
SetDebugLog("Android Control not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Control not available, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $aPosFrmBotEx, $aPosLog
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
Local $hCtrlTargetParent = $g_aiAndroidEmbeddedCtrlTarget[1]
Local $HWnDParent = $g_aiAndroidEmbeddedCtrlTarget[2]
Local $HWnD2 = $g_aiAndroidEmbeddedCtrlTarget[3]
Local $lCurStyle = $g_aiAndroidEmbeddedCtrlTarget[4]
Local $lCurExStyle = $g_aiAndroidEmbeddedCtrlTarget[5]
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $lCurStyleTarget = $g_aiAndroidEmbeddedCtrlTarget[8]
Local $hThumbnail = $g_aiAndroidEmbeddedCtrlTarget[9]
Local $targetIsHWnD = $hCtrlTarget = $g_hAndroidWindow
Local $botStyle = _WinAPI_GetWindowLong($g_hFrmBot, $GWL_STYLE)
Local $activeHWnD = WinGetHandle("")
Local $HWnD_available = WinGetHandle($g_hAndroidWindow) = $g_hAndroidWindow
If $Embed = False Then
If $g_bAndroidEmbedded = True Then
SetDebugLog("Undocking Android Control...")
If _WinAPI_IsIconic($g_hFrmBot) Then BotMinimize("_AndroidEmbed (1)", True)
If $g_bAndroidShieldEnabled = True Then
AndroidShield("AndroidEmbed undock", False, $CallWinGetAndroidHandle, 100)
If $g_hFrmBotEmbeddedShield Then
GUIDelete($g_hFrmBotEmbeddedShield)
$g_hFrmBotEmbeddedShield = 0
EndIf
If $g_hFrmBotEmbeddedMouse Then
GUIDelete($g_hFrmBotEmbeddedMouse)
$g_hFrmBotEmbeddedMouse = 0
EndIf
$g_avAndroidShieldStatus[0] = Default
EndIf
SetRedrawBotWindow(False, Default, Default, Default, "_AndroidEmbed")
If $hThumbnail <> 0 Then
_WinAPI_DwmUnregisterThumbnail($hThumbnail)
$g_aiAndroidEmbeddedCtrlTarget[9] = 0
EndIf
$aPos = $g_aiAndroidEmbeddedCtrlTarget[7]
$g_hProcShieldInput[3] = True
If $HWnD_available Then
Switch $g_iAndroidEmbedMode
Case 0
If $targetIsHWnD = False Then
_WinAPI_SetParent($hCtrlTarget, $hCtrlTargetParent)
_WinAPI_SetWindowLong($hCtrlTarget, $GWL_HWNDPARENT, $hCtrlTargetParent)
EndIf
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_SetParent($g_hAndroidWindow, $HWnDParent)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_HWNDPARENT, $HWnDParent)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $lCurStyle)
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3] - 1)
WinMove2($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
Case 1
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $lCurStyle)
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3] - 1)
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
EndSwitch
EndIf
WinMove(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3])
WinMove2(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
If $g_bDebugAndroidEmbedded Then SetDebugLog("Placed Android Control at " & $aPosCtl[0] & "," & $aPosCtl[1])
ControlHide($g_hGUI_LOG, "", $g_hDivider)
$aPosFrmBotEx = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)
If UBound($aPosFrmBotEx) < 4 Then
SetLog("Bot Window not available", $COLOR_ERROR)
$g_hProcShieldInput[3] = False
Return False
EndIf
ControlMove($g_hFrmBot, "", $g_hFrmBotEx, 0, 0, $aPosFrmBotEx[2], $aPosFrmBotEx[3] - $g_iFrmBotAddH)
ControlMove($g_hFrmBot, "", $g_hFrmBotBottom, 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP)
WinSetTrans($g_hFrmBotBottom, "", 255)
$aPosLog = ControlGetPos($g_hFrmBotEx, "", $g_hGUI_LOG)
ControlMove($g_hFrmBotEx, "", $g_hGUI_LOG, Default, Default, $aPosLog[2], $aPosLog[3] - $g_iFrmBotAddH)
$g_bAndroidEmbedded = False
WinMove2($g_hFrmBot, "", $g_iFrmBotPosX, $g_iFrmBotPosY, $g_aFrmBotPosInit[2], $g_aFrmBotPosInit[3] + $g_aFrmBotPosInit[7], $HWND_NOTOPMOST, 0, False)
updateBtnEmbed()
$g_iLogDividerY -= $g_iFrmBotAddH
$g_iFrmBotAddH = 0
cmbLog()
SetRedrawBotWindow(True, Default, Default, Default, "_AndroidEmbed")
If $HWnD_available Then
_SendMessage($g_hAndroidWindow, $WM_SETREDRAW, False, 0)
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_HIDE)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, BitOR($lCurExStyle, $WS_EX_APPWINDOW))
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_SHOWNOACTIVATE)
_SendMessage($g_hAndroidWindow, $WM_SETREDRAW, True, 0)
_WinAPI_UpdateWindow($g_hAndroidWindow)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_EnableWindow($g_hAndroidWindow, True)
_WinAPI_EnableWindow($hCtrlTarget, True)
WinMove2(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
WinMove($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
If $g_iAndroidEmbedMode = 1 Then
WinMove2($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3], $HWND_TOPMOST)
WinMove2($g_hAndroidWindow, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3], $HWND_NOTOPMOST, 0, False)
EndIf
If $bNoAndroidScreenSizeCheck = False Then
getBSPos()
EndIf
Execute("Embed" & $g_sAndroidEmulator & "(False)")
EndIf
SetDebugLog("Undocked Android Window")
$g_hProcShieldInput[3] = False
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_STYLE, $botStyle)
Return True
EndIf
updateBtnEmbed()
Return False
EndIf
If $g_bAndroidEmbedded = True And $bForceEmbed = False Then
If $g_hAndroidWindow = $HWnD2 Then
Local $a = AndroidEmbed_HWnD_Position()
If $targetIsHWnD = False Then
WinMove2($g_hAndroidWindow, "", $a[0], $a[1], -1, -1, $HWND_BOTTOM)
EndIf
Return False
EndIf
SetDebugLog("Docked Android Window gone", $COLOR_ERROR)
Return _AndroidEmbed(False)
EndIf
Local $bAlreadyEmbedded = $g_bAndroidEmbedded = True
SetDebugLog("Docking Android Control...")
If _WinAPI_DwmEnableComposition(True) = 1 Then
SetDebugLog("Desktop Window Manager available", $COLOR_SUCCESS)
Else
SetDebugLog("Desktop Window Manager not available!", $COLOR_ERROR)
SetDebugLog("Android Shield will be invisible!", $COLOR_ERROR)
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then BotMinimize("_AndroidEmbed (2)", True)
If _WinAPI_IsIconic($g_hAndroidWindow) Then WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
Switch $g_iAndroidEmbedMode
Case 0
Local $iBotDpiAware = GetProcessDpiAwareness(@AutoItPID)
If GetProcessDpiAwareness(GetAndroidPid()) And $iBotDpiAware = 0 And CheckDpiAwareness(True) = False Then
CheckDpiAwareness(False, True)
EndIf
If $iBotDpiAware Then
$g_hAndroidWindowDpiAware = $g_hAndroidWindow
EndIf
EndSwitch
If $bNoAndroidScreenSizeCheck = False Then getAndroidPos()
Local $hTimer = __TimerInit()
Do
$aPos = WinGetPos($g_hAndroidWindow)
If UBound($aPos) < 3 Then Sleep(10)
Until UBound($aPos) > 2 Or __TimerDiff($hTimer) > 3000
If UBound($aPos) < 3 Then
SetDebugLog("Android Window not accessible", $COLOR_ERROR)
updateBtnEmbed()
Return False
EndIf
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPos[] = " & $aPos[0] & ", " & $aPos[1] & ", " & $aPos[2] & ", " & $aPos[3], Default, True)
$lCurStyle = _WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_STYLE)
$lCurExStyle = _WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE)
$HWnDParent = __WinAPI_GetParent($g_hAndroidWindow)
$hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
$hCtrlTarget = __WinAPI_GetParent($hCtrl)
$targetIsHWnD = $hCtrlTarget = $g_hAndroidWindow
$lCurStyleTarget = _WinAPI_GetWindowLong($hCtrlTarget, $GWL_STYLE)
$hCtrlTargetParent = __WinAPI_GetParent($hCtrlTarget)
SetDebugLog("AndroidEmbed: $hCtrl=" & $hCtrl & ", $hCtrlTarget=" & $hCtrlTarget & ", $hCtrlTargetParent=" & $hCtrlTargetParent & ", $g_hAndroidWindow=" & $g_hAndroidWindow, Default, True)
Local $adjustPosCtrl = False
If $bAlreadyEmbedded = True Then
$g_hProcShieldInput[3] = True
Else
$aPosCtl = ControlGetPos($g_hAndroidWindow, "",($targetIsHWnD ? $hCtrl : $hCtrlTarget))
If UBound($aPosCtl) < 3 Then
SetDebugLog("Android Control Position not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
EndIf
If $aPosCtl[2] <> $g_iAndroidClientWidth Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosCtl[2] = " & $aPosCtl[2] & " changed to " & $g_iAndroidClientWidth, Default, True)
$aPosCtl[2] = $g_iAndroidClientWidth
EndIf
If $aPosCtl[3] <> $g_iAndroidClientHeight Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosCtl[3] = " & $aPosCtl[3] & " changed to " & $g_iAndroidClientHeight, Default, True)
$aPosCtl[3] = $g_iAndroidClientHeight
EndIf
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosCtl[] = " & $aPosCtl[0] & ", " & $aPosCtl[1] & ", " & $aPosCtl[2] & ", " & $aPosCtl[3], Default, True)
If $targetIsHWnD Then
Local $aPosParentCtl = $aPosCtl
$hCtrlTargetParent = $hCtrlTarget
ElseIf $hCtrlTargetParent = $g_hAndroidWindow Then
Local $aPosParentCtl = $aPosCtl
Else
$adjustPosCtrl = True
Local $aPosParentCtl = ControlGetPos($g_hAndroidWindow, "", $hCtrlTargetParent)
If $hCtrlTargetParent = 0 Or IsArray($aPosParentCtl) = 0 Or @error <> 0 Then
SetDebugLog("Android Parent Control not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
EndIf
EndIf
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosParentCtl[] = " & $aPosParentCtl[0] & ", " & $aPosParentCtl[1] & ", " & $aPosParentCtl[2] & ", " & $aPosParentCtl[3], Default, True)
Local $botClientHeight = $g_aFrmBotPosInit[5] - $g_aFrmBotPosInit[7]
$g_iFrmBotAddH = $aPosCtl[3] - $botClientHeight - $g_aFrmBotPosInit[7]
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $g_iFrmBotAddH = " & $g_iFrmBotAddH, Default, True)
If $g_iFrmBotAddH < 0 Then $g_iFrmBotAddH = 0
Local $g_hFrmBotWidth = $g_aFrmBotPosInit[2] + $aPosCtl[2] + 2
Local $g_hFrmBotHeight = $g_aFrmBotPosInit[3] + $g_iFrmBotAddH + $g_aFrmBotPosInit[7]
$g_hProcShieldInput[3] = True
$g_bAndroidEmbedded = True
If $g_iFrmBotDockedPosX = $g_WIN_POS_DEFAULT Or $g_iFrmBotDockedPosY = $g_WIN_POS_DEFAULT Then
If $g_iFrmBotPosX < $g_iAndroidPosX Then
$g_iFrmBotDockedPosX = $g_iFrmBotPosX
$g_iFrmBotDockedPosY = $g_iFrmBotPosY
Else
$g_iFrmBotDockedPosX = $g_iAndroidPosX
$g_iFrmBotDockedPosY = $g_iAndroidPosY
EndIf
EndIf
WinMove2($g_hFrmBot, "", $g_iFrmBotDockedPosX, $g_iFrmBotDockedPosY, -1, -1, 0, 0, False)
$aPosFrmBotEx = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)
$aPosFrmBotEx[3] = $g_aFrmBotPosInit[6]
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosFrmBotEx[] = " & $aPosFrmBotEx[0] & ", " & $aPosFrmBotEx[1] & ", " & $aPosFrmBotEx[2] & ", " & $aPosFrmBotEx[3], Default, True)
WinMove($g_hFrmBotEx, "", $aPosCtl[2] + 2, 0, $aPosFrmBotEx[2], $aPosFrmBotEx[3] + $g_iFrmBotAddH)
WinMove($g_hFrmBotBottom, "", $aPosCtl[2] + 2, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP + $g_iFrmBotAddH)
If $g_iAndroidEmbedMode = 0 Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM)
EndIf
_SendMessage($g_hFrmBot, $WM_SETREDRAW, False, 0)
Local $a = ControlGetRelativePos($g_hFrmBotEx, "", $g_hTabMain)
If UBound($a) > 3 Then
Local $ctrlResult = WinMove(GUICtrlGetHandle($g_hTabMain), "", $a[0], $a[1], $a[2], $a[3] + $g_iFrmBotAddH)
If $g_bDebugAndroidEmbedded Then SetDebugLog("Move $g_hTabMain Pos: " & $a[0] & ", " & $a[1] & ", " & $a[2] & ", " & $a[3] + $g_iFrmBotAddH & ": " & $ctrlResult)
EndIf
$aPosLog = ControlGetPos($g_hFrmBotEx, "", $g_hGUI_LOG)
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosLog[] = " & $aPosLog[0] & ", " & $aPosLog[1] & ", " & $aPosLog[2] & ", " & $aPosLog[3], Default, True)
WinMove($g_hGUI_LOG, "", $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, $aPosLog[2], $aPosLog[3] + $g_iFrmBotAddH)
WinMove2($g_hFrmBot, "", $g_iFrmBotDockedPosX, $g_iFrmBotDockedPosY, $g_hFrmBotWidth, $g_hFrmBotHeight,($g_bChkBackgroundMode ? $HWND_NOTOPMOST : $HWND_TOPMOST), 0, False)
$g_aiAndroidEmbeddedCtrlTarget[0] = $hCtrlTarget
$g_aiAndroidEmbeddedCtrlTarget[1] = $hCtrlTargetParent
$g_aiAndroidEmbeddedCtrlTarget[2] = $HWnDParent
$g_aiAndroidEmbeddedCtrlTarget[3] = $g_hAndroidWindow
$g_aiAndroidEmbeddedCtrlTarget[4] = $lCurStyle
$g_aiAndroidEmbeddedCtrlTarget[5] = $lCurExStyle
If $adjustPosCtrl = True Then
$aPosCtl[0] = $aPosParentCtl[0] - $aPosCtl[0]
$aPosCtl[1] = $aPosParentCtl[1] - $aPosCtl[1]
EndIf
$g_aiAndroidEmbeddedCtrlTarget[6] = $aPosCtl
$g_aiAndroidEmbeddedCtrlTarget[7] = $aPos
$g_aiAndroidEmbeddedCtrlTarget[8] = $lCurStyleTarget
EndIf
Local $newStyle = AndroidEmbed_GWL_STYLE()
SetDebugLog("AndroidEmbed_GWL_STYLE=" & Get_GWL_STYLE_Text($newStyle))
Local $a = AndroidEmbed_HWnD_Position()
Switch $g_iAndroidEmbedMode
Case 0
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, $WS_EX_MDICHILD)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $newStyle)
_WinAPI_SetParent($g_hAndroidWindow, $g_hFrmBot)
If $targetIsHWnD = False Then
_WinAPI_SetWindowLong($hCtrlTarget, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetParent($hCtrlTarget, $g_hFrmBot)
EndIf
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $newStyle)
If $targetIsHWnD = False Then
WinMove2($g_hAndroidWindow, "", $a[0], $a[1], -1, -1, $HWND_BOTTOM, 0, False)
EndIf
Case 1
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $newStyle)
WinMove2($g_hAndroidWindow, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_HIDE)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
_WinAPI_ShowWindow($g_hAndroidWindow, @SW_SHOWNOACTIVATE)
_SendMessage($g_hAndroidWindow, $WM_SETREDRAW, True, 0)
_WinAPI_UpdateWindow($g_hAndroidWindow)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
WinMove($g_hAndroidWindow, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3] - 1)
WinMove($g_hAndroidWindow, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3])
If $targetIsHWnD = False Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], 0, 0, False)
EndIf
If _WinAPI_DwmIsCompositionEnabled() And $hThumbnail = 0 Then
Local $iFix = 0
If $g_bCustomTitleBarActive = True Then $iFix = 1
$hThumbnail = _WinAPI_DwmRegisterThumbnail($g_hFrmBot, $g_hAndroidWindow)
Local $tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $iWidth = DllStructGetData($tSIZE, 1)
Local $iHeight = DllStructGetData($tSIZE, 2)
Local $tDestRect = _WinAPI_CreateRectEx(0 + $iFix, 0 + $iFix, $aPosCtl[2] + $iFix, $aPosCtl[3] + $iFix)
Local $tSrcRect = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
_WinAPI_DwmUpdateThumbnailProperties($hThumbnail, 1, 0, 255, $tDestRect, $tSrcRect)
$g_aiAndroidEmbeddedCtrlTarget[9] = $hThumbnail
EndIf
WinMove2($g_hAndroidWindow, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM, $SWP_SHOWWINDOW, False)
EndSwitch
Execute("Embed" & $g_sAndroidEmulator & "(True)")
updateBtnEmbed()
$g_iLogDividerY += $g_iFrmBotAddH
cmbLog()
_WinAPI_EnableWindow($hCtrlTarget, False)
_WinAPI_EnableWindow($g_hAndroidWindow, False)
Local $aCheck = WinGetPos($g_hAndroidWindow)
If IsArray($aCheck) Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: Android Window Pos: " & $aCheck[0] & ", " & $aCheck[1] & ", " & $aCheck[2] & ", " & $aCheck[3], Default, True)
Else
SetDebugLog("AndroidEmbed: Android Window not found", $COLOR_ERROR)
EndIf
Local $aCheck = ControlGetPos(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
If IsArray($aCheck) Then
If $g_bDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: Android Control Pos: " & $aCheck[0] & ", " & $aCheck[1] & ", " & $aCheck[2] & ", " & $aCheck[3], Default, True)
Else
SetDebugLog("AndroidEmbed: Android Control not found", $COLOR_ERROR)
EndIf
If $bNoAndroidScreenSizeCheck = False Then
getBSPos()
EndIf
_SendMessage($g_hFrmBot, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($g_hFrmBot, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN + $RDW_ERASE)
_WinAPI_RedrawWindow($g_hFrmBotBottom, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN + $RDW_ERASE)
_WinAPI_UpdateWindow($g_hFrmBot)
_WinAPI_UpdateWindow($g_hFrmBotBottom)
If $g_iAndroidEmbedMode = 0 Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2] - 1, $aPosCtl[3] - 1, $HWND_BOTTOM, 0, False)
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM, 0, False)
If $targetIsHWnD Then
WinMove2($hCtrl, "", 0, 0, $aPosCtl[2] - 1, $aPosCtl[3] - 1, $HWND_BOTTOM)
WinMove2($hCtrl, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM)
EndIf
EndIf
SetDebugLog("Android Window docked")
$g_hProcShieldInput[3] = False
$g_hProcShieldInput[4] = 0
_WinAPI_RedrawWindow($g_hFrmBot, 0, 0, BitOR($RDW_FRAME, $RDW_UPDATENOW, $RDW_INVALIDATE))
AndroidShield("AndroidEmbed dock", Default, $CallWinGetAndroidHandle, 100)
If $g_bBotLaunchOption_HideAndroid Then
BotMinimizeRequest()
EndIf
Return True
EndFunc
Func Get_GWL_STYLE_Text($iGWL_STYLE)
Local $s = ""
Local $a[20][2] = [[$WS_MAXIMIZEBOX, "$WS_MAXIMIZEBOX"] , [$WS_MINIMIZEBOX, "$WS_MINIMIZEBOX"] , [$WS_TABSTOP, "$WS_TABSTOP"] , [$WS_GROUP, "$WS_GROUP"] , [$WS_SIZEBOX, "$WS_SIZEBOX"] , [$WS_SYSMENU, "$WS_SYSMENU"] , [$WS_HSCROLL, "$WS_HSCROLL"] , [$WS_VSCROLL, "$WS_VSCROLL"] , [$WS_DLGFRAME, "$WS_DLGFRAME"] , [$WS_BORDER, "$WS_BORDER"] , [$WS_CAPTION, "$WS_CAPTION"] , [$WS_MAXIMIZE, "$WS_MAXIMIZE"] , [$WS_CLIPCHILDREN, "$WS_CLIPCHILDREN"] , [$WS_CLIPSIBLINGS, "$WS_CLIPSIBLINGS"] , [$WS_DISABLED, "$WS_DISABLED"] , [$WS_VISIBLE, "$WS_VISIBLE"] , [$WS_MINIMIZE, "$WS_MINIMIZE"] , [$WS_CHILD, "$WS_CHILD"] , [$WS_POPUP, "$WS_POPUP"] , [$WS_POPUPWINDOW, "$WS_POPUPWINDOW"] ]
Local $i
For $i = 0 To UBound($a) - 1
If BitAND($iGWL_STYLE, $a[$i][0]) > 0 Then
If $s <> "" Then $s &= ", "
$s &= $a[$i][1]
$iGWL_STYLE -= $a[$i][0]
EndIf
Next
If $iGWL_STYLE > 0 Then
If $s <> "" Then $s &= ","
$s &= Hex($iGWL_STYLE, 8)
EndIf
Return $s
EndFunc
Func AndroidEmbed_GWL_STYLE()
If $g_bAndroidEmbedded = True Then
Local $lCurStyle = $g_aiAndroidEmbeddedCtrlTarget[4]
Local $newStyle = BitOR($WS_CHILD, BitAND($lCurStyle, BitNOT(BitOR($WS_POPUP, $WS_CAPTION, $WS_SYSMENU, $WS_MINIMIZEBOX, $WS_MAXIMIZEBOX, $WS_SIZEBOX, $WS_BORDER, $WS_THICKFRAME))))
If $g_iAndroidEmbedMode = 1 Then
$newStyle = BitOR($WS_POPUP, BitAND($newStyle, BitNOT($WS_CHILD)))
EndIf
Return $newStyle
EndIf
Return ""
EndFunc
Func AndroidEmbed_HWnD_Position($bForShield = False, $bDetachedShield = Default, $hCtrlTarget = Default, $aPosCtl = Default)
Local $aPos[2]
If $bDetachedShield = Default Then
$bDetachedShield = $g_avAndroidShieldStatus[4]
EndIf
If $g_iAndroidEmbedMode = 1 Or($bForShield = True And $bDetachedShield = True) Then
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", 0)
DllStructSetData($tPoint, "Y", 0)
_WinAPI_ClientToScreen($g_hFrmBot, $tPoint)
$aPos[0] = DllStructGetData($tPoint, "X")
$aPos[1] = DllStructGetData($tPoint, "Y")
$tPoint = 0
ElseIf $g_iAndroidEmbedMode = 0 And $bForShield = False Then
If $hCtrlTarget = Default Then
$hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
EndIf
If $aPosCtl = Default Then
$aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
EndIf
Local $targetIsHWnD = $hCtrlTarget = $g_hAndroidWindow
If $targetIsHWnD = False Then
$aPos[0] = 0
If $g_bAndroidEmbeddedWindowZeroPosition Then
$aPos[1] = 0
Else
$aPos[1] = $aPosCtl[3]
EndIf
Else
$aPos[0] = 0
$aPos[1] = 0
EndIf
ElseIf $bForShield = True And($bDetachedShield = False Or $bDetachedShield = Default) Then
$aPos[0] = 0
$aPos[1] = 0
Else
SetDebugLog("AndroidEmbed_HWnD_Position: Wrong window state:" & @CRLF & "$bForShield=" & $bForShield & @CRLF & "$g_iAndroidEmbedMode=" & $g_iAndroidEmbedMode & @CRLF & "$bDetachedShield=" & $bDetachedShield)
EndIf
Return $aPos
EndFunc
Func AndroidEmbedCheck($bTestIfRequired = Default, $bHasFocus = Default, $iAction = 6)
If $g_bFrmBotMinimized Then $bHasFocus = False
If $bHasFocus = Default Then $bHasFocus = WinActive($g_hFrmBot) <> 0
If $bTestIfRequired = Default Then
$iAction = AndroidEmbedCheck(True, $bHasFocus)
If $iAction = 0 Then
Return 0
EndIf
$bTestIfRequired = False
EndIf
If $g_bAndroidEmbedded = True And AndroidEmbedArrangeActive() = False Then
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $aPos = AndroidEmbed_HWnD_Position()
Local $aPosShield = AndroidEmbed_HWnD_Position(True)
Local $newStyle = AndroidEmbed_GWL_STYLE()
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
If $bTestIfRequired = False Then
SetDebugLog("AndroidEmbedCheck: $iAction=" & $iAction, Default, True)
If BitAND($iAction, 2) > 0 Then
AndroidEmbedArrangeActive(True)
_WinAPI_SetWindowLong($g_hAndroidWindow, $GWL_STYLE, $newStyle)
AndroidEmbed(True, False, True)
EndIf
If BitAND($iAction, 1) Or BitAND($iAction, 4) > 0 Then
WinMove2($g_hAndroidWindow, "", $aPos[0], $aPos[1], -1, -1, $HWND_BOTTOM, 0, True)
EndIf
If $g_bAndroidShieldEnabled = True And $bDetachedShield = True Then
If BitAND($iAction, 1) > 0 Or BitAND($iAction, 4) > 0 Then
If BitAND($iAction, 4) > 0 Then
WinMove2($g_hFrmBotEmbeddedShield, "", $aPosShield[0], $aPosShield[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
If $g_hFrmBotEmbeddedGraphics Then
WinMove2($g_hFrmBotEmbeddedGraphics, "", $aPosShield[0], $aPosShield[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
EndIf
EndIf
CheckBotZOrder()
EndIf
EndIf
Return True
EndIf
Local $iZorder = 0
If $g_bAndroidShieldEnabled = True And $bDetachedShield = True And $bHasFocus = False Then
If CheckBotZOrder(True) Then
$iZorder = 1
EndIf
EndIf
Local $style = _WinAPI_GetWindowLong($g_hAndroidWindow, $GWL_STYLE)
If BitAND($style, $WS_DISABLED) > 0 Then $newStyle = BitOR($newStyle, $WS_DISABLED)
If BitAND($style, $WS_MAXIMIZEBOX) > 0 Then $newStyle = BitOR($newStyle, $WS_MAXIMIZEBOX)
Local $iStyle =(($style <> $newStyle) ? 2 : 0)
If $iStyle > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Window GWL_STYLE changed: " & Get_GWL_STYLE_Text($newStyle) & " to " & Get_GWL_STYLE_Text($style), Default, True)
EndIf
Local $a1[2] = [$aPos[0], $aPos[1]]
Local $a2 = $aPos
Switch $g_iAndroidEmbedMode
Case 0
Local $a1 = ControlGetPos($g_hFrmBot, "", $g_hAndroidWindow)
Case 1
Local $a1 = WinGetPos($g_hAndroidWindow)
EndSwitch
Local $iPos =((IsArray($a1) And($a1[0] <> $a2[0] Or $a1[1] <> $a2[1])) ? 4 : 0)
If $iPos > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Window Position changed: X: " & $a1[0] & " <> " & $a2[0] & ", Y: " & $a1[1] & " <> " & $a2[1], Default, True)
EndIf
If $iPos = 0 And $bDetachedShield = True Then
$a1 = WinGetPos($g_hFrmBotEmbeddedShield)
$a2 = $aPosShield
$iPos =((IsArray($a1) And($a1[0] <> $a2[0] Or $a1[1] <> $a2[1])) ? 4 : 0)
If $iPos > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Shield Position changed: X: " & $a1[0] & " <> " & $a2[0] & ", Y: " & $a1[1] & " <> " & $a2[1], Default, True)
EndIf
EndIf
Return BitOR($iZorder, $iStyle, $iPos)
EndIf
Return 0
EndFunc
Func AndroidEmbedded()
Return $g_bAndroidEmbedded
EndFunc
Func AndroidEmbedArrangeActive($bActive = Default)
If $bActive = Default Then Return $g_hProcShieldInput[3]
Local $bWasActive = $g_hProcShieldInput[3]
$g_hProcShieldInput[3] = $bActive
Return $bWasActive
EndFunc
Func AndroidShieldStartup()
_OnAutoItErrorRegister()
EndFunc
Func AndroidShieldDestroy()
_OnAutoItErrorUnRegister()
EndFunc
Func AndroidShieldForceDown($bForceDown = True, $AndroidHasFocus = False)
Local $wasDown = $g_bAndroidShieldForceDown
$g_bAndroidShieldForceDown = $bForceDown
AndroidShield("AndroidShieldForceDown", Default, True, 0, $AndroidHasFocus)
Return $wasDown
EndFunc
Func AndroidShieldForcedDown()
Return $g_bAndroidShieldForceDown
EndFunc
Func AndroidShieldHasFocus()
Return $g_hProcShieldInput[2] = True
EndFunc
Func AndroidShielded()
Return $g_avAndroidShieldStatus[0] = True
EndFunc
Func AndroidShieldActiveDelay($bIsStillWaiting = False)
Return $g_avAndroidShieldDelay[0] <> 0 And $g_avAndroidShieldDelay[1] > 0 And($bIsStillWaiting = False Or __TimerDiff($g_avAndroidShieldDelay[0]) < $g_avAndroidShieldDelay[1])
EndFunc
Func AndroidShieldCheck()
If AndroidShieldActiveDelay(True) = True Then Return False
Return AndroidShield("AndroidShieldCheck")
EndFunc
Func AndroidShieldLock($Lock = Default)
If $Lock = Default Then Return $g_hProcShieldInput[3]
Local $wasLock = $g_hProcShieldInput[3]
$g_hProcShieldInput[3] = $Lock
Return $wasLock
EndFunc
Func AndroidShield($sCaller, $Enable = Default, $CallWinGetAndroidHandle = True, $iDelay = 0, $AndroidHasFocus = Default, $AndroidUpdateFocus = True)
If $g_bAndroidShieldEnabled = False Or $g_hProcShieldInput[3] = True Then Return False
If $iDelay > 0 Then
Return _AndroidShield($sCaller, $Enable, $CallWinGetAndroidHandle, $iDelay, $AndroidHasFocus, $AndroidUpdateFocus)
EndIf
Return _AndroidShield($sCaller, $Enable, $CallWinGetAndroidHandle, $iDelay, $AndroidHasFocus, $AndroidUpdateFocus)
EndFunc
Func _AndroidShield($sCaller, $Enable = Default, $CallWinGetAndroidHandle = True, $iDelay = 0, $AndroidHasFocus = Default, $AndroidUpdateFocus = True)
Local $bForceUpdate = False
If AndroidShieldActiveDelay() Then
If AndroidShieldActiveDelay(True) = False Then
If $Enable = Default Then $Enable = $g_avAndroidShieldDelay[2]
If $AndroidHasFocus = Default Then $AndroidHasFocus = $g_avAndroidShieldDelay[3]
Else
If $iDelay = 0 Then
If $Enable <> Default Then $g_avAndroidShieldDelay[2] = $Enable
If $AndroidHasFocus <> Default Then $g_avAndroidShieldDelay[3] = $AndroidHasFocus
Return False
EndIf
EndIf
EndIf
If $iDelay > 0 Then
$g_avAndroidShieldDelay[0] = __TimerInit()
$g_avAndroidShieldDelay[1] = $iDelay
$g_avAndroidShieldDelay[2] = $Enable
$g_avAndroidShieldDelay[3] = $AndroidHasFocus
Return False
EndIf
$g_avAndroidShieldDelay[0] = 0
$g_avAndroidShieldDelay[1] = 0
$g_avAndroidShieldDelay[2] = Default
$g_avAndroidShieldDelay[3] = Default
If $Enable = Default Then
$Enable = $g_bRunState And $g_bBotPaused = False
If $g_bAndroidShieldForceDown Then $Enable = False
EndIf
If $AndroidHasFocus = Default Then
$AndroidHasFocus = AndroidShieldHasFocus()
Else
If $AndroidUpdateFocus Then $g_hProcShieldInput[2] = $AndroidHasFocus
EndIf
Local $shieldState = "active"
Local $color = $g_iAndroidShieldColor
Local $trans = $g_iAndroidShieldTransparency
If $Enable = False Or $g_bBotPaused = True Then
If _WinAPI_GetActiveWindow() = $g_hFrmBot And $AndroidHasFocus Then
$shieldState = "disabled-focus"
$color = $g_iAndroidActiveColor
$trans = $g_iAndroidActiveTransparency
SetAccelerators(True)
Else
$shieldState = "disabled-nofocus"
$color = $g_iAndroidInactiveColor
$trans = $g_iAndroidInactiveTransparency
SetAccelerators(False)
EndIf
Else
SetAccelerators(False)
EndIf
Local $bNoVisibleShield = $g_bChkBackgroundMode = False
Local $bDetachedShield = $bNoVisibleShield = False And($g_bAndroidShieldPreWin8 = True Or $g_iAndroidEmbedMode = 1)
Local $bCreateShield = Not($bNoVisibleShield And($g_bAndroidShieldPreWin8 = True Or $g_iAndroidEmbedMode = 1))
If $g_bAndroidEmbedded = False Then
Return False
EndIf
If $g_bAndroidBackgroundLaunched = True Then
Return False
EndIf
If $bForceUpdate = False And $g_avAndroidShieldStatus[0] = $Enable And $g_avAndroidShieldStatus[1] = $color And $g_avAndroidShieldStatus[2] = $trans And $g_avAndroidShieldStatus[3] = $bNoVisibleShield And $g_avAndroidShieldStatus[4] = $bDetachedShield Then
Return False
EndIf
If($CallWinGetAndroidHandle = False And $g_hAndroidWindow = 0) Or($CallWinGetAndroidHandle = True And WinGetAndroidHandle() = 0) Then
Return False
EndIf
Local $aPos = WinGetPos($g_hAndroidWindow)
If IsArray($aPos) = 0 Or @error <> 0 Then
Return False
EndIf
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
If $g_hFrmBotEmbeddedShield <> 0 And($g_avAndroidShieldStatus[3] <> $bNoVisibleShield Or $g_avAndroidShieldStatus[4] <> $bDetachedShield) Then
GUIDelete($g_hFrmBotEmbeddedShield)
$g_hFrmBotEmbeddedShield = 0
EndIf
$g_hProcShieldInput[3] = True
Local $show_shield = @SW_SHOWNOACTIVATE
If $bCreateShield And($Enable <> $g_avAndroidShieldStatus[0] Or $g_hFrmBotEmbeddedShield = 0) Then
If $bDetachedShield = False Then
If $g_hFrmBotEmbeddedShield = 0 Then
$g_hFrmBotEmbeddedShield = GUICreate("", $aPosCtl[2], $aPosCtl[3], 0, 0, BitOR($WS_CHILD, $WS_TABSTOP),($bNoVisibleShield ? $WS_EX_TRANSPARENT : 0), $g_hFrmBot)
Else
WinMove($g_hFrmBotEmbeddedShield, "", 0, 0, $aPosCtl[2], $aPosCtl[3])
EndIf
WinMove2($hCtrlTarget, "", -1, -1, -1, -1, $HWND_BOTTOM)
Else
Local $bHasFocus = WinActive($g_hFrmBot) <> 0
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
If $g_hFrmBotEmbeddedShield = 0 Then
$g_hFrmBotEmbeddedShield = GUICreate("", $aPosCtl[2], $aPosCtl[3], $a[0], $a[1], BitOR($WS_POPUP, $WS_TABSTOP), BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_TRANSPARENT), $g_hFrmBot)
_WinAPI_EnableWindow($g_hFrmBotEmbeddedShield, False)
GUISetOnEvent($GUI_EVENT_PRIMARYDOWN, "BotMoveRequest")
$g_hFrmBotEmbeddedMouse = GUICreate("", $aPosCtl[2], $aPosCtl[3], 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), $WS_EX_TRANSPARENT, $g_hFrmBot)
EndIf
If $g_bBotDockedShrinked And Not $bHasFocus Then WinMove2($g_hFrmBotButtons, "", -1, -1, -1, -1, $HWND_BOTTOM, 0, False)
WinMove2($g_hFrmBotEmbeddedShield, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3],($bHasFocus ? -1 : $HWND_BOTTOM), 0, False)
WinMove2($g_hFrmBotEmbeddedMouse, "", 0, 0, $aPosCtl[2], $aPosCtl[3],($bHasFocus ? -1 : $HWND_BOTTOM), 0, False)
WinMove2($hCtrlTarget, "", -1, -1, -1, -1, $HWND_BOTTOM)
SetDebugLog("$g_hFrmBotEmbeddedShield Position: " & $a[0] & ", " & $a[1] & ", " & $aPosCtl[2] & ", " & $aPosCtl[3], Default, True)
EndIf
EndIf
If $bNoVisibleShield = False Then
WinSetTrans($g_hFrmBotEmbeddedShield, "", $trans)
GUISetBkColor($color, $g_hFrmBotEmbeddedShield)
EndIf
GUISetState($show_shield, $g_hFrmBotEmbeddedShield)
GUISetState($show_shield, $g_hFrmBotEmbeddedMouse)
If $g_bBotDockedShrinked Then GUISetState($show_shield, $g_hFrmBotButtons)
$g_hProcShieldInput[3] = False
$g_avAndroidShieldStatus[0] = $Enable
$g_avAndroidShieldStatus[1] = $color
$g_avAndroidShieldStatus[2] = $trans
$g_avAndroidShieldStatus[3] = $bNoVisibleShield
$g_avAndroidShieldStatus[4] = $bDetachedShield
AndroidShieldStartup()
HandleWndProc($shieldState = "disabled-focus")
CheckBotZOrder()
SetDebugLog("AndroidShield updated to " & $shieldState & "(handle=" & $g_hFrmBotEmbeddedShield & ", color=" & Hex($color, 6) & "), caller: " & $sCaller, Default, True)
Return True
EndFunc
Func AndroidGraphicsGdiBegin()
If $g_bAndroidEmbedded = False Then Return 0
AndroidGraphicsGdiEnd()
Local $wasDown = AndroidShieldForcedDown()
AndroidShieldForceDown(False)
AndroidShield("AndroidGraphicsGdiBegin", True, True, 0, False)
Local $iL = 0
Local $iT = 0
Local $iW = $g_iAndroidClientWidth
Local $iH = $g_iAndroidClientHeight
Local $iOpacity = 255
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
If IsArray($aPosCtl) = 1 Then
$iW = $aPosCtl[2]
$iH = $aPosCtl[3]
EndIf
Local $a = [0, 0]
If $g_hFrmBotEmbeddedGraphics = 0 Then
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
If $bDetachedShield = True Then
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
$iL = $a[0]
$iT = $a[1]
EndIf
$g_hFrmBotEmbeddedGraphics = GUICreate("", $iW, $iH, $iL, $iT, $WS_CHILD, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_LAYERED, $WS_EX_TOPMOST), $g_hFrmBot)
EndIf
WinMove2($g_hFrmBotEmbeddedGraphics, "", $iW, $iH, $iL, $iT, $HWND_NOTOPMOST, 0, False)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotEmbeddedGraphics)
Local $hDC = _WinAPI_GetDC($g_hFrmBotEmbeddedGraphics)
Local $hMDC = AndroidGraphicsGdiAddObject("hMDC", _WinAPI_CreateCompatibleDC($hDC))
Local $hBitmap = AndroidGraphicsGdiAddObject("hBitmap", _WinAPI_CreateCompatibleBitmap($hDC, $iW, $iH))
_WinAPI_SelectObject($hMDC, $hBitmap)
AndroidGraphicsGdiAddObject("hDC", $hDC)
Local $hGraphics = AndroidGraphicsGdiAddObject("Graphics", _GDIPlus_GraphicsCreateFromHDC($hMDC))
_GDIPlus_GraphicsSetSmoothingMode($hGraphics, $GDIP_SMOOTHINGMODE_HIGHQUALITY)
_GDIPlus_GraphicsClear($hGraphics)
Local $tSIZE = DllStructCreate($tagSIZE)
AndroidGraphicsGdiAddObject("DllStruct", $tSIZE)
Local $pSize = DllStructGetPtr($tSIZE)
DllStructSetData($tSIZE, "X", $iW)
DllStructSetData($tSIZE, "Y", $iH)
Local $tSource = DllStructCreate($tagPOINT)
AndroidGraphicsGdiAddObject("DllStruct", $tSource)
Local $pSource = DllStructGetPtr($tSource)
Local $tBlend = DllStructCreate($tagBLENDFUNCTION)
AndroidGraphicsGdiAddObject("DllStruct", $tBlend)
Local $pBlend = DllStructGetPtr($tBlend)
DllStructSetData($tBlend, "Alpha", $iOpacity)
DllStructSetData($tBlend, "Format", 1)
Local $tPoint = DllStructCreate($tagPOINT)
AndroidGraphicsGdiAddObject("DllStruct", $tPoint)
Local $pPoint = DllStructGetPtr($tPoint)
DllStructSetData($tPoint, "X", $a[0])
DllStructSetData($tPoint, "Y", $a[1])
AndroidGraphicsGdiUpdate()
SetDebugLog("AndroidGraphicsGdiBegin: Graphics " & $hGraphics)
AndroidShieldForceDown($wasDown)
Return $hGraphics
EndFunc
Func AndroidGraphicsGdiUpdate()
If $g_bAndroidEmbedded = False Then Return 0
Local $hMDC = $g_aiAndroidEmbeddedGraphics[0][1]
Local $hDC = $g_aiAndroidEmbeddedGraphics[2][1]
Local $pSize = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[4][1])
Local $pSource = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[5][1])
Local $pBlend = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[6][1])
Local $pPoint = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[7][1])
Local $tPoint = DllStructCreate($tagPOINT, $pPoint)
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
DllStructSetData($tPoint, "X", $a[0])
DllStructSetData($tPoint, "Y", $a[1])
_WinAPI_UpdateLayeredWindow($g_hFrmBotEmbeddedGraphics, $hDC, $pPoint, $pSize, $hMDC, $pSource, 0, $pBlend, $ULW_ALPHA)
EndFunc
Func AndroidGraphicsGdiAddObject($sType, $hHandle)
If $g_bAndroidEmbedded = False Then Return 0
Local $i = UBound($g_aiAndroidEmbeddedGraphics)
ReDim $g_aiAndroidEmbeddedGraphics[$i + 1][2]
$g_aiAndroidEmbeddedGraphics[$i][0] = $sType
$g_aiAndroidEmbeddedGraphics[$i][1] = $hHandle
SetDebugLog("AndroidGraphicsGdiAddObject: " & $sType & " " & $hHandle)
Return $hHandle
EndFunc
Func AndroidGraphicsGdiEnd($Result = Default, $bClear = True)
If UBound($g_aiAndroidEmbeddedGraphics) > 0 Then
Local $i
For $i = UBound($g_aiAndroidEmbeddedGraphics) - 1 To 0 Step -1
Local $sType = $g_aiAndroidEmbeddedGraphics[$i][0]
Local $hHandle = $g_aiAndroidEmbeddedGraphics[$i][1]
If $hHandle <> 0 Then
SetDebugLog("AndroidGraphicsGdiEnd: Dispose/release/delete " & $sType & " " & $hHandle)
Switch $sType
Case "Pen"
_GDIPlus_PenDispose($hHandle)
Case "DllStruct"
Case "Graphics"
_GDIPlus_GraphicsClear($hHandle)
AndroidGraphicsGdiUpdate()
_GDIPlus_GraphicsDispose($hHandle)
Case "hDC"
_WinAPI_ReleaseDC($g_hFrmBotEmbeddedGraphics, $hHandle)
Case "hBitmap"
_WinAPI_DeleteObject($hHandle)
Case "hMDC"
_WinAPI_DeleteDC($hHandle)
Case Else
SetDebugLog("Unknown GDI Type: " & $sType)
EndSwitch
EndIf
Next
ReDim $g_aiAndroidEmbeddedGraphics[0][2]
If $g_hFrmBotEmbeddedGraphics <> 0 Then
GUIDelete($g_hFrmBotEmbeddedGraphics)
$g_hFrmBotEmbeddedGraphics = 0
EndIf
EndIf
Return $Result
EndFunc
Func AndroidDpiAwareness($bCheckAwareness = Default)
If $bCheckAwareness = Default Then $bCheckAwareness = False
If $g_hAndroidWindowDpiAware = $g_hAndroidWindow Or GetProcessDpiAwareness(GetAndroidPid()) Then
$g_hAndroidWindowDpiAware = $g_hAndroidWindow
If $bCheckAwareness = True Then Return True
Return False
EndIf
If CheckDpiAwareness(True) = True Then
If $g_hAndroidWindowDpiAware <> $g_hAndroidWindow Then
Local $bWasEmbedded = AndroidEmbedded()
AndroidEmbed(True, False, False, True)
AndroidEmbed(False, False, False, True)
Return True
EndIf
EndIf
Return False
EndFunc
Func WerFaultClose($programFile, $tryCountMax = 10, $tryCount = 0)
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $sTitle = $programFile
Local $iLastBS = StringInStr($sTitle, "\", 0, -1)
If $iLastBS > 0 Then $sTitle = StringMid($sTitle, $iLastBS + 1)
Local $aList = WinList($sTitle)
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Local $closed = 0
Local $i
SetDebugLog("Found " & $aList[0][0] & " WerFault Windows with title '" & $sTitle & "'")
If $aList[0][0] > 0 Then
For $i = 1 To $aList[0][0]
Local $HWnD = $aList[$i][1]
Local $pid = WinGetProcess($HWnD)
Local $process = ProcessGetWmiProcess($pid)
If IsArray($process) Then
Local $werfault = $process[1]
$iLastBS = StringInStr($werfault, "\", 0, -1)
$werfault = StringMid($werfault, $iLastBS + 1)
If $werfault = "WerFault.exe" Then
SetDebugLog("Found WerFault Process " & $pid)
If WinClose($HWnD) Then
SetDebugLog("Closed " & $werfault & " Window " & $HWnD)
$closed += 1
Else
If WinKill($HWnD) Then
SetDebugLog("Killed " & $werfault & " Window " & $HWnD)
$closed += 1
Else
SetDebugLog("Cannot close " & $werfault & " Window " & $HWnD, $COLOR_ERROR)
EndIf
EndIf
Else
SetDebugLog("Process " & $pid & " is not WerFault, " & $process[2], $COLOR_ERROR)
EndIf
ELse
SetDebugLog("Wmi Object for process " & $pid & " not found")
EndIF
Next
ElseIf FileExists($programFile) = 1 Then
Local $pFileVersionInfo
If _WinAPI_GetFileVersionInfo($programFile, $pFileVersionInfo) Then
Local $aFileDescription = _WinAPI_VerQueryValue($pFileVersionInfo, $FV_FILEDESCRIPTION)
If UBound($aFileDescription) > 1 And UBound($aFileDescription, 2) > 1 Then
Local $sFileDescription = $aFileDescription[1][1]
If $sFileDescription Then Return WerFaultClose($sFileDescription, $tryCountMax, $tryCount)
EndIf
EndIf
EndIf
If $closed > 0 And $tryCount < $tryCountMax Then
If _Sleep(1000) = False Then
$closed += WerFaultClose($programFile, $tryCountMax, $tryCount + 1)
EndIF
EndIf
Return $closed
EndFunc
Func _TcpTable($idx = Default, $sValue = Default)
Local $aTcpTable = _CV_GetExtendedTcpTable()
If $idx = Default Or $sValue = Default Then Return $aTcpTable
Local $aTcpTableFiltered[0][UBound($aTcpTable, 2)]
_ArrayAdd($aTcpTableFiltered, _ArrayToString($aTcpTable, Default, 0, 0))
For $i = 1 To UBound($aTcpTable) -1
If $aTcpTable[$i][$idx] = $sValue Then _ArrayAdd($aTcpTableFiltered, _ArrayToString($aTcpTable, Default, $i, $i))
Next
Return $aTcpTableFiltered
EndFUnc
Func _CV_GetExtendedTcpTable()
Local $aCall = DllCall("iphlpapi.dll", "dword", "GetExtendedTcpTable", "ptr*", 0, "dword*", 0, "int", 1, "dword", 2, "dword", 5, "dword", 0)
If @error Then
Return SetError(1, 0, 0)
EndIf
If $aCall[0] <> 122 Then
Return SetError(2, 0, 0)
EndIf
Local $iSize = $aCall[2]
Local $tByteStructure = DllStructCreate("byte[" & $iSize & "]")
$aCall = DllCall("iphlpapi.dll", "dword", "GetExtendedTcpTable", "ptr", DllStructGetPtr($tByteStructure), "dword*", $iSize, "int", 1, "dword", 2, "dword", 5, "dword", 0)
If @error Or $aCall[0] Then
Return SetError(3, 0, 0)
EndIf
Local $tMIB_TCPTABLE_OWNER_PID_DWORDS = DllStructCreate("dword[" & Ceiling($iSize / 4) & "]", DllStructGetPtr($tByteStructure))
Local $iTCPentries = DllStructGetData($tMIB_TCPTABLE_OWNER_PID_DWORDS, 1)
Local $aTCPTable[$iTCPentries + 1][8] = [["Process Name", "Local IP", "Local Port", "Remote IP", "Remote port", "Connection state", "PID", "User Name"]]
Local $aState[12] = ["CLOSED", "LISTENING", "SYN_SENT", "SYN_RCVD", "ESTABLISHED", "FIN_WAIT1", "FIN_WAIT2", "CLOSE_WAIT", "CLOSING", "LAST_ACK", "TIME_WAIT", "DELETE_TCB"]
Local $aProcesses = _CV_ProcessList()
Local $iOffset
Local $iIP
For $i = 1 To $iTCPentries
$iOffset =($i - 1) * 6 + 1
$aTCPTable[$i][5] = $aState[DllStructGetData($tMIB_TCPTABLE_OWNER_PID_DWORDS, 1, $iOffset + 1) - 1]
$iIP = DllStructGetData($tMIB_TCPTABLE_OWNER_PID_DWORDS, 1, $iOffset + 2)
If $iIP = 16777343 Then
$aTCPTable[$i][1] = "localhost (127.0.0.1)"
ElseIf $iIP = 0 Then
$aTCPTable[$i][1] = "Any local address"
Else
$aTCPTable[$i][1] = BitOR(BinaryMid($iIP, 1, 1), 0) & "." & BitOR(BinaryMid($iIP, 2, 1), 0) & "." & BitOR(BinaryMid($iIP, 3, 1), 0) & "." & BitOR(BinaryMid($iIP, 4, 1), 0)
EndIf
$aTCPTable[$i][2] = Dec(Hex(BinaryMid(DllStructGetData($tMIB_TCPTABLE_OWNER_PID_DWORDS, 1, $iOffset + 3), 1, 2)))
If DllStructGetData($tMIB_TCPTABLE_OWNER_PID_DWORDS, 1, $iOffset + 1) < 3 Then
$aTCPTable[$i][4] = "-"
$aTCPTable[$i][3] = "-"
Else
$iIP = DllStructGetData($tMIB_TCPTABLE_OWNER_PID_DWORDS, 1, $iOffset + 4)
$aTCPTable[$i][3] = BitOR(BinaryMid($iIP, 1, 1), 0) & "." & BitOR(BinaryMid($iIP, 2, 1), 0) & "." & BitOR(BinaryMid($iIP, 3, 1), 0) & "." & BitOR(BinaryMid($iIP, 4, 1), 0)
$aTCPTable[$i][4] = Dec(Hex(BinaryMid(DllStructGetData($tMIB_TCPTABLE_OWNER_PID_DWORDS, 1, $iOffset + 5), 1, 2)))
EndIf
$aTCPTable[$i][6] = DllStructGetData($tMIB_TCPTABLE_OWNER_PID_DWORDS, 1, $iOffset + 6)
If Not $aTCPTable[$i][6] Then
$aTCPTable[$i][6] = "-"
$aTCPTable[$i][0] = "System Idle Process"
$aTCPTable[$i][7] = "SYSTEM"
Else
For $j = 1 To $aProcesses[0][0]
If $aProcesses[$j][1] = $aTCPTable[$i][6] Then
$aTCPTable[$i][0] = $aProcesses[$j][0]
If Not $aTCPTable[$i][0] Then $aTCPTable[$i][0] = $aProcesses[$j][0]
$aTCPTable[$i][7] = $aProcesses[$j][2]
If Not $aTCPTable[$i][7] Then
If IsAdmin() Then
$aTCPTable[$i][7] = "SYSTEM"
Else
$aTCPTable[$i][7] = "-"
EndIf
EndIf
ExitLoop
EndIf
Next
EndIf
Next
_ArraySort($aTCPTable, 0, 1, 0, 2)
Return $aTCPTable
EndFunc
Func _CV_SystemModuleInformation()
Local $aCall = DllCall("ntdll.dll", "long", "NtQuerySystemInformation", "dword", 11, "ptr", 0, "dword", 0, "dword*", 0)
If @error Then Return SetError(1, 0, "")
Local $iSize = $aCall[4]
Local $tBufferRaw = DllStructCreate("byte[" & $iSize & "]")
Local $pBuffer = DllStructGetPtr($tBufferRaw)
$aCall = DllCall("ntdll.dll", "long", "NtQuerySystemInformation", "dword", 11, "ptr", $pBuffer, "dword", $iSize, "dword*", 0)
If @error Then Return SetError(2, 0, "")
Local $pPointer = $pBuffer
Local $tSYSTEM_MODULE_Modified = DllStructCreate("dword_ptr ModulesCount;" & "dword_ptr Reserved[2];" & "ptr ImageBaseAddress;" & "dword ImageSize;" & "dword Flags;" & "word Index;" & "word Unknown;" & "word LoadCount;" & "word ModuleNameOffset;" & "char ImageName[256]", $pPointer)
Local $iNameOffset = DllStructGetData($tSYSTEM_MODULE_Modified, "ModuleNameOffset")
Local $sImageName = DllStructGetData($tSYSTEM_MODULE_Modified, "ImageName")
Return StringTrimLeft($sImageName, $iNameOffset)
EndFunc
Func _CV_ProcessList()
Const $sSystemModule = _CV_SystemModuleInformation()
Local $aCall = DllCall("wtsapi32.dll", "bool", "WTSEnumerateProcessesW", "handle", 0, "dword", 0, "dword", 1, "ptr*", 0, "dword*", 0)
If @error Or Not $aCall[0] Then
Local $aProcesses = ProcessList()
ReDim $aProcesses[$aProcesses[0][0]][3]
For $i = 1 To UBound($aProcesses) - 1
$aProcesses[$i][2] = "-"
Next
Return SetError(1, 0, $aProcesses)
EndIf
Local $tWTS_PROCESS_INFO
Local $pString, $iStringLen
Local $aOut[$aCall[5] + 1][3]
$aOut[0][0] = $aCall[5]
For $i = 1 To $aCall[5]
$tWTS_PROCESS_INFO = DllStructCreate("dword SessionId;" & "dword ProcessId;" & "ptr ProcessName;" & "ptr UserSid", $aCall[4] +($i - 1) * DllStructGetSize($tWTS_PROCESS_INFO))
$pString = DllStructGetData($tWTS_PROCESS_INFO, "ProcessName")
$iStringLen = _CV_PtrStringLenW($pString)
$aOut[$i][0] = DllStructGetData(DllStructCreate("wchar[" & $iStringLen + 1 & "]", $pString), 1)
If $aOut[$i][0] = "System" Then $aOut[$i][0] = $sSystemModule
$aOut[$i][1] = DllStructGetData($tWTS_PROCESS_INFO, "ProcessId")
$aOut[$i][2] = _CV_AccountName(DllStructGetData($tWTS_PROCESS_INFO, "UserSid"))
Next
DllCall("wtsapi32.dll", "none", "WTSFreeMemory", "ptr", $aCall[4])
Return $aOut
EndFunc
Func _CV_PtrStringLenW($pString)
Local $aCall = DllCall("kernel32.dll", "dword", "lstrlenW", "ptr", $pString)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _CV_AccountName($pSID)
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", "ptr", 0, "ptr", $pSID, "wstr", "", "dword*", 1024, "wstr", "", "dword*", 1024, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, "")
Return $aCall[3]
EndFunc
Func _NumberFormat($Number, $NullToZero = False)
If $Number = "" Then
If $NullToZero = False Then
Return ""
Else
Return "0"
EndIf
EndIf
If StringLeft($Number, 1) = "-" Then
Return "- " & StringRegExpReplace(StringTrimLeft($Number, 1), "(\A\d{1,3}(?=(\d{3})+\z)|\d{3}(?=\d))", "\1 ")
Else
Return StringRegExpReplace($Number, "(\A\d{1,3}(?=(\d{3})+\z)|\d{3}(?=\d))", "\1 ")
EndIf
EndFunc
Func _PadStringCenter($String = "", $Width = 50, $PadChar = "=")
If $String = "" Then Return ""
Local $Odd = Mod(($Width - StringLen($String)), 2)
Local $Count =($Width - StringLen($String)) / 2
Local $Pad = ""
For $i = 0 To $Count - 1
$Pad &= $PadChar
Next
Local $Out = ""
If $Odd Then
$Out = $Pad & $String & $Pad & $PadChar
Else
$Out = $Pad & $String & $Pad
EndIf
Return $Out
EndFunc
Func _ProcessSuspendResume($iPIDorName, $iSuspend = True)
If IsString($iPIDorName) Then $iPIDorName = ProcessExists($iPIDorName)
If Not $iPIDorName Then Return SetError(2, 0, 0)
Local $ai_Handle = _WinAPI_OpenProcess($PROCESS_ALL_ACCESS, False, $iPIDorName)
Local $i_sucess = DllCall("ntdll.dll", "int", "Nt" &($iSuspend ? "Suspend" : "Resume") & "Process", "int", $ai_Handle)
_WinAPI_CloseHandle($ai_Handle)
If IsArray($i_sucess) Then Return 1
Return SetError(1, 0, 0)
EndFunc
Func _ProcessSuspendResume2($iPIDorName, $iSuspend = True)
If IsString($iPIDorName) Then $iPIDorName = ProcessExists($iPIDorName)
If Not $iPIDorName Then Return SetError(2, 0, 0)
If $iSuspend Then
DllCall('kernel32.dll', 'ptr', 'DebugActiveProcess', 'int', $iPIDorName)
DllCall('kernel32.dll', 'ptr', 'DebugSetProcessKillOnExit', 'int', False)
Else
DllCall('kernel32.dll', 'ptr', 'DebugActiveProcessStop', 'int', $iPIDorName)
EndIf
EndFunc
Func _Sleep($iDelay, $iSleep = True, $CheckRunState = True, $SleepWhenPaused = True)
Static $hTimer_SetTime = 0
Static $hTimer_PBRemoteControlInterval = 0
Static $hTimer_EmptyWorkingSetAndroid = 0
Static $hTimer_EmptyWorkingSetBot = 0
Static $b_Sleep_Active = False
Local $iBegin = __TimerInit()
If $b_Sleep_Active = True Then
EndIf
$b_Sleep_Active = True
debugGdiHandle("_Sleep")
CheckBotRequests()
If SetCriticalMessageProcessing() = False Then
If $g_bMoveDivider Then
MoveDivider()
$g_bMoveDivider = False
EndIf
If $iDelay > 0 And __TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout Then
If __TimerDiff($hTimer_PBRemoteControlInterval) >= $g_iPBRemoteControlInterval Or($hTimer_PBRemoteControlInterval = 0 And $g_bNotifyRemoteEnable) Then
NotifyRemoteControl()
$hTimer_PBRemoteControlInterval = __TimerInit()
EndIf
If(($g_iEmptyWorkingSetAndroid > 0 And __TimerDiff($hTimer_EmptyWorkingSetAndroid) >= $g_iEmptyWorkingSetAndroid * 1000) Or $hTimer_EmptyWorkingSetAndroid = 0) And $g_bRunState And TestCapture() = False Then
If IsArray(getAndroidPos(True)) = 1 Then _WinAPI_EmptyWorkingSet(GetAndroidPid())
$hTimer_EmptyWorkingSetAndroid = __TimerInit()
EndIf
If($g_iEmptyWorkingSetBot > 0 And __TimerDiff($hTimer_EmptyWorkingSetBot) >= $g_iEmptyWorkingSetBot * 1000) Or $hTimer_EmptyWorkingSetBot = 0 Then
ReduceBotMemory(False)
$hTimer_EmptyWorkingSetBot = __TimerInit()
EndIf
CheckPostponedLog()
If BotCloseRequestProcessed() Then
BotClose()
$b_Sleep_Active = False
Return True
EndIf
EndIf
EndIf
If $CheckRunState And Not $g_bRunState Then
ResumeAndroid()
$b_Sleep_Active = False
Return True
EndIf
Local $iRemaining = $iDelay - __TimerDiff($iBegin)
While $iRemaining > 0
DllCall($g_hLibNTDLL, "dword", "ZwYieldExecution")
If $CheckRunState = True And $g_bRunState = False Then
ResumeAndroid()
$b_Sleep_Active = False
Return True
EndIf
If SetCriticalMessageProcessing() = False Then
If $g_bBotPaused And $SleepWhenPaused And $g_bTogglePauseAllowed Then TogglePauseSleep()
If $g_bTogglePauseUpdateState Then TogglePauseUpdateState("_Sleep")
If $g_bMakeScreenshotNow = True Then
If $g_bScreenshotPNGFormat = False Then
MakeScreenshot($g_sProfileTempPath, "jpg")
Else
MakeScreenshot($g_sProfileTempPath, "png")
EndIf
EndIf
If __TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout Then
If $g_bRunState And Not $g_bSearchMode And Not $g_bBotPaused And($hTimer_SetTime = 0 Or __TimerDiff($hTimer_SetTime) >= 750) Then
SetTime()
$hTimer_SetTime = __TimerInit()
EndIf
AndroidEmbedCheck()
AndroidShieldCheck()
CheckPostponedLog()
EndIf
EndIf
$iRemaining = $iDelay - __TimerDiff($iBegin)
If $iRemaining >= $DELAYSLEEP Then
_SleepMilli($DELAYSLEEP)
Else
_SleepMilli($iRemaining)
EndIf
CheckBotRequests()
WEnd
$b_Sleep_Active = False
Return False
EndFunc
Func _SleepMicro($iMicroSec)
DllStructSetData($g_hStruct_SleepMicro, "time", $iMicroSec * -10)
DllCall($g_hLibNTDLL, "dword", "ZwDelayExecution", "int", 0, "ptr", $g_pStruct_SleepMicro)
EndFunc
Func _SleepMilli($iMilliSec)
_SleepMicro(Int($iMilliSec * 1000))
EndFunc
Func _SleepStatus($iDelay, $iSleep = True, $bDirection = True, $CheckRunState = True, $iBeginTimer = __TimerInit())
Local $iDay = 0, $iHour = 0, $iMin = 0, $iSec = 0
Local $iCurTime, $iTime
Local $bUpdate = True, $hLastUpdate
Local $iDayCalc = 0, $iHourCalc = 0, $iMinCalc = 0, $iSecCalc = 0
Local $sTimeWait, $sTimeLeftLapse = ",  Time Lapse = "
_TicksToDay($iDelay, $iDay, $iHour, $iMin, $iSec)
While __TimerDiff($iBeginTimer) < $iDelay
If $g_bRunState = False And $CheckRunState = True Then Return True
If $bUpdate Then
$iCurTime = __TimerDiff($iBeginTimer)
$iTime = $iCurTime
If $bDirection = True Then
$iTime = $iDelay - $iCurTime
$sTimeLeftLapse = ",  Time Left = "
EndIf
_TicksToDay($iTime, $iDayCalc, $iHourCalc, $iMinCalc, $iSecCalc)
$sTimeWait = "Waiting Time = "
Select
Case $iDay > 0
$sTimeWait &= StringFormat("%2u Day(s) ", $iDay)
$sTimeLeftLapse &= StringFormat("%2u Day(s) ", $iDayCalc)
ContinueCase
Case $iHour > 0
$sTimeWait &= StringFormat("%02u:", $iHour)
$sTimeLeftLapse &= StringFormat("%02u:", $iHourCalc)
ContinueCase
Case Else
$sTimeWait &= StringFormat("%02u:%02u", $iMin, $iSec)
$sTimeLeftLapse &= StringFormat("%02u:%02u", $iMinCalc, $iSecCalc)
EndSelect
$hLastUpdate = __TimerInit()
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, " Status: " & $sTimeWait & $sTimeLeftLapse)
EndIf
_Sleep($DELAYSLEEP)
$bUpdate = __TimerDiff($hLastUpdate) > 750
WEnd
If $g_bRunState = False And $CheckRunState = True Then Return True
Return False
EndFunc
Func _StatusUpdateTime($hTimer, $sWhyWait = "")
Local $iCurTime = __TimerDiff($hTimer)
Local $iMinCalc = Int($iCurTime /(60 * 1000))
Local $iSecCalc = Int(($iCurTime -($iMinCalc * 60 * 1000)) / 1000)
Local $sString = $sWhyWait & " Wait Time = " & StringFormat("%02u" & ":" & "%02u", $iMinCalc, $iSecCalc)
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, " Status: " & $sString)
EndFunc
Func _TicksToDay($iTicks, ByRef $iDays, ByRef $iHours, ByRef $iMins, ByRef $iSecs)
_TicksToTime($iTicks, $iHours, $iMins, $iSecs)
If @error Then Return SetError(1, 0, 0)
$iDays = Int($iHours / 24)
$iHours = Mod($iHours, 24)
Return 1
EndFunc
Func Click($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_bDebugClick Or TestCapture() Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
AndroidClick($x, $y, $times, $speed)
Return
EndIf
Local $SuspendMode = ResumeAndroid()
If $times <> 1 Then
For $i = 0 To($times - 1)
If isProblemAffectBeforeClick($i) Then
If $g_bDebugClick Then SetLog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isProblemAffectBeforeClick() Then
If $g_bDebugClick Then SetLog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func _ControlClick($x, $y)
Local $useHWnD = $g_iAndroidControlClickWindow = 1 And $g_bAndroidEmbedded = False
Local $hWin =(($useHWnD) ?($g_hAndroidWindow) :($g_hAndroidControl))
$x = Int($x) + $g_aiMouseOffset[0]
$y = Int($y) + $g_aiMouseOffset[1]
If $g_bAndroidEmbedded = False Then
$x += $g_aiMouseOffsetWindowOnly[0]
$y += $g_aiMouseOffsetWindowOnly[1]
EndIf
If $hWin = $g_hAndroidWindow Then
$x += $g_aiBSrpos[0]
$y += $g_aiBSrpos[1]
EndIf
If $g_iAndroidControlClickMode = 0 Then
Return ControlClick($hWin, "", "", "left", "1", $x, $y)
EndIf
Local $WM_LBUTTONDOWN = 0x0201, $WM_LBUTTONUP = 0x0202
Local $lParam = BitOR(Int($y) * 0x10000, BitAND(Int($x), 0xFFFF))
_SendMessage($hWin, $WM_LBUTTONDOWN, 0x0001, $lParam)
_SleepMicro($g_iAndroidControlClickDownDelay * 1000)
_SendMessage($hWin, $WM_LBUTTONUP, 0x0000, $lParam)
_SleepMicro($g_iAndroidControlClickDelay * 1000)
Return 1
EndFunc
Func isProblemAffectBeforeClick($iCount = 0)
If NeedCaptureRegion($iCount) = True Then Return isProblemAffect(True)
Return False
EndFunc
Func ClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
Click($point[0], $point[1], $howMuch, $speed, $debugtxt)
EndFunc
Func BuildingClick($x, $y, $debugtxt = "")
Local $point[2] = [$x, $y]
ConvertToVillagePos($x, $y)
If $g_bDebugClick Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("BuildingClick " & $point[0] & "," & $point[1] & " converted to " & $x & "," & $y & " " & $debugtxt & $txt, $COLOR_ACTION)
EndIf
Return Click($x, $y, 1, 0, $debugtxt)
EndFunc
Func BuildingClickP($point, $debugtxt = "")
Return BuildingClick($point[0], $point[1], $debugtxt)
EndFunc
Func PureClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_bDebugClick Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("PureClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
For $i = 1 to $times
AndroidClick($x, $y, 1, $speed, False)
Next
Return
EndIf
Local $SuspendMode = ResumeAndroid()
If $times <> 1 Then
For $i = 0 To($times - 1)
MoveMouseOutBS()
_ControlClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
MoveMouseOutBS()
_ControlClick($x, $y)
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func PureClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
PureClick($point[0], $point[1], $howMuch, $speed, $debugtxt)
EndFunc
Func GemClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_bDebugClick Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
If isGemOpen(True) Then
Return False
EndIf
AndroidClick($x, $y, $times, $speed)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
Local $i
If $times <> 1 Then
For $i = 0 To($times - 1)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick($i) Then
If $g_bDebugClick Then SetLog("VOIDED GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick() Then
If $g_bDebugClick Then SetLog("VOIDED GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func GemClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
Return GemClick($point[0], $point[1], $howMuch, $speed, $debugtxt = "")
EndFunc
Func AttackClick($x, $y, $times = 1, $speed = 0, $afterDelay = 0, $debugtxt = "")
Local $timer = __TimerInit()
If $y > 555 + $g_iBottomOffsetY Then $y = 555 + $g_iBottomOffsetY
AttackRemainingTime(False)
Local $result = PureClick($x, $y, $times, $speed, $debugtxt)
Local $delay = $times * $speed + $afterDelay - __TimerDiff($timer)
If IsKeepClicksActive() = False And $delay > 0 Then _Sleep($delay, False)
Return $result
EndFunc
Func _DecodeDebug($message)
Local $separator = " | "
Switch $message
Case "#0112", "#0115", "#0140", "#0141", "#0142", "#0143", "#0199", "#0328", "#0201", "#0204", "#0205", "#0206", "#0327", "#0207", "#0208", "#0209", "#0210", "#0211"
Return $separator & "Away"
Case "#0214", "#0215", "#0216", "#0217", "#0218", "#0219", "#0220", "#0221", "#0235", "#0242", "#0268", "#0291", "#0292", "#0295", "#0298", "#0300", "#0301", "#0302"
Return $separator & "Away"
Case "#0303", "#0306", "#0308", "#0309", "#0310", "#0311", "#0312", "#0319", "#0333", "#0257", "#0139", "#0125", "#0251", "#0335", "#0313", "#0314", "#0332", "#0329"
Return $separator & "Away"
Case "#0121", "#0124", "#0133", "#0157", "#0161", "#0165", "#0166", "#0167", "#0170", "#0171", "#0176", "#0224", "#0234", "#0265", "#0346", "#0348", "#0350", "#0351"
Return $separator & "Away"
Case "#0352", "#0353", "#0354", "#0355", "#0356", "#0357", "#0358", "#0359", "#0360", "#0361", "#0362", "#0363", "#0364", "#0365", "#0366", "#0367", "#0368", "#0369"
Return $separator & "Away"
Case "#0370", "#0371", "#0373", "#0374", "#0375", "#0376", "#0377", "#0378", "#0379", "#0380", "#0381", "#0382", "#0383", "#0384", "#0385", "#0386", "#0387", "#0388"
Return $separator & "Away"
Case "#0389", "#0390", "#0391", "#0392", "#0393", "#0394", "#0395", "#0501", "#0502", "#0503", "#0504", "#0467", "#0505", "#0931", "#0932", "#0933"
Return $separator & "Away"
Case "#0001"
Return $separator & "AtkTH - Select Barbarian"
Case "#0002", "#0006"
Return $separator & "AtkTH - Barbarian Bottom Left"
Case "#0003", "#0007"
Return $separator & "AtkTH - Barbarian Bottom Right"
Case "#0004", "#0008"
Return $separator & "AtkTH - Barbarian Top Right"
Case "#0005", "#0009"
Return $separator & "AtkTH - Barbarian Top Left"
Case "#0010"
Return $separator & "AtkTH - Select Archer"
Case "#0011", "#0015"
Return $separator & "AtkTH - Arcer Bottom Left"
Case "#0012", "#0016"
Return $separator & "AtkTH - Arcer Bottom Right"
Case "#0013", "#0017"
Return $separator & "AtkTH - Arcer Top Right"
Case "#0014", "#0018"
Return $separator & "AtkTH - Arcer Top Left"
Case "#0155"
Return $separator & "Attack - Next Button"
Case "#0331"
Return $separator & "Collect resources"
Case "#0330"
Return $separator & "Collect resources*"
Case "#0432"
Return $separator & "Clean tombs*"
Case "#0431"
Return $separator & "Clean yard"
Case "#0430"
Return $separator & "Clean yard*"
Case "#0266"
Return $separator & "Train - TrainIT Selected Troop"
Case "#0269"
Return $separator & "Train - Open Barrack"
Case "#0270"
Return $separator & "Train - Train Troops button"
Case "#0271"
Return $separator & "Train - Next Button "
Case "#0272", "#0286", "#0289", "#0325"
Return $separator & "Train - Prev Button "
Case "#0273", "#0284", "#0285", "#0287", "#0288"
Return $separator & "Train - Remove Troops"
Case "#0274"
Return $separator & "Train - Train Barbarian"
Case "#0275"
Return $separator & "Train - Train Archer"
Case "#0276"
Return $separator & "Train - Train Giant"
Case "#0277"
Return $separator & "Train - Train Goblin"
Case "#0278"
Return $separator & "Train - Train Wall Breaker"
Case "#0279"
Return $separator & "Train - Train Balloon"
Case "#0280"
Return $separator & "Train - Train Wizard"
Case "#0281"
Return $separator & "Train - Train Healer"
Case "#0282"
Return $separator & "Train - Train Dragon"
Case "#0283"
Return $separator & "Train - Train P.E.K.K.A."
Case "#0290"
Return $separator & "Train - GemClick Spell"
Case "#0293"
Return $separator & "Train - Click Army Camp"
Case "#0294"
Return $separator & "Train - Open Info Army Camp"
Case "#0336"
Return $separator & "Train - Go to first barrack"
Case "#0337"
Return $separator & "Train - Click Prev Button*"
Case "#0338"
Return $separator & "Train - Click Next Button*"
Case "#0339"
Return $separator & "Train - Select Prev Barrack/SP"
Case "#0340"
Return $separator & "Train - Click Next Barrack/SP"
Case "#0341"
Return $separator & "Train - Train Bowler"
Case "#0342"
Return $separator & "Train - Train Baby Dragon"
Case "#0343"
Return $separator & "Train - Train Miner"
Case "#0344"
Return $separator & "Train - Train Ice Golem"
Case "#0168"
Return $separator & "Donate - Open Chat"
Case "#0169"
Return $separator & "Donate - Select Clan Tab"
Case "#0172"
Return $separator & "Donate - Scroll"
Case "#0173"
Return $separator & "Donate - Click Chat"
Case "#0174"
Return $separator & "Donate - Click Donate Button"
Case "#0175"
Return $separator & "Donate - Donate Selected Troop first row"
Case "#0600"
Return $separator & "Donate - Donate Selected Troop second row"
Case "#0601"
Return $separator & "Donate - Donate Selected Troop spell"
Case "#0144"
Return $separator & "ChkLang - Config Button"
Case "#0145", "#0146", "#0147", "#0148"
Return $separator & "ChkLang - Close Page"
Case "#0222"
Return $separator & "Profile - Profile Button"
Case "#0223"
Return $separator & "Profile - Close Page"
Case "#0250"
Return $separator & "Request - Click Castle Clan"
Case "#0253"
Return $separator & "Request - Click Request Button"
Case "#0254", "#0255"
Return $separator & "Request - Click Select Text For Request"
Case "#0256"
Return $separator & "Request - Click Send Request"
Case "#0334"
Return $separator & "Request - Click Train Button"
Case "#0099"
Return $separator & "Return Home - End Battle"
Case "#0100"
Return $separator & "Return Home - Surrender, Confirm"
Case "#0101"
Return $separator & "Return Home - Return Home Button"
Case "#0396"
Return $separator & "Reach Limit - Return home, Press End Battle "
Case "#0468"
Return $separator & "Clan Level - Open Chat"
Case "#0469"
Return $separator & "Clan Level - Open Chat Clan Tab "
Case "#0470"
Return $separator & "Clan Level - Click Info Clan Button"
Case "#071", "#0472"
Return $separator & "Clan Level - Close Chat"
Case "#0473"
Return $separator & "Clan Level - Close Clan Info Page"
Case "#0149"
Return $separator & "Prepare Search - Press Attack Button"
Case "#0150"
Return $separator & "Prepare Search - Press Find a Match Button"
Case "#0030"
Return $separator & "Attack - press surrender"
Case "#0031"
Return $separator & "Attack - press confirm surrender"
Case "#0510"
Return $separator & "Attack Search - Open chat tab"
Case "#0511"
Return $separator & "Attack Search - close chat tab"
Case "#0512"
Return $separator & "Attack Search - Press retry search button"
Case "#0513"
Return $separator & "Attack Search - Return Home button"
Case "#0514"
Return $separator & "Attack Search - Clouds, keep game alive"
Case "#0000"
Return $separator & " "
Case Else
Return ""
EndSwitch
EndFunc
Func SendText($sText)
Local $result = 1
Local $error = 0
If $g_bAndroidAdbInput = True Then
AndroidSendText($sText)
$error = @error
EndIf
If $g_bAndroidAdbInput = False Or $error <> 0 Then
Local $SuspendMode = ResumeAndroid()
Local $ascText = ""
Local $r, $i, $vk, $shiftBits, $char
Local $c = 0
For $i = 1 To StringLen($sText)
$char = StringMid($sText, $i, 1)
$vk = _VkKeyScan($char)
$shiftBits = @extended
If $vk = -1 And $shiftBits = -1 Then
SetDebugLog("SendText cannot send character: " & $char)
$c += 1
Else
If BitAND($shiftBits, 1) > 0 Then $ascText &= "{LSHIFT down}"
If BitAND($shiftBits, 2) > 0 Then $ascText &= "{LCTRL down}"
If BitAND($shiftBits, 4) > 0 Then $ascText &= "{LALT down}"
$ascText &= "{ASC " & _WinAPI_MapVirtualKey($vk, $MAPVK_VK_TO_CHAR) & "}"
If BitAND($shiftBits, 4) > 0 Then $ascText &= "{LALT up}"
If BitAND($shiftBits, 2) > 0 Then $ascText &= "{LCTRL up}"
If BitAND($shiftBits, 1) > 0 Then $ascText &= "{LSHIFT up}"
$r = ControlSend($g_hAndroidWindow, "", "", $ascText, 0)
$ascText = ""
If $r = 1 Then
$c += 1
EndIf
EndIf
Next
$result = 0
If $c = StringLen($sText) Then $result = 1
SuspendAndroid($SuspendMode)
EndIf
Return $result
EndFunc
Func _VkKeyScan($s_Char)
Local $a_Ret = DllCall("user32.dll", "short", "VkKeyScanW", "ushort", AscW($s_Char))
If @error Then Return SetError(@error, @extended, -1)
Return SetExtended(BitShift($a_Ret[0], 8), BitAND($a_Ret[0], 0xFF))
EndFunc
Func ClickOkay($FeatureName = "Okay", $bCheckOneTime = False)
Local $i = 0
If _Sleep($DELAYSPECIALCLICK1) Then Return False
While 1
Local $offColors[3][3] = [[0x0D0D0D, 141, 0], [0xFFFFFF, 54, 19], [0xDDF783, 54, 10]]
Local $ButtonPixel = _MultiPixelSearch(438, 372 + $g_iMidOffsetY, 590, 404 + $g_iMidOffsetY, 1, 1, Hex(0x2C2C2C, 6), $offColors, 20)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 141, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 19, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 10, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
ExitLoop
EndIf
If $bCheckOneTime Then Return False
If $i > 5 Then
SetLog("Can not find button for " & $FeatureName & ", giving up", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($FeatureName & "_ButtonCheck_")
SetError(1, @extended, False)
Return
EndIf
$i += 1
If _Sleep($DELAYSPECIALCLICK2) Then Return False
WEnd
Return True
EndFunc
Func ClickRemove($FeatureName = "Remove")
If _CheckPixel($aIsShieldInfo, $g_bCapturePixel) Then
Local $i = 0
While 1
Local $offColors[3][3] = [[0x1A1A1A, 108, 0], [0xFFFFFF, 64, 12], [0xE51115, 55, 20]]
Local $ButtonPixel = _MultiPixelSearch(474, 252, 587, 276, 1, 1, Hex(0x0D0D0D, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog($FeatureName & " btn chk-#1: " & _GetPixelColor(476, 253, True) & ", #2: " & _GetPixelColor(476 + 108, 253, True) & ", #3: " & _GetPixelColor(476 + 64, 253 + 12, True) & ", #4: " & _GetPixelColor(476 + 55, 253 + 20, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 108, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 64, $ButtonPixel[1] + 12, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 55, $ButtonPixel[1] + 20, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 55, $ButtonPixel[1] + 10, 1, 0)
ExitLoop
EndIf
If $i > 15 Then
SetLog("Can not find button for " & $FeatureName & ", giving up", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave($FeatureName & "_ButtonCheck_")
SetError(1, @extended, False)
Return
EndIf
$i += 1
If _Sleep($DELAYSPECIALCLICK1) Then Return False
WEnd
Return True
Else
If $g_bDebugSetlog Then SetDebugLog($FeatureName & " remove button found", $COLOR_INFO)
Return False
EndIf
EndFunc
Func CreateLogFile()
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
Local $aOldLogs = _FileListToArray($g_sProfileLogsPath, @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & ".*.log", $FLTA_FILES)
If UBound($aOldLogs) < 2 Then
Local $aDate, $aTime, $YEAR, $MON, $MDAY, $HOUR
_DateTimeSplit(_DateAdd("h", -1, _NowCalc()), $aDate, $aTime)
$YEAR = StringFormat("%04d", $aDate[1])
$MON = StringFormat("%02d", $aDate[2])
$MDAY = StringFormat("%02d", $aDate[3])
$HOUR = StringFormat("%02d", $aTime[1])
$aOldLogs = _FileListToArray($g_sProfileLogsPath, $YEAR & "-" & $MON & "-" & $MDAY & "_" & $HOUR & ".*.log", $FLTA_FILES)
EndIf
Local $sLogPath
If UBound($aOldLogs) > 1 Then
_ArraySort($aOldLogs, 1, 1, 0)
$g_sLogFileName = $aOldLogs[1]
$sLogPath = $g_sProfileLogsPath & $g_sLogFileName
$g_hLogFile = FileOpen($sLogPath, $FO_APPEND)
SetDebugLog("Append to log file: " & $sLogPath)
Else
$g_sLogFileName = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "." & @MIN & "." & @SEC & ".log"
$sLogPath = $g_sProfileLogsPath & $g_sLogFileName
$g_hLogFile = FileOpen($sLogPath, $FO_APPEND)
SetDebugLog("Created log file: " & $sLogPath)
EndIf
If IsBotLaunched() Then
SetDebugLog("Android: " & $g_sAndroidEmulator)
SetDebugLog("Android Instance: " & $g_sAndroidInstance)
SetDebugLog("Android Version: " & $g_sAndroidVersion)
SetDebugLog("Android Version API: " & $g_iAndroidVersionAPI)
SetDebugLog("Android ADB Device: " & $g_sAndroidAdbDevice)
SetDebugLog("Android Program Path: " & $g_sAndroidProgramPath)
SetDebugLog("Android Program FileVersionInfo: " &((IsArray($g_avAndroidProgramFileVersionInfo) ? _ArrayToString($g_avAndroidProgramFileVersionInfo, ",", 1) : "not available")))
SetDebugLog("Android ADB Path: " & $g_sAndroidAdbPath)
SetDebugLog("Android ADB Global Options: " & $g_sAndroidAdbGlobalOptions)
SetDebugLog("Android VBoxManage Path: " & $__VBoxManage_Path)
SetDebugLog("Android ADB Shared Folder: " & $g_sAndroidPicturesPath)
EndIf
SetDebugLog("Full Command Line: " & _ArrayToString($CmdLine, " "))
SetDebugLog("@AutoItExe: " & @AutoItExe)
SetDebugLog("@ScriptFullPath: " & @ScriptFullPath)
SetDebugLog("@WorkingDir: " & @WorkingDir)
SetDebugLog("@AutoItPID: " & @AutoItPID)
SetDebugLog("@OSArch: " & @OSArch)
SetDebugLog("@OSVersion: " & @OSVersion)
SetDebugLog("@OSBuild: " & @OSBuild)
SetDebugLog("@OSServicePack: " & @OSServicePack)
SetDebugLog("Primary Display: " & @DesktopWidth & " x " & @DesktopHeight & " - " & @DesktopDepth & "bit")
FlushGuiLog($g_hTxtLog, $g_oTxtLogInitText)
EndFunc
Func CreateAttackLogFile()
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
Local $sAttackLogFName = "AttackLog" & "-" & @YEAR & "-" & @MON & ".log"
Local $sAttackLogPath = $g_sProfileLogsPath & $sAttackLogFName
$g_hAttackLogFile = FileOpen($sAttackLogPath, $FO_APPEND)
SetDebugLog("Created attack log file: " & $sAttackLogPath)
EndFunc
Func CreateSwitchLogFile()
If $g_hSwitchLogFile <> 0 Then
FileClose($g_hSwitchLogFile)
$g_hSwitchLogFile = 0
EndIf
Local $sSwitchLogFName = "SwitchAccLog" & "-" & @YEAR & "-" & @MON & ".log"
Local $sSwitchLogPath = $g_sProfilePath & "\" & $sSwitchLogFName
$g_hSwitchLogFile = FileOpen($sSwitchLogPath, $FO_APPEND)
SetDebugLog("Created attack log file: " & $sSwitchLogPath)
EndFunc
Func DebugImageSave($TxtName = "Unknown", $capturenew = Default, $extensionpng = Default, $makesubfolder = Default, $sTag = "")
If $capturenew = Default Then $capturenew = True
If $extensionpng = Default Then $extensionpng = "png"
If $makesubfolder = Default Then $makesubfolder = True
Local $Date = @MDAY & "." & @MON & "." & @YEAR
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $savefolder = $g_sProfileTempDebugPath
If $makesubfolder = True Then
$savefolder = $g_sProfileTempDebugPath & $TxtName & "\"
DirCreate($savefolder)
EndIf
Local $extension
If $extensionpng = "png" then
$extension = "png"
Else
$extension = "jpg"
EndIf
Local $exist = true
local $i = 1
Local $first = True
Local $filename = ""
While $exist
If $first Then
$first = False
$filename = $savefolder & $TxtName & $sTag & $Date & " at " & $Time & "." & $extension
If FileExists($filename) = 1 Then
$exist = True
Else
$exist = False
EndIf
Else
$filename = $savefolder & $TxtName & $sTag & $Date & " at " & $Time & " (" & $i & ")." & $extension
If FileExists($filename) = 1 Then
$i +=1
Else
$exist = False
EndIf
EndIf
WEnd
If IsBool($capturenew) And $capturenew Then
_CaptureRegion2()
EndIf
If IsPtr($capturenew) Then
_GDIPlus_ImageSaveToFile($capturenew, $filename)
If $g_bDebugSetlog Then SetDebugLog("DebugImageSave(" & $capturenew & ") " & $filename, $COLOR_DEBUG)
Else
Local $EditedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
_GDIPlus_ImageSaveToFile($EditedImage, $filename)
_GDIPlus_BitmapDispose($EditedImage)
If $g_bDebugSetlog Then SetDebugLog("DebugImageSave " & $filename, $COLOR_DEBUG)
EndIf
If _Sleep($DELAYDEBUGIMAGESAVE1) Then Return
EndFunc
Func _logErrorDLLCall($sDllName, $ErrorCode)
Local $sEmsg
If $ErrorCode > 0 Then
Switch $ErrorCode
Case 1
$sEmsg = "unable to use DLL file"
Case 2
$sEmsg = "unknown return type"
Case 3
$sEmsg = "function not found in the DLL file"
Case 4
$sEmsg = "bad number of parameters"
Case 5
$sEmsg = "bad parameter"
Case Else
$sEmsg = "Unknown Error Code?"
EndSwitch
SetLog($sDllName & " DLLCall Error, @error code: " & $sEmsg, $COLOR_ERROR)
EndIf
EndFunc
Func _logErrorDateDiff($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Invalid $sType"
Case 2
$sEmsg = "2| Invalid $iNumber"
Case 3
$sEmsg = "3| Invalid $sEndDate"
EndSwitch
SetLog("_DateDiff error code = " & $sEmsg, $COLOR_ERROR)
EndFunc
Func _logErrorDateAdd($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Invalid $sType"
Case 2
$sEmsg = "2| Invalid $sStartDate"
Case 3
$sEmsg = "3| Invalid $sEndDate"
EndSwitch
SetLog("_DateAdd error code = " & $sEmsg, $COLOR_ERROR)
EndFunc
Func _logErrorGetBuilding($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Path missing in $g_oBldgImages dictionary"
Case 2
$sEmsg = "2| DLL found no buildings"
Case Else
$sEmsg = "Slap Code Monkey!"
EndSwitch
SetLog("# GetLocationBuilding error code: " & $sEmsg, $COLOR_ERROR)
EndFunc
Func FindPos()
getBSPos()
AndroidToFront(Default, "FindPos")
Local $wasDown = AndroidShieldForceDown(True, True)
While 1
If _IsPressed("01") Or _IsPressed("02") Then
Local $Pos = MouseGetPos()
$Pos[0] -= $g_aiBSpos[0]
$Pos[1] -= $g_aiBSpos[1]
ConvertFromVillagePos($Pos[0], $Pos[1])
While _IsPressed("01") Or _IsPressed("02")
Sleep(10)
WEnd
AndroidShieldForceDown($wasDown, True)
Return $Pos
EndIf
Sleep(10)
WEnd
EndFunc
Func Tab($a, $b)
Local $Tab = ""
For $i = StringLen($a) To $b Step 1
$Tab &= " "
Next
Return $Tab
EndFunc
Func Time()
Return "[" & _NowTime(3) & "] "
EndFunc
Func TimeDebug()
Return "[" & @YEAR & "-" & @MON & "-" & @MDAY & " " & _NowTime(5) & "." & @MSEC & "] "
EndFunc
Func __TimerInit()
Local $iCurrentTimeMSec = _Date_Time_GetTickCount()
Return $iCurrentTimeMSec
EndFunc
Func __TimerDiff($iTimeMsec)
If $iTimeMsec <= 0 Then
SetError(1, 0, 0)
Return
EndIf
Local $iCurrentTimeMSec = _Date_Time_GetTickCount()
If $iCurrentTimeMSec < $iTimeMsec Then
$iTimeMsec = $iTimeMsec - 4294967296
EndIf
Return $iCurrentTimeMSec - $iTimeMsec
EndFunc
Global $g_iHPTimerFreq = 0
Func _HPTimerInit()
Local $iTimerCount = _WinAPI_QueryPerformanceCounter()
If $iTimerCount = 0 Then
Local $err = _WinAPI_GetLastError()
SetLog("QueryPerformanceCounter error code: " & $err, $COLOR_ERROR)
SetError(1, $err, 0)
Return
EndIf
If $g_iHPTimerFreq = 0 Then
$g_iHPTimerFreq = _WinAPI_QueryPerformanceFrequency()
If $g_iHPTimerFreq = 0 Then
Local $err = _WinAPI_GetLastError()
SetLog("QueryPerformanceFrequency error code: " & $err, $COLOR_ERROR)
Else
SetDebugLog("QueryPerformanceFrequency is: " & $g_iHPTimerFreq)
EndIf
EndIf
Return $iTimerCount
EndFunc
Func _HPTimerDiff($iOldTimerCount)
If $iOldTimerCount = 0 Then
SetLog("Bad parameter data passed to _HPTimerDiff", $COLOR_ERROR)
SetError(1, 0, 0)
Return
EndIf
Local $iNewTimerCount = _WinAPI_QueryPerformanceCounter()
If $iNewTimerCount = 0 Then
Local $err = _WinAPI_GetLastError()
SetLog("QueryPerformanceCounter error code: " & $err, $COLOR_ERROR)
SetError(1, $err, 0)
Return
EndIf
If $g_iHPTimerFreq = 0 Then
SetLog("QueryPerformanceFrequency error code: " & $err & " ,Abort timer check", $COLOR_ERROR)
Return 0
EndIf
Return(($iNewTimerCount - $iOldTimerCount) / $g_iHPTimerFreq) * 1000
EndFunc
Func TogglePause()
TogglePauseImpl("Button")
EndFunc
Func TogglePauseImpl($Source, $bDelayed = False)
If Not $g_bRunState Then Return
ResumeAndroid()
$g_bBotPaused = Not $g_bBotPaused
If $g_bTogglePauseAllowed = False Then
$g_bTogglePauseUpdateState = True
Return
EndIf
TogglePauseUpdateState($Source)
If $bDelayed = False Then TogglePauseSleep()
EndFunc
Func TogglePauseUpdateState($Source)
$g_iActualTrainSkip = 0
ResumeAndroid()
$g_bTogglePauseUpdateState = False
If $g_bBotPaused Then
AndroidShield("TogglePauseImpl paused", False)
TrayTip($g_sBotTitle, "", 1)
If Not $g_bDisableNotifications Then TrayTip($g_sBotTitle, "was Paused!", 1, $TIP_ICONEXCLAMATION)
SetLog("Bot was Paused!", $COLOR_ERROR)
If Not $g_bSearchMode Then
$g_iTimePassed += Int(__TimerDiff($g_hTimerSinceStarted))
If ProfileSwitchAccountEnabled() Then $g_aiRunTime[$g_iCurAccount] += Int(__TimerDiff($g_ahTimerSinceSwitched[$g_iCurAccount]))
EndIf
PushMsg("Pause", $Source)
GUICtrlSetState($g_hBtnPause, $GUI_HIDE)
GUICtrlSetState($g_hBtnResume, $GUI_SHOW)
TrayItemSetText($g_hTiPause, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Resume", "Resume bot"))
Else
AndroidShield("TogglePauseImpl resumed")
TrayTip($g_sBotTitle, "", 1)
If Not $g_bDisableNotifications Then TrayTip($g_sBotTitle, "was Resumed.", 1, $TIP_ICONASTERISK)
SetLog("Bot was Resumed.", $COLOR_SUCCESS)
If Not $g_bSearchMode Then
$g_hTimerSinceStarted = __TimerInit()
If ProfileSwitchAccountEnabled() Then $g_ahTimerSinceSwitched[$g_iCurAccount] = $g_hTimerSinceStarted
EndIf
PushMsg("Resume", $Source)
GUICtrlSetState($g_hBtnPause, $GUI_SHOW)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
TrayItemSetText($g_hTiPause, GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_Pause", "Pause bot"))
EndIf
SetRedrawBotWindow(True, Default, Default, Default, "TogglePauseUpdateState")
EndFunc
Func TogglePauseSleep()
Local $counter = 0
Local $hTimerAutoResume = __TimerInit()
While $g_bBotPaused
If _Sleep($DELAYTOGGLEPAUSE1, True, True, False) Then ExitLoop
If $g_bAutoResumeEnable And __TimerDiff($hTimerAutoResume) >=($g_iAutoResumeTime * 60000) Then
SetLog("Auto resume bot after " & $g_iAutoResumeTime & " minutes of waiting", $COLOR_INFO)
TogglePause()
EndIf
$counter = $counter + 1
If $g_bNotifyTGEnable And $g_bNotifyRemoteEnable And $counter = 200 Then
NotifyRemoteControl()
$counter = 0
EndIf
WEnd
$g_bSkipFirstZoomout = False
If _Sleep($DELAYTOGGLEPAUSE2, True, True, False) Then Return
EndFunc
Func CheckPrerequisites($bSilent = False)
Local $isAllOK = True
Local $isNetFramework4dot5Installed = isNetFramework4dot5Installed()
Local $isVC2010Installed = isVC2010Installed()
If($isNetFramework4dot5Installed = False Or $isVC2010Installed = False) Then
If($isNetFramework4dot5Installed = False And Not $bSilent) Then
SetLog("The .Net Framework 4.5 is not installed", $COLOR_ERROR)
SetLog("Please download here : https://www.microsoft.com/en-US/download/details.aspx?id=30653", $COLOR_ERROR)
EndIf
If($isVC2010Installed = False And Not $bSilent) Then
SetLog("The VC 2010 x86 is not installed", $COLOR_ERROR)
SetLog("Please download here : https://www.microsoft.com/en-US/download/details.aspx?id=5555", $COLOR_ERROR)
EndIf
$isAllOK = False
EndIf
If isEveryFileInstalled($bSilent) = False Then $isAllOK = False
If Not checkAutoitVersion($bSilent) Then $isAllOK = False
checkIsAdmin($bSilent)
If @DesktopHeight <= 768 Then
Opt('WinTitleMatchMode', 4)
Local $pos = ControlGetPos("classname=Shell_TrayWnd", "", "")
If Not @error Then
If $pos[2] > $pos[3] And Int($pos[3]) + 732 > 768 Then
SetLog("Display: " & @DesktopWidth & "," & @DesktopHeight, $COLOR_ERROR)
SetLog("Windows TaskBar: " & $pos[2] & "," & $pos[3], $COLOR_ERROR)
SetLog("Emulator[732] and taskbar[" & $pos[3] & "] doesn't fit on your display!", $COLOR_ERROR)
SetLog("Please set your Windows taskbar location to Right!", $COLOR_ERROR)
EndIf
EndIf
Opt('WinTitleMatchMode', 3)
EndIf
If $isAllOK = False And Not $bSilent Then
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
$g_bRestarted = False
EndIf
Return $isAllOK
EndFunc
Func isNetFramework4Installed()
Local $z = 0, $sKeyName, $success = False
Do
$z += 1
$sKeyName = RegEnumKey("HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP", $z)
If StringRegExp($sKeyName, "v4|v4.\d+") Then
$success = True
EndIf
Until $sKeyName = '' Or $success
Return $success
EndFunc
Func isNetFramework4dot5Installed()
Local $z = 0, $sKeyValue, $success = False
$sKeyValue = RegRead("HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\", "Release")
If Number($sKeyValue) >= 378389 Then $success = True
Return $success
EndFunc
Func isVC2010Installed()
Local $hDll = DllOpen("msvcp100.dll")
Local $success = $hDll <> -1
If $success = False Then Return $success
DllClose($hDll)
_WinAPI_FreeLibrary($hDll)
Return $success
EndFunc
Func isEveryFileInstalled($bSilent = False)
Local $bResult = False, $iCount = 0
Local $aCheckFiles = [@ScriptDir & "\COCBot", $g_sLibPath, @ScriptDir & "\Images", @ScriptDir & "\imgxml", $g_sLibPath & "\helper_functions.dll", $g_sLibPath & "\ImageSearchDLL.dll", $g_sLibPath & "\MBRBot.dll", $g_sLibPath & "\MyBot.run.dll", $g_sLibPath & "\Newtonsoft.Json.dll", $g_sLibPath & "\sqlite3.dll", $g_sLibPath & "\opencv_core220.dll", $g_sLibPath & "\opencv_imgproc220.dll"]
For $vElement In $aCheckFiles
$iCount += FileExists($vElement)
Next
Local $xmls = _FileListToArrayRec(@ScriptDir & "\imgxml\", "*.xml", $FLTAR_FILES + $FLTAR_NOHIDDEN, $FLTAR_RECUR, $FLTAR_NOSORT)
If IsArray($xmls) Then
If Number($xmls[0]) < 570 Then SetLog("Verify '\imgxml\' folder, found " & $xmls[0] & " *.xml files.", $COLOR_ERROR)
EndIf
Local $MsgBox = 0
Local $sText1 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_01", "Hey Chief, we are missing some files!")
Local $sText2 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_02", "Please extract all files and folders and start this program again!")
Local $sText3 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_03", "Sorry, Start button disabled until fixed!")
Local $sText4 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_04", "Hey Chief, file name incorrect!")
Local $sText5 = GetTranslatedFileIni("MBR Popups", "CheckPrerequisites_Item_05", 'You have renamed the file "MyBot.run.exe"! Please change it back to MyBot.run.exe and restart the bot!')
If $iCount = UBound($aCheckFiles) Then
$bResult = True
ElseIf Not $bSilent Then
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
SetLog($sText1, $COLOR_ERROR)
SetLog($sText2, $COLOR_ERROR)
SetLog($sText3, $COLOR_ERROR)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), $sText1, $sText2, 0)
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
EndIf
If @Compiled Then
If Not StringInStr(@ScriptFullPath, "MyBot.run.exe", 1) Then
If Not $bSilent Then
SetLog($sText1, $COLOR_ERROR)
SetLog($sText5, $COLOR_ERROR)
SetLog($sText3, $COLOR_ERROR)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), $sText1, $sText5, 0)
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
EndIf
$bResult = False
EndIf
EndIf
Return $bResult
EndFunc
Func checkAutoitVersion($bSilent = False)
If @Compiled = True Then Return 1
Local $requiredAutoit = "3.3.14.2"
Local $result = _VersionCompare(@AutoItVersion, $requiredAutoit)
If $result = 0 Or $result = 1 Then Return 1
If Not $bSilent Then
Local $sText1 = "Hey Chief, your AutoIt version is out of date!"
Local $sText3 = "Click OK to download the latest version of AutoIt."
Local $sText2 = "The bot requires AutoIt version " & $requiredAutoit & " or above. Your version of AutoIt is " & @AutoItVersion & "." & @CRLF & $sText3 & @CRLF & "After installing the new version, open the bot again."
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $MsgBox = _ExtMsgBox(48, "OK|Cancel", $sText1, $sText2, 0)
If $MsgBox = 1 Then ShellExecute("https://www.autoitscript.com/site/autoit/downloads/")
EndIf
Return 0
EndFunc
Func checkIsAdmin($bSilent = False)
If IsAdmin() Then Return True
If Not $bSilent Then SetLog("My Bot running without admin privileges", $COLOR_ERROR)
Return False
EndFunc
Func WindowsArrange($position, $offsetX = 0, $offsetY = 0)
WinGetAndroidHandle()
Local $AndroidPos = WinGetPos($g_hAndroidWindow)
Local $BotPos = WinGetPos($g_hFrmBot)
If IsArray($AndroidPos) And IsArray($BotPos) Then
Local $hTimer = __TimerInit()
WinSetState($g_hAndroidWindow, "", @SW_RESTORE)
While IsArray($AndroidPos) And __TimerDiff($hTimer) < 3000 And $AndroidPos[0] < -30000 And $AndroidPos[1] < -30000
$AndroidPos = WinGetPos($g_hAndroidWindow)
If _Sleep($DELAYSLEEP) Then Return False
WEnd
Local $x = $offsetX
Local $y = $offsetY
Local $AndroidX = $AndroidPos[0]
Local $AndroidY = $AndroidPos[1]
Local $AndroidW = $AndroidPos[2]
Local $AndroidH = $AndroidPos[3]
Local $BotX = $BotPos[0]
Local $BotY = $BotPos[1]
Local $BotW = $BotPos[2]
Local $BotH = $BotPos[3]
If Number($AndroidX) > -30000 And Number($AndroidY) > -30000 Then
Local $bAdjusted = False
If $position = "EMBED" Then
AndroidEmbed(True)
If Not($offsetX == "" Or $offsetY == "") Then
$bAdjusted = $BotX <> $offsetX Or $BotY <> $offsetY
If $bAdjusted = True Then WinMove($g_hFrmBot, "", $offsetX, $offsetY)
EndIf
Else
If $g_bAndroidEmbedded = True Then
Return
EndIf
Switch $position
Case "BS-BOT"
If $offsetX == "" Then
$x = $AndroidX
$offsetX = 0
EndIf
If $offsetY == "" Then
$y = $AndroidY
$offsetY = 0
EndIf
$bAdjusted = $AndroidX <> $x Or $AndroidY <> $y
If $bAdjusted Then
WinMove($g_hAndroidWindow, "", $x, $y)
_Sleep($DELAYWINDOWSARRANGE1, True, False)
EndIf
$bAdjusted = $bAdjusted = True Or $BotX <> $AndroidW + $offsetX * 2 Or $BotY <> $y
If $bAdjusted Then WinMove($g_hFrmBot, "", $x + $AndroidW + $offsetX, $y)
Case "BOT-BS"
If $offsetX == "" Then
$x = $BotX
$offsetX = 0
EndIf
If $offsetY == "" Then
$y = $BotY
$offsetY = 0
EndIf
$bAdjusted = $BotX <> $x Or $BotY <> $y
If $bAdjusted Then
WinMove($g_hFrmBot, "", $x, $y)
_Sleep($DELAYWINDOWSARRANGE1, True, False)
EndIf
$bAdjusted = $bAdjusted Or $AndroidX <> $x + $BotW + $offsetX Or $AndroidY <> $y
If $bAdjusted Then WinMove($g_hAndroidWindow, "", $x + $BotW + $offsetX, $y)
Case "SNAP-TR"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX + $AndroidW + $offsetX Or $BotY <> $AndroidY + $offsetY
If $bAdjusted Then WinMove($g_hFrmBot, "", $AndroidX + $AndroidW + $offsetX, $AndroidY + $offsetY)
Case "SNAP-BR"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $AndroidX <> $AndroidX + $AndroidW + $offsetX Or $AndroidY <> $AndroidY +($AndroidH - $BotH) + $offsetY
If $bAdjusted Then WinMove($g_hFrmBot, "", $AndroidX + $AndroidW + $offsetX, $AndroidY +($AndroidH - $BotH) + $offsetY)
Case "SNAP-TL"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX - $BotW - $offsetX Or $BotY <> $AndroidY + $offsetY
If $bAdjusted Then WinMove($g_hFrmBot, "", $AndroidX - $BotW - $offsetX, $AndroidY + $offsetY)
Case "SNAP-BL"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX - $BotW - $offsetX Or $BotY <> $AndroidY +($AndroidH - $BotH) + $offsetY
If $bAdjusted Then WinMove($g_hFrmBot, "", $AndroidX - $BotW - $offsetX, $AndroidY +($AndroidH - $BotH) + $offsetY)
EndSwitch
EndIf
If $bAdjusted = True Then
SetDebugLog("WindowsArrange: " & $position & ", offsetX=" & $offsetX & ", offsetY=" & $offsetY & ", X=" & $x & ", Y=" & $y)
_Sleep($DELAYWINDOWSARRANGE1, True, False)
EndIf
EndIf
EndIf
EndFunc
Func DisposeWindows()
updateBtnEmbed()
Local $aPos = WinGetPos($g_hFrmBot)
If IsArray($aPos) Then
If _CheckWindowVisibility($g_hFrmBot, $aPos) Then
SetDebugLog("Bot Window '" & $g_sAndroidTitle & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove($g_hFrmBot, "", $aPos[0], $aPos[1])
EndIf
EndIf
CheckDpiAwareness()
If $g_bAutoAlignEnable Then
Switch $g_iAutoAlignPosition
Case 0
WindowsArrange("BS-BOT", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 1
WindowsArrange("BOT-BS", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 2
WindowsArrange("SNAP-TR", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 3
WindowsArrange("SNAP-TL", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 4
WindowsArrange("SNAP-BR", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 5
WindowsArrange("SNAP-BL", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
Case 6
WindowsArrange("EMBED", $g_iAutoAlignOffsetX, $g_iAutoAlignOffsetY)
EndSwitch
EndIf
EndFunc
Func WinMove2($WinTitle, $WinText, $x = -1, $y = -1, $w = -1, $h = -1, $hAfter = 0, $iFlags = 0, $bCheckAfterPos = True, $bIconCheck = True)
If $WinTitle = $g_hFrmBot And $g_iGuiMode = 0 Then Return $WinTitle
Local $hWin = WinGetHandle($WinTitle, $WinText)
If @error Then Return 0
If $bIconCheck And _WinAPI_IsIconic($hWin) Then
SetDebugLog("Window " & $WinTitle &(($WinTitle <> $hWin) ? "(" & $hWin & ")" : "") & " restored", $COLOR_ACTION)
WinSetState($hWin, "", @SW_RESTORE)
EndIf
Local $NoMove = $x = -1 And $y = -1
Local $NoResize = $w = -1 And $h = -1
Local $NOZORDER =($hAfter = 0 ? BitOR($SWP_NOZORDER, $SWP_NOOWNERZORDER) : 0)
$bCheckAfterPos = $bCheckAfterPos And(Not $NoMove Or Not $NoResize)
If Not $NoMove Or Not $NoResize Then
Local $aPos = WinGetPos($hWin)
If @error <> 0 Or Not IsArray($aPos) Then
SetError(1, @extended, -1)
Return 0
EndIf
Local $aPPos = WinGetClientPos(__WinAPI_GetParent($hWin))
If IsArray($aPPos) Then
$aPos[0] -= $aPPos[0]
$aPos[1] -= $aPPos[1]
EndIf
If $x = -1 Or $y = -1 Or $w = -1 Or $h = -1 Then
If $x = -1 Then $x = $aPos[0]
If $y = -1 Then $y = $aPos[1]
If $w = -1 Then $w = $aPos[2]
If $h = -1 Then $h = $aPos[3]
EndIf
$NoMove = $NoMove Or($x = $aPos[0] And $y = $aPos[1])
$NoResize = $NoResize Or($w = $aPos[2] And $h = $aPos[3])
EndIf
If $g_bWinMove2_Compatible And $NoResize = False Then
WinMove($WinTitle, $WinText, $x, $y, $w, $h)
_WinAPI_SetWindowPos($hWin, $hAfter, 0, 0, 0, 0, BitOR($SWP_NOSIZE, $SWP_NOMOVE, $SWP_NOREPOSITION, $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
Else
_WinAPI_SetWindowPos($hWin, $hAfter, $x, $y, $w, $h, BitOR(($NoMove ? BitOR($SWP_NOMOVE, $SWP_NOREPOSITION) : 0),($NoResize ? $SWP_NOSIZE : 0), $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
EndIf
If $bCheckAfterPos Then
$aPos = WinGetPos($hWin)
If @error <> 0 Or Not IsArray($aPos) Then
SetError(1, @extended, -1)
Return 0
EndIf
Local $aPPos = WinGetClientPos(__WinAPI_GetParent($hWin))
If IsArray($aPPos) Then
$aPos[0] -= $aPPos[0]
$aPos[1] -= $aPPos[1]
EndIf
If $x <> $aPos[0] Or $y <> $aPos[1] Or $w <> $aPos[2] Or $h <> $aPos[3] Then
SetDebugLog("Window " & $WinTitle &(($WinTitle <> $hWin) ? "(" & $hWin & ")" : "") & " got resized/moved again to " & $aPos[0] & "/" & $aPos[1] & " " & $aPos[2] & "x" & $aPos[3] & ", restore now " & $x & "/" & $y & " " & $w & "x" & $h, $COLOR_ACTION)
WinMove($hWin, "", $x, $y, $w, $h - 1)
If $g_bWinMove2_Compatible Then
WinMove($hWin, "", $x, $y, $w, $h)
_WinAPI_SetWindowPos($hWin, $hAfter, 0, 0, 0, 0, BitOR($SWP_NOSIZE, $SWP_NOMOVE, $SWP_NOREPOSITION, $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
Else
_WinAPI_SetWindowPos($hWin, $hAfter, $x, $y, $w, $h, BitOR($SWP_NOMOVE, $SWP_NOREPOSITION, $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
EndIf
EndIf
EndIf
Return $hWin
EndFunc
Func ControlGetHandle2($title, $text, $controlID, $iMinWidth = Default, $iMinHeight = Default)
For $sClass In StringSplit($controlID, "|", $STR_NOCOUNT)
Local $hCtrl = ControlGetHandle($title, $text, $sClass)
If $hCtrl Then
If $iMinWidth <> Default Or $iMinHeight <> Default Then
Local $aPos = WinGetPos($hCtrl)
If UBound($aPos) > 3 Then
If($iMinWidth = Default Or $aPos[2] >= $iMinWidth) And($iMinHeight = Default Or $aPos[2] >= $iMinHeight) Then
$g_sControlGetHandle2_Classname = $sClass
Return $hCtrl
EndIf
Else
SetDebugLog("ControlGetHandle2 cannot validate window dimension")
$g_sControlGetHandle2_Classname = $sClass
Return $hCtrl
EndIf
Else
$g_sControlGetHandle2_Classname = $sClass
Return $hCtrl
EndIf
EndIf
Next
$g_sControlGetHandle2_Classname = ""
Return SetError(1, 0, 0)
EndFunc
Func WinGetClientPos($hWin, $x = 0, $y = 0)
Local $tPoint = DllStructCreate("int x;int y")
DllStructSetData($tPoint, "x", $x)
DllStructSetData($tPoint, "y", $y)
_WinAPI_ClientToScreen($hWin, $tPoint)
If @error Then Return SetError(1, 0, 0)
Local $a[2] = [DllStructGetData($tPoint, "x"), DllStructGetData($tPoint, "y")]
$tPoint = 0
Return $a
EndFunc
Func WinGetPos2($title, $text = "")
Local $aPos = 0
If $title = $g_hFrmBot And $g_iGuiMode = 0 Then Return $aPos
If IsHWnd($title) = 0 Then $title = WinGetHandle($title, $text)
While IsHWnd($title) And(IsArray($aPos) = 0 Or $aPos[2] < 200)
If _WinAPI_IsIconic($title) Then WinSetState($title, "", @SW_RESTORE)
If _WinAPI_IsIconic($title) = False Then $aPos = WinGetPos($title)
WEnd
Return $aPos
EndFunc
Func ControlGetPos2($title, $text, $controlID)
Local $aPos = 0
If $title = $g_hFrmBot And $g_iGuiMode = 0 Then Return $aPos
If IsHWnd($title) = 0 Then $title = WinGetHandle($title, $text)
While IsHWnd($title) And(IsArray($aPos) = 0 Or $aPos[2] < 200)
If _WinAPI_IsIconic($title) Then WinSetState($title, "", @SW_RESTORE)
If _WinAPI_IsIconic($title) = False Then $aPos = ControlGetPos($title, $text, $controlID)
WEnd
Return $aPos
EndFunc
Func ControlGetRelativePos($title, $text, $controlID)
Local $a = ControlGetPos($title, $text, $controlID)
If UBound($a) < 4 Then Return SetError(1)
Local $hCtrl =((IsHWnd($controlID)) ?($controlID) :(GUICtrlGetHandle($controlID)))
Local $hWinParent = __WinAPI_GetParent($hCtrl)
Local $aParent = ControlGetPos($title, "", $hWinParent)
If IsArray($aParent) = 1 Then
$a[0] -= $aParent[0]
$a[1] -= $aParent[1]
EndIf
Return $a
EndFunc
Func __WinAPI_GetParent($hWin, $iMillis = 3000)
If $hWin = 0 Then Return 0
Local $hTimer = __TimerInit()
Local $bPostSomething = True
Local $hWinParent = 0
Do
$hWinParent = _WinAPI_GetParent($hWin)
If IsPtr($hWinParent) = 0 Then
If $bPostSomething And __TimerDiff($hTimer) > $iMillis / 2 Then
$bPostSomething = False
EndIf
Sleep(10)
EndIf
Until IsPtr($hWinParent) = 1 Or __TimerDiff($hTimer) > $iMillis
Return $hWinParent
EndFunc
Func _CheckWindowVisibility(Const $hWnd, ByRef $p)
If $p[0] < -30000 And $p[1] < -30000 Then Return False
Local $monitorHandle = _MonitorFromWindow($hWnd, 0)
If $monitorHandle <> 0 Then
Return False
EndIf
$monitorHandle = _MonitorFromWindow($hWnd, 2)
Local $monitorInfo = _MonitorGetInfo($monitorHandle)
If UBound($monitorInfo) > 1 Then
$p[0] = $monitorInfo[0]
$p[1] = $monitorInfo[1]
EndIf
Return True
EndFunc
Func _GraphicsCreateDC($sDriver="DISPLAY",$sDevice=0,$pInitData=0)
If Not IsString($sDriver) Then Return SetError(1,0,False)
Local $aRet,$sDeviceType
If $sDevice="" Or Not IsString($sDevice) Then
$sDeviceType="ptr"
$sDevice=0
Else
$sDeviceType="wstr"
EndIf
$aRet=DllCall('gdi32.dll',"handle","CreateDCW","wstr",$sDriver,$sDeviceType,$sDevice,"ptr",0,"ptr",$pInitData)
If @error Then Return SetError(2,@error,0)
If $aRet[0]=0 Then Return SetError(3,0,0)
Return $aRet[0]
EndFunc
Func _MonitorGetInfo($hMonitor,$hMonitorDC=0)
If Not IsPtr($hMonitor) Or $hMonitor=0 Then Return SetError(1,0,'')
Local $aRet, $stMonInfoEx=DllStructCreate('dword;long[8];dword;wchar[32]'), $bMonDCCreated=0
DllStructSetData($stMonInfoEx,1,DllStructGetSize($stMonInfoEx))
$aRet=DllCall('user32.dll','bool','GetMonitorInfoW','handle',$hMonitor,'ptr',DllStructGetPtr($stMonInfoEx))
If @error Then
$stMonInfoEx = 0
Return SetError(2,0,'')
EndIf
If Not $aRet[0] Then
$stMonInfoEx = 0
Return SetError(3,0,'')
EndIf
Dim $aRet[12]
For $i=0 To 7
$aRet[$i]=DllStructGetData($stMonInfoEx,2,$i+1)
Next
$aRet[8]=DllStructGetData($stMonInfoEx,3)
$aRet[9]=DllStructGetData($stMonInfoEx,4)
If $hMonitorDC=0 Then
$hMonitorDC=_GraphicsCreateDC($aRet[9],$aRet[9])
$bMonDCCreated=1
EndIf
$aRet[10]=_WinAPI_GetDeviceCaps($hMonitorDC,12)
$aRet[11]=_WinAPI_GetDeviceCaps($hMonitorDC,116)
If $bMonDCCreated Then _WinAPI_DeleteDC($hMonitorDC)
$stMonInfoEx = 0
Return $aRet
EndFunc
Func _MonitorFromWindow($hWnd, $iFlags=2)
If Not IsHWnd($hWnd) Or $iFlags<0 Or $iFlags>2 Then Return SetError(1,0,0)
Local $aRet=DllCall('user32.dll', 'handle', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlags)
If @error Then Return SetError(2,@error,0)
If $aRet[0]=0 Then Return SetError(3,0,0)
Return $aRet[0]
EndFunc
Func MakeScreenshot($TargetDir, $type = "jpg")
If WinGetAndroidHandle() <> 0 Then
Local $iLeft = 0, $iTop = 0, $iRight = $g_iAndroidClientWidth, $iBottom = $g_iAndroidClientHeight
Local $iW = Number($iRight) - Number($iLeft)
Local $iH = Number($iBottom) - Number($iTop)
Local $hHBitmapScreenshot = _CaptureRegion($iLeft, $iTop, $iRight, $iBottom, True)
Local $hBitmapScreenshot = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmapScreenshot)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmapScreenshot)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFF000029)
If $g_bScreenshotHideName Then
If $g_aiClanCastlePos[0] = -1 Or $g_aiClanCastlePos[1] = -1 Then
SetLog("Screenshot warning: Locate the Clan Castle to hide the clanname!", $COLOR_ERROR)
EndIf
_GDIPlus_GraphicsFillRect($hGraphic, 0, 0, 250, 63, $hBrush)
If $g_aiClanCastlePos[0] <> -1 Then
Local $xCC = $g_aiClanCastlePos[0]
Local $yCC = $g_aiClanCastlePos[1]
ConvertToVillagePos($xCC, $yCC)
_GDIPlus_GraphicsFillRect($hGraphic, $xCC - 31, $yCC - 3, 66, 20, $hBrush)
EndIf
EndIf
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $Date & "_" & $Time & "." & $type
_GDIPlus_ImageSaveToFile($hBitmapScreenshot, $TargetDir & $filename)
If FileExists($TargetDir & $filename) = 1 Then
If $g_sProfileTempPath = $TargetDir Then
SetLog("Screenshot saved: .\Profiles\" & $g_sProfileCurrentName & "\Temp\" & $filename)
Else
SetLog("Screenshot saved: " & $TargetDir & $filename)
EndIf
Else
SetLog("Screenshot file not created: " & $TargetDir & $filename, $COLOR_ERROR)
EndIf
$g_bMakeScreenshotNow = False
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($hBitmapScreenshot)
_WinAPI_DeleteObject($hHBitmapScreenshot)
Else
SetLog("Not in game", $COLOR_ERROR)
EndIf
EndFunc
Func _PostMessage_ClickDrag($X1, $Y1, $X2, $Y2, $Button = "left", $Delay = 50)
Local $hWin = $g_hAndroidControl
$X1 = Int($X1) + $g_aiMouseOffset[0]
$Y1 = Int($Y1) + $g_aiMouseOffset[1]
$X2 = Int($X2) + $g_aiMouseOffset[0]
$Y2 = Int($Y2) + $g_aiMouseOffset[1]
If $hWin = $g_hAndroidWindow Then
$X1 += $g_aiBSrpos[0]
$Y1 += $g_aiBSrpos[1]
$X2 += $g_aiBSrpos[0]
$Y2 += $g_aiBSrpos[1]
EndIf
If $g_bAndroidEmbedded = False Then
$X1 += $g_aiMouseOffsetWindowOnly[0]
$Y1 += $g_aiMouseOffsetWindowOnly[1]
$X2 += $g_aiMouseOffsetWindowOnly[0]
$Y2 += $g_aiMouseOffsetWindowOnly[1]
EndIf
WinGetAndroidHandle()
If Not IsHWnd($g_hAndroidWindow) Then
Return SetError(1, "", False)
EndIf
Local $Pressed = 0
If StringLower($Button) == "left" Then
$Button = $WM_LBUTTONDOWN
$Pressed = 1
ElseIf StringLower($Button) == "right" Then
$Button = $WM_RBUTTONDOWN
$Pressed = 2
ElseIf StringLower($Button) == "middle" Then
$Button = $WM_MBUTTONDOWN
$Pressed = 10
If $Delay == 10 Then $Delay = 100
EndIf
Local $User32 = DllOpen("User32.dll")
If @error Then Return SetError(4, "", False)
MoveMouseOutBS()
DllCall($User32, "bool", "PostMessage", "hwnd", $g_hAndroidWindow, "int", $Button, "int", "0", "long", _MakeLong($X1, $Y1))
If @error Then
DllClose($User32)
Return SetError(5, "", False)
EndIf
If _Sleep($Delay / 2) Then Return SetError(-1, "", False)
DllCall($User32, "bool", "PostMessage", "hwnd", $g_hAndroidWindow, "int", $WM_MOUSEMOVE, "int", $Pressed, "long", _MakeLong($X2, $Y2))
If @error Then
DllClose($User32)
Return SetError(6, "", False)
EndIf
If _Sleep($Delay / 2) Then Return SetError(-1, "", False)
DllCall($User32, "bool", "PostMessage", "hwnd", $g_hAndroidWindow, "int", $Button + 1, "int", "0", "long", _MakeLong($X2, $Y2))
If @error Then
DllClose($User32)
Return SetError(7, "", False)
EndIf
DllClose($User32)
Return SetError(0, 0, True)
EndFunc
Func _MakeLong($LowWORD, $HiWORD)
Return BitOR($HiWORD * 0x10000, BitAND($LowWORD, 0xFFFF))
EndFunc
Func ClickDrag($X1, $Y1, $X2, $Y2, $Delay = 50)
If TestCapture() Then Return
Local $error = 0
If $g_bDebugClick Then
SetLog("ClickDrag " & $X1 & "," & $Y1 & " to " & $X2 & "," & $Y2 & " delay=" & $Delay, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If $g_bAndroidAdbClickDrag = True Then
If $g_bAndroidAdbClickDragScript = True Then
AndroidClickDrag($X1, $Y1, $X2, $Y2, $g_bRunState)
$error = @error
Else
AndroidInputSwipe($X1, $Y1, $X2, $Y2, $g_bRunState)
$error = @error
EndIf
If _Sleep($Delay / 5) Then Return SetError(-1, "", False)
EndIf
If $g_bAndroidAdbClickDrag = False Or $error <> 0 Then
Return _PostMessage_ClickDrag($X1, $Y1, $X2, $Y2, "left", $Delay)
EndIf
Return SetError(0, 0,($error = 0 ? True : False))
EndFunc
Func TestLanguage()
If Not $g_bRunState Then Return
If getOcrLanguage($aDetectLang[0], $aDetectLang[1]) = "english" Then
SetLog("Language setting is English: Correct.", $COLOR_INFO)
Return True
ElseIf Not ChangeLanguage() Then
SetLog("Language setting is Wrong: Change CoC language to English!", $COLOR_ERROR)
btnStop()
EndIf
EndFunc
Func ChangeLanguage()
SetLog("Change Language To English", $COLOR_INFO)
If IsMainPage() Then Click($aButtonSetting[0], $aButtonSetting[1], 1, 0, "Click Setting")
If _Sleep(500) Then Return False
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aButtonLanguage[0], $aButtonLanguage[1], True), Hex($aButtonLanguage[2], 6), $aButtonLanguage[3]) Then
Click($aButtonLanguage[0], $aButtonLanguage[1], 1, 1000)
SetLog("   1. Click Language Button")
If _Sleep(200) Then Return False
ExitLoop
EndIf
If $i = 20 Then Return False
If _Sleep(900) Then Return False
Next
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aListLanguage[0], $aListLanguage[1], True), Hex($aListLanguage[2], 6), $aListLanguage[3]) Then
ClickDrag(Random(370, 375, 1), Random(170, 175, 1), Random(370, 375, 1), Random(590, 595, 1), 200)
If _Sleep(200) Then Return False
ClickDrag(Random(370, 375, 1), Random(170, 175, 1), Random(370, 375, 1), Random(380, 385, 1), 200)
If _Sleep(900) Then Return False
If _ColorCheck(_GetPixelColor($aEnglishLanguage[0], $aEnglishLanguage[1], True), Hex($aEnglishLanguage[2], 6), $aEnglishLanguage[3]) Then
Click($aEnglishLanguage[0], $aEnglishLanguage[1], 1, 1000)
SetLog("   2. Click English Language")
If _Sleep(300) Then Return False
ExitLoop
EndIf
EndIf
If $i = 20 Then Return False
If _Sleep(900) Then Return False
Next
For $i = 0 To 10
If _ColorCheck(_GetPixelColor($aLanguageOkay[0], $aLanguageOkay[1], True), Hex($aLanguageOkay[2], 6), $aLanguageOkay[3]) Then
If _Sleep(250) Then Return False
Click($aLanguageOkay[0], $aLanguageOkay[1], 1, 0, "Click OKAY")
SetLog("   3. Click OKAY")
SetLog("Please wait for loading CoC...!")
waitMainScreen()
Return True
EndIf
If $i = 10 Then Return False
If _Sleep(900) Then Return False
Next
Return False
EndFunc
Func Deletefiles($Folder, $Filter, $daydiff = 120, $type = 0, $Recursion = $FLTAR_NORECUR)
Local $x
Local $FileListName = _FileListToArrayRec($Folder, $Filter, $FLTAR_FILESFOLDERS, $Recursion)
If Not((Not IsArray($FileListName)) Or(@error = 1)) Then
For $x = $FileListName[0] To 1 Step -1
Local $FileDate = FileGetTime($Folder & $FileListName[$x])
If IsArray($FileDate) Then
Local $Date = $FileDate[0] & '/' & $FileDate[1] & '/' & $FileDate[2] & ' ' & $FileDate[3] & ':' & $FileDate[4] & ':' & $FileDate[5]
If _DateDiff('D', $Date, _NowCalc()) < $daydiff Then ContinueLoop
If $type = 0 Then
FileDelete($Folder & $FileListName[$x])
Else
FileRecycle($Folder & $FileListName[$x])
EndIf
Else
ContinueLoop
EndIf
Next
Else
Return False
EndIf
If $Folder = $g_sProfileTempDebugPath Then
$FileListName = _FileListToArray($Folder, "*", $FLTA_FOLDERS)
If IsArray($FileListName) Then
For $x = $FileListName[0] To 1 Step -1
If DirGetSize($Folder & $FileListName[$x]) = 0 Then DirRemove($Folder & $FileListName[$x])
Next
EndIf
EndIf
Return True
EndFunc
Global $ResetStats = 0
Func UpdateStats($bForceUpdate = False)
Static $s_iOldSmartZapGain = 0, $s_iOldNumLSpellsUsed = 0, $s_iOldNumEQSpellsUsed = 0
Static $topgoldloot = 0, $topelixirloot = 0, $topdarkloot = 0, $topTrophyloot = 0
Static $bDonateTroopsStatsChanged = False, $bDonateSpellsStatsChanged = False, $bDonateSiegeStatsChanged = False
Static $iOldFreeBuilderCount, $iOldTotalBuilderCount, $iOldGemAmount
Static $iOldCurrentLoot[$eLootCount]
Static $iOldTotalLoot[$eLootCount]
Static $iOldLastLoot[$eLootCount]
Static $iOldLastBonus[$eLootCount]
Static $iOldSkippedVillageCount, $iOldDroppedTrophyCount
Static $iOldCostGoldWall, $iOldCostElixirWall, $iOldCostGoldBuilding, $iOldCostElixirBuilding, $iOldCostDElixirHero
Static $iOldNbrOfWallsUppedGold, $iOldNbrOfWallsUppedElixir, $iOldNbrOfBuildingsUppedGold, $iOldNbrOfBuildingsUppedElixir, $iOldNbrOfHeroesUpped
Static $iOldSearchCost, $iOldTrainCostElixir, $iOldTrainCostDElixir, $iOldTrainCostGold
Static $iOldNbrOfOoS
Static $iOldNbrOfTHSnipeFails, $iOldNbrOfTHSnipeSuccess
Static $iOldGoldFromMines, $iOldElixirFromCollectors, $iOldDElixirFromDrills
Static $iOldAttackedCount, $iOldAttackedVillageCount[$g_iModeCount + 1]
Static $iOldTotalGoldGain[$g_iModeCount + 1], $iOldTotalElixirGain[$g_iModeCount + 1], $iOldTotalDarkGain[$g_iModeCount + 1], $iOldTotalTrophyGain[$g_iModeCount + 1]
Static $iOldNbrOfDetectedMines[$g_iModeCount + 1], $iOldNbrOfDetectedCollectors[$g_iModeCount + 1], $iOldNbrOfDetectedDrills[$g_iModeCount + 1]
Static $iOldCurrentLootBB[$eLootCountBB]
If $bForceUpdate Then
$s_iOldSmartZapGain = 0
$s_iOldNumLSpellsUsed = 0
$s_iOldNumEQSpellsUsed = 0
$topgoldloot = 0
$topelixirloot = 0
$topdarkloot = 0
$topTrophyloot = 0
$bDonateTroopsStatsChanged = True
$bDonateSpellsStatsChanged = True
$bDonateSiegeStatsChanged = True
$iOldFreeBuilderCount = 0
$iOldTotalBuilderCount = 0
$iOldGemAmount = 0
UpdateStats_ClearArray($iOldCurrentLoot)
UpdateStats_ClearArray($iOldTotalLoot)
UpdateStats_ClearArray($iOldLastLoot)
UpdateStats_ClearArray($iOldLastBonus)
$iOldSkippedVillageCount = 0
$iOldDroppedTrophyCount = 0
$iOldCostGoldWall = 0
$iOldCostElixirWall = 0
$iOldCostGoldBuilding = 0
$iOldCostElixirBuilding = 0
$iOldCostDElixirHero = 0
$iOldNbrOfWallsUppedGold = 0
$iOldNbrOfWallsUppedElixir = 0
$iOldNbrOfBuildingsUppedGold = 0
$iOldNbrOfBuildingsUppedElixir = 0
$iOldNbrOfHeroesUpped = 0
$iOldSearchCost = 0
$iOldTrainCostElixir = 0
$iOldTrainCostDElixir = 0
$iOldTrainCostGold = 0
$iOldNbrOfOoS = 0
$iOldNbrOfTHSnipeFails = 0
$iOldNbrOfTHSnipeSuccess = 0
$iOldGoldFromMines = 0
$iOldElixirFromCollectors = 0
$iOldDElixirFromDrills = 0
$iOldAttackedCount = 0
UpdateStats_ClearArray($iOldAttackedVillageCount)
UpdateStats_ClearArray($iOldTotalGoldGain)
UpdateStats_ClearArray($iOldTotalElixirGain)
UpdateStats_ClearArray($iOldTotalDarkGain)
UpdateStats_ClearArray($iOldTotalTrophyGain)
UpdateStats_ClearArray($iOldNbrOfDetectedMines)
UpdateStats_ClearArray($iOldNbrOfDetectedCollectors)
UpdateStats_ClearArray($iOldNbrOfDetectedDrills)
UpdateStats_ClearArray($iOldCurrentLootBB)
EndIf
If $g_iFirstRun = 1 Then
GUICtrlSetState($g_hLblVillageReportTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultGoldTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultElixirTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultDETemp, $GUI_HIDE)
GUICtrlSetState($g_hLblResultGoldNow, $GUI_SHOW + $GUI_DISABLE)
GUICtrlSetState($g_hPicResultGoldNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_SHOW)
GUICtrlSetState($g_hPicResultElixirNow, $GUI_SHOW)
If $g_aiCurrentLoot[$eLootDarkElixir] <> "" Then
GUICtrlSetState($g_hLblResultDeNow, $GUI_SHOW)
GUICtrlSetState($g_hPicResultDeNow, $GUI_SHOW)
Else
GUICtrlSetState($g_hPicResultDEStart, $GUI_HIDE)
GUICtrlSetState($g_hPicDarkLoot, $GUI_HIDE)
GUICtrlSetState($g_hPicDarkLastAttack, $GUI_HIDE)
GUICtrlSetState($g_hPicHourlyStatsDark, $GUI_HIDE)
EndIf
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultGemNow, $GUI_SHOW)
btnVillageStat("UpdateStats")
$g_iStatsStartedWith[$eLootGold] = $g_aiCurrentLoot[$eLootGold]
$g_iStatsStartedWith[$eLootElixir] = $g_aiCurrentLoot[$eLootElixir]
$g_iStatsStartedWith[$eLootDarkElixir] = $g_aiCurrentLoot[$eLootDarkElixir]
$g_iStatsStartedWith[$eLootTrophy] = $g_aiCurrentLoot[$eLootTrophy]
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootGold], _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
GUICtrlSetData($g_hLblResultGoldNow, _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
$iOldCurrentLoot[$eLootGold] = $g_aiCurrentLoot[$eLootGold]
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootElixir], _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
GUICtrlSetData($g_hLblResultElixirNow, _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
$iOldCurrentLoot[$eLootElixir] = $g_aiCurrentLoot[$eLootElixir]
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootDarkElixir], _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], True))
GUICtrlSetData($g_hLblResultDeNow, _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], True))
$iOldCurrentLoot[$eLootDarkElixir] = $g_aiCurrentLoot[$eLootDarkElixir]
EndIf
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootTrophy], _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
GUICtrlSetData($g_hLblResultTrophyNow, _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
$iOldCurrentLoot[$eLootTrophy] = $g_aiCurrentLoot[$eLootTrophy]
GUICtrlSetData($g_hLblResultGemNow, _NumberFormat($g_iGemAmount, True))
$iOldGemAmount = $g_iGemAmount
GUICtrlSetData($g_hLblResultBuilderNow, $g_iFreeBuilderCount & "/" & $g_iTotalBuilderCount)
$iOldFreeBuilderCount = $g_iFreeBuilderCount
$iOldTotalBuilderCount = $g_iTotalBuilderCount
$g_iFirstRun = 0
GUICtrlSetState($btnResetStats, $GUI_ENABLE)
If $g_iGuiMode = 0 Then
UpdateStatsManagedMyBotHost()
EndIf
Return
EndIf
Local $bStatsUpdated = False
If $g_iFirstAttack = 1 Then
$g_iFirstAttack = 2
EndIf
If Number($g_iStatsLastAttack[$eLootGold]) > Number($topgoldloot) Then
$bStatsUpdated = True
$topgoldloot = $g_iStatsLastAttack[$eLootGold]
GUICtrlSetData($g_ahLblStatsTop[$eLootGold], _NumberFormat($topgoldloot))
EndIf
If Number($g_iStatsLastAttack[$eLootElixir]) > Number($topelixirloot) Then
$bStatsUpdated = True
$topelixirloot = $g_iStatsLastAttack[$eLootElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootElixir], _NumberFormat($topelixirloot))
EndIf
If Number($g_iStatsLastAttack[$eLootDarkElixir]) > Number($topdarkloot) Then
$bStatsUpdated = True
$topdarkloot = $g_iStatsLastAttack[$eLootDarkElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootDarkElixir], _NumberFormat($topdarkloot))
EndIf
If Number($g_iStatsLastAttack[$eLootTrophy]) > Number($topTrophyloot) Then
$bStatsUpdated = True
$topTrophyloot = $g_iStatsLastAttack[$eLootTrophy]
GUICtrlSetData($g_ahLblStatsTop[$eLootTrophy], _NumberFormat($topTrophyloot))
EndIf
If $ResetStats = 1 Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootGold], _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootElixir], _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootDarkElixir], _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], True))
EndIf
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootTrophy], _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootGold], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootElixir], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootDarkElixir], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootTrophy], "")
GUICtrlSetData($g_hLblResultGoldHourNow, "")
GUICtrlSetData($g_hLblResultElixirHourNow, "")
GUICtrlSetData($g_hLblResultDEHourNow, "")
EndIf
If $iOldFreeBuilderCount <> $g_iFreeBuilderCount Or $iOldTotalBuilderCount <> $g_iTotalBuilderCount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultBuilderNow, $g_iFreeBuilderCount & "/" & $g_iTotalBuilderCount)
$iOldFreeBuilderCount = $g_iFreeBuilderCount
$iOldTotalBuilderCount = $g_iTotalBuilderCount
EndIf
If $iOldGemAmount <> $g_iGemAmount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultGemNow, _NumberFormat($g_iGemAmount, True))
$iOldGemAmount = $g_iGemAmount
EndIf
If $iOldCurrentLoot[$eLootGold] <> $g_aiCurrentLoot[$eLootGold] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultGoldNow, _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
$iOldCurrentLoot[$eLootGold] = $g_aiCurrentLoot[$eLootGold]
EndIf
If $iOldCurrentLoot[$eLootElixir] <> $g_aiCurrentLoot[$eLootElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultElixirNow, _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
$iOldCurrentLoot[$eLootElixir] = $g_aiCurrentLoot[$eLootElixir]
EndIf
If $iOldCurrentLoot[$eLootDarkElixir] <> $g_aiCurrentLoot[$eLootDarkElixir] And $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultDeNow, _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], False))
$iOldCurrentLoot[$eLootDarkElixir] = $g_aiCurrentLoot[$eLootDarkElixir]
EndIf
If $iOldCurrentLoot[$eLootTrophy] <> $g_aiCurrentLoot[$eLootTrophy] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultTrophyNow, _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
$iOldCurrentLoot[$eLootTrophy] = $g_aiCurrentLoot[$eLootTrophy]
EndIf
If $iOldTotalLoot[$eLootGold] <> $g_iStatsTotalGain[$eLootGold] And($g_iFirstAttack = 2 Or $ResetStats = 1) Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootGold], _NumberFormat($g_iStatsTotalGain[$eLootGold]))
$iOldTotalLoot[$eLootGold] = $g_iStatsTotalGain[$eLootGold]
EndIf
If $iOldTotalLoot[$eLootElixir] <> $g_iStatsTotalGain[$eLootElixir] And($g_iFirstAttack = 2 Or $ResetStats = 1) Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootElixir], _NumberFormat($g_iStatsTotalGain[$eLootElixir]))
$iOldTotalLoot[$eLootElixir] = $g_iStatsTotalGain[$eLootElixir]
EndIf
If $iOldTotalLoot[$eLootDarkElixir] <> $g_iStatsTotalGain[$eLootDarkElixir] And(($g_iFirstAttack = 2 And $g_iStatsStartedWith[$eLootDarkElixir] <> "") Or $ResetStats = 1) Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootDarkElixir], _NumberFormat($g_iStatsTotalGain[$eLootDarkElixir]))
$iOldTotalLoot[$eLootDarkElixir] = $g_iStatsTotalGain[$eLootDarkElixir]
EndIf
If $iOldTotalLoot[$eLootTrophy] <> $g_iStatsTotalGain[$eLootTrophy] And($g_iFirstAttack = 2 Or $ResetStats = 1) Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootTrophy], _NumberFormat($g_iStatsTotalGain[$eLootTrophy]))
$iOldTotalLoot[$eLootTrophy] = $g_iStatsTotalGain[$eLootTrophy]
EndIf
If $iOldLastLoot[$eLootGold] <> $g_iStatsLastAttack[$eLootGold] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootGold], _NumberFormat($g_iStatsLastAttack[$eLootGold]))
$iOldLastLoot[$eLootGold] = $g_iStatsLastAttack[$eLootGold]
EndIf
If $iOldLastLoot[$eLootElixir] <> $g_iStatsLastAttack[$eLootElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootElixir], _NumberFormat($g_iStatsLastAttack[$eLootElixir]))
$iOldLastLoot[$eLootElixir] = $g_iStatsLastAttack[$eLootElixir]
EndIf
If $iOldLastLoot[$eLootDarkElixir] <> $g_iStatsLastAttack[$eLootDarkElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootDarkElixir], _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]))
$iOldLastLoot[$eLootDarkElixir] = $g_iStatsLastAttack[$eLootDarkElixir]
EndIf
If $iOldLastLoot[$eLootTrophy] <> $g_iStatsLastAttack[$eLootTrophy] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootTrophy], _NumberFormat($g_iStatsLastAttack[$eLootTrophy]))
$iOldLastLoot[$eLootTrophy] = $g_iStatsLastAttack[$eLootTrophy]
EndIf
If $iOldLastBonus[$eLootGold] <> $g_iStatsBonusLast[$eLootGold] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootGold], _NumberFormat($g_iStatsBonusLast[$eLootGold]))
$iOldLastBonus[$eLootGold] = $g_iStatsBonusLast[$eLootGold]
EndIf
If $iOldLastBonus[$eLootElixir] <> $g_iStatsBonusLast[$eLootElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootElixir], _NumberFormat($g_iStatsBonusLast[$eLootElixir]))
$iOldLastBonus[$eLootElixir] = $g_iStatsBonusLast[$eLootElixir]
EndIf
If $iOldLastBonus[$eLootDarkElixir] <> $g_iStatsBonusLast[$eLootDarkElixir] Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootDarkElixir], _NumberFormat($g_iStatsBonusLast[$eLootDarkElixir]))
$iOldLastBonus[$eLootDarkElixir] = $g_iStatsBonusLast[$eLootDarkElixir]
EndIf
If $iOldCostGoldWall <> $g_iCostGoldWall Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblWallUpgCostGold, _NumberFormat($g_iCostGoldWall, True))
$iOldCostGoldWall = $g_iCostGoldWall
EndIf
If $iOldCostElixirWall <> $g_iCostElixirWall Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblWallUpgCostElixir, _NumberFormat($g_iCostElixirWall, True))
$iOldCostElixirWall = $g_iCostElixirWall
EndIf
If $iOldCostGoldBuilding <> $g_iCostGoldBuilding Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblBuildingUpgCostGold, _NumberFormat($g_iCostGoldBuilding, True))
$iOldCostGoldBuilding = $g_iCostGoldBuilding
EndIf
If $iOldCostElixirBuilding <> $g_iCostElixirBuilding Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblBuildingUpgCostElixir, _NumberFormat($g_iCostElixirBuilding, True))
$iOldCostElixirBuilding = $g_iCostElixirBuilding
EndIf
If $iOldCostDElixirHero <> $g_iCostDElixirHero Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblHeroUpgCost, _NumberFormat($g_iCostDElixirHero, True))
$iOldCostDElixirHero = $g_iCostDElixirHero
EndIf
If $iOldSkippedVillageCount <> $g_iSkippedVillageCount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultVillagesSkipped, _NumberFormat($g_iSkippedVillageCount, True))
GUICtrlSetData($g_hLblResultSkippedHourNow, _NumberFormat($g_iSkippedVillageCount, True))
$iOldSkippedVillageCount = $g_iSkippedVillageCount
EndIf
If $iOldDroppedTrophyCount <> $g_iDroppedTrophyCount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultTrophiesDropped, _NumberFormat($g_iDroppedTrophyCount, True))
$iOldDroppedTrophyCount = $g_iDroppedTrophyCount
EndIf
If $iOldNbrOfWallsUppedGold <> $g_iNbrOfWallsUppedGold Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblWallGoldMake, $g_iNbrOfWallsUppedGold)
$iOldNbrOfWallsUppedGold = $g_iNbrOfWallsUppedGold
WallsStatsMAJ()
EndIf
If $iOldNbrOfWallsUppedElixir <> $g_iNbrOfWallsUppedElixir Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblWallElixirMake, $g_iNbrOfWallsUppedElixir)
$iOldNbrOfWallsUppedElixir = $g_iNbrOfWallsUppedElixir
WallsStatsMAJ()
EndIf
If $iOldNbrOfBuildingsUppedGold <> $g_iNbrOfBuildingsUppedGold Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfBuildingUpgGold, $g_iNbrOfBuildingsUppedGold)
$iOldNbrOfBuildingsUppedGold = $g_iNbrOfBuildingsUppedGold
EndIf
If $iOldNbrOfBuildingsUppedElixir <> $g_iNbrOfBuildingsUppedElixir Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfBuildingUpgElixir, $g_iNbrOfBuildingsUppedElixir)
$iOldNbrOfBuildingsUppedElixir = $g_iNbrOfBuildingsUppedElixir
EndIf
If $iOldNbrOfHeroesUpped <> $g_iNbrOfHeroesUpped Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfHeroUpg, $g_iNbrOfHeroesUpped)
$iOldNbrOfHeroesUpped = $g_iNbrOfHeroesUpped
EndIf
If $iOldSearchCost <> $g_iSearchCost Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblSearchCost, _NumberFormat($g_iSearchCost, True))
$iOldSearchCost = $g_iSearchCost
EndIf
If $iOldTrainCostElixir <> $g_iTrainCostElixir Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTrainCostElixir, _NumberFormat($g_iTrainCostElixir, True))
$iOldTrainCostElixir = $g_iTrainCostElixir
EndIf
If $iOldTrainCostDElixir <> $g_iTrainCostDElixir Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTrainCostDElixir, _NumberFormat($g_iTrainCostDElixir, True))
$iOldTrainCostDElixir = $g_iTrainCostDElixir
EndIf
If $iOldTrainCostGold <> $g_iTrainCostGold Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTrainCostGold, _NumberFormat($g_iTrainCostGold, True))
$iOldTrainCostGold = $g_iTrainCostGold
EndIf
If $iOldNbrOfOoS <> $g_iNbrOfOoS Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfOoS, $g_iNbrOfOoS)
$iOldNbrOfOoS = $g_iNbrOfOoS
EndIf
If $iOldNbrOfTHSnipeFails <> $g_iNbrOfTHSnipeFails Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfTSFailed, $g_iNbrOfTHSnipeFails)
$iOldNbrOfTHSnipeFails = $g_iNbrOfTHSnipeFails
EndIf
If $iOldNbrOfTHSnipeSuccess <> $g_iNbrOfTHSnipeSuccess Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfTSSuccess, $g_iNbrOfTHSnipeSuccess)
$iOldNbrOfTHSnipeSuccess = $g_iNbrOfTHSnipeSuccess
EndIf
If $iOldGoldFromMines <> $g_iGoldFromMines Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblGoldFromMines, _NumberFormat($g_iGoldFromMines, True))
$iOldGoldFromMines = $g_iGoldFromMines
EndIf
If $iOldElixirFromCollectors <> $g_iElixirFromCollectors Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblElixirFromCollectors, _NumberFormat($g_iElixirFromCollectors, True))
$iOldElixirFromCollectors = $g_iElixirFromCollectors
EndIf
If $iOldDElixirFromDrills <> $g_iDElixirFromDrills Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblDElixirFromDrills, _NumberFormat($g_iDElixirFromDrills, True))
$iOldDElixirFromDrills = $g_iDElixirFromDrills
EndIf
For $i = 0 To $eTroopCount - 1
If $g_aiDonateStatsTroops[$i][0] <> $g_aiDonateStatsTroops[$i][1] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblDonTroop[$i], _NumberFormat($g_aiDonateStatsTroops[$i][0], True))
If $g_aiDonateStatsTroops[$i][0] > $g_aiDonateStatsTroops[$i][1] Then
$g_iTotalDonateStatsTroops +=($g_aiDonateStatsTroops[$i][0] - $g_aiDonateStatsTroops[$i][1])
$g_iTotalDonateStatsTroopsXP +=(($g_aiDonateStatsTroops[$i][0] - $g_aiDonateStatsTroops[$i][1]) * $g_aiTroopDonateXP[$i])
EndIf
$g_aiDonateStatsTroops[$i][1] = $g_aiDonateStatsTroops[$i][0]
$bDonateTroopsStatsChanged = True
EndIf
Next
If $bDonateTroopsStatsChanged Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalTroopsQ, _NumberFormat($g_iTotalDonateStatsTroops, True))
GUICtrlSetData($g_hLblTotalTroopsXP, _NumberFormat($g_iTotalDonateStatsTroopsXP, True))
$bDonateTroopsStatsChanged = False
EndIf
For $i = 0 To $eSpellCount - 1
If $g_aiDonateStatsSpells[$i][0] <> $g_aiDonateStatsSpells[$i][1] And $i <> $eSpellClone Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblDonSpell[$i], _NumberFormat($g_aiDonateStatsSpells[$i][0], True))
If $g_aiDonateStatsSpells[$i][0] > $g_aiDonateStatsSpells[$i][1] Then
$g_iTotalDonateStatsSpells +=($g_aiDonateStatsSpells[$i][0] - $g_aiDonateStatsSpells[$i][1])
$g_iTotalDonateStatsSpellsXP +=(($g_aiDonateStatsSpells[$i][0] - $g_aiDonateStatsSpells[$i][1]) * $g_aiSpellDonateXP[$i])
EndIf
$g_aiDonateStatsSpells[$i][1] = $g_aiDonateStatsSpells[$i][0]
$bDonateSpellsStatsChanged = True
EndIf
Next
If $bDonateSpellsStatsChanged Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalSpellsQ, _NumberFormat($g_iTotalDonateStatsSpells, True))
GUICtrlSetData($g_hLblTotalSpellsXP, _NumberFormat($g_iTotalDonateStatsSpellsXP, True))
$bDonateSpellsStatsChanged = False
EndIf
For $i = 0 To $eSiegeMachineCount - 1
If $g_aiDonateStatsSieges[$i][0] <> $g_aiDonateStatsSieges[$i][1] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblDonSiegel[$i], _NumberFormat($g_aiDonateStatsSieges[$i][0], True))
If $g_aiDonateStatsSieges[$i][0] > $g_aiDonateStatsSieges[$i][1] Then
$g_iTotalDonateStatsSiegeMachines +=($g_aiDonateStatsSieges[$i][0] - $g_aiDonateStatsSieges[$i][1])
$g_iTotalDonateStatsSiegeMachinesXP +=(($g_aiDonateStatsSieges[$i][0] - $g_aiDonateStatsSieges[$i][1]) * $g_aiSiegeMachineDonateXP[$i])
EndIf
$g_aiDonateStatsSieges[$i][1] = $g_aiDonateStatsSieges[$i][0]
$bDonateSiegeStatsChanged = True
$g_iTotalDonateStatsTroopsXP = $g_iTotalDonateStatsSiegeMachinesXP + $g_iTotalDonateStatsTroopsXP
$g_iTotalDonateStatsTroops = $g_iTotalDonateStatsTroops + $g_iTotalDonateStatsSiegeMachines
EndIf
Next
If $bDonateSiegeStatsChanged Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalTroopsQ, _NumberFormat($g_iTotalDonateStatsTroops, True))
GUICtrlSetData($g_hLblTotalTroopsXP, _NumberFormat($g_iTotalDonateStatsTroopsXP, True))
EndIf
If $s_iOldSmartZapGain <> $g_iSmartZapGain Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblSmartZap, _NumberFormat($g_iSmartZapGain, True))
$s_iOldSmartZapGain = $g_iSmartZapGain
EndIf
If $s_iOldNumLSpellsUsed <> $g_iNumLSpellsUsed Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblSmartLightningUsed, _NumberFormat($g_iNumLSpellsUsed, True))
$s_iOldNumLSpellsUsed = $g_iNumLSpellsUsed
EndIf
If $s_iOldNumEQSpellsUsed <> $g_iNumEQSpellsUsed Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblSmartEarthQuakeUsed, _NumberFormat($g_iNumEQSpellsUsed, True))
$s_iOldNumEQSpellsUsed = $g_iNumEQSpellsUsed
EndIf
$g_aiAttackedCount = 0
For $i = 0 To $g_iModeCount
If $iOldAttackedVillageCount[$i] <> $g_aiAttackedVillageCount[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblAttacked[$i], _NumberFormat($g_aiAttackedVillageCount[$i], True))
$iOldAttackedVillageCount[$i] = $g_aiAttackedVillageCount[$i]
EndIf
$g_aiAttackedCount += $g_aiAttackedVillageCount[$i]
If $iOldTotalGoldGain[$i] <> $g_aiTotalGoldGain[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalGoldGain[$i], _NumberFormat($g_aiTotalGoldGain[$i], True))
$iOldTotalGoldGain[$i] = $g_aiTotalGoldGain[$i]
EndIf
If $iOldTotalElixirGain[$i] <> $g_aiTotalElixirGain[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalElixirGain[$i], _NumberFormat($g_aiTotalElixirGain[$i], True))
$iOldTotalElixirGain[$i] = $g_aiTotalElixirGain[$i]
EndIf
If $iOldTotalDarkGain[$i] <> $g_aiTotalDarkGain[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalDElixirGain[$i], _NumberFormat($g_aiTotalDarkGain[$i], True))
$iOldTotalDarkGain[$i] = $g_aiTotalDarkGain[$i]
EndIf
If $iOldTotalTrophyGain[$i] <> $g_aiTotalTrophyGain[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblTotalTrophyGain[$i], _NumberFormat($g_aiTotalTrophyGain[$i], True))
$iOldTotalTrophyGain[$i] = $g_aiTotalTrophyGain[$i]
EndIf
Next
If $iOldAttackedCount <> $g_aiAttackedCount Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblResultVillagesAttacked, _NumberFormat($g_aiAttackedCount, True))
GUICtrlSetData($g_hLblResultAttackedHourNow, _NumberFormat($g_aiAttackedCount, True))
$iOldAttackedCount = $g_aiAttackedCount
EndIf
For $i = 0 To $g_iModeCount
If $i = $TS Then ContinueLoop
If $iOldNbrOfDetectedMines[$i] <> $g_aiNbrOfDetectedMines[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfDetectedMines[$i], $g_aiNbrOfDetectedMines[$i])
$iOldNbrOfDetectedMines[$i] = $g_aiNbrOfDetectedMines[$i]
EndIf
If $iOldNbrOfDetectedCollectors[$i] <> $g_aiNbrOfDetectedCollectors[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfDetectedCollectors[$i], $g_aiNbrOfDetectedCollectors[$i])
$iOldNbrOfDetectedCollectors[$i] = $g_aiNbrOfDetectedCollectors[$i]
EndIf
If $iOldNbrOfDetectedDrills[$i] <> $g_aiNbrOfDetectedDrills[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_hLblNbrOfDetectedDrills[$i], $g_aiNbrOfDetectedDrills[$i])
$iOldNbrOfDetectedDrills[$i] = $g_aiNbrOfDetectedDrills[$i]
EndIf
Next
If $g_iFirstAttack = 2 Then
$bStatsUpdated = True
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootGold], _NumberFormat(Round($g_iStatsTotalGain[$eLootGold] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootElixir], _NumberFormat(Round($g_iStatsTotalGain[$eLootElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootDarkElixir], _NumberFormat(Round($g_iStatsTotalGain[$eLootDarkElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootTrophy], _NumberFormat(Round($g_iStatsTotalGain[$eLootTrophy] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
GUICtrlSetData($g_hLblResultGoldHourNow, _NumberFormat(Round($g_iStatsTotalGain[$eLootGold] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_hLblResultElixirHourNow, _NumberFormat(Round($g_iStatsTotalGain[$eLootElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_hLblResultDEHourNow, _NumberFormat(Round($g_iStatsTotalGain[$eLootDarkElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
EndIf
If Number($g_iStatsLastAttack[$eLootGold]) > Number($topgoldloot) Then
$bStatsUpdated = True
$topgoldloot = $g_iStatsLastAttack[$eLootGold]
GUICtrlSetData($g_ahLblStatsTop[$eLootGold], _NumberFormat($topgoldloot))
EndIf
If Number($g_iStatsLastAttack[$eLootElixir]) > Number($topelixirloot) Then
$bStatsUpdated = True
$topelixirloot = $g_iStatsLastAttack[$eLootElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootElixir], _NumberFormat($topelixirloot))
EndIf
If Number($g_iStatsLastAttack[$eLootDarkElixir]) > Number($topdarkloot) Then
$bStatsUpdated = True
$topdarkloot = $g_iStatsLastAttack[$eLootDarkElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootDarkElixir], _NumberFormat($topdarkloot))
EndIf
If Number($g_iStatsLastAttack[$eLootTrophy]) > Number($topTrophyloot) Then
$bStatsUpdated = True
$topTrophyloot = $g_iStatsLastAttack[$eLootTrophy]
GUICtrlSetData($g_ahLblStatsTop[$eLootTrophy], _NumberFormat($topTrophyloot))
EndIf
For $i = 0 To UBound($g_aiCurrentLootBB) - 1
If $iOldCurrentLootBB[$i] <> $g_aiCurrentLootBB[$i] Then
$bStatsUpdated = True
GUICtrlSetData($g_alblBldBaseStats[$i], _NumberFormat($g_aiCurrentLootBB[$i], True))
$iOldCurrentLootBB[$i] = $g_aiCurrentLootBB[$i]
EndIf
Next
If Not _DateIsValid($g_sLabUpgradeTime) Then GUICtrlSetData($g_hLbLLabTime, "00:00:00")
If ProfileSwitchAccountEnabled() Then
GUICtrlSetData($g_ahLblResultGoldNowAcc[$g_iCurAccount], _NumberFormat($g_aiCurrentLoot[$eLootGold], True))
GUICtrlSetData($g_ahLblResultElixirNowAcc[$g_iCurAccount], _NumberFormat($g_aiCurrentLoot[$eLootElixir], True))
GUICtrlSetData($g_ahLblResultDENowAcc[$g_iCurAccount], _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir], False))
GUICtrlSetData($g_ahLblResultTrophyNowAcc[$g_iCurAccount], _NumberFormat($g_aiCurrentLoot[$eLootTrophy], True))
If Not _DateIsValid($g_sNextBuilderReadyTime) Then GUICtrlSetData($g_ahLblResultBuilderNowAcc[$g_iCurAccount], $g_iFreeBuilderCount & "/" & $g_iTotalBuilderCount)
Local $TempGemDisplay = $g_iGemAmount < 10000 ? $g_iGemAmount : Round($g_iGemAmount/1000,1)
GUICtrlSetData($g_ahLblResultGemNowAcc[$g_iCurAccount], _NumberFormat($TempGemDisplay, True))
SwitchAccountVariablesReload("UpdateStats")
GUICtrlSetData($g_ahLblResultAttacked[$g_iCurAccount], $g_aiAttackedCount)
GUICtrlSetData($g_ahLblResultSkipped[$g_iCurAccount], $g_iSkippedVillageCount)
EndIf
If $ResetStats = 1 Then
$ResetStats = 0
EndIf
If $bStatsUpdated And $g_iGuiMode = 0 Then
UpdateStatsManagedMyBotHost()
EndIf
EndFunc
Func ResetStats()
$ResetStats = 1
$g_iFirstAttack = 0
$g_iTimePassed = 0
$g_hTimerSinceStarted = __TimerInit()
GUICtrlSetData($g_hLblResultRuntime, "00:00:00")
GUICtrlSetData($g_hLblResultRuntimeNow, "00:00:00")
$g_iStatsStartedWith[$eLootGold] = $g_aiCurrentLoot[$eLootGold]
$g_iStatsStartedWith[$eLootElixir] = $g_aiCurrentLoot[$eLootElixir]
$g_iStatsStartedWith[$eLootDarkElixir] = $g_aiCurrentLoot[$eLootDarkElixir]
$g_iStatsStartedWith[$eLootTrophy] = $g_aiCurrentLoot[$eLootTrophy]
$g_iStatsTotalGain[$eLootGold] = 0
$g_iStatsTotalGain[$eLootElixir] = 0
$g_iStatsTotalGain[$eLootDarkElixir] = 0
$g_iStatsTotalGain[$eLootTrophy] = 0
$g_iStatsLastAttack[$eLootGold] = 0
$g_iStatsLastAttack[$eLootElixir] = 0
$g_iStatsLastAttack[$eLootDarkElixir] = 0
$g_iStatsLastAttack[$eLootTrophy] = 0
$g_iStatsBonusLast[$eLootGold] = 0
$g_iStatsBonusLast[$eLootElixir] = 0
$g_iStatsBonusLast[$eLootDarkElixir] = 0
$g_iSkippedVillageCount = 0
$g_iDroppedTrophyCount = 0
$g_iCostGoldWall = 0
$g_iCostElixirWall = 0
$g_iCostGoldBuilding = 0
$g_iCostElixirBuilding = 0
$g_iCostDElixirHero = 0
$g_iNbrOfWallsUppedGold = 0
$g_iNbrOfWallsUppedElixir = 0
$g_iNbrOfBuildingsUppedGold = 0
$g_iNbrOfBuildingsUppedElixir = 0
$g_iNbrOfHeroesUpped = 0
$g_iSearchCost = 0
$g_iTrainCostElixir = 0
$g_iTrainCostDElixir = 0
$g_iTrainCostGold = 0
$g_iNbrOfOoS = 0
$g_iNbrOfTHSnipeFails = 0
$g_iNbrOfTHSnipeSuccess = 0
$g_iGoldFromMines = 0
$g_iElixirFromCollectors = 0
$g_iDElixirFromDrills = 0
$g_iSmartZapGain = 0
$g_iNumLSpellsUsed = 0
$g_iNumEQSpellsUsed = 0
For $i = 0 To $g_iModeCount
$g_aiAttackedVillageCount[$i] = 0
$g_aiTotalGoldGain[$i] = 0
$g_aiTotalElixirGain[$i] = 0
$g_aiTotalDarkGain[$i] = 0
$g_aiTotalTrophyGain[$i] = 0
$g_aiNbrOfDetectedMines[$i] = 0
$g_aiNbrOfDetectedCollectors[$i] = 0
$g_aiNbrOfDetectedDrills[$i] = 0
Next
For $i = 0 To $eTroopCount - 1
$g_aiDonateStatsTroops[$i][0] = 0
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$g_aiDonateStatsSpells[$i][0] = 0
EndIf
Next
For $i = 0 To $eSiegeMachineCount - 1
$g_aiDonateStatsSieges[$i][0] = 0
Next
$g_iTotalDonateStatsTroops = 0
$g_iTotalDonateStatsTroopsXP = 0
$g_iTotalDonateStatsSpells = 0
$g_iTotalDonateStatsSpellsXP = 0
$g_iTotalDonateStatsSiegeMachines = 0
$g_iTotalDonateStatsSiegeMachinesXP = 0
If ProfileSwitchAccountEnabled() Then
SwitchAccountVariablesReload("Reset")
For $i = 0 To $g_iTotalAcc
GUICtrlSetData($g_ahLblResultRuntimeNowAcc[$i], "00:00:00")
$g_aiRunTime[$i] = 0
GUICtrlSetData($g_hLbLLabTime, "00:00:00")
For $j = 0 To 2
GUICtrlSetState($g_hPicHeroGreenStatus[$j][$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroRedStatus[$j][$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroBlueStatus[$j][$i], $GUI_HIDE)
GUICtrlSetState($g_hPicHeroGrayStatus[$j][$i], $GUI_SHOW)
Next
GUICtrlSetState($g_hPicLabGreenStatus[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicLabRedStatus[$i], $GUI_HIDE)
GUICtrlSetState($g_hPicLabGrayStatus[$i], $GUI_SHOW)
GUICtrlSetData($g_hLblLabTimeStatus[$i], "00:00:00")
Next
EndIf
UpdateStats()
EndFunc
Func WallsStatsMAJ()
$g_aiWallsCurrentCount[$g_iCmbUpgradeWallsLevel + 4] -= Number($g_iNbrOfWallsUpped)
$g_aiWallsCurrentCount[$g_iCmbUpgradeWallsLevel + 5] += Number($g_iNbrOfWallsUpped)
$g_iNbrOfWallsUpped = 0
For $i = 4 To 13
GUICtrlSetData($g_ahWallsCurrentCount[$i], $g_aiWallsCurrentCount[$i])
Next
SaveConfig()
EndFunc
Func UpdateStats_ClearArray(ByRef $a)
For $i = 0 To UBound($a) - 1
$a[$i] = 0
Next
EndFunc
Func CheckVersion()
If not $g_bCheckVersion Then Return
Local $g_sBotGitVersion = ""
Local $sCorrectStdOut = InetRead("https://api.github.com/repos/NguyenAnhHD/MyBot.Run-AIO-MOD/releases/latest")
If @error Or $sCorrectStdOut = "" Then Return
Local $Temp = BinaryToString($sCorrectStdOut)
If $Temp <> "" And Not @error Then
Local $g_aBotVersionN = StringSplit($g_sModVersion, " ", 2)
If @error Then
Local $g_iBotVersionN = StringReplace($g_sModVersion, "v", "")
Else
Local $g_iBotVersionN = StringReplace($g_aBotVersionN[0], "v", "")
EndIf
Local $version = GetLastVersion($Temp)
$g_sBotGitVersion = StringReplace($version[0], "v", "")
SetDebugLog("Last GitHub version is " & $g_sBotGitVersion )
SetDebugLog("Your version is " & $g_iBotVersionN )
If _VersionCompare($g_iBotVersionN, $g_sBotGitVersion) = -1 Then
SetLog("WARNING, YOUR VERSION (" & $g_iBotVersionN & ") IS OUT OF DATE.", $COLOR_ERROR)
Local $ChangelogTXT = GetLastChangeLog($Temp)
Local $Changelog = StringSplit($ChangelogTXT[0], '\r\n', $STR_ENTIRESPLIT + $STR_NOCOUNT)
For $i = 0 To UBound($Changelog) - 1
SetLog($Changelog[$i] )
Next
PushMsg("Update")
If MsgBox(BitOR($MB_ICONWARNING, $MB_YESNO), "BOT Update Detected", "Chief, there is a new version of the bot available (v" & $g_sBotGitVersion & ")" & @CRLF & @CRLF & "Do you want to download the latest version ?", 30) = $IDYES Then
ShellExecute($g_sModSupportUrl)
Return False
EndIf
ElseIf _VersionCompare($g_iBotVersionN, $g_sBotGitVersion) = 0 Then
SetLog("WELCOME CHIEF, YOU HAVE THE LATEST AIO++ MOD VERSION", $COLOR_SUCCESS)
Else
SetLog("YOU ARE USING A FUTURE VERSION CHIEF!", $COLOR_ACTION)
EndIf
SetLog("AIO++ MOD DEVELOPERS: NguyenAnhHD, Eloy", $COLOR_INFO)
Else
SetDebugLog($Temp)
EndIf
EndFunc
Func GetLastVersion($txt)
Return _StringBetween($txt, '"tag_name":"', '","')
EndFunc
Func GetLastChangeLog($txt)
Return _StringBetween($txt, '"body":"', '"}')
EndFunc
Func GetVersionNormalized($VersionString, $Chars = 5)
If StringLeft($VersionString, 1) = "v" Then $VersionString = StringMid($VersionString, 2)
Local $a = StringSplit($VersionString, ".", 2)
Local $i
For $i = 0 To UBound($a) - 1
If StringLen($a[$i]) < $Chars Then $a[$i] = _StringRepeat("0", $Chars - StringLen($a[$i])) & $a[$i]
Next
Return _ArrayToString($a, ".")
EndFunc
Func CloseRunningBot($sBotWindowTitle = $g_sBotTitle, $bCheckOnly = False, $bGuiInitialized = IsHWnd($g_hFrmBot))
Local $param = ""
For $i = 1 To $g_asCmdLine[0]
If $param <> "" Then $param &= " "
$param &= $g_asCmdLine[$i]
Next
Local $pid = 0
Local $otherPID = 0
Local $otherHWnD = 0
Local $otherPIDs = 0
If $param <> "" Then
$otherPIDs = ProcessesExist(@AutoItExe, $param, 1, 1, Default, True)
EndIf
Local $otherHWnDs = WinList($sBotWindowTitle)
Local $iExpectedWindows =(($bGuiInitialized) ?(1) :(0))
If $otherHWnDs[0][0] > $iExpectedWindows Or UBound($otherPIDs) > $iExpectedWindows Then
For $i = 1 To $otherHWnDs[0][0]
$pid = WinGetProcess($otherHWnDs[$i][1])
If $pid <> @AutoItPID Then
$otherPID = $pid
$otherHWnD = $otherHWnDs[$i][1]
ExitLoop
EndIf
Next
If $otherPID = 0 And UBound($otherPIDs) > $iExpectedWindows Then
For $aProcess In $otherPIDs
$pid = $aProcess[0]
Local $sCommandLine = $aProcess[2]
If $pid <> @AutoItPID And StringInStr($sCommandLine, "AutoIt3Wrapper.au3") = 0 Then
$otherPID = $pid
ExitLoop
EndIf
Next
EndIf
If $otherPID > 0 And $otherPID <> @AutoItPID Then
If $bCheckOnly = True Then
Return True
EndIf
SetDebugLog("Found existing " & $sBotWindowTitle & " instance to close, PID " & $otherPID & ", HWnD " & $otherHWnD)
WerFaultClose("AutoIt v3 Script")
WerFaultClose(@AutoItExe)
SetDebugLog("Send close message...")
_WinAPI_PostMessage($otherHWnD, $WM_CLOSE, 0, 0)
If ProcessWaitClose($otherPID, 30) = 0 Then
SetDebugLog("Existing bot window still there...")
WinKill($otherHWnD)
SetDebugLog("Existing bot window killed")
EndIf
If ProcessExists($otherPID) = $otherPID Then
SetDebugLog("Existing bot process still there...")
If KillProcess($otherPID, "CloseRunningBot") = True Then
SetDebugLog("Existing bot process now closed")
Return True
EndIf
Return False
EndIf
Return True
EndIf
EndIf
Return False
EndFunc
Func RestartBot($bCloseAndroid = True, $bAutostart = True)
SetDebugLog("Restart " & $g_sBotTitle)
Local $sCmdLine = ProcessGetCommandLine(@AutoItPID)
If @error <> 0 Then
SetLog("Cannot prepare to restart " & $g_sBotTitle & ", error code " & @error, $COLOR_RED)
Return SetError(1, 0, False)
EndIf
If $bAutostart = True Then
IniWrite($g_sProfileConfigPath, "general", "Restarted", 1)
EndIf
If StringInStr($sCmdLine, " /restart") = 0 Then
$sCmdLine &= " /restart"
EndIf
If $bCloseAndroid = True Then
CloseAndroid("RestartBot")
_Sleep(1000)
EndIf
Local $pid = Run("cmd.exe /c start """" " & $sCmdLine, $g_sWorkingDir, @SW_HIDE)
If @error = 0 Then
SetLog("Restarting " & $g_sBotTitle)
_SleepStatus(60 * 1000)
Return True
Else
SetLog("Cannot restart " & $g_sBotTitle, $COLOR_RED)
EndIf
Return SetError(2, 0, False)
EndFunc
Func WindowSystemMenu($HWnD, $iButton, $Action = Default, $DebugInfo = "")
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, False)
If $Action = Default Then
Return _GUICtrlMenu_GetItemID($hSysMenu, $iButton, False) <> 0
EndIf
Local $enabled = WindowSystemMenu($HWnD, $iButton)
If $Action <> $enabled Then
Local $i, $c = _GUICtrlMenu_GetItemCount($hSysMenu)
Local $aVisible[$c]
For $i = 0 To $c - 1
$aVisible[$i] = _GUICtrlMenu_GetItemID($hSysMenu, $i)
Next
_GUICtrlMenu_GetSystemMenu($HWnD, True)
$hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
$c = _GUICtrlMenu_GetItemCount($hSysMenu)
If $DebugInfo = "" Then $DebugInfo = $iButton
For $i = 0 To $c - 1
Local $id = _GUICtrlMenu_GetItemID($hSysMenu, $i)
If $id = $iButton Then
If $Action = False Then
SetDebugLog("Hide SystemMenu Item: " & $DebugInfo)
_GUICtrlMenu_RemoveMenu($hSysMenu, $i)
Else
SetDebugLog("Show SystemMenu Item: " & $DebugInfo)
EndIf
ElseIf  _ArraySearch($aVisible, $id) = -1 Then
_GUICtrlMenu_RemoveMenu($hSysMenu, $i)
EndIf
Next
EndIf
EndFunc
Global $g_hWaitableTimerWakeUp = 0
Func SetWakeUpSeconds($iInSecs)
SetDebugLog("SetWakeUpTime: " & $iInSecs & " Seconds")
If $g_hWaitableTimerWakeUp Then _WinAPI_CloseHandle($g_hWaitableTimerWakeUp)
Local $result = DllCall("kernel32.dll", "long", "CreateWaitableTimer", "long", 0, "boolean", True, "str", "")
If $result[0] = 0 Then
Local $lastError = DllCall("kernel32.dll", "int", "GetLastError")
SetExtended($lastError[0])
SetError(1)
Return 0
EndIf
$g_hWaitableTimerWakeUp = $result[0]
DllCall("kernel32.dll", "none", "CancelWaitableTimer", "long", $g_hWaitableTimerWakeUp)
Local $iNanoSecs = -$iInSecs * 1000 * 1000 * 10
$result = DllCall("kernel32.dll", "boolean", "SetWaitableTimer", "handle", $g_hWaitableTimerWakeUp, "INT64*", $iNanoSecs, "long", 0, "ptr", 0, "ptr", 0, "boolean", True)
If $result[0] = 0 Then
Local $lastError = DllCall("kernel32.dll", "int", "GetLastError")
SetExtended($lastError[0])
SetError(2)
Return 0
EndIf
Return 1
EndFunc
Func SetSuspend($bSuspend = True, $bForce = True)
Local $bDisableWakeEvent = False
Local $result = DllCall("PowrProf.dll", "boolean", "SetSuspendState", "boolean", Not $bSuspend, "boolean", $bForce, "boolean", $bDisableWakeEvent)
If @error Or UBound($result) = 0 Then
Local $lastError = DllCall("kernel32.dll", "int", "GetLastError")
SetExtended($lastError[0])
SetError(1)
Return 0
EndIf
Return $result[0]
EndFunc
Func _ObjErrMsg($sFunctionName, $iErrorCode)
SetDebugLog("Dictionary Error: " & $sFunctionName & " code: " & $iErrorCode, $COLOR_ERROR, True)
EndFunc
Func _ObjAdd(ByRef $oDICT, $KEY, $VALUE)
If Not IsObj($oDICT) Then
SetError(1)
Return -1
ElseIf $KEY = '' Then
SetError(2)
Return -1
ElseIf $VALUE = '' Then
SetError(3)
Return -1
ElseIf $oDICT.Exists($KEY) Then
SetError(4)
Return -1
EndIf
$oDICT.Add($KEY, $VALUE)
Return 0
EndFunc
Func _ObjPutValue(ByRef $oDICT, $KEY, $VALUE)
If Not IsObj($oDICT) Then
SetError(1)
Return -1
ElseIf $KEY = '' Then
SetError(2)
Return -1
ElseIf $VALUE = '' Then
SetError(3)
Return -1
EndIf
If $oDICT.Exists($KEY) Then
$oDICT.Item($KEY) = $VALUE
Else
$oDICT.Add($KEY, $VALUE)
EndIf
Return 0
EndFunc
Func _ObjGetValue(ByRef $oDICT, $KEY)
If Not IsObj($oDICT) Then
SetError(1)
Return -1
ElseIf $KEY = '' Then
SetError(2)
Return -1
ElseIf Not $oDICT.Exists($KEY) Then
SetError(5)
Return -1
EndIf
Return $oDICT.Item($KEY)
EndFunc
Func _ObjSearch(ByRef $oDICT, $KEY)
If Not IsObj($oDICT) Then
SetError(1)
Return -1
ElseIf $KEY = '' Then
SetError(2)
Return -1
ElseIf Not $oDICT.Exists($KEY) Then
Return False
Else
Return True
EndIf
EndFunc
Func _ObjDeleteKey(ByRef $oDICT, $KEY = '')
If Not IsObj($oDICT) Then
SetError(1)
Return -1
EndIf
If $KEY = '' Then
$oDICT.RemoveAll
Return 0
ElseIf Not $oDICT.Exists($KEY) Then
SetError(5)
Return -1
EndIf
$oDICT.Remove($KEY)
Return 0
EndFunc
Func _LogObjList(ByRef $oDICT)
If Not IsObj($oDICT) Then
SetLog("_LogObjList parameter is not object dictionary!", $COLOR_ERROR)
SetError(1)
Return -1
EndIf
Local $count = $oDICT.Count
If $count > 0 Then
Local $strKey, $Text, $array, $TotalTime
Local $colKeys = $oDICT.Keys
For $strKey In $colKeys
$Text = ""
If IsArray($oDICT.Item($strKey)) Then
$array = $oDICT.Item($strKey)
$Text = "Array Contents: "
Select
Case UBound($array, 1) > 1 And IsArray($array[1])
$Text &= PixelArrayToString($array, ",")
Case UBound($array[0]) = 2
Local $aPixel = $array[0]
$Text &= PixelToString($aPixel, ";")
Case UBound($array) = 2 And IsArray($array[0]) = 0
$Text &= PixelToString($array, ":")
Case Else
$Text = "Monkey found bad banana!"
EndSelect
Else
$Text = $oDICT.Item($strKey)
If StringInStr($strKey, "FINDTIME", $STR_NOCASESENSEBASIC) Then $TotalTime += Number($Text)
EndIf
SetLog("Dictionary Key: " & StringFormat("[%18s]", $strKey) & " = " & $Text, $COLOR_DEBUG)
Next
SetLog("Key Summary: " & StringFormat("[%18s]", "TOTAL FINDTIME") & " = " & $TotalTime, $COLOR_DEBUG)
EndIf
EndFunc
Func IsPageLoop($aCheckPixel, $iLoop = 30, $bCapturePixel = $g_bCapturePixel)
$bCapturePixel = $bCapturePixel Or $iLoop > 1
Local $IsPage = False
Local $i = 0
While $i < $iLoop
ForceCaptureRegion()
If _CheckPixel($aCheckPixel, $bCapturePixel) Then
$IsPage = True
ExitLoop
EndIf
If _Sleep($DELAYISTRAINPAGE2) Then ExitLoop
$i += 1
WEnd
Return $IsPage
EndFunc
Func IsSettingPage($bSetLog = True, $iLoop = 30)
If IsPageLoop($aIsSettingPage, $iLoop) Then
If($g_bDebugSetlog Or $g_bDebugClick) And $bSetLog Then SetLog("**Setting Window OK**", $COLOR_ACTION)
Return True
EndIf
If $bSetLog Then SetLog("Cannot find Setting Window...", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave("IsSettingPage")
If $iLoop > 1 Then AndroidPageError("IsSettingPage")
Return False
EndFunc
Func IsTrainPage($bSetLog = True, $iLoop = 30)
If IsPageLoop($aIsTrainPgChk1, $iLoop) Then
If($g_bDebugSetlog Or $g_bDebugClick) And $bSetLog Then SetLog("**Army Window OK**", $COLOR_ACTION)
Return True
EndIf
If $bSetLog Then SetLog("Cannot find Army Window...", $COLOR_ERROR)
If $g_bDebugImageSave Then DebugImageSave("IsTrainPage")
If $iLoop > 1 Then AndroidPageError("IsTrainPage")
Return False
EndFunc
Func IsAttackPage($bCapturePixel = $g_bCapturePixel)
If IsPageLoop($aIsAttackPage, 1, $bCapturePixel) Or IsPageLoop($aDoubRowAttackBar, 1, $bCapturePixel) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Attack Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_bDebugSetlog Or $g_bDebugClick Then
Local $colorRead = _GetPixelColor($aIsAttackPage[0], $aIsAttackPage[1], $bCapturePixel)
SetLog("**Attack Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aIsAttackPage[0] & "," & $aIsAttackPage[1] & ")  = " & Hex($aIsAttackPage[2], 6) & " - Found " & $colorRead, $COLOR_ACTION)
EndIf
If $g_bDebugImageSave Then DebugImageSave("IsAttackPage")
Return False
EndFunc
Func IsAttackWhileShieldPage($bSaveDebugImage = True)
If IsPageLoop($aIsAttackShield, 1) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Attack Shield Window Open**", $COLOR_ACTION)
Return True
EndIf
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Attack Shield Window not open**", $COLOR_ACTION)
If $g_bDebugImageSave And $bSaveDebugImage Then DebugImageSave("IsAttackWhileShieldPage_")
Return False
EndFunc
Func IsMainPage($iLoop = 30)
If IsPageLoop($aIsMain, $iLoop) Then
$g_bMainWindowOk = True
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Main Window OK**", $COLOR_ACTION)
Return True
EndIf
$g_bMainWindowOk = False
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Main Window FAIL**", $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsMainPage")
If $iLoop > 1 Then AndroidPageError("IsMainPage")
Return False
EndFunc
Func IsMainPageBuilderBase($iLoop = 30)
If IsPageLoop($aIsOnBuilderBase, $iLoop) Then
$g_bMainWindowOk = True
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Main Window Builder Base OK**", $COLOR_ACTION)
Return True
EndIf
$g_bMainWindowOk = False
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Main Window Builder Base FAIL**", $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsMainPageBuilderBase")
If $iLoop > 1 Then AndroidPageError("IsMainPageBase")
Return False
EndFunc
Func IsMainChatOpenPage()
If IsPageLoop($aChatTab, 1) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Chat Open Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Chat Open Window FAIL** " & $aChatTab[0] & "," & $aChatTab[1] & " " & _GetPixelColor($aChatTab[0], $aChatTab[1], True), $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsMainChatOpenPage")
Return False
EndFunc
Func IsClanInfoPage()
If IsPageLoop($aPerkBtn, 1) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Clan Info Window OK**", $COLOR_ACTION)
Return True
EndIf
Local $result = _ColorCheck(_GetPixelColor(214, 106, True), Hex(0xFFFFFF, 6), 1) And _ColorCheck(_GetPixelColor(815, 58, True), Hex(0xD80402, 6), 5)
If $result Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Clan Info Window OK**", $COLOR_ACTION)
SetLog("Join a Clan to donate and receive troops!", $COLOR_ACTION)
Return True
Else
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Clan Info Window FAIL**", $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsClanInfoPage")
Return False
EndIf
EndFunc
Func IsLaunchAttackPage()
Local $resultnoshield = IsPageLoop($aFindMatchButton, 1)
Local $resultwithshield = IsPageLoop($aFindMatchButton2, 1)
If $resultnoshield Or $resultwithshield Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Launch Attack Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_bDebugSetlog Or $g_bDebugClick Then
Local $colorReadnoshield = _GetPixelColor($aFindMatchButton[0], $aFindMatchButton[1], True)
Local $colorReadwithshield = _GetPixelColor($aFindMatchButton2[0], $aFindMatchButton2[1], True)
SetLog("**Launch Attack Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aFindMatchButton[0] & "," & $aFindMatchButton[1] & ")  = " & Hex($aFindMatchButton[2], 6) & " or " & Hex($aFindMatchButton2[2], 6) & " - Found " & $colorReadnoshield & " or " & $colorReadwithshield, $COLOR_ACTION)
EndIf
If $g_bDebugImageSave Then DebugImageSave("IsLaunchAttackPage")
Return False
EndFunc
Func IsEndBattlePage($bWriteLog = True)
If IsPageLoop($aConfirmSurrender, 1) Then
If($g_bDebugSetlog Or $g_bDebugClick) And $bWriteLog Then SetLog("**End Battle Window OK**", $COLOR_ACTION)
Return True
Else
If($g_bDebugSetlog Or $g_bDebugClick) And $bWriteLog Then
Local $colorRead = _GetPixelColor($aConfirmSurrender[0], $aConfirmSurrender[1], True)
SetLog("**End Battle Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aConfirmSurrender[0] & "," & $aConfirmSurrender[1] & ")  = " & Hex($aConfirmSurrender[2], 6) & " - Found " & $colorRead, $COLOR_ACTION)
EndIf
If $g_bDebugImageSave And $bWriteLog Then DebugImageSave("IsEndBattlePage")
Return False
EndIf
EndFunc
Func IsReturnHomeBattlePage($useReturnValue = False, $makeDebugImageScreenshot = True)
If IsPageLoop($aReturnHomeButton, 1) Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Return Home Battle Window OK**", $COLOR_ACTION)
Return True
EndIf
If($g_bDebugSetlog Or $g_bDebugClick) And($makeDebugImageScreenshot = True) Then SetLog("**Return Home Battle Window FAIL**", $COLOR_ACTION)
If $g_bDebugImageSave And $makeDebugImageScreenshot Then DebugImageSave("IsReturnHomeBattlePage")
If $useReturnValue Then
Return False
Else
Return True
EndIf
EndFunc
Func IsPostDefenseSummaryPage($bCapture = True)
Local $result
Local $GoldSpot = _GetPixelColor(330, 201 + $g_iMidOffsetY, $bCapture)
Local $ElixirSpot = _GetPixelColor(334, 233 + $g_iMidOffsetY, $bCapture)
$result = _ColorCheck($GoldSpot, Hex(0xF6E851, 6), 20) And _ColorCheck($ElixirSpot, Hex(0xE835E8, 6), 20)
If $result Then
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Post Defense Page visible**", $COLOR_ACTION)
Return True
Else
If $g_bDebugSetlog Or $g_bDebugClick Then SetLog("**Post Defense Page not visible**", $COLOR_ACTION)
If $g_bDebugImageSave Then DebugImageSave("IsPostDefenseSummaryPage")
Return False
EndIf
EndFunc
Func MoveMouseOutBS()
If $g_bMoveMouseOutBS = False Then Return
Local $hWindow, $txtTitleW, $hControl, $aMousePos
$aMousePos = MouseGetPos()
If IsArray($aMousePos) Then
$hControl = _WindowFromPoint($aMousePos[0], $aMousePos[1])
If $hControl <> 0 Then
$hWindow = _WinAPI_GetAncestor($hControl, 2)
$txtTitleW = WinGetTitle($hWindow)
If $hWindow = $g_hAndroidWindow And $txtTitleW == $g_sAndroidTitle Then
MouseMove(@DesktopWidth + 100, Round(@DesktopHeight / 2), 0)
SetLog("Keep Your Mouse Out of BlueStacks Window while bot is running", $COLOR_ERROR)
EndIf
EndIf
EndIf
EndFunc
Func _WindowFromPoint($iX, $iY)
Local $aRet, $stPoint = DllStructCreate("long;long")
DllStructSetData($stPoint, 1, $iX)
DllStructSetData($stPoint, 2, $iY)
Local $stInt64 = DllStructCreate("int64", DllStructGetPtr($stPoint))
$aRet = DllCall("user32.dll", "hwnd", "WindowFromPoint", "int64", DllStructGetData($stInt64, 1))
$stPoint = 0
$stInt64 = 0
If @error Then Return SetError(0, 0, 0)
If $aRet[0] = 0 Then Return SetError(0, 0, 0)
Return $aRet[0]
EndFunc
Func KillProcess($pid, $process_info = "", $attempts = 3)
Local $iCount = 0
If $process_info <> "" Then $process_info = ", " & $process_info
While ProcessExists($pid) And $iCount < $attempts
If ProcessClose($pid) = 1 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " closed" & $process_info)
Else
Switch @error
Case 1
SetDebugLog("Process close error: OpenProcess failed")
Case 2
SetDebugLog("Process close error: AdjustTokenPrivileges Failed")
Case 3
SetDebugLog("Process close error: TerminateProcess Failed")
Case 4
SetDebugLog("Process close error: Cannot verify if process exists")
EndSwitch
EndIf
If ProcessExists($pid) Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -pid " & $pid, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return False
If ProcessExists($pid) = 0 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " killed (using taskkill)" & $process_info)
EndIf
EndIf
If ProcessExists($pid) Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", "-f -t -pid " & $pid, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return False
If ProcessExists($pid) = 0 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " killed (using taskkill -f -t)" & $process_info)
EndIf
EndIf
$iCount += 1
WEnd
If ProcessExists($pid) Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " failed to kill" & $process_info, $COLOR_ERROR)
Return False
EndIf
Return True
EndFunc
Func CreateMutex($sMutex)
Local $hMutex = _WinAPI_CreateMutex($sMutex, False)
If $hMutex Then
Switch _WinAPI_WaitForSingleObject($hMutex, 0)
Case 0x80, 0
Return $hMutex
EndSwitch
_WinAPI_CloseHandle($hMutex)
EndIf
Return 0
EndFunc
Func AcquireMutex($mutexName, $scope = Default, $timeout = Default, $sWaitMessage = "", $bUse_Sleep = False)
Local $timer = __TimerInit()
If $sWaitMessage = Default Then $sWaitMessage = "Waiting for mutex " & $mutexName & " to become available..."
Local $iDelay = $DELAYSLEEP
If $sWaitMessage Then $iDelay = 1000
Local $g_hMutex_MyBot = 0
If $scope = Default Then
$scope = @AutoItPID & "/"
ElseIf $scope <> "" Then
$scope &= "/"
EndIf
If $timeout = Default Then $timeout = 30000
Local $bLogged = False
While $g_hMutex_MyBot = 0 And($timeout < 1 Or __TimerDiff($timer) < $timeout)
$g_hMutex_MyBot = CreateMutex("MyBot.run/" & $scope & $mutexName)
If $g_hMutex_MyBot <> 0 Then ExitLoop
If $timeout = 0 Then ExitLoop
If $sWaitMessage Then
If $bLogged = False Then
$bLogged = True
SetLog($sWaitMessage)
EndIf
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, $sWaitMessage)
EndIf
If $bUse_Sleep Then
_Sleep($iDelay)
Else
Sleep($iDelay)
EndIf
WEnd
If $g_hMutex_MyBot Then
EndIf
Return $g_hMutex_MyBot
EndFunc
Func ReleaseMutex($hMutex, $ReturnValue = Default)
If $hMutex Then
_WinAPI_ReleaseMutex($hMutex)
_WinAPI_CloseHandle($hMutex)
EndIf
If $ReturnValue = Default Then Return
Return $ReturnValue
EndFunc
Func LockSemaphore($Semaphore, $sWaitMessage = Default)
Local $bAquired = False
If $sWaitMessage = Default Then $sWaitMessage = "Waiting for slot to become available..."
Local $iDelay = $DELAYSLEEP
If $sWaitMessage Then $iDelay = 1000
Local $hSemaphore = $Semaphore
If IsString($Semaphore) = 1 Then $hSemaphore = _WinAPI_CreateSemaphore($Semaphore, 1, 1)
Local $bLogged = False
While $bAquired = False And $g_bRunState = True
$bAquired = _WinAPI_WaitForSingleObject($hSemaphore, $DELAYSLEEP) <> $WAIT_TIMEOUT
If $bAquired = True Then
Return $hSemaphore
EndIf
If $sWaitMessage Then
If $bLogged = False Then
$bLogged = True
SetLog($sWaitMessage)
EndIf
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, $sWaitMessage)
EndIf
_Sleep($iDelay, True, False)
WEnd
If $Semaphore <> $hSemaphore Then _WinAPI_CloseHandle($hSemaphore)
Return 0
EndFunc
Func UnlockSemaphore(ByRef $hSemaphore, $bCloseHandle = False)
If $hSemaphore <> 0 And $hSemaphore <> -1 Then
Local $iPreviousCount = _WinAPI_ReleaseSemaphore($hSemaphore)
If $bCloseHandle = True Then
_WinAPI_CloseHandle($hSemaphore)
$hSemaphore = 0
EndIf
Return $iPreviousCount
EndIf
Return -1
EndFunc
Func AcquireMutexTicket($sMutexName, $iMinTicketNo, $sWaitMessage = Default, $bCheckRunState = True)
Local $hTicketMutex = 0
Local $sTicketMutex = 0
Local $iTicket = 256
For $i = 1 To 255
If $bCheckRunState = True And $g_bRunState = False Then Return 0
$sTicketMutex = $sMutexName & "." & $i
$hTicketMutex = AcquireMutex($sTicketMutex, "Global", 0)
If $hTicketMutex Then
$iTicket = $i
ExitLoop
EndIf
Next
If $hTicketMutex = 0 Then
SetLog("Could not aquire mutex ticker for: " & $sMutexName, $COLOR_RED)
Return 0
EndIf
If $iTicket <= $iMinTicketNo Then
SetDebugLog("Aquired mutex ticket: " & $sTicketMutex & ", " & $hTicketMutex)
Return $hTicketMutex
EndIf
SetDebugLog("Wait mutex ticket: " & $sTicketMutex)
If $sWaitMessage = Default Then $sWaitMessage = "Waiting for slot to become available..."
Local $iDelay = $DELAYSLEEP
If $sWaitMessage Then $iDelay = 1000
Local $bLogged = False
While $bCheckRunState = False Or $g_bRunState = True
If $iTicket = $iMinTicketNo + 1 Then
For $i = 1 To $iMinTicketNo
$sTicketMutex = $sMutexName & "." & $i
Local $hFinalTicketMutex = AcquireMutex($sTicketMutex, "Global", 0)
If $hFinalTicketMutex Then
SetDebugLog("Aquired mutex ticket: " & $sTicketMutex & ", " & $hFinalTicketMutex)
Return ReleaseMutex($hTicketMutex, $hFinalTicketMutex)
EndIf
Next
Else
$sTicketMutex = $sMutexName & "." &($iTicket - 1)
Local $hNextTicketMutex = AcquireMutex($sTicketMutex, "Global", 0)
If $hNextTicketMutex Then
SetDebugLog("New mutex ticket: " & $sTicketMutex)
$iTicket -= 1
$hTicketMutex = ReleaseMutex($hTicketMutex, $hNextTicketMutex)
EndIf
EndIf
If $sWaitMessage Then
If $bLogged = False Then
$bLogged = True
SetLog($sWaitMessage)
EndIf
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, $sWaitMessage)
EndIf
_Sleep($iDelay, True, False)
WEnd
Return ReleaseMutex($hTicketMutex, 0)
EndFunc
Func LockBotSlot($bLock = True)
If $g_bBotLaunchOption_NoBotSlot = True Then Return False
Static $bBotIsLocked = False
If $bLock = Default Then Return $bBotIsLocked
If $bLock = $bBotIsLocked Then Return $bBotIsLocked
Local $bWasLocked = $bBotIsLocked
If $bLock = True And $g_bRunState = True Then
If $g_hMutextOrSemaphoreGlobalActiveBots Then
SetDebugLog("LockBotSlot not released: " & $g_hMutextOrSemaphoreGlobalActiveBots)
ReleaseMutex($g_hMutextOrSemaphoreGlobalActiveBots)
$g_hMutextOrSemaphoreGlobalActiveBots = 0
EndIf
$g_hMutextOrSemaphoreGlobalActiveBots = AcquireMutexTicket("ActiveBot", $g_iGlobalActiveBotsAllowed, GetTranslatedFileIni("MBR GUI Design - Loading", "SplashStep_09", "Waiting for bot slot..."))
If $g_hMutextOrSemaphoreGlobalActiveBots Then $bBotIsLocked = $bLock
ElseIf $bLock = False Then
ReleaseMutex($g_hMutextOrSemaphoreGlobalActiveBots)
SetDebugLog("Released Bot slot mutex: " & $g_hMutextOrSemaphoreGlobalActiveBots)
$g_hMutextOrSemaphoreGlobalActiveBots = 0
$bBotIsLocked = $bLock
EndIf
Return $bWasLocked
EndFunc
Global $g_oWMI = 0
Global $g_WmiAPI_External = False
Global Static $g_WmiFields = ["Handle", "ExecutablePath", "CommandLine"]
Func GetWmiSelectFields()
Return _ArrayToString($g_WmiFields, ",")
EndFunc
Func GetWmiObject()
If $g_oWMI = 0 Then $g_oWMI = ObjGet("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")
If @error Or Not IsObj($g_oWMI) Then Return -1
Return $g_oWMI
EndFunc
Func CloseWmiObject()
$g_oWMI = 0
EndFunc
Func WmiQuery($sQuery)
If $g_WmiAPI_External = True Then
Local $sAppFile = @ScriptDir & "\MyBot.run.Wmi." &((@Compiled) ?("exe") :("au3"))
If FileExists($sAppFile) Then
Local $process_killed
Local $cmd = """" & $sAppFile & """"
If @Compiled = 0 Then $cmd = """" & @AutoItExe & """ /AutoIt3ExecuteScript """ & $sAppFile & """"
Local $s = LaunchConsole($cmd, """" & $sQuery & """", $process_killed)
Return WmiOutputToArray($s)
EndIf
EndIf
Local $aProcesses[0]
SetDebugLog("WMI Query: " & $sQuery)
Local $oObjc = GetWmiObject()
If $oObjc = -1 Or @error Then Return 0
Local $oProcessColl = $oObjc.ExecQuery($sQuery, "WQL", 0x20 + 0x10)
For $Process In $oProcessColl
Local $aProcess[UBound($g_WmiFields)]
For $i = 0 To UBound($g_WmiFields) - 1
$aProcess[$i] = Execute("$Process." & $g_WmiFields[$i])
Next
ReDim $aProcesses[UBound($aProcesses) + 1]
$aProcesses[UBound($aProcesses) - 1] = $aProcess
Next
Return $aProcesses
EndFunc
Func WmiOutputToArray(ByRef $s)
Local $aProcesses[0]
Local $sProcesses = StringBetween($s, "<Processes>", "</Processes>")
If @error Then Return $aProcesses
Local $iPos = 1
While $iPos > 0
Local $sProcess = StringBetween($sProcesses, "<Process>", "</Process>", $iPos)
$iPos = @extended
If $iPos > 0 Then
Local $aProcess[UBound($g_WmiFields)]
Local $iPos2 = 1
For $i = 0 To UBound($g_WmiFields) - 1
$aProcess[$i] = StringBetween($sProcess, "<" & $g_WmiFields[$i] & ">", "</" & $g_WmiFields[$i] & ">", $iPos2)
$iPos2 = @extended
Next
ReDim $aProcesses[UBound($aProcesses) + 1]
$aProcesses[UBound($aProcesses) - 1] = $aProcess
EndIf
WEnd
Return $aProcesses
EndFunc
Func StringBetween(ByRef $s, $sStartTag, $sEndTag, $iStartPos = 1)
Local $iS = StringInStr($s, $sStartTag, 0, 1, $iStartPos)
If $iS > 0 Then
$iS += StringLen($sStartTag)
Local $iE = StringInStr($s, $sEndTag, 0, 1, $iS)
If $iE > 0 Then
Return SetError(0, $iE + StringLen($sEndTag), StringMid($s, $iS, $iE - $iS))
EndIf
EndIf
Return SetError(1, 0, "")
EndFunc
Func _NamedPipes_CreatePipe(ByRef $hReadPipe, ByRef $hWritePipe, $tSecurity = 0, $iSize = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "CreatePipe", "handle*", 0, "handle*", 0, "struct*", $tSecurity, "dword", $iSize)
If @error Then Return SetError(@error, @extended, False)
$hReadPipe = $aResult[1]
$hWritePipe = $aResult[2]
Return $aResult[0]
EndFunc
Global $g_RunPipe_hProcess = 0
Global $g_RunPipe_hThread = 0
Func LaunchConsole($cmd, $param, ByRef $process_killed, $timeout = 10000, $bUseSemaphore = False)
Local $bDebug = $g_bDebugSetlog Or $g_bDebugAndroid
If $bUseSemaphore Then
Local $hSemaphore = LockSemaphore(StringReplace($cmd, "\", "/"), "Waiting to launch: " & $cmd)
EndIf
Local $data, $pid, $hStdIn[2], $hStdOut[2], $hTimer, $hProcess, $hThread
If StringLen($param) > 0 Then $cmd &= " " & $param
$hTimer = __TimerInit()
$process_killed = False
If $bDebug Then SetLog("Func LaunchConsole: " & $cmd, $COLOR_DEBUG)
$pid = RunPipe($cmd, "", @SW_HIDE, $STDERR_MERGED, $hStdIn, $hStdOut, $hProcess, $hThread)
If $bDebug Then SetLog("Func LaunchConsole: command launched", $COLOR_DEBUG)
If $pid = 0 Then
SetLog("Launch faild: " & $cmd, $COLOR_ERROR)
If $bUseSemaphore = True Then UnlockSemaphore($hSemaphore)
Return
EndIf
Local $timeout_sec = Round($timeout / 1000)
Local $iWaitResult
Do
$iWaitResult = _WinAPI_WaitForSingleObject($hProcess, $DELAYSLEEP)
$data &= ReadPipe($hStdOut[0])
Until($timeout > 0 And __TimerDiff($hTimer) > $timeout) Or $iWaitResult <> $WAIT_TIMEOUT
If ProcessExists($pid) Then
If ClosePipe($pid, $hStdIn, $hStdOut, $hProcess, $hThread) = 1 Then
If $bDebug Then SetLog("Process killed: " & $cmd, $COLOR_ERROR)
$process_killed = True
EndIf
Else
ClosePipe($pid, $hStdIn, $hStdOut, $hProcess, $hThread)
EndIf
$g_RunPipe_hProcess = 0
$g_RunPipe_hThread = 0
CleanLaunchOutput($data)
If $bDebug Then SetLog("Func LaunchConsole Output: " & $data, $COLOR_DEBUG)
If $bUseSemaphore Then UnlockSemaphore($hSemaphore)
Return $data
EndFunc
Func ProcessExists2($ProgramPath, $ProgramParameter = Default, $CompareMode = Default, $SearchMode = 0, $CompareCommandLineFunc = "")
If IsInt($ProgramPath) Then
Local $hProcess, $pid = Int($ProgramPath)
If _WinAPI_GetVersion() >= 6.0 Then
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_LIMITED_INFORMATION, 0, $pid)
Else
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_INFORMATION, 0, $pid)
EndIf
Local $iExitCode = 0
If $hProcess And @error = 0 Then
$iExitCode = _WinAPI_GetExitCodeProcess($hProcess)
_WinAPI_CloseHandle($hProcess)
EndIf
Return(($iExitCode = 259) ? $pid : 0)
EndIf
If $ProgramParameter = Default Then
$ProgramParameter = ""
If $CompareMode = Default Then $CompareMode = 1
EndIf
If $CompareMode = Default Then
$CompareMode = 0
EndIf
Local $exe = $ProgramPath
Local $iLastBS = StringInStr($exe, "\", 0, -1)
If $iLastBS > 0 Then $exe = StringMid($exe, $iLastBS + 1)
Local $commandLine =($ProgramPath <> "" ?('"' & $ProgramPath & '"' &($ProgramParameter = "" ? "" : " " & $ProgramParameter)) : $ProgramParameter)
Local $commandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($commandLine, ".exe", "", 1), " ", ""), '"', ""), "'", "")
Local $query = "Select " & GetWmiSelectFields() & " from Win32_Process"
If StringLen($commandLine) > 0 Then
$query &= " where "
If StringLen($ProgramPath) > 0 Then
$query &= "ExecutablePath like '%" & StringReplace($ProgramPath, "\", "\\") & "%'"
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= " And "
EndIf
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= "CommandLine like '%" & StringReplace($ProgramParameter, "\", "\\") & "%'"
EndIf
Local $pid = 0, $i = 0
For $Process In WmiQuery($query)
SetDebugLog($Process[0] & " = " & $Process[1] & " (" & $Process[2] & ")")
If $pid = 0 Then
Local $processCommandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($Process[2], ".exe", "", 1), " ", ""), '"', ""), "'", "")
If($CompareMode = 0 And $commandLineCompare = $processCommandLineCompare) Or($CompareMode = 0 And StringRight($commandLineCompare, StringLen($processCommandLineCompare)) = $processCommandLineCompare) Or($CompareMode = 0 And $CompareCommandLineFunc <> "" And Execute($CompareCommandLineFunc & "(""" & StringReplace($Process[2], """", "") & """)") = True) Or $CompareMode = 1 Then
$pid = Number($Process[0])
EndIf
EndIf
$i += 1
$Process = 0
Next
If $pid = 0 Then
SetDebugLog("Process by CommandLine not found: " & $ProgramPath &($ProgramParameter = "" ? "" :($ProgramPath <> "" ? " " : "") & $ProgramParameter))
Else
SetDebugLog("Found Process " & $pid & " by CommandLine: " & $ProgramPath &($ProgramParameter = "" ? "" :($ProgramPath <> "" ? " " : "") & $ProgramParameter))
EndIf
CloseWmiObject()
Return $pid
EndFunc
Func ProcessesExist($ProgramPath, $ProgramParameter = Default, $CompareMode = Default, $SearchMode = Default, $CompareCommandLineFunc = Default, $bReturnDetailedArray = Default, $strComputer = ".")
If $ProgramParameter = Default Then $ProgramParameter = ""
If $CompareMode = Default Then $CompareMode = 0
If $SearchMode = Default Then $SearchMode = 0
If $CompareCommandLineFunc = Default Then $CompareCommandLineFunc = ""
If $bReturnDetailedArray = Default Then $bReturnDetailedArray = False
If IsNumber($ProgramPath) Then
Local $a[1] = [ProcessExists($ProgramPath)]
Return $a
EndIf
Local $exe = $ProgramPath
Local $iLastBS = StringInStr($exe, "\", 0, -1)
If $iLastBS > 0 Then $exe = StringMid($exe, $iLastBS + 1)
Local $commandLine =($ProgramPath <> "" ?('"' & $ProgramPath & '"' &($ProgramParameter = "" ? "" : " " & $ProgramParameter)) : $ProgramParameter)
Local $commandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($commandLine, ".exe", "", 1), " ", ""), '"', ""), "'", "")
Local $query = "Select " & GetWmiSelectFields() & " from Win32_Process"
If StringLen($commandLine) > 0 Then
$query &= " where "
If StringLen($ProgramPath) > 0 Then
$query &= "ExecutablePath like '%" & StringReplace($ProgramPath, "\", "\\") & "%'"
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= " And "
EndIf
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= "CommandLine like '%" & StringReplace($ProgramParameter, "\", "\\") & "%'"
EndIf
Local $Process, $pid = 0, $i = 0
Local $PIDs[0]
For $Process In WmiQuery($query)
SetDebugLog($Process[0] & " = " & $Process[2])
Local $processCommandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($Process[2], ".exe", "", 1), " ", ""), '"', ""), "'", "")
If($CompareMode = 0 And $commandLineCompare = $processCommandLineCompare) Or($CompareMode = 0 And StringRight($commandLineCompare, StringLen($processCommandLineCompare)) = $processCommandLineCompare) Or($CompareMode = 0 And $CompareCommandLineFunc <> "" And Execute($CompareCommandLineFunc & "(""" & StringReplace($Process[2], """", "") & """)") = True) Or $CompareMode = 1 Then
$pid = Number($Process[0])
ReDim $PIDs[$i + 1]
Local $a = $pid
If $bReturnDetailedArray Then
Local $a = [$pid, $Process[1], $Process[2]]
EndIf
$PIDs[$i] = $a
$i += 1
$Process = 0
EndIf
Next
If $i = 0 Then
SetDebugLog("No process found by CommandLine: " & $ProgramPath &($ProgramParameter = "" ? "" : " " & $ProgramParameter))
Else
SetDebugLog("Found " & $i & " process(es) with " & $ProgramPath &($ProgramParameter = "" ? "" : " " & $ProgramParameter))
EndIf
CloseWmiObject()
Return $PIDs
EndFunc
Func ProcessGetCommandLine($pid, $strComputer = ".")
If Not IsNumber($pid) Then Return SetError(2, 0, -1)
Local $query = "Select " & GetWmiSelectFields() & " from Win32_Process where Handle = " & $pid
For $Process In WmiQuery($query)
SetDebugLog($Process[0] & " = " & $Process[2])
SetError(0, 0, 0)
Local $sProcessCommandLine = $Process[2]
$Process = 0
CloseWmiObject()
Return $sProcessCommandLine
Next
SetDebugLog("Process not found with PID " & $pid)
$Process = 0
CloseWmiObject()
Return SetError(1, 0, -1)
EndFunc
Func ProcessGetWmiProcess($pid, $strComputer = ".")
If Not IsNumber($pid) Then Return SetError(2, 0, -1)
Local $query = "Select " & GetWmiSelectFields() & " from Win32_Process where Handle = " & $pid
For $Process In WmiQuery($query)
SetDebugLog($Process[0] & " = " & $Process[2])
SetError(0, 0, 0)
CloseWmiObject()
Return $Process
Next
SetDebugLog("Process not found with PID " & $pid)
$Process = 0
CloseWmiObject()
Return SetError(1, 0, -1)
EndFunc
Func CleanLaunchOutput(ByRef $output)
$output = StringReplace($output, @CR & @CR, "")
$output = StringReplace($output, @CRLF & @CRLF, "")
If StringRight($output, 1) = @LF Then $output = StringLeft($output, StringLen($output) - 1)
If StringRight($output, 1) = @CR Then $output = StringLeft($output, StringLen($output) - 1)
EndFunc
Func RunPipe($program, $workdir, $show_flag, $opt_flag, ByRef $hStdIn, ByRef $hStdOut, ByRef $hProcess, ByRef $hThread)
If UBound($hStdIn) < 2 Then
Local $a = [0, 0]
$hStdIn = $a
EndIf
If UBound($hStdOut) < 2 Then
Local $a = [0, 0]
$hStdOut = $a
EndIf
Local $tSecurity = DllStructCreate($tagSECURITY_ATTRIBUTES)
DllStructSetData($tSecurity, "Length", DllStructGetSize($tSecurity))
DllStructSetData($tSecurity, "InheritHandle", True)
_NamedPipes_CreatePipe($hStdIn[0], $hStdIn[1], $tSecurity)
_WinAPI_SetHandleInformation($hStdIn[1], $HANDLE_FLAG_INHERIT, 0)
_NamedPipes_CreatePipe($hStdOut[0], $hStdOut[1], $tSecurity)
_WinAPI_SetHandleInformation($hStdOut[0], $HANDLE_FLAG_INHERIT, 0)
Local $StartupInfo = DllStructCreate($tagSTARTUPINFO)
DllStructSetData($StartupInfo, "Size", DllStructGetSize($StartupInfo))
DllStructSetData($StartupInfo, "Flags", $STARTF_USESTDHANDLES + $STARTF_USESHOWWINDOW)
DllStructSetData($StartupInfo, "StdInput", $hStdIn[0])
DllStructSetData($StartupInfo, "StdOutput", $hStdOut[1])
DllStructSetData($StartupInfo, "StdError", $hStdOut[1])
DllStructSetData($StartupInfo, "ShowWindow", $show_flag)
Local $lpStartupInfo = DllStructGetPtr($StartupInfo)
Local $ProcessInformation = DllStructCreate($tagPROCESS_INFORMATION)
Local $lpProcessInformation = DllStructGetPtr($ProcessInformation)
If __WinAPI_CreateProcess("", $program, 0, 0, True, 0, 0, $workdir, $lpStartupInfo, $lpProcessInformation) Then
Local $pid = DllStructGetData($ProcessInformation, "ProcessID")
$hProcess = DllStructGetData($ProcessInformation, "hProcess")
$hThread = DllStructGetData($ProcessInformation, "hThread")
Return $pid
EndIf
SetDebugLog("RunPipe: Failed creating new process: " & $program)
ClosePipe(0, $hStdIn, $hStdOut, 0, 0)
EndFunc
Func ClosePipe($pid, $hStdIn, $hStdOut, $hProcess, $hThread)
_WinAPI_CloseHandle($hStdIn[0])
_WinAPI_CloseHandle($hStdIn[1])
_WinAPI_CloseHandle($hStdOut[0])
_WinAPI_CloseHandle($hStdOut[1])
If $hProcess Then _WinAPI_CloseHandle($hProcess)
If $hThread Then _WinAPI_CloseHandle($hThread)
Return ProcessClose($pid)
EndFunc
Func ReadPipe(ByRef $hPipe)
If DataInPipe($hPipe) = 0 Then Return SetError(@error, @extended, "")
Local $tBuffer = DllStructCreate("char Text[4096]")
Local $iRead
If _WinAPI_ReadFile($hPipe, DllStructGetPtr($tBuffer), 4096, $iRead) Then
Return SetError(0, 0, DllStructGetData($tBuffer, "Text"))
EndIf
Return SetError(@error, @extended, "")
EndFunc
Func WritePipe(ByRef $hPipe, Const $s)
Local $tBuffer = DllStructCreate("char Text[4096]")
DllStructSetData($tBuffer, "Text", $s)
Local $iToWrite = StringLen($s)
Local $iWritten = 0
If _WinAPI_WriteFile($hPipe, DllStructGetPtr($tBuffer), $iToWrite, $iWritten) Then
Return SetError(0, 0, $iWritten)
EndIf
Return SetError(@error, @extended, 0)
EndFunc
Func DataInPipe(ByRef $hPipe)
Local $aResult = DllCall("kernel32.dll", "bool", "PeekNamedPipe", "handle", $hPipe, "ptr", 0, "int", 0, "dword*", 0, "dword*", 0, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
Return SetError(0, 0, $aResult[5])
EndFunc
Func __WinAPI_CreateProcess($sAppName, $sCommand, $tSecurity, $tThread, $bInherit, $iFlags, $pEnviron, $sDir, $tStartupInfo, $tProcess)
Local $tCommand = 0
Local $sAppNameType = "wstr", $sDirType = "wstr"
If $sAppName = "" Then
$sAppNameType = "ptr"
$sAppName = 0
EndIf
If $sCommand <> "" Then
$tCommand = DllStructCreate("wchar Text[" & 4096 + 1 & "]")
DllStructSetData($tCommand, "Text", $sCommand)
EndIf
If $sDir = "" Then
$sDirType = "ptr"
$sDir = 0
EndIf
Local $aResult = DllCall("kernel32.dll", "bool", "CreateProcessW", $sAppNameType, $sAppName, "struct*", $tCommand, "struct*", $tSecurity, "struct*", $tThread, "bool", $bInherit, "dword", $iFlags, "struct*", $pEnviron, $sDirType, $sDir, "struct*", $tStartupInfo, "struct*", $tProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FreeConsole()
Local $aResult = DllCall("kernel32.dll", "bool", "FreeConsole")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_AllocConsole()
Local $aResult = DllCall("kernel32.dll", "bool", "AllocConsole")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetConsoleIcon($g_sLibIconPath, $nIconID, $hWnD = Default)
Local $hIcon = DllStructCreate("int")
Local $Result = DllCall("shell32.dll", "int", "ExtractIconEx", "str", $g_sLibIconPath, "int", $nIconID - 1, "hwnd", 0, "ptr", DllStructGetPtr($hIcon), "int", 1)
If UBound($Result) > 0 Then
$Result = $Result[0]
If $Result > 0 Then
Local $error = 0, $extended = 0
If $hWnD = Default Then
$Result = DllCall("kernel32.dll", "bool", "SetConsoleIcon", "ptr", DllStructGetData($hIcon, 1))
$Result = DllCall("kernel32.dll", "hwnd", "GetConsoleWindow")
$error = @error
$extended = @extended
If UBound($Result) > 0 Then $hWnD = $Result[0]
EndIf
If IsHWnd($hWnD) Then
_SendMessage($hWnD, $WM_SETICON, 0, DllStructGetData($hIcon, 1))
_SendMessage($hWnD, $WM_SETICON, 1, DllStructGetData($hIcon, 1))
Sleep(50)
EndIf
DllCall("user32.dll", "int", "DestroyIcon", "hwnd", DllStructGetData($hIcon, 1))
If $error Then Return SetError($error, $extended, False)
Return True
EndIf
EndIf
If @error Then Return SetError(@error, @extended, False)
EndFunc
Func _ConsoleWrite($Text)
Local $hFile, $pBuffer, $iToWrite, $iWritten, $tBuffer = DllStructCreate("char[" & StringLen($Text) & "]")
DllStructSetData($tBuffer, 1, $Text)
$hFile = _WinAPI_GetStdHandle(1)
_WinAPI_WriteFile($hFile, $tBuffer, StringLen($Text), $iWritten)
Return $iWritten
EndFunc
Func FindExitButton($sButtonName)
Local $aCoor
Local $sDirectory = "exitbutton-bundle"
Local $sReturnProps = "objectpoints"
Local $result = ""
Local $aPosXY = ""
$aCoor = StringSplit(GetButtonRectangle($sButtonName), ",", $STR_NOCOUNT)
_CaptureRegion2($aCoor[0], $aCoor[1], $aCoor[2], $aCoor[3])
$result = findMultiple($sDirectory ,"FV" ,"FV", 0, 0, 1 , $sReturnProps, False)
If IsArray($result) then
$aPosXY = StringSplit(($result[0])[0], ",", $STR_NOCOUNT)
$aPosXY[0] += $aCoor[0]
$aPosXY[1] += $aCoor[1]
If $g_bDebugSetlog Then SetDebugLog("FindExitButton: " & $sButtonName & " Button X|Y = " & $aPosXY[0] & "|" & $aPosXY[1], $COLOR_DEBUG)
Return $aPosXY
EndIf
If $g_bDebugSetlog Then SetDebugLog("FindExitButton: " & $sButtonName & " NOT Found" , $COLOR_DEBUG)
Return $aPosXY
EndFunc
Func FindAdsXButton()
Local $sCoor
Local $sDirectory = "adsxbutton-bundle"
Local $sReturnProps = "objectpoints"
Local $result = ""
Local $aPosXY = ""
$sCoor = GetDiamondFromRect(GetButtonRectangle("AdsX"))
$result = findMultiple($sDirectory, $sCoor, $sCoor, 0, 0, 1, $sReturnProps, False)
If IsArray($result) then
$aPosXY = StringSplit(($result[0])[0], ",", $STR_NOCOUNT)
If $g_bDebugSetlog Then SetDebugLog("FindAdsXButton: " & $g_sAndroidGameDistributor & " AdsX Button X|Y = " & $aPosXY[0] & "|" & $aPosXY[1], $COLOR_DEBUG)
Return $aPosXY
EndIf
If $g_bDebugSetlog Then SetDebugLog("FindAdsXButton: " & $g_sAndroidGameDistributor & " NOT Found", $COLOR_DEBUG)
Return $aPosXY
EndFunc
Func GetButtonRectangle($sButtonName)
Local $btnRectangle = "0,0," & $g_iDEFAULT_WIDTH & "," & $g_iDEFAULT_HEIGHT
Switch $sButtonName
Case "Kunlun", "Huawei", "Kaopu", "Microvirt", "Yeshen"
$btnRectangle = GetDummyRectangle("345,394", 10)
Case "Qihoo"
$btnRectangle = GetDummyRectangle("302,456", 10)
Case "Baidu"
$btnRectangle = GetDummyRectangle("464,426", 10)
Case "OPPO"
$btnRectangle = GetDummyRectangle("476,412", 10)
Case "Anzhi"
$btnRectangle = GetDummyRectangle("328,371", 10)
Case "Lenovo"
$btnRectangle = GetDummyRectangle("477,476", 10)
Case "Aiyouxi"
$btnRectangle = GetDummyRectangle("468,392", 10)
Case "9game"
$btnRectangle = "349,352,369,436"
Case "VIVO", "Xiaomi"
$btnRectangle = GetDummyRectangle("353,387", 10)
Case "Guopan"
$btnRectangle = GetDummyRectangle("409,440", 10)
Case "AdsX"
$btnRectangle =($g_iDEFAULT_WIDTH / 2) & ",0," & $g_iDEFAULT_WIDTH & "," &($g_iDEFAULT_HEIGHT / 2)
Case Else
$btnRectangle = "0,0," & $g_iDEFAULT_WIDTH & "," & $g_iDEFAULT_HEIGHT
EndSwitch
Return $btnRectangle
EndFunc
Func _CaptureRegion(Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT, Const $ReturnLocal_hHBitmap = False)
If $ReturnLocal_hHBitmap Then
Local $_hHBitmap
_CaptureGameScreen($_hHBitmap, $iLeft, $iTop, $iRight, $iBottom)
Return $_hHBitmap
EndIf
If $g_hHBitmap <> 0 And $g_hHBitmap <> $g_hHBitmapTest And $g_hHBitmap2 <> $g_hHBitmap Then
GdiDeleteHBitmap($g_hHBitmap)
EndIf
_CaptureGameScreen($g_hHBitmap, $iLeft, $iTop, $iRight, $iBottom)
If $g_hBitmap <> 0 Then
GdiDeleteBitmap($g_hBitmap)
EndIf
$g_hBitmap = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap)
GdiAddBitmap($g_hBitmap)
Return $g_hHBitmap
EndFunc
Func _CaptureRegion2(Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
If $g_hHBitmap2 <> 0 And $g_hHBitmap2 <> $g_hHBitmapTest And $g_hHBitmap2 <> $g_hHBitmap Then
GdiDeleteHBitmap($g_hHBitmap2)
EndIf
_CaptureGameScreen($g_hHBitmap2, $iLeft, $iTop, $iRight, $iBottom)
EndFunc
Func _CaptureGameScreen(ByRef $_hHBitmap, Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
Local $SuspendMode
If $g_hHBitmapTest = 0 Then
If $g_bRunState Then CheckAndroidRunning()
Local $iL = $iLeft, $iT = $iTop, $iR = $iRight, $iB = $iBottom
Local $iW = Number($iR) - Number($iL), $iH = Number($iB) - Number($iT)
Local $bDebugAlwaysSaveFullScreenTimer = False
If Not $g_hDebugAlwaysSaveFullScreenTimer = 0 Then
If __TimerDiff($g_hDebugAlwaysSaveFullScreenTimer) < 300000 Then
$bDebugAlwaysSaveFullScreenTimer = True
$iL = 0
$iT = 0
$iR = $g_iGAME_WIDTH
$iB = $g_iGAME_HEIGHT
$iW = Number($iR) - Number($iL)
$iH = Number($iB) - Number($iT)
Else
SetLog("Disable $g_hDebugAlwaysSaveFullScreenTimer")
$g_hDebugAlwaysSaveFullScreenTimer = 0
EndIf
EndIf
If $g_bChkBackgroundMode = True Then
If $g_bAndroidAdbScreencap = True Then
$_hHBitmap = AndroidScreencap($iL, $iT, $iW, $iH)
Else
$SuspendMode = ResumeAndroid(False)
Local $hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
If $hCtrl = 0 Then SetLog("AndroidHandle not found, contact support", $COLOR_ERROR)
Local $hDC_Capture = _WinAPI_GetDC($hCtrl)
Local $hMemDC = _WinAPI_CreateCompatibleDC($hDC_Capture)
$_hHBitmap = _WinAPI_CreateCompatibleBitmap($hDC_Capture, $iW, $iH)
Local $hObjectOld = _WinAPI_SelectObject($hMemDC, $_hHBitmap)
Local $flags = 0
DllCall("user32.dll", "int", "PrintWindow", "hwnd", $hCtrl, "handle", $hMemDC, "int", $flags)
_WinAPI_SelectObject($hMemDC, $_hHBitmap)
_WinAPI_BitBlt($hMemDC, 0, 0, $iW, $iH, $hDC_Capture, $iL, $iT, $SRCCOPY)
_WinAPI_DeleteDC($hMemDC)
_WinAPI_SelectObject($hMemDC, $hObjectOld)
_WinAPI_ReleaseDC($hCtrl, $hDC_Capture)
SuspendAndroid($SuspendMode, False)
EndIf
Else
getBSPos()
$SuspendMode = ResumeAndroid(False)
$_hHBitmap = _ScreenCapture_Capture("", $iL + $g_aiBSpos[0], $iT + $g_aiBSpos[1], $iR + $g_aiBSpos[0] - 1, $iB + $g_aiBSpos[1] - 1, False)
SuspendAndroid($SuspendMode, False)
EndIf
If $bDebugAlwaysSaveFullScreenTimer = True Then
Local $sDateTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN & "-" & @SEC & "." & @MSEC
Local $hBitmap_full = _GDIPlus_BitmapCreateFromHBITMAP($_hHBitmap)
SetDebugLog("Save full screen: " & $g_sProfileTempDebugPath & "FullScreen_" & $sDateTime & ".png")
_GDIPlus_ImageSaveToFile($hBitmap_full, $g_sProfileTempDebugPath & "FullScreen_" & $sDateTime & ".png")
_GDIPlus_BitmapDispose($hBitmap_full)
If $iLeft > 0 Or $iTop > 0 Or $iRight < $g_iGAME_WIDTH Or $iBottom < $g_iGAME_HEIGHT Then
Local $hHBitmap_full = $_hHBitmap
$_hHBitmap = GetHHBitmapArea($_hHBitmap, $iLeft, $iTop, $iRight, $iBottom)
_WinAPI_DeleteObject($hHBitmap_full)
EndIf
EndIf
ElseIf $iLeft > 0 Or $iTop > 0 Or $iRight < $g_iGAME_WIDTH Or $iBottom < $g_iGAME_HEIGHT Then
$_hHBitmap = GetHHBitmapArea($g_hHBitmapTest, $iLeft, $iTop, $iRight, $iBottom)
Else
$_hHBitmap = $g_hHBitmapTest
EndIf
GdiAddHBitmap($_hHBitmap)
$g_bForceCapture = False
EndFunc
Func _CaptureDispose()
If $g_hBitmap <> 0 Then GdiDeleteBitmap($g_hBitmap)
If $g_hHBitmap <> 0 Then GdiDeleteHBitmap($g_hHBitmap)
If $g_hHBitmap2 <> 0 Then GdiDeleteHBitmap($g_hHBitmap2)
If $g_hHBitmapTest <> 0 Then GdiDeleteHBitmap($g_hHBitmapTest)
$g_hBitmap = 0
$g_hHBitmap = 0
$g_hHBitmap2 = 0
$g_hHBitmapTest = 0
EndFunc
Func _CaptureRegion2Sync()
If $g_hHBitmap2 <> 0 And $g_hHBitmap2 <> $g_hHBitmapTest And $g_hHBitmap2 <> $g_hHBitmap Then
GdiDeleteHBitmap($g_hHBitmap2)
EndIf
$g_hHBitmap2 = GetHHBitmapArea($g_hHBitmap)
EndFunc
Func _CaptureRegions()
_CaptureRegion()
_CaptureRegion2Sync()
Return True
EndFunc
Func GetHHBitmapArea(Const ByRef $_hHBitmap, Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
Local $iW = Number($iRight) - Number($iLeft), $iH = Number($iBottom) - Number($iTop)
Local $hDC = _WinAPI_GetDC($g_hFrmBot)
Local $hMemDC_src = _WinAPI_CreateCompatibleDC($hDC)
Local $hMemDC_dst = _WinAPI_CreateCompatibleDC($hDC)
Local $_hHBitmapArea = _WinAPI_CreateCompatibleBitmap($hDC, $iW, $iH)
Local $hObjectOld_src = _WinAPI_SelectObject($hMemDC_src, $_hHBitmap)
Local $hObjectOld_dst = _WinAPI_SelectObject($hMemDC_dst, $_hHBitmapArea)
_WinAPI_BitBlt($hMemDC_dst, 0, 0, $iW, $iH, $hMemDC_src, $iLeft, $iTop, $SRCCOPY)
_WinAPI_SelectObject($hMemDC_src, $hObjectOld_src)
_WinAPI_SelectObject($hMemDC_dst, $hObjectOld_dst)
_WinAPI_ReleaseDC($g_hFrmBot, $hDC)
_WinAPI_DeleteDC($hMemDC_src)
_WinAPI_DeleteDC($hMemDC_dst)
GdiAddHBitmap($_hHBitmapArea)
Return $_hHBitmapArea
EndFunc
Func FastCaptureRegion()
Return $g_bChkBackgroundMode = True And $g_bAndroidAdbScreencap = False
EndFunc
Func NeedCaptureRegion(Const $iCount)
Local $bNeedCaptureRegion = FastCaptureRegion() Or Mod($iCount, 10) = 0
Return $bNeedCaptureRegion
EndFunc
Func ForceCaptureRegion(Const $bForceCapture = True)
$g_bForceCapture = $bForceCapture
EndFunc
Func TestCapture(Const $g_hHBitmap = Default)
If $g_hHBitmap = Default Then Return $g_hHBitmapTest <> 0
If $g_hHBitmapTest <> 0 Then _WinAPI_DeleteObject($g_hHBitmapTest)
$g_hHBitmapTest = $g_hHBitmap
Return $g_hHBitmap
EndFunc
Func debugGdiHandle(Const $sSource, Const $bLogAlways = False)
If $g_iDebugGDICount <> 0 Then
Local $iCount = _WinAPI_GetGuiResources()
If $iCount <> $g_iDebugGDICount Or $bLogAlways Then
Local $sMsg = "GDI Handle Count: " & $iCount & " / " &($iCount - $g_iDebugGDICount) & ", active: " & $g_oDebugGDIHandles.Count & " (" & $sSource & ")"
$g_iDebugGDICount = $iCount
If $g_iDebugGDICount > $g_iDebugGDICountMax Then
$g_iDebugGDICountMax = $g_iDebugGDICount
$sMsg &= " NEW MAX!"
EndIf
SetDebugLog($sMsg, Default, True)
EndIf
EndIf
EndFunc
Func GdiAddBitmap(Const ByRef $_hBitmap)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles("Bitmap:" & $_hBitmap) = Time()
SetDebugLog("GdiAddBitmap " & $_hBitmap, Default, True)
EndIf
EndFunc
Func GdiDeleteBitmap(ByRef $_hBitmap)
If $g_iDebugGDICount <> 0 Then SetDebugLog("_GDIPlus_BitmapDispose>: " & $_hBitmap & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
Local $Result = _GDIPlus_BitmapDispose($_hBitmap)
If($Result <> True Or @error) And $g_iDebugGDICount = 0 Then SetDebugLog("GdiDeleteBitmap not deleted: " & $_hBitmap, Default, True)
If $g_iDebugGDICount <> 0 Then
SetDebugLog("_GDIPlus_BitmapDispose<: " & $_hBitmap & " " & $Result & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
$g_oDebugGDIHandles.Remove("Bitmap:" & $_hBitmap)
SetDebugLog("GdiDeleteBitmap " & $_hBitmap & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
EndIf
$_hBitmap = 0
EndFunc
Func GdiAddHBitmap(Const ByRef $_hHBitmap)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles("HBitmap:" & $_hHBitmap) = Time()
SetDebugLog("GdiAddHBitmap " & $_hHBitmap & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
EndIf
EndFunc
Func GdiDeleteHBitmap(ByRef $_hHBitmap)
Local $Result = _WinAPI_DeleteObject($_hHBitmap)
If($Result <> True Or @error) And $g_iDebugGDICount = 0 Then SetDebugLog("GdiDeleteHBitmap not deleted: " & $_hHBitmap, Default, True)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles.Remove("HBitmap:" & $_hHBitmap)
SetDebugLog("GdiDeleteHBitmap " & $_hHBitmap & " " & $Result & ", active: " & $g_oDebugGDIHandles.Count, Default, True)
EndIf
$_hHBitmap = 0
EndFunc
Func __GDIPlus_Startup()
_GDIPlus_Startup()
$g_iDebugGDICountMax = _WinAPI_GetGuiResources()
debugGdiHandle("__GDIPlus_Startup", True)
EndFunc
Func __GDIPlus_Shutdown()
_CaptureDispose()
Local $hDll = $__g_hGDIPDll
_GDIPlus_Shutdown()
_WinAPI_FreeLibrary($hDll)
debugGdiHandle("__GDIPlus_Shutdown", True)
EndFunc
Func _ColorCheck($nColor1, $nColor2, $sVari = 5, $Ignore = Default)
Local $Red1, $Red2, $Blue1, $Blue2, $Green1, $Green2
$Red1 = Dec(StringMid(String($nColor1), 1, 2))
$Blue1 = Dec(StringMid(String($nColor1), 3, 2))
$Green1 = Dec(StringMid(String($nColor1), 5, 2))
$Red2 = Dec(StringMid(String($nColor2), 1, 2))
$Blue2 = Dec(StringMid(String($nColor2), 3, 2))
$Green2 = Dec(StringMid(String($nColor2), 5, 2))
Switch $Ignore
Case "Red"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
Case "Heroes"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
Case "Red+Blue"
If Abs($Green1 - $Green2) > $sVari Then Return False
Case Else
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
EndSwitch
Return True
EndFunc
Func _CheckPixel($aScreenCode, $bNeedCapture = Default, $Ignore = Default, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
If $bNeedCapture = Default Then $bNeedCapture = False
If $g_bDebugSetlog And $sLogText <> Default And IsString($sLogText) Then
$sLogText &= ", Expected: " & Hex($aScreenCode[2], 6) & ", Tolerance: " & $aScreenCode[3]
Else
$sLogText = Default
EndIf
If _ColorCheck(  _GetPixelColor($aScreenCode[0], $aScreenCode[1], $bNeedCapture, $sLogText, $LogTextColor, $bSilentSetLog), Hex($aScreenCode[2], 6), $aScreenCode[3], $Ignore) Then
Return True
EndIf
Return False
EndFunc
Func _CheckPixel2($aScreenCode, $sHexColor, $Ignore = Default)
If _ColorCheck( $sHexColor, Hex($aScreenCode[2], 6), $aScreenCode[3], $Ignore) Then
Return True
EndIf
Return False
EndFunc
Func _WaitForCheckPixel($aScreenCode, $bNeedCapture = Default, $Ignore = Default, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default, $iWaitLoop = Default)
If $iWaitLoop = Default Then $iWaitLoop = 250
Local $wCount = 0
While _CheckPixel($aScreenCode, $bNeedCapture, $Ignore, $sLogText, $LogTextColor, $bSilentSetLog) = False
If _Sleep($iWaitLoop ) Then Return
$wCount += 1
If $wCount > 20 Then
SetLog($sLogText & " not found!", $COLOR_ERROR)
Return False
EndIf
WEnd
Return True
EndFunc
Func GetListPixel($listPixel, $sDelim = "-", $sName = "")
If $sName <> "" Then debugAttackCSV("GetListPixel for " & $sName & ": " & $listPixel)
Local $listPixelSideStr = StringSplit($listPixel, "|")
If($listPixelSideStr[0] > 1) Then
Local $listPixelSide[UBound($listPixelSideStr) - 1]
For $i = 0 To UBound($listPixelSide) - 1
Local $pixel = GetPixel($listPixelSideStr[$i + 1], $sDelim)
If UBound($pixel) > 1 Then
$listPixelSide[$i] = $pixel
EndIf
Next
Return $listPixelSide
Else
If StringInStr($listPixel, $sDelim) > 0 Then
Local $pixel = GetPixel($listPixel, $sDelim)
Local $listPixelHere = [$pixel]
Return $listPixelHere
EndIf
Return -1
EndIf
EndFunc
Func GetPixel($sPixel, $sDelim = "-")
Local $pixel = StringSplit($sPixel, $sDelim, $STR_NOCOUNT)
If UBound($pixel) < 2 Then Return $pixel
$pixel[0] = Int($pixel[0])
$pixel[1] = Int($pixel[1])
Return $pixel
EndFunc
Func GetPixelDistance(Const ByRef $Pixel0, Const ByRef $Pixel1)
Local $a = $Pixel0[0] - $Pixel1[0]
Local $b = $Pixel0[1] - $Pixel1[1]
Local $d = Sqrt($a * $a + $b * $b)
Return $d
EndFunc
Func GetPixelListDistance(Const $PixelArray, Const $iMaxAllowedPixelDistance)
Local $dTotal = 0
Local $i
Local $iMax = UBound($PixelArray) - 1
If $iMax < 1 Then Return $dTotal
Local $prePixel = $PixelArray[0]
Local $curPixel
Local $d
For $i = 1 To $iMax
$curPixel = $PixelArray[$i]
If UBound($prePixel) > 1 And UBound($curPixel) > 1 Then
$d = GetPixelDistance($prePixel, $curPixel)
If $d <= $iMaxAllowedPixelDistance Then $dTotal += $d
EndIf
$prePixel = $curPixel
Next
Return $dTotal
EndFunc
Func GetLocationItem($functionName)
If $g_bDebugSetlog Or $g_bDebugBuildingPos Then
Local $hTimer = __TimerInit()
SetLog("GetLocationItem(" & $functionName & ")", $COLOR_DEBUG)
EndIf
Local $resultHere = DllCall($g_hLibMyBot, "str", $functionName, "ptr", $g_hHBitmap2)
If UBound($resultHere) > 0 Then
If $g_bDebugBuildingPos Then SetLog("#*# " & $functionName & ": " & $resultHere[0] & "calc in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
Return GetListPixel($resultHere[0])
Else
If $g_bDebugBuildingPos Then SetLog("#*# " & $functionName & ": NONE calc in " & Round(__TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
EndIf
EndFunc
Func _GetPixelColor($iX, $iY, $bNeedCapture = False, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $aPixelColor = 0
If Not $bNeedCapture Or Not $g_bRunState Then
$aPixelColor = _GDIPlus_BitmapGetPixel($g_hBitmap, $iX, $iY)
Else
_CaptureRegion($iX - 1, $iY - 1, $iX + 1, $iY + 1)
$aPixelColor = _GDIPlus_BitmapGetPixel($g_hBitmap, 1, 1)
EndIf
If $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & " at X,Y: " & $iX & "," & $iY & " Found: " & Hex($aPixelColor, 6)
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return Hex($aPixelColor, 6)
EndFunc
Func IsPixelColorGray($sPixelColorRgbHex)
If StringLen($sPixelColorRgbHex) <> 6 Then Return False
Local $sRed = StringLeft($sPixelColorRgbHex, 2)
Local $sBlue = StringRight($sPixelColorRgbHex, 2)
Return $sRed = $sBlue And $sRed = StringMid($sPixelColorRgbHex, 3, 2)
EndFunc
Func _PixelSearch($iLeft, $iTop, $iRight, $iBottom, $sColor, $iColorVariation, $bNeedCapture = True)
Local $x1, $x2, $y1, $y2
If $bNeedCapture = True Then
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
$x1 = $iRight - $iLeft
$x2 = 0
$y1 = 0
$y2 = $iBottom - $iTop
Else
$x1 = $iRight
$x2 = $iLeft
$y1 = $iTop
$y2 = $iBottom
EndIf
For $x = $x1 To $x2 Step -1
For $y = $y1 To $y2
If _ColorCheck(_GetPixelColor($x, $y), $sColor, $iColorVariation) Then
Local $Pos[2] = [$iLeft + $x - $x2, $iTop + $y - $y1]
Return $Pos
EndIf
Next
Next
Return 0
EndFunc
Func _MultiPixelSearch($iLeft, $iTop, $iRight, $iBottom, $xSkip, $ySkip, $firstColor, $offColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
Local $offColorVariation = UBound($offColor, 2) > 3
Local $xRange = $iRight - $iLeft
Local $yRange = $iBottom - $iTop
If $xSkip < 0 Then
$xRange = Abs($xSkip)
$xSkip = 1
EndIf
If $ySkip < 0 Then
$yRange = Abs($ySkip)
$ySkip = 1
EndIf
For $x = 0 To $xRange Step $xSkip
For $y = 0 To $yRange Step $ySkip
If _ColorCheck(_GetPixelColor($x, $y), $firstColor, $iColorVariation) Then
Local $allchecked = True
Local $iCV = $iColorVariation
For $i = 0 To UBound($offColor) - 1
If $offColorVariation = True Then $iCV = $offColor[$i][3]
If _ColorCheck(_GetPixelColor($x + $offColor[$i][1], $y + $offColor[$i][2]), Hex($offColor[$i][0], 6), $iCV) = False Then
$allchecked = False
ExitLoop
EndIf
Next
If $allchecked Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
EndIf
Next
Next
Return 0
EndFunc
Func _MultiPixelSearch2($iLeft, $iTop, $iRight, $iBottom, $xSkip, $ySkip, $firstColor, $offColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
Local $offColorVariation = UBound($offColor, 2) > 3
Local $xRange = $iRight - $iLeft
Local $yRange = $iBottom - $iTop
If $xSkip < 0 Then
$xRange = Abs($xSkip)
$xSkip = 1
EndIf
If $ySkip < 0 Then
$yRange = Abs($ySkip)
$ySkip = 1
EndIf
For $y = 0 To $yRange Step $ySkip
For $x = 0 To $xRange Step $xSkip
If _ColorCheck(_GetPixelColor($x, $y), $firstColor, $iColorVariation) Then
Local $allchecked = True
Local $iCV = $iColorVariation
For $i = 0 To UBound($offColor) - 1
If $offColorVariation = True Then $iCV = $offColor[$i][3]
If _ColorCheck(_GetPixelColor($x + $offColor[$i][1], $y + $offColor[$i][2]), Hex($offColor[$i][0], 6), $iCV) = False Then
$allchecked = False
ExitLoop
EndIf
Next
If $allchecked Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
EndIf
Next
Next
Return 0
EndFunc
Func WaitforPixel($iLeft, $iTop, $iRight, $iBottom, $firstColor, $iColorVariation, $maxDelay = 10)
For $i = 1 To $maxDelay * 10
Local $result = _PixelSearch($iLeft, $iTop, $iRight, $iBottom, $firstColor, $iColorVariation)
If IsArray($result) Then Return True
If _Sleep(50) Then Return
Next
Return False
EndFunc
Func isInsideDiamondXY($Coordx, $Coordy)
Local $aCoords = [$Coordx, $Coordy]
Return isInsideDiamond($aCoords)
EndFunc
Func isInsideDiamond($aCoords)
Local $x = $aCoords[0], $y = $aCoords[1], $xD, $yD
Local $Left = 0, $Right = 855, $Top = 20, $Bottom = 675
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
$xD = $aMiddle[0]
$yD = $Top
ConvertToVillagePos($xD, $yD)
$Top = $yD
$xD = $aMiddle[0]
$yD = $Bottom
ConvertToVillagePos($xD, $yD)
$Bottom = $yD
$xD = $Left
$yD = $aMiddle[1]
ConvertToVillagePos($xD, $yD)
$Left = $xD
$xD = $Right
$yD = $aMiddle[1]
ConvertToVillagePos($xD, $yD)
$Right = $xD
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
Local $aSize = [$aMiddle[0] - $aDiamond[0][0], $aMiddle[1] - $aDiamond[0][1]]
Local $DX = Abs($x - $aMiddle[0])
Local $DY = Abs($y - $aMiddle[1])
If($DX / $aSize[0] + $DY / $aSize[1] <= 1) Then
If $x < 68 And $y > 316 Then
If $g_bDebugSetlog Then SetDebugLog("Coordinate Inside Village, but Exclude CHAT")
Return False
ElseIf $y < 63 Then
If $g_bDebugSetlog Then SetDebugLog("Coordinate Inside Village, but Exclude BUILDER")
Return False
ElseIf $x > 692 And $y > 156 And $y < 210 Then
If $g_bDebugSetlog Then SetDebugLog("Coordinate Inside Village, but Exclude GEMS")
Return False
EndIf
Return True
Else
If $g_bDebugSetlog Then SetDebugLog("Coordinate Outside Village")
Return False
EndIf
EndFunc
Func getBuilderCount($bSuppressLog = False, $bBuilderBase = False)
Local $sBuilderInfo, $aGetBuilders, $bIsMainPage = False
If Not $bBuilderBase Then
$bIsMainPage = IsMainPage()
Else
$bIsMainPage = IsMainPageBuilderBase()
EndIf
If $bIsMainPage Then
If Not $bBuilderBase Then
$sBuilderInfo = getBuilders($aBuildersDigits[0], $aBuildersDigits[1])
Else
$sBuilderInfo = getBuilders($aBuildersDigitsBuilderBase[0], $aBuildersDigitsBuilderBase[1])
EndIf
If StringInStr($sBuilderInfo, "#") > 0 Then
$aGetBuilders = StringSplit($sBuilderInfo, "#", $STR_NOCOUNT)
If Not $bBuilderBase Then
$g_iFreeBuilderCount = Int($aGetBuilders[0])
If $g_iTestFreeBuilderCount <> -1 Then $g_iFreeBuilderCount = $g_iTestFreeBuilderCount
$g_iTotalBuilderCount = Int($aGetBuilders[1])
If $g_bDebugSetlog And Not $bSuppressLog Then SetLog("No. of Free/Total Builders: " & $g_iFreeBuilderCount & "/" & $g_iTotalBuilderCount, $COLOR_DEBUG)
Else
$g_iFreeBuilderCountBB = Int($aGetBuilders[0])
$g_iTotalBuilderCountBB = Int($aGetBuilders[1])
If $g_bDebugSetlog And Not $bSuppressLog Then SetLog("No. of Free/Total Builders: " & $g_iFreeBuilderCountBB & "/" & $g_iTotalBuilderCountBB, $COLOR_DEBUG)
EndIf
Return True
Else
SetLog("Bad OCR read Free/Total Builders", $COLOR_ERROR)
EndIf
Else
SetLog("Unable to read Builders info at this time", $COLOR_ERROR)
EndIf
If $g_bDebugSetlog Or $g_bDebugImageSave Then DebugImageSave("getBuilderCount_")
If checkObstacles() Then checkMainScreen()
Return False
EndFunc
Func BuildingInfo($iXstart, $iYstart)
Local $sBldgText, $sBldgLevel, $aString
Local $aResult[3] = ["", "", ""]
$sBldgText = getNameBuilding($iXstart, $iYstart)
If $sBldgText = "" Then
If _Sleep($DELAYBUILDINGINFO1) Then Return $aResult
$sBldgText = getNameBuilding($iXstart, $iYstart)
EndIf
If $g_bDebugSetlog Then SetDebugLog("Read building Name String = " & $sBldgText, $COLOR_DEBUG)
If StringInStr($sBldgText, "Cart") Then $sBldgText &= " (FakeLevel 100)"
If StringInStr($sBldgText, "Tree") Then $sBldgText &= " (FakeLevel 99)"
If StringInStr($sBldgText, "Mush") Then $sBldgText &= " (FakeLevel 98)"
If StringInStr($sBldgText, "Trunk") Then $sBldgText &= " (FakeLevel 97)"
If StringInStr($sBldgText, "Bush") Then $sBldgText &= " (FakeLevel 96)"
If StringInStr($sBldgText, "Bark") Then $sBldgText &= " (FakeLevel 95)"
If StringInStr($sBldgText, "Gem") Then $sBldgText &= " (FakeLevel 94)"
$aString = StringSplit($sBldgText, "(")
If $aString[0] = 2 Then
If $g_bDebugSetlog Then SetDebugLog("1st $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[1] <> "" Then $aResult[1] = StringStripWS($aString[1], 7)
If $aString[2] <> "" Then
$sBldgLevel = $aString[2]
$aString = StringSplit($sBldgLevel, ")")
If $aString[0] = 2 Then
If StringInStr($aString[1], "Broken") Then $aString[1] &= " 200"
If $g_bDebugSetlog Then SetDebugLog("2nd $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[1] <> "" Then $sBldgLevel = $aString[1]
EndIf
$aString = StringSplit($sBldgLevel, " ")
If $aString[0] = 2 Then
If $g_bDebugSetlog Then SetDebugLog("3rd $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[2] <> "" Then $aResult[2] = Number($aString[2])
EndIf
EndIf
EndIf
If $aResult[1] <> "" Then $aResult[0] = 1
If $aResult[2] <> "" Then $aResult[0] += 1
If $aResult[2] > 90 Then
If $aResult[2] = 200 Then
$aResult[2] = "Broken"
Else
$aResult[2] = ""
EndIf
EndIf
Return $aResult
EndFunc
Func getNameBuilding($x_start, $y_start)
Return getOcrAndCapture("coc-build", $x_start, $y_start, 377, 27)
EndFunc
Func getGoldVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-g", $x_start, $y_start, 90, 16, True)
EndFunc
Func getRemainTrainTimer($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-RemainTrain", $x_start, $y_start, 70, 12, True, False, $bNeedCapture)
EndFunc
Func getRemainBuildTimer($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-siegeremain", $x_start, $y_start, 50, 10, True, False, $bNeedCapture)
EndFunc
Func getElixirVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-e", $x_start, $y_start, 90, 16, True)
EndFunc
Func getResourcesValueTrainPage($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 100, 18, True)
EndFunc
Func getDarkElixirVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-de", $x_start, $y_start, 75, 18, True)
EndFunc
Func getTrophyVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-t", $x_start, $y_start, 75, 18, True)
EndFunc
Func getTrophyMainScreen($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 50, 16, True)
EndFunc
Func getTrophyLossAttackScreen($x_start, $y_start)
Return getOcrAndCapture("coc-t-p", $x_start, $y_start, 50, 16, True)
EndFunc
Func getUpgradeResource($x_start, $y_start)
Return getOcrAndCapture("coc-u-r", $x_start, $y_start, 98, 16, True)
EndFunc
Func getResourcesMainScreen($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 110, 16, True)
EndFunc
Func getResourcesLoot($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 160, 22, True)
EndFunc
Func getResourcesLootDE($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 75, 22, True)
EndFunc
Func getResourcesLootT($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 37, 22, True)
EndFunc
Func getResourcesBonus($x_start, $y_start)
Return getOcrAndCapture("coc-bonus", $x_start, $y_start, 98, 20, True)
EndFunc
Func getResourcesBonusPerc($x_start, $y_start)
Return getOcrAndCapture("coc-bonus", $x_start, $y_start, 48, 16, True)
EndFunc
Func getLabUpgrdResourceWht($x_start, $y_start)
Return getOcrAndCapture("coc-lab-w", $x_start, $y_start, 70, 14, True)
EndFunc
Func getLabUpgrdResourceRed($x_start, $y_start)
Return getOcrAndCapture("coc-lab-r", $x_start, $y_start, 70, 14, True)
EndFunc
Func getStarLabUpgrdResourceRed($x_start, $y_start)
Return getOcrAndCapture("coc-starlab-r", $x_start, $y_start, 70, 14, True)
EndFunc
Func getBldgUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime", $x_start, $y_start, 42, 18)
EndFunc
Func getLabUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime2", $x_start, $y_start, 68, 22)
EndFunc
Func getHeroUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime2", $x_start, $y_start, 68, 20)
EndFunc
Func getChatString($x_start, $y_start, $language)
Return getOcrAndCapture($language, $x_start, $y_start, 280, 16)
EndFunc
Func getBuilders($x_start, $y_start)
Return getOcrAndCapture("coc-Builders", $x_start, $y_start, 40, 18, True)
EndFunc
Func getProfile($x_start, $y_start)
Return getOcrAndCapture("coc-profile", $x_start, $y_start, 55, 13, True)
EndFunc
Func getTroopCountSmall($x_start, $y_start, $bNeedNewCapture = Default)
Return getOcrAndCapture("coc-t-s", $x_start, $y_start, 55, 16, True, Default, $bNeedNewCapture)
EndFunc
Func getTroopCountBig($x_start, $y_start, $bNeedNewCapture = Default)
Return getOcrAndCapture("coc-t-b", $x_start, $y_start, 55, 17, True, Default, $bNeedNewCapture)
EndFunc
Func getTroopsSpellsLevel($x_start, $y_start)
Return getOcrAndCapture("coc-spellslevel", $x_start, $y_start, 20, 14, True)
EndFunc
Func getArmyCampCap($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 82, 16, True, False, $bNeedCapture)
EndFunc
Func getCastleDonateCap($x_start, $y_start)
Return getOcrAndCapture("coc-army", $x_start, $y_start, 30, 14, True)
EndFunc
Func getBarracksTroopQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-train", $x_start, $y_start, 52, 16, True)
EndFunc
Func getAttackDisable($x_start, $y_start)
Return getOcrAndCapture("coc-dis", $x_start, $y_start, 118, 24, True)
EndFunc
Func getOcrLanguage($x_start, $y_start)
Return getOcrAndCapture("coc-ms-testl", $x_start, $y_start, 93, 16, True)
EndFunc
Func getOcrSpaceCastleDonate($x_start, $y_start)
Return getOcrAndCapture("coc-totalreq", $x_start, $y_start, 45, 12, True)
EndFunc
Func getOcrOverAllDamage($x_start, $y_start)
Return getOcrAndCapture("coc-overalldamage", $x_start, $y_start, 50, 20, True)
EndFunc
Func getOcrGuardShield($x_start, $y_start)
Return getOcrAndCapture("coc-guardshield", $x_start, $y_start, 68, 15)
EndFunc
Func getOcrPBTtime($x_start, $y_start)
Return getOcrAndCapture("coc-pbttime", $x_start, $y_start, 59, 15)
EndFunc
Func getOcrMaintenanceTime($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-reloadmsg", $x_start, $y_start, 116, 19, True)
Local $String = ""
If $sLogText = Default Then
$String = "getOcrMaintenanceTime: " & $result
Else
$String = $sLogText & " " & $result
EndIf
If $g_bDebugSetlog Then
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
ElseIf $result <> "" Then
SetDebugLog($String, $LogTextColor, True)
EndIf
Return $result
EndFunc
Func getRemainTLaboratory($x_start, $y_start)
Return getOcrAndCapture("coc-RemainLaboratory", $x_start, $y_start, 194, 25)
EndFunc
Func getRemainTHero($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-remainhero", $x_start, $y_start, 55, 12, True, False, $bNeedCapture)
EndFunc
Func getRequestRemainTime($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-CCremainTime", $x_start, $y_start, 30, 14, False, False, $bNeedCapture)
EndFunc
Func getCloudTextShort($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-cloudsearch", $x_start, $y_start, 51, 27)
If $g_bDebugSetlog And $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & $result
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return $result
EndFunc
Func getCloudFailShort($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-cloudfail", $x_start, $y_start, 72, 24)
If $g_bDebugSetlog And $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & $result
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return $result
EndFunc
Func getBarracksNewTroopQuantity($x_start, $y_start, $bNeedCapture = True)
Return getOcrAndCapture("coc-newarmy", $x_start, $y_start, 45, 18, True, False, $bNeedCapture)
EndFunc
Func getArmyCapacityOnTrainTroops($x_start, $y_start)
Return getOcrAndCapture("coc-NewCapacity", $x_start, $y_start, 67, 14, True)
EndFunc
Func getQueueTroopsQuantity($x_start, $y_start)
Return StringReplace(getOcrAndCapture("coc-qqtroop", $x_start, $y_start, 71, 22, True), "b", "")
EndFunc
Func getChatStringChinese($x_start, $y_start)
Local $bUseOcrImgLoc = True
Return getOcrAndCapture("chinese-bundle", $x_start, $y_start, 160, 14, Default, $bUseOcrImgLoc)
EndFunc
Func getChatStringKorean($x_start, $y_start)
Local $bUseOcrImgLoc = True
Return getOcrAndCapture("korean-bundle", $x_start, $y_start, 160, 14, Default, $bUseOcrImgLoc)
EndFunc
Func getChatStringPersian($x_start, $y_start, $bConvert = True)
Local $bUseOcrImgLoc = True
Local $OCRString = getOcrAndCapture("persian-bundle", $x_start, $y_start, 240, 20, Default, $bUseOcrImgLoc, True)
If $bConvert = True Then
$OCRString = StringReverse($OCRString)
$OCRString = StringReplace($OCRString, "A", "ا")
$OCRString = StringReplace($OCRString, "B", "ب")
$OCRString = StringReplace($OCRString, "C", "چ")
$OCRString = StringReplace($OCRString, "D", "د")
$OCRString = StringReplace($OCRString, "F", "ف")
$OCRString = StringReplace($OCRString, "G", "گ")
$OCRString = StringReplace($OCRString, "J", "ج")
$OCRString = StringReplace($OCRString, "H", "ه")
$OCRString = StringReplace($OCRString, "R", "ر")
$OCRString = StringReplace($OCRString, "K", "ک")
$OCRString = StringReplace($OCRString, "K", "ل")
$OCRString = StringReplace($OCRString, "M", "م")
$OCRString = StringReplace($OCRString, "N", "ن")
$OCRString = StringReplace($OCRString, "P", "پ")
$OCRString = StringReplace($OCRString, "S", "س")
$OCRString = StringReplace($OCRString, "T", "ت")
$OCRString = StringReplace($OCRString, "V", "و")
$OCRString = StringReplace($OCRString, "Y", "ی")
$OCRString = StringReplace($OCRString, "L", "ل")
$OCRString = StringReplace($OCRString, "Z", "ز")
$OCRString = StringReplace($OCRString, "X", "خ")
$OCRString = StringReplace($OCRString, "Q", "ق")
$OCRString = StringReplace($OCRString, ",", ",")
$OCRString = StringReplace($OCRString, "0", " ")
$OCRString = StringReplace($OCRString, "1", ".")
$OCRString = StringReplace($OCRString, "22", "ع")
$OCRString = StringReplace($OCRString, "44", "ش")
$OCRString = StringReplace($OCRString, "55", "ح")
$OCRString = StringReplace($OCRString, "66", "ض")
$OCRString = StringReplace($OCRString, "77", "ط")
$OCRString = StringReplace($OCRString, "88", "لا")
$OCRString = StringReplace($OCRString, "99", "ث")
$OCRString = StringStripWS($OCRString, 1 + 2)
EndIf
Return $OCRString
EndFunc
Func OcrForceCaptureRegion($bForce = Default)
If $bForce = Default Then Return $g_bOcrForceCaptureRegion
Local $wasForce = $g_bOcrForceCaptureRegion
$g_bOcrForceCaptureRegion = $bForce
Return $wasForce
EndFunc
Func getOcrAndCapture($language, $x_start, $y_start, $width, $height, $removeSpace = Default, $bImgLoc = Default, $bForceCaptureRegion = Default)
If $removeSpace = Default Then $removeSpace = False
If $bImgLoc = Default Then $bImgLoc = False
If $bForceCaptureRegion = Default Then $bForceCaptureRegion = $g_bOcrForceCaptureRegion
Static $_hHBitmap = 0
If $bForceCaptureRegion = True Then
_CaptureRegion2($x_start, $y_start, $x_start + $width, $y_start + $height)
Else
$_hHBitmap = GetHHBitmapArea($g_hHBitmap2, $x_start, $y_start, $x_start + $width, $y_start + $height)
EndIf
Local $result
If $bImgLoc Then
If $_hHBitmap <> 0 Then
$result = getOcrImgLoc($_hHBitmap, $language)
Else
$result = getOcrImgLoc($g_hHBitmap2, $language)
EndIf
Else
If $_hHBitmap <> 0 Then
$result = getOcr($_hHBitmap, $language)
Else
$result = getOcr($g_hHBitmap2, $language)
EndIf
EndIf
If $_hHBitmap <> 0 Then
GdiDeleteHBitmap($_hHBitmap)
EndIf
$_hHBitmap = 0
If($removeSpace) Then
$result = StringReplace($result, " ", "")
Else
$result = StringStripWS($result, BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING, $STR_STRIPSPACES))
EndIf
Return $result
EndFunc
Func getOcr(ByRef Const $_hHBitmap, $language)
Local $result = DllCallMyBot("ocr", "ptr", $_hHBitmap, "str", $language, "int", $g_bDebugOcr ? 1 : 0)
If IsArray($result) Then
Return $result[0]
Else
Return ""
EndIf
EndFunc
Func getOcrImgLoc(ByRef Const $_hHBitmap, $sLanguage)
Local $result = DllCallMyBot("DoOCR", "handle", $_hHBitmap, "str", $sLanguage)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_hLibMyBot, $error)
If $g_bDebugSetlog Then SetDebugLog(" imgloc DLL Error : " & $error & " --- " & $extError)
Return SetError(2, $extError, "")
EndIf
If $g_bDebugImageSave Then DebugImageSave($sLanguage, False)
If IsArray($result) Then
Return $result[0]
Else
Return ""
EndIf
EndFunc
Func getPBTime()
Local $sTimeResult = ""
Local $aString[3]
Local $bPBTStart = False
Local $iPBTSeconds, $Result
Local $iHour = 0, $iMin = 0, $iSec = 0
Local $sPBTReturnResult = ""
If IsMainPage() = False Then
SetLog("Not on Main page to read PB information", $COLOR_ERROR)
Return
EndIf
ClickP($aShieldInfoButton)
If _Sleep($DELAYPERSONALSHIELD3) Then Return
Local $iCount = 0
While _CheckPixel($aIsShieldInfo, $g_bCapturePixel) = False
If _Sleep($DELAYPERSONALSHIELD2) Then Return
$Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If $g_bDebugSetlog Then SetDebugLog("OCR PBT early warning= " & $Result, $COLOR_DEBUG)
If(StringLen($Result) > 3) And StringRegExp($Result, "[a-w]", $STR_REGEXPMATCH) Then
SetLog("Personal Break Warning found!", $COLOR_INFO)
$bPBTStart = True
ExitLoop
EndIf
$iCount += 1
If $iCount > 20 Then
SetLog("PBT information window failed to open", $COLOR_DEBUG)
If $g_bDebugImageSave Then DebugImageSave("PBTInfo_", $g_bCapturePixel, "png", False)
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
EndIf
WEnd
If _CheckPixel($aIsShieldInfo, $g_bCapturePixel) Or $bPBTStart Then
$sTimeResult = getOcrPBTtime(555, 499 + $g_iMidOffsetY)
If $g_bDebugSetlog Then SetDebugLog("OCR PBT Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
If _Sleep($DELAYPERSONALSHIELD2) Then Return
$sTimeResult = getOcrPBTtime(555, 499 + $g_iMidOffsetY)
If $g_bDebugSetlog Then SetDebugLog("OCR2 PBT Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" And $bPBTStart = False Then
SetLog("strange error, no PBT value found?", $COLOR_ERROR)
SetError(1, "Bad OCR of PB time value ")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
$aString = StringSplit($sTimeResult, " ")
Switch $aString[0]
Case 1
Select
Case StringInStr($aString[1], "s", $STR_NOCASESENSEBASIC)
$iSec = Number($aString[1])
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[2])
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
Case Else
SetLog("strange error, unexpected PBT value? |" & $aString[1], $COLOR_ERROR)
SetError(2, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
EndSelect
Case 2
Select
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
If StringInStr($aString[2], "m", $STR_NOCASESENSEBASIC) Then
$iMin = Number($aString[2])
EndIf
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[1])
If StringInStr($aString[2], "s", $STR_NOCASESENSEBASIC) Then
$iSec = Number($aString[2])
EndIf
Case Else
SetLog("strange error, unexpected PBT value? |" & $aString[1] & "|" & $aString[2], $COLOR_ERROR)
SetError(3, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
EndSelect
Case Else
If $bPBTStart = False Then
SetLog("Error processing PBT time string: " & $sTimeResult, $COLOR_ERROR)
SetError(4, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return
Else
SetLog("Error processing PBT time string: " & $sTimeResult, $COLOR_INFO)
SetLog("Continue due PB starting now", $COLOR_SUCCESS)
EndIf
EndSwitch
$iPBTSeconds =($iHour * 3600) +($iMin * 60) + $iSec
If $g_bDebugSetlog Then SetDebugLog("Computed PBT Seconds = " & $iPBTSeconds, $COLOR_DEBUG)
If $bPBTStart Then
$sPBTReturnResult = _DateAdd('s', -10, _NowCalc())
Else
$sPBTReturnResult = _DateAdd('s', $iPBTSeconds, _NowCalc())
EndIf
If @error Then SetLog("_DateAdd error= " & @error, $COLOR_ERROR)
If $g_bDebugSetlog Then SetDebugLog("PBT starts: " & $sPBTReturnResult, $COLOR_DEBUG)
If _Sleep($DELAYPERSONALSHIELD1) Then Return
ClickP($aAway, 1, 0, "#9999")
If _Sleep($DELAYPERSONALSHIELD2) Then Return
Return $sPBTReturnResult
Else
If $g_bDebugSetlog Then SetDebugLog("PB Info window failed to open for PB Time OCR", $COLOR_ERROR)
EndIf
EndFunc
Func getShieldInfo()
Local $sTimeResult = ""
Local $aString[3]
Local $iShieldSeconds
Local $iDay = 0, $iHour = 0, $iMin = 0, $iSec = 0
Local $aPBReturnResult[3] = ["", "", ""]
$aPBReturnResult[1] = StringFormat("%02s",($iDay * 24) + $iHour) & ":" & StringFormat("%02s", $iMin) & ":" & StringFormat("%02s", $iSec)
If IsMainPage() = False Then
SetLog("unable to read shield information", $COLOR_ERROR)
Return
EndIf
Select
Case _CheckPixel($aNoShield, $g_bCapturePixel)
$aPBReturnResult[0] = "none"
If $g_bDebugSetlog Then SetDebugLog("No shield active", $COLOR_DEBUG)
Return $aPBReturnResult
Case _CheckPixel($aHaveShield, $g_bCapturePixel)
$aPBReturnResult[0] = "shield"
If $g_bDebugSetlog Then SetDebugLog("Shield Active", $COLOR_DEBUG)
Case _CheckPixel($aHavePerGuard, $g_bCapturePixel)
$aPBReturnResult[0] = "guard"
If $g_bDebugSetlog Then SetDebugLog("Guard Active", $COLOR_DEBUG)
Case Else
SetLog("Sorry, Monkey needs more bananas to read shield type", $COLOR_ERROR)
SetError(1, "Bad shield pixel read")
Return
EndSelect
$sTimeResult = getOcrGuardShield(484, 21)
If $g_bDebugSetlog Then SetDebugLog("OCR Shield Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
If _Sleep($DELAYPERSONALSHIELD2) Then Return $aPBReturnResult
$sTimeResult = getOcrGuardShield(484, 21)
If $g_bDebugSetlog Then SetDebugLog("OCR2 Shield Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
$aPBReturnResult[1] = '00:00:00'
SetLog("strange error, no shield value found?", $COLOR_ERROR)
SetError(2, "Bad time value OCR")
Return $aPBReturnResult
EndIf
EndIf
If _Sleep($DELAYPERSONALSHIELD3) Then Return $aPBReturnResult
$aString = StringSplit($sTimeResult, " ")
Switch $aString[0]
Case 1
If StringInStr($aString[1], "s", $STR_NOCASESENSEBASIC) Then $iSec = Number($aString[1])
Case 2
Select
Case StringInStr($aString[1], "d", $STR_NOCASESENSEBASIC)
$iDay = Number($aString[1])
If StringInStr($aString[2], "h", $STR_NOCASESENSEBASIC) Then
$iHour = Number($aString[2])
EndIf
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
If StringInStr($aString[2], "m", $STR_NOCASESENSEBASIC) Then
$iMin = Number($aString[2])
EndIf
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[1])
If StringInStr($aString[2], "s", $STR_NOCASESENSEBASIC) Then
$iSec = Number($aString[2])
EndIf
Case Else
SetLog("strange error, unexpected shield value?", $COLOR_ERROR)
SetError(3, "Error processing time string")
Return $aPBReturnResult
EndSelect
Case Else
SetLog("Error processing time string: " & $sTimeResult, $COLOR_ERROR)
SetError(4, "Error processing time string")
Return $aPBReturnResult
EndSwitch
$aPBReturnResult[1] = StringFormat("%02s",($iDay * 24) + $iHour) & ":" & StringFormat("%02s", $iMin) & ":" & StringFormat("%02s", $iSec)
If $g_bDebugSetlog Then SetDebugLog("Shield Time String = " & $aPBReturnResult[1], $COLOR_DEBUG)
$iShieldSeconds =($iDay * 86400) +($iHour * 3600) +($iMin * 60) + $iSec
If $g_bDebugSetlog Then SetDebugLog("Computed Shield Seconds = " & $iShieldSeconds, $COLOR_DEBUG)
$aPBReturnResult[2] = _DateAdd('s', Int($iShieldSeconds), _NowCalc())
If @error Then SetLog("_DateAdd error= " & @error, $COLOR_ERROR)
If $g_bDebugSetlog Then SetDebugLog("Shield expires at: " & $aPBReturnResult[2], $COLOR_INFO)
Return $aPBReturnResult
EndFunc
Func updateMultiSearchStats($aResult, $statFile = "")
Switch $statFile
Case $g_sProfileBuildingStatsPath
updateWeakBaseStats($aResult)
Case Else
EndSwitch
EndFunc
Func addInfoToDebugImage(ByRef $hGraphic, ByRef $hPen, $fileName, $x, $y)
_GDIPlus_GraphicsDrawRect($hGraphic, $x - 5, $y - 5, 10, 10, $hPen)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $hFormat = _GDIPlus_StringFormatCreate()
Local $hFamily = _GDIPlus_FontFamilyCreate("Tahoma")
Local $hFont = _GDIPlus_FontCreate($hFamily, 12, 2)
Local $tLayout = _GDIPlus_RectFCreate($x + 10, $y, 0, 0)
Local $sString = String($fileName)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphic, $sString, $hFont, $tLayout, $hFormat)
_GDIPlus_GraphicsDrawStringEx($hGraphic, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
$tLayout = 0
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
EndFunc
Func captureDebugImage($aResult, $subDirectory)
If TestCapture() Then Return
Local $coords
If IsArray($aResult) Then
DirCreate($g_sProfileTempDebugPath & $subDirectory)
Local $editedImage = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = String($Date & "_" & $Time & ".png")
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][4]) > 0 Then
$coords = $aResult[$i][5]
If IsArray($coords) Then
For $j = 0 To UBound($coords) - 1
Local $coord = $coords[$j]
If UBound($coord) > 1 Then
addInfoToDebugImage($hGraphic, $hPen, $aResult[$i][0], $coord[0], $coord[1])
EndIf
Next
EndIf
EndIf
Next
_GDIPlus_GraphicsDrawString($hGraphic, "Time Taken:" & $aResult[0][2] & " " & $aResult[0][3], 350, 50, "Verdana", 20)
_GDIPlus_ImageSaveToFile($editedImage, $g_sProfileTempDebugPath & $subDirectory & "\" & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($editedImage)
EndIf
EndFunc
Func updateResultsRow(ByRef $aResult, $redLines = "")
Local $numberFound = 0
If IsArray($aResult) Then
If UBound($aResult) > 1 Then
For $j = 1 To UBound($aResult) - 1
$numberFound += Number($aResult[$j][4])
Next
EndIf
$aResult[0][0] = $redLines
$aResult[0][1] = $numberFound
Else
EndIf
EndFunc
Func multiMatches($directory, $maxReturnPoints = 0, $fullCocAreas = "DCD", $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult[1][6] = [["", 0, 0, "Seconds", "", ""]], $aCoordArray[0][0], $aCoords, $aCoordsSplit, $aValue
If $forceCaptureRegion = True Then _CaptureRegion2()
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
$aValue = DllCall($g_hLibMyBot, "str", "GetProperty", "str", "redline", "str", "")
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
$redLines = $aValue[0]
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys) + 1][6]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i + 1][0] = RetrieveImglocProperty($aKeys[$i], "filename")
$aResult[$i + 1][1] = RetrieveImglocProperty($aKeys[$i], "objectname")
$aResult[$i + 1][2] = RetrieveImglocProperty($aKeys[$i], "objectlevel")
$aResult[$i + 1][3] = RetrieveImglocProperty($aKeys[$i], "fillLevel")
$aResult[$i + 1][4] = RetrieveImglocProperty($aKeys[$i], "totalobjects")
$aValue = RetrieveImglocProperty($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
ReDim $aCoordArray[UBound($aCoords)][2]
For $j = 0 To UBound($aCoords) - 1
$aCoordsSplit = StringSplit($aCoords[$j], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[$j][0] = $aCoordsSplit[0]
$aCoordArray[$j][1] = $aCoordsSplit[1]
EndIf
Next
$aResult[$i + 1][5] = $aCoordArray
Next
EndIf
updateResultsRow($aResult, $redLines)
updateMultiSearchStats($aResult, $statFile)
Return $aResult
EndFunc
Func returnMultipleMatchesOwnVillage($directory, $maxReturnPoints = 0, $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, $maxReturnPoints, "ECD", "ECD", $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnSingleMatchOwnVillage($directory, $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, 1, "ECD", "ECD", $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnAllMatches($directory, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, 0, "DCD", $redLines, $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnLowestLevelSingleMatch($directory, $returnMax = 100, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $return[7] = ["None", "None", $returnMax + 1, 0, 0, $defaultCoords, ""]
Local $aResult = multiMatches($directory, 1, "DCD", $redLines, $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) < Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[2] = $aResult[$i][2]
$return[3] = $aResult[$i][3]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
EndIf
$return[6] = $aResult[0][0]
Return $return
EndFunc
Func returnMultipleMatches($directory, $maxReturnPoints = 0, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, $maxReturnPoints, "DCD", $redLines, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Func createWeakBaseStats()
Local $aKeys = _FileListToArrayRec($g_sImgWeakBaseBuildingsDir, "*.xml", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_NOPATH)
Local $return[UBound($aKeys) - 1][2]
If Not FileExists($g_sProfileBuildingStatsPath) Then _FileCreate($g_sProfileBuildingStatsPath)
For $i = 1 To UBound($aKeys) - 1
$return[$i - 1][0] = $aKeys[$i]
$return[$i - 1][1] = 0
IniWrite($g_sProfileBuildingStatsPath, "WeakBase", $aKeys[$i], "0")
Next
Return $return
EndFunc
Func readWeakBaseStats()
Local $aKeys = _FileListToArrayRec($g_sImgWeakBaseBuildingsDir, "*.xml", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_NOPATH)
Local $return[UBound($aKeys) - 1][2]
If FileExists($g_sProfileBuildingStatsPath) Then
For $i = 1 To UBound($aKeys) - 1
$return[$i - 1][0] = $aKeys[$i]
$return[$i - 1][1] = IniRead($g_sProfileBuildingStatsPath, "WeakBase", $aKeys[$i], "0")
Next
Else
$return = createWeakBaseStats()
EndIf
Return $return
EndFunc
Func updateWeakBaseStats(ByRef $aResult)
If IsArray($aResult) Then
For $i = 1 To UBound($aResult) - 1
For $j = 0 To UBound($g_aiWeakBaseStats) - 1
If $g_aiWeakBaseStats[$j][0] = $aResult[$i][0] Then
$g_aiWeakBaseStats[$j][1] = Number($g_aiWeakBaseStats[$j][1]) + 1
EndIf
Next
Next
EndIf
EndFunc
Func displayWeakBaseLog($aResult, $showLog = False)
If $showLog And IsArray($aResult) Then
SetLog("================ Weak Base Detection Start ================", $COLOR_INFO)
SetLog("Highest Eagle Artillery: " & $aResult[1][0] & " - Level: " & $aResult[1][2], $COLOR_INFO)
SetLog("Highest Inferno Tower: " & $aResult[2][0] & " - Level: " & $aResult[2][2], $COLOR_INFO)
SetLog("Highest X-Bow: " & $aResult[3][0] & " - Level: " & $aResult[3][2], $COLOR_INFO)
SetLog("Highest Wizard Tower: " & $aResult[4][0] & " - Level: " & $aResult[4][2], $COLOR_INFO)
SetLog("Highest Mortar: " & $aResult[5][0] & " - Level: " & $aResult[5][2], $COLOR_INFO)
SetLog("Highest Air Defense: " & $aResult[6][0] & " - Level: " & $aResult[6][2], $COLOR_INFO)
SetLog("Time taken: " & $aResult[0][2] & " " & $aResult[0][3], $COLOR_INFO)
SetLog("================ Weak Base Detection Stop =================", $COLOR_INFO)
EndIf
EndFunc
Func getTHDefenseMax($levelTownHall, $iDefenseType)
If $levelTownHall = 0 Or $levelTownHall = "-" Then $levelTownHall = 11
Local $maxLevel = _ObjGetValue($g_oBldgLevels, $iDefenseType + 7)[$levelTownHall - 1]
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgLevels", @error)
$maxLevel = 100
EndIf
Return $maxLevel
EndFunc
Func getMaxUISetting($settingArray, $iDefenseType)
Local $result = 0, $maxDB = 0, $maxLB = 0
If IsArray($settingArray) Then
$maxDB =(IsWeakBaseActive($DB)) ? $settingArray[$DB] : 0
$maxLB =(IsWeakBaseActive($LB)) ? $settingArray[$LB] : 0
$result = _Max(Number($maxDB), Number($maxLB))
EndIf
If $g_bDebugSetlog Then SetDebugLog("Max " & $g_aWeakDefenseNames[$iDefenseType] & " Level: " & $result, $COLOR_INFO)
Return $result
EndFunc
Func getMinUISetting($settingArray, $iDefenseType)
Local $result = 0, $minDB = 0, $minLB = 0
If IsArray($settingArray) Then
$minDB =(IsWeakBaseActive($DB)) ? $settingArray[$DB] : 0
$minLB =(IsWeakBaseActive($LB)) ? $settingArray[$LB] : 0
$result = _Min(Number($minDB), Number($minLB))
EndIf
If $g_bDebugSetlog Then SetDebugLog("Min " & $g_aWeakDefenseNames[$iDefenseType] & " Level: " & $result, $COLOR_INFO)
Return $result
EndFunc
Func getIsWeak($aResults, $searchType)
Return $aResults[$eWeakEagle][2] <= Number($g_aiFilterMaxEagleLevel[$searchType]) And $aResults[$eWeakInferno][2] <= Number($g_aiFilterMaxInfernoLevel[$searchType]) And $aResults[$eWeakXBow][2] <= Number($g_aiFilterMaxXBowLevel[$searchType]) And $aResults[$eWeakWizard][2] <= Number($g_aiFilterMaxWizTowerLevel[$searchType]) And $aResults[$eWeakMortar][2] <= Number($g_aiFilterMaxMortarLevel[$searchType]) And $aResults[$eWeakAirDefense][2] <= Number($g_aiFilterMaxAirDefenseLevel[$searchType])
Local $text = "DB"
If $searchType = 1 Then $text = "LB"
SetLog("================ Weak Base Detection Start ================")
If $g_abFilterMaxEagleEnable[$searchType] Then SetLog("[" & $text & "] Eagle level " & $g_aiFilterMaxEagleLevel[$searchType] & " as max, detection higher level : " & $aResults[$eWeakEagle][2], $COLOR_DEBUG)
If $g_abFilterMaxInfernoEnable[$searchType] Then SetLog("[" & $text & "] Inferno level " & $g_aiFilterMaxInfernoLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakInferno][2], $COLOR_DEBUG)
If $g_abFilterMaxXBowEnable[$searchType] Then SetLog("[" & $text & "] XBow level " & $g_aiFilterMaxXBowLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakXBow][2], $COLOR_DEBUG)
If $g_abFilterMaxWizTowerEnable[$searchType] Then SetLog("[" & $text & "] WTower level " & $g_aiFilterMaxWizTowerLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakWizard][2], $COLOR_DEBUG)
If $g_abFilterMaxMortarEnable[$searchType] Then SetLog("[ " & $text & "] Mortar level " & $g_aiFilterMaxMortarLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakMortar][2], $COLOR_DEBUG)
If $g_abFilterMaxAirDefenseEnable[$searchType] Then SetLog("[" & $text & "] AirDef level " & $g_aiFilterMaxAirDefenseLevel[$searchType] & " as max, detection higher level: " & $aResults[$eWeakAirDefense][2], $COLOR_DEBUG)
SetLog("Is a Weak Base? " & $aResults)
SetLog("================ Weak Base Detection Stop =================")
Return $aResults
EndFunc
Func IsWeakBaseActive($type)
Return($g_abFilterMaxEagleEnable[$type] Or $g_abFilterMaxInfernoEnable[$type] Or $g_abFilterMaxXBowEnable[$type] Or $g_abFilterMaxWizTowerEnable[$type] Or $g_abFilterMaxMortarEnable[$type] Or $g_abFilterMaxAirDefenseEnable[$type]) And IsSearchModeActiveMini($type)
EndFunc
Func defenseSearch(ByRef $aResult, $directory, $townHallLevel, $settingArray, $iDefenseType, ByRef $performSearch, $guiEnabledArray, $bForceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $aDefenseResult[7] = ["Skipped", "Skipped", $g_oBldgLevels.Item($iDefenseType + 7), 0, 0, $defaultCoords, ""]
Local $aNotNecessary[7] = ["None", "None", 0, 0, 0, $defaultCoords, ""]
If $performSearch Then
Local $minSearchLevel = getMinUISetting($settingArray, $iDefenseType) + 1
Local $maxSearchLevel = getTHDefenseMax($townHallLevel, $iDefenseType)
Local $bGuiEnableArray = IsArray($guiEnabledArray), $bIsSearchModeActiveDB = IsSearchModeActiveMini($DB), $bIsSearchModeActiveLB = IsSearchModeActiveMini($LB)
Local $guiCheckDefense = $bGuiEnableArray And(($bIsSearchModeActiveDB And $guiEnabledArray[$DB]) Or($bIsSearchModeActiveLB And $guiEnabledArray[$LB]))
Local $defenseTimer = __TimerInit()
If $guiCheckDefense And $maxSearchLevel >= $minSearchLevel Then
Local $sDefenseName = StringSplit($directory, "\", $STR_NOCOUNT)
If $g_bDebugSetlog Then SetDebugLog("checkDefense :" & $sDefenseName[UBound($sDefenseName) - 1] & " > " & $minSearchLevel & " < " & $maxSearchLevel & " For TH:" & $townHallLevel, $COLOR_ORANGE)
$aDefenseResult = DefenseSearchMultiMatch($iDefenseType, $directory, $aResult[0][0], $g_sProfileBuildingStatsPath, $minSearchLevel, $maxSearchLevel, $bForceCaptureRegion)
If $aResult[0][0] = "" Then $aResult[0][0] = $aDefenseResult[6]
If Number($aDefenseResult[2]) > getMaxUISetting($settingArray, $iDefenseType) Then $performSearch = False
If $g_bDebugSetlog Then
SetDebugLog("checkDefense: " & $g_aWeakDefenseNames[$iDefenseType] & " - " & Round(__TimerDiff($defenseTimer) / 1000, 2) & " seconds")
For $i = 0 To UBound($aDefenseResult) - 2
SetDebugLog("$aDefenseResult[" & $i & "]: " & $aDefenseResult[$i])
Next
EndIf
Else
$aDefenseResult = $aNotNecessary
If $g_bDebugSetlog Then SetDebugLog("checkDefense: " & $g_aWeakDefenseNames[$iDefenseType] & " not necessary! $bGuiEnableArray=" & $bGuiEnableArray & ", $bIsSearchModeActiveDB=" & $bIsSearchModeActiveDB & ", $bIsSearchModeActiveLB=" & $bIsSearchModeActiveLB & ", $maxSearchLevel=" & $maxSearchLevel & ", $minSearchLevel=" & $minSearchLevel)
EndIf
EndIf
Return $aDefenseResult
EndFunc
Func weakBaseCheck($townHallLevel = 11, $redlines = "", $bForceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $aResult[7][6] = [[$redlines, 0, 0, "Seconds", "", ""], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakEagle + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakInferno + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakXBow + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakWizard + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakMortar + 6), 0, 0, $defaultCoords], ["Skipped", "Skipped", $g_oBldgLevels.Item($eWeakAirDefense + 6), 0, 0, $defaultCoords]]
Local $aEagleResults, $aInfernoResults, $aMortarResults, $aWizardTowerResults, $aXBowResults, $aAirDefenseResults
Local $performSearch = True
Local $hWeakTimer = __TimerInit()
$aEagleResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsEagleDir, $townHallLevel, $g_aiFilterMaxEagleLevel, $eWeakEagle, $performSearch, $g_abFilterMaxEagleEnable, $bForceCaptureRegion)
$aInfernoResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsInfernoDir, $townHallLevel, $g_aiFilterMaxInfernoLevel, $eWeakInferno, $performSearch, $g_abFilterMaxInfernoEnable, $bForceCaptureRegion)
$aXBowResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsXbowDir, $townHallLevel, $g_aiFilterMaxXBowLevel, $eWeakXBow, $performSearch, $g_abFilterMaxXBowEnable, $bForceCaptureRegion)
If $g_iDetectedImageType = 1 Then
$aWizardTowerResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsWizTowerSnowDir, $townHallLevel, $g_aiFilterMaxWizTowerLevel, $eWeakWizard, $performSearch, $g_abFilterMaxWizTowerEnable, $bForceCaptureRegion)
Else
$aWizardTowerResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsWizTowerDir, $townHallLevel, $g_aiFilterMaxWizTowerLevel, $eWeakWizard, $performSearch, $g_abFilterMaxWizTowerEnable, $bForceCaptureRegion)
EndIf
$aMortarResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsMortarsDir, $townHallLevel, $g_aiFilterMaxMortarLevel, $eWeakMortar, $performSearch, $g_abFilterMaxMortarEnable, $bForceCaptureRegion)
$aAirDefenseResults = defenseSearch($aResult, $g_sImgWeakBaseBuildingsAirDefenseDir, $townHallLevel, $g_aiFilterMaxAirDefenseLevel, $eWeakAirDefense, $performSearch, $g_abFilterMaxAirDefenseEnable, $bForceCaptureRegion)
For $i = 1 To UBound($aResult) - 1
For $j = 0 To UBound($aResult, 2) - 1
Switch $i
Case $eWeakEagle
If IsArray($aEagleResults) Then $aResult[$i][$j] = $aEagleResults[$j]
Case $eWeakInferno
If IsArray($aInfernoResults) Then $aResult[$i][$j] = $aInfernoResults[$j]
Case $eWeakXBow
If IsArray($aXBowResults) Then $aResult[$i][$j] = $aXBowResults[$j]
Case $eWeakWizard
If IsArray($aWizardTowerResults) Then $aResult[$i][$j] = $aWizardTowerResults[$j]
Case $eWeakMortar
If IsArray($aMortarResults) Then $aResult[$i][$j] = $aMortarResults[$j]
Case $eWeakAirDefense
If IsArray($aAirDefenseResults) Then $aResult[$i][$j] = $aAirDefenseResults[$j]
Case Else
EndSwitch
Next
Next
$aResult[0][2] = Round(__TimerDiff($hWeakTimer) / 1000, 2)
$aResult[0][3] = "Seconds"
Return $aResult
EndFunc
Func IsWeakBase($townHallLevel = $g_iMaxTHLevel, $redlines = "", $bForceCaptureRegion = True)
Local $aResult = weakBaseCheck($townHallLevel, $redlines, $bForceCaptureRegion)
displayWeakBaseLog($aResult, $g_bDebugSetlog)
If $g_bDebugSetlog Then
_LogObjList($g_oBldgAttackInfo)
Local $text = _ArrayToString($aResult, ",", 0, UBound($aResult, 1) - 1, "|", 0, UBound($aResult, 2) - 1)
If @error Then SetDebugLog("Error _ArrayToString, code:" & @error, $COLOR_ERROR)
SetDebugLog("$aResult Array: " & $text, $COLOR_DEBUG)
EndIf
If Number($aResult[0][2]) > 10 Then
captureDebugImage($aResult, "WeakBase_Detection_TooSlow")
ElseIf $g_bDebugImageSave And Number($aResult[1][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Eagle_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[2][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Inferno_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[3][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Xbow_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[4][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_WTower_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[5][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Mortar_NotDetected")
ElseIf $g_bDebugImageSave And Number($aResult[6][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_ADefense_NotDetected")
ElseIf $g_bDebugImageSave Then
captureDebugImage($aResult, "WeakBase_Detection")
EndIf
Return $aResult
EndFunc
Func DefenseSearchMultiMatch($iDefenseType, $directory, $redlines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 100, $bForceCaptureRegion = True)
If $g_bDebugSetlog Then SetDebugLog("Begin DefenseSearchMultiMatch: " & $g_sBldgNames[$iDefenseType + 7], $COLOR_DEBUG1)
Local $hTimer = __TimerInit()
Local $defaultCoords[1][2] = [[0, 0]]
Local $return[7] = ["None", "None", 0, 0, 0, $defaultCoords, ""]
Local $aStatData[1][1] = [[""]]
Local $aCoordArray[0][0], $aCoords, $aCoordsSplit, $aValue, $maxLevelSearch, $iTmpObjectLevel, $iTmpBldTotal, $iBuildingTotal, $sTempCoord
Local $sLocCoord, $sNearCoord, $sFarCoord, $redlinesCount, $iCountUpdate
Local $bRedLineExists = False
Local $maxReturnPoints = _ObjGetValue($g_oBldgMaxQty, $iDefenseType + 7)[($g_iSearchTH = "-" ? 10 : $g_iSearchTH - 1)]
If @error Then
_ObjErrMsg("_ObjGetValue $g_oBldgMaxQty", @error)
EndIf
Local $fullCocAreas = "DCD"
$maxLevelSearch = $maxLevel
If $redlines = "" Or $redlines = "DCD" Then
If _ObjSearch($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS") = True Then
If _ObjGetValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT") > 50 Then
$redlines = $g_oBldgAttackInfo.item($eBldgRedLine & "_LOCATION")
If IsString($redlines) And $redlines <> "" And $redlines <> "DCD" Then
$bRedLineExists = True
Else
$bRedLineExists = False
EndIf
Else
$bRedLineExists = False
EndIf
Else
$bRedLineExists = False
EndIf
ElseIf $redlines <> "" And $redlines <> "DCD" Then
$bRedLineExists = True
If _ObjSearch($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS") = False Then
If $redlines <> "DCD" Then
$aCoordsSplit = StringSplit($redlines, "|")
$redlinesCount = $aCoordsSplit[0]
If $redlinesCount > 50 Then
_ObjAdd($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS", $redlines)
If @error Then _ObjErrMsg("_ObjAdd $g_oBldgAttackInfo", @error)
_ObjAdd($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT", $redlinesCount)
If @error Then _ObjErrMsg("_ObjAdd $g_oBldgAttackInfo", @error)
Else
$bRedLineExists = False
EndIf
EndIf
EndIf
Else
$bRedLineExists = False
EndIf
If $bRedLineExists = False Then
$redlines = "DCD"
EndIf
If $g_bDebugSetlog Then
SetDebugLog("> " & $g_sBldgNames[$iDefenseType + 7] & " Max Level: " & $maxLevel & " Max Search Level: " & $maxLevelSearch, $COLOR_DEBUG)
SetDebugLog("> Max return points: " & $maxReturnPoints, $COLOR_DEBUG)
SetDebugLog("> Red Line Exists:" & $bRedLineExists & " , redlines=" & $redlines, $COLOR_DEBUG)
EndIf
If _Sleep($DELAYCHECKARMYCAMP6) Then Return $return
If $bForceCaptureRegion = True Then _CaptureRegion2()
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redlines, "Int", $minLevel, "Int", $maxLevelSearch)
If @error Then _logErrorDLLCall($g_sLibMyBotPath, @error)
If $bRedLineExists = False Then
$aValue = RetrieveImglocProperty("redline", "")
If $aValue <> "" Then
Local $aCoordsSplit = StringSplit($aValue, "|")
If $aCoordsSplit[0] > 50 Then
$redlines = $aValue
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_OBJECTPOINTS", $redlines)
If @error Then _ObjErrMsg("_ObjPutValue $g_oBldgAttackInfo redline", @error)
Local $redlinesCount = $aCoordsSplit[0]
_ObjPutValue($g_oBldgAttackInfo, $eBldgRedLine & "_COUNT", $redlinesCount)
If @error Then _ObjErrMsg("_ObjSetValue $g_oBldgAttackInfo", @error)
$return[6] = $redlines
Else
Setdebuglog("> Not enough red line points to save in building dictionary?", $COLOR_WARNING)
EndIf
Else
SetLog("> DLL Error getting Red Lines in DefenseSearchMultiMatch", $COLOR_ERROR)
EndIf
Else
$return[6] = $redlines
EndIf
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aStatData[UBound($aKeys) + 1][1]
For $i = 0 To UBound($aKeys) - 1
$aStatData[$i + 1][0] = RetrieveImglocProperty($aKeys[$i], "filename")
$iTmpObjectLevel = Int(RetrieveImglocProperty($aKeys[$i], "objectlevel"))
$sTempCoord = RetrieveImglocProperty($aKeys[$i], "objectpoints")
If $i = 0 And StringLen($sTempCoord) > 7 Then
$iCountUpdate = RemoveDupNearby($sTempCoord)
EndIf
$iTmpBldTotal = RetrieveImglocProperty($aKeys[$i], "totalobjects")
If $iTmpObjectLevel > Number($return[2]) Then
$return[0] = $aStatData[$i + 1][0]
$return[1] = RetrieveImglocProperty($aKeys[$i], "objectname")
$return[2] = $iTmpObjectLevel
$return[3] = RetrieveImglocProperty($aKeys[$i], "fillLevel")
$return[4] = $iTmpBldTotal
$aCoords = StringSplit($sTempCoord, "|", $STR_NOCOUNT)
ReDim $aCoordArray[UBound($aCoords)][2]
For $j = 0 To UBound($aCoords) - 1
$aCoordsSplit = StringSplit($aCoords[$j], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[$j][0] = $aCoordsSplit[0]
$aCoordArray[$j][1] = $aCoordsSplit[1]
EndIf
Next
$return[5] = $aCoordArray
EndIf
If isScriptedAttackActive() Then
If UBound($aKeys) > 1 Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_LVLFOUND_K" & $i, $iTmpObjectLevel)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _LVLFOUND_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_FILENAME_K" & $i, $aKeys[$i])
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _FILENAME_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_COUNT_K" & $i, $iTmpBldTotal)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _COUNT_K" & $i, @error)
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_OBJECTPOINTS_K" & $i, $sTempCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _OBJECTPOINTS_K" & $i, @error)
EndIf
If $iBuildingTotal >= $maxReturnPoints Then ContinueLoop
If $sTempCoord <> "" Then
If $sLocCoord = "" Then
$sLocCoord = $sTempCoord
$iBuildingTotal = $iTmpBldTotal
Else
$iCountUpdate = AddPoints_RemoveDuplicate($sLocCoord, $sTempCoord, $maxReturnPoints)
If $iCountUpdate <> "" Then $iBuildingTotal = $iCountUpdate
EndIf
Else
SetDebugLog("> no data in 'objectpoints' request?", $COLOR_WARNING)
EndIf
EndIf
Next
Local $aBldgCoord = decodeMultipleCoords($sLocCoord)
If IsArray($aBldgCoord) Then $return[5] = $aBldgCoord
If $g_bDebugSetlog Or $g_bDebugBuildingPos Then
SetLog($g_sBldgNames[$iDefenseType + 7] & " Coordinates: " & $sLocCoord, $COLOR_DEBUG)
Local $sText
Select
Case UBound($aBldgCoord, 1) > 1 And IsArray($aBldgCoord[1])
$sText = PixelArrayToString($aBldgCoord, ",")
Case UBound($aBldgCoord) > 0 And UBound($aBldgCoord[0]) = 2
Local $aPixelb = $aBldgCoord[0]
$sText = PixelToString($aPixelb, ":")
Case UBound($aBldgCoord) = 2 And IsArray($aBldgCoord[0]) = 0
$sText = PixelToString($aBldgCoord, ":")
Case Else
$sText = "Monkey ate bad banana!"
EndSelect
SetLog($g_sBldgNames[$iDefenseType + 7] & " $aBldgCoord Array Contents: " & $sText, $COLOR_DEBUG)
EndIf
If isScriptedAttackActive() Then
If $return[2] <> 0 Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_MAXLVLFOUND", $return[2])
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _MAXLVLFOUND", @error)
EndIf
If $return[0] <> "None" Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_NAMEFOUND", $return[0])
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _NAMEFOUND", @error)
EndIf
If IsArray($aBldgCoord) Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_OBJECTPOINTS", $sLocCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _OBJECTPOINTS", @error)
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_LOCATION", $aBldgCoord)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _LOCATION", @error)
EndIf
If $iBuildingTotal <> 0 Then
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_COUNT", $iBuildingTotal)
If @error Then _ObjErrMsg("_ObjAdd " & $g_sBldgNames[$iDefenseType + 7] & " _COUNT", @error)
EndIf
SetDebugLog("Total " & $g_sBldgNames[$iDefenseType + 7] & " Buildings: " & $iBuildingTotal)
Local $iTime = __TimerDiff($hTimer) * 0.001
_ObjAdd($g_oBldgAttackInfo, $iDefenseType + 7 & "_FINDTIME", $iTime)
If @error Then _ObjErrMsg("_ObjAdd" & $g_sBldgNames[$iDefenseType + 7] & " _FINDTIME", @error)
If $g_bDebugSetlog Then SetDebugLog("  - Location(s) found in: " & Round($iTime, 2) & " seconds ", $COLOR_DEBUG1)
EndIf
EndIf
updateMultiSearchStats($aStatData, $statFile)
Return $return
EndFunc
Func isScriptedAttackActive()
If($g_abAttackTypeEnable[$DB] And $g_aiAttackAlgorithm[$DB] = 1) Or($g_abAttackTypeEnable[$LB] And $g_aiAttackAlgorithm[$LB] = 1) Then Return True
Return False
EndFunc
Func CompareResources($pMode)
If $g_bSearchReductionEnable Then
If $g_iSearchCount <> 0 And Mod($g_iSearchCount, $g_iSearchReductionCount) = 0 Then
If $g_iAimGold[$pMode] - $g_iSearchReductionGold >= 0 Then $g_iAimGold[$pMode] -= $g_iSearchReductionGold
If $g_iAimElixir[$pMode] - $g_iSearchReductionElixir >= 0 Then $g_iAimElixir[$pMode] -= $g_iSearchReductionElixir
If $g_iAimDark[$pMode] - $g_iSearchReductionDark >= 0 Then $g_iAimDark[$pMode] -= $g_iSearchReductionDark
If $g_iAimTrophy[$pMode] - $g_iSearchReductionTrophy >= 0 Then $g_iAimTrophy[$pMode] -= $g_iSearchReductionTrophy
If $g_iAimTrophyMax[$pMode] + $g_iSearchReductionTrophy < 99 Then $g_iAimTrophyMax[$pMode] += $g_iSearchReductionTrophy
If $g_iAimGoldPlusElixir[$pMode] - $g_iSearchReductionGoldPlusElixir >= 0 Then $g_iAimGoldPlusElixir[$pMode] -= $g_iSearchReductionGoldPlusElixir
Local $txtTrophies = "", $txtTownhall = ""
If $g_abFilterMeetTrophyEnable[$pMode] Then $txtTrophies = " [T]:" & StringFormat("%2s", $g_iAimTrophy[$pMode]) & "-" & StringFormat("%2s", $g_iAimTrophyMax[$pMode])
If $g_abFilterMeetTH[$pMode] Then $txtTownhall = " [TH]:" & StringFormat("%2s", $g_aiMaxTH[$pMode])
If $g_abFilterMeetTHOutsideEnable[$pMode] Then $txtTownhall &= ", Out"
If $g_aiFilterMeetGE[$pMode] = 2 Then
SetLog("Aim:           [G+E]:" & StringFormat("%7s", $g_iAimGoldPlusElixir[$pMode]) & " [D]:" & StringFormat("%5s", $g_iAimDark[$pMode]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$pMode], $COLOR_SUCCESS, "Lucida Console", 7.5)
Else
SetLog("Aim: [G]:" & StringFormat("%7s", $g_iAimGold[$pMode]) & " [E]:" & StringFormat("%7s", $g_iAimElixir[$pMode]) & " [D]:" & StringFormat("%5s", $g_iAimDark[$pMode]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$pMode], $COLOR_SUCCESS, "Lucida Console", 7.5)
EndIf
EndIf
EndIf
Local $G =(Number($g_iSearchGold) >= Number($g_iAimGold[$pMode])), $E =(Number($g_iSearchElixir) >= Number($g_iAimElixir[$pMode])), $D =(Number($g_iSearchDark) >= Number($g_iAimDark[$pMode])), $T =(Number($g_iSearchTrophy) >= Number($g_iAimTrophy[$pMode])) And(Number($g_iSearchTrophy) <= Number($g_iAimTrophyMax[$pMode])), $GPE =((Number($g_iSearchGold) + Number($g_iSearchElixir)) >= Number($g_iAimGoldPlusElixir[$pMode]))
If $g_abFilterMeetOneConditionEnable[$pMode] Then
If $g_aiFilterMeetGE[$pMode] = 0 Then
If $G = True And $E = True Then Return True
EndIf
If $g_abFilterMeetDEEnable[$pMode] Then
If $D = True Then Return True
EndIf
If $g_abFilterMeetTrophyEnable[$pMode] Then
If $T = True Then Return True
EndIf
If $g_aiFilterMeetGE[$pMode] = 1 Then
If $G = True Or $E = True Then Return True
EndIf
If $g_aiFilterMeetGE[$pMode] = 2 Then
If $GPE = True Then Return True
EndIf
Return False
Else
If $g_aiFilterMeetGE[$pMode] = 0 Then
If $G = False Or $E = False Then Return False
EndIf
If $g_abFilterMeetDEEnable[$pMode] Then
If $D = False Then Return False
EndIf
If $g_abFilterMeetTrophyEnable[$pMode] Then
If $T = False Then Return False
EndIf
If $g_aiFilterMeetGE[$pMode] = 1 Then
If $G = False And $E = False Then Return False
EndIf
If $g_aiFilterMeetGE[$pMode] = 2 Then
If $GPE = False Then Return False
EndIf
EndIf
Return True
EndFunc
Func CompareTH($pMode)
Local $THL = -1, $THLO = -1
If $g_iSearchTH = 6 Then $g_iSearchTH = "4-6"
For $i = 0 To 5
If $g_iSearchTH = $g_asTHText[$i] Then $THL = $i
Next
Switch $g_sTHLoc
Case "In"
$THLO = 0
Case "Out"
$THLO = 1
EndSwitch
$g_iSearchTHLResult = 0
If $THL > -1 And $THL <= $g_iAtkTBMaxTHLevel And $g_iSearchTH <> "-" Then $g_iSearchTHLResult = 1
If $g_abFilterMeetOneConditionEnable[$pMode] Then
If $g_abFilterMeetTH[$pMode] Then
If $THL <> -1 And $THL <= $g_aiFilterMeetTHMin[$pMode] Then Return True
EndIf
If $g_abFilterMeetTHOutsideEnable[$pMode] Then
If $THLO = 1 Then Return True
EndIf
Return False
Else
If $g_abFilterMeetTH[$pMode] Then
If $THL = -1 Or $THL > $g_aiFilterMeetTHMin[$pMode] Then Return False
EndIf
If $g_abFilterMeetTHOutsideEnable[$pMode] Then
If $THLO <> 1 Then Return False
EndIf
EndIf
Return True
EndFunc
Func GetResources($bLog = True, $pMatchMode = -1)
Static $iStuck = 0, $iSearchGold2 = 0, $iSearchElixir2 = 0
If _Sleep($DELAYRESPOND) Then Return
$g_iSearchGold = ""
$g_iSearchElixir = ""
$g_iSearchDark = ""
$g_iSearchTrophy = ""
SuspendAndroid()
Local $iCount = 0
While(getGoldVillageSearch(48, 69) = "") Or(getElixirVillageSearch(48, 69 + 29) = "")
$iCount += 1
If _Sleep($DELAYGETRESOURCES3) Then Return
If $iCount >= 50 Or isProblemAffect(True) Then ExitLoop
WEnd
If _Sleep($DELAYRESPOND) Then Return
$g_iSearchGold = getGoldVillageSearch(48, 69)
If _Sleep($DELAYRESPOND) Then Return
$g_iSearchElixir = getElixirVillageSearch(48, 69 + 29)
If _Sleep($DELAYRESPOND) Then Return
If _CheckPixel($aAtkHasDarkElixir, $g_bCapturePixel, Default, "HasDarkElixir1") Or  _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
$g_iSearchDark = getDarkElixirVillageSearch(48, 126)
$g_iSearchTrophy = getTrophyVillageSearch(45, 168)
Else
$g_iSearchDark = "N/A"
$g_iSearchTrophy = getTrophyVillageSearch(48, 69 + 69)
EndIf
If $g_iSearchGold = $iSearchGold2 And $g_iSearchElixir = $iSearchElixir2 Then $iStuck += 1
If $g_iSearchGold <> $iSearchGold2 Or $g_iSearchElixir <> $iSearchElixir2 Then $iStuck = 0
$iSearchGold2 = $g_iSearchGold
$iSearchElixir2 = $g_iSearchElixir
If $iStuck >= 5 Or isProblemAffect(True) Then
$iStuck = 0
resetAttackSearch(True)
Return
EndIf
$g_iSearchCount += 1
ResumeAndroid()
EndFunc
Func resetAttackSearch($bStuck = False)
$g_bIsClientSyncError = True
checkMainScreen()
If $g_bRestart Then
$g_iNbrOfOoS += 1
UpdateStats()
If $bStuck Then
SetLog("Connection Lost While Searching", $COLOR_ERROR)
Else
SetLog("Disconnected At Search Clouds", $COLOR_ERROR)
EndIf
PushMsg("OoSResources")
Else
If $bStuck Then
SetLog("Attack Is Disabled Or Slow connection issues, Restarting CoC and Bot...", $COLOR_ERROR)
Else
SetLog("Stuck At Search Clouds, Restarting CoC and Bot...", $COLOR_ERROR)
EndIf
$g_bIsClientSyncError = False
CloseCoC(True)
EndIf
Return
EndFunc
Func PrepareSearch($Mode = $DB)
SetLog("Going to Attack...", $COLOR_INFO)
If $g_bSearchRestartPickupHero And $Mode <> $DT Then
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $g_iModeCount - 1
If IsUnitUsed($pMatchMode, $pTroopType) Then
If Not _DateIsValid($g_asHeroHealTime[$pTroopType - $eKing]) Then
getArmyHeroTime("All", True, True)
ExitLoop 2
EndIf
EndIf
Next
Next
EndIf
ChkAttackCSVConfig()
If IsMainPage() Then
If _Sleep($DELAYTREASURY4) Then Return
If _CheckPixel($aAttackForTreasury, $g_bCapturePixel, Default, "Is attack for treasury:") Then
SetLog("It isn't attack for Treasury :-(", $COLOR_SUCCESS)
Return
EndIf
If _Sleep($DELAYTREASURY4) Then Return
If $g_bUseRandomClick = False Then
ClickP($aAttackButton, 1, 0, "#0149")
Else
ClickR($aAttackButtonRND, $aAttackButton[0], $aAttackButton[1], 1, 0)
EndIf
EndIf
If _Sleep($DELAYPREPARESEARCH1) Then Return
Local $j = 0
While Not(IsLaunchAttackPage())
If _Sleep($DELAYPREPARESEARCH1) Then Return
$j += 1
If $j > 15 Then ExitLoop
WEnd
If $j > 15 Then
SetLog("Launch attack Page Fail", $COLOR_ERROR)
AndroidPageError("PrepareSearch")
checkMainScreen()
$g_bRestart = True
$g_bIsClientSyncError = False
Return
Else
$g_bCloudsActive = True
If $g_bUseRandomClick = False Then
ClickP($aFindMatchButton, 1, 0, "#0150")
Else
ClickR($aFindMatchButtonRND, $aFindMatchButton[0], $aFindMatchButton[1], 1, 0)
EndIf
If $g_iTownHallLevel <> "" And $g_iTownHallLevel > 0 Then
$g_iSearchCost += $g_aiSearchCost[$g_iTownHallLevel - 1]
$g_iStatsTotalGain[$eLootGold] -= $g_aiSearchCost[$g_iTownHallLevel - 1]
EndIf
UpdateStats()
EndIf
If _Sleep($DELAYPREPARESEARCH2) Then Return
Local $Result = getAttackDisable(346, 182)
If isGemOpen(True) = True Then
SetLog(" Not enough gold to start searching.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0151")
If _Sleep($DELAYPREPARESEARCH1) Then Return
Click(822, 32, 1, 0, "#0152")
If _Sleep($DELAYPREPARESEARCH1) Then Return
$g_bOutOfGold = True
EndIf
checkAttackDisable($g_iTaBChkAttack, $Result)
If $g_bDebugSetlog Then SetDebugLog("PrepareSearch exit check $g_bRestart= " & $g_bRestart & ", $g_bOutOfGold= " & $g_bOutOfGold, $COLOR_DEBUG)
If $g_bRestart Or $g_bOutOfGold Then
$g_bIsClientSyncError = False
Return
EndIf
If IsAttackWhileShieldPage(False) Then
Local $offColors[3][3] = [[0x000000, 144, 1], [0xFFFFFF, 54, 17], [0xFFFFFF, 54, 28]]
Local $ButtonPixel = _MultiPixelSearch(359, 404 + $g_iMidOffsetY, 510, 445 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog("Shield btn clr chk-#1: " & _GetPixelColor(441, 344 + $g_iMidOffsetY, True) & ", #2: " &  _GetPixelColor(441 + 144, 344 + $g_iMidOffsetY, True) & ", #3: " & _GetPixelColor(441 + 54, 344 + 17 + $g_iMidOffsetY, True) & ", #4: " &  _GetPixelColor(441 + 54, 344 + 10 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Shld Btn Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "#0153")
EndIf
EndIf
EndFunc
Func VillageSearch()
$g_bVillageSearchActive = True
$g_bCloudsActive = True
Local $Result = _VillageSearch()
If $g_bSearchAttackNowEnable Then
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_HIDE)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_SHOW)
GUICtrlSetState($g_hLblVersion, $GUI_SHOW)
GUICtrlSetState($g_hLblMod, $GUI_SHOW)
$g_bBtnAttackNowPressed = False
EndIf
$g_bVillageSearchActive = False
$g_bCloudsActive = False
Return $Result
EndFunc
Func _VillageSearch()
Local $Result
Local $weakBaseValues
Local $logwrited = False
Local $iSkipped = 0
Local $bReturnToPickupHero = False
Local $abHeroUse[3] = [False, False, False]
For $i = 0 to 2
$abHeroUse[$i] =($g_abSearchSearchesEnable[$DB] ? IsUnitUsed($DB, $eKing + $i) : False) Or($g_abSearchSearchesEnable[$LB] ? IsUnitUsed($LB, $eKing + $i) : False)
Next
If $g_bDebugDeadBaseImage Or $g_aiSearchEnableDebugDeadBaseImage > 0 Then
DirCreate($g_sProfileTempDebugPath & "\SkippedZombies\")
DirCreate($g_sProfileTempDebugPath & "\Zombies\")
setZombie()
EndIf
If $g_bIsClientSyncError = False Then
For $i = 0 To $g_iModeCount - 1
$g_iAimGold[$i] = $g_aiFilterMinGold[$i]
$g_iAimElixir[$i] = $g_aiFilterMinElixir[$i]
$g_iAimGoldPlusElixir[$i] = $g_aiFilterMinGoldPlusElixir[$i]
$g_iAimDark[$i] =($g_abFilterMeetDEEnable[$i] ?($g_aiFilterMeetDEMin[$i]) :(0))
$g_iAimTrophy[$i] =($g_abFilterMeetTrophyEnable[$i] ?($g_aiFilterMeetTrophyMin[$i]) :(0))
$g_iAimTrophyMax[$i] =($g_abFilterMeetTrophyEnable[$i] ?($g_aiFilterMeetTrophyMax[$i]) :(99))
Next
EndIf
If _Sleep($DELAYVILLAGESEARCH1) Then Return
$Result = getAttackDisable(346, 182)
checkAttackDisable($g_iTaBChkAttack, $Result)
If $g_bRestart = True Then Return
If Not($g_bIsSearchLimit) Then
SetLogCentered("=", "=", $COLOR_INFO)
EndIf
For $x = 0 To $g_iModeCount - 1
If IsSearchModeActive($x) Then WriteLogVillageSearch($x)
Next
If Not($g_bIsSearchLimit) Then
SetLogCentered("=", "=", $COLOR_INFO)
Else
SetLogCentered(" Restart To Search ", Default, $COLOR_INFO)
EndIf
If $g_bSearchAttackNowEnable Then
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_SHOW)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_SHOW)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_SHOW)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_HIDE)
GUICtrlSetState($g_hLblVersion, $GUI_HIDE)
GUICtrlSetState($g_hLblMod, $GUI_HIDE)
EndIf
If $g_bIsClientSyncError = False And $g_bIsSearchLimit = False Then
$g_iSearchCount = 0
EndIf
If $g_bIsSearchLimit = True Then $g_bIsSearchLimit = False
InitAndroidPageError()
While 1
ResetTHsearch()
_ObjDeleteKey($g_oBldgAttackInfo, "")
If $g_bDebugVillageSearchImages Then DebugImageSave("villagesearch")
$logwrited = False
$g_bBtnAttackNowPressed = False
$g_iSearchTHLResult = -1
If $g_bRestart = True Then Return
WaitForClouds()
AttackRemainingTime(True)
If $g_bRestart = True Then Return
$g_bCloudsActive = False
GetResources(False)
If $g_bRestart = True Then Return
SuspendAndroid()
Local $noMatchTxt = ""
Local $dbBase = False
Local $match[$g_iModeCount]
Global $isModeActive[$g_iModeCount]
For $i = 0 To $g_iModeCount - 1
$match[$i] = False
$isModeActive[$i] = False
Next
If _Sleep($DELAYRESPOND) Then Return
For $i = 0 To $g_iModeCount - 1
$isModeActive[$i] = IsSearchModeActive($i)
If $isModeActive[$i] Then
$match[$i] = CompareResources($i)
EndIf
Next
setVillageOffset(0, 0, 1)
ConvertInternalExternArea()
ForceCaptureRegion()
_CaptureRegion2()
Local $bAlwaysMeasure = $g_bVillageSearchAlwaysMeasure
For $i = 0 To $g_iModeCount - 1
If $match[$i] Or $bAlwaysMeasure Then
If CheckZoomOut("VillageSearch", True, False) = False Then
DebugImageSave("VillageSearchMeasureFailed", False, Default, Default)
ExitLoop
$i = 0
Local $bMeasured
Do
$i += 1
If _Sleep($DELAYPREPARESEARCH2) Then Return
ForceCaptureRegion()
_CaptureRegion2()
$bMeasured = CheckZoomOut("VillageSearch", $i < 2, False)
Until $bMeasured = True Or $i >= 2
If $bMeasured = False Then Return
EndIf
ExitLoop
EndIf
Next
Local $THString = ""
If $match[$DB] Or $match[$LB] Or $match[$TS] Then
$THString = FindTownhall(False, False)
ElseIf($g_abFilterMeetOneConditionEnable[$DB] Or $g_abFilterMeetOneConditionEnable[$LB]) Then
$THString = FindTownhall(True, False)
ElseIf $g_abAttackTypeEnable[$TB] = 1 And($g_iSearchCount >= $g_iAtkTBEnableCount) Then
$THString = FindTownhall(True, False)
EndIf
For $i = 0 To $g_iModeCount - 2
If $isModeActive[$i] Then
If $g_abFilterMeetOneConditionEnable[$i] Then
If $g_abFilterMeetTH[$i] = False And $g_abFilterMeetTHOutsideEnable[$i] = False Then
Else
If CompareTH($i) Then $match[$i] = True
EndIf
Else
If Not CompareTH($i) Then $match[$i] = False
EndIf
EndIf
Next
If $g_iSearchTHLResult = -1 Then CompareTH(0)
Local $GetResourcesTXT = StringFormat("%3s", $g_iSearchCount) & "> [G]:" & StringFormat("%7s", $g_iSearchGold) & " [E]:" & StringFormat("%7s", $g_iSearchElixir) & " [D]:" & StringFormat("%5s", $g_iSearchDark) & " [T]:" & StringFormat("%2s", $g_iSearchTrophy) & $THString
$g_sSearchCount = $g_iSearchCount
$g_sOppGold = $g_iSearchGold
$g_sOppElixir = $g_iSearchElixir
$g_sOppDE = $g_iSearchDark
$g_sOppTrophies = $g_iSearchTrophy
If Not $g_bRunState Then Return
Local $checkDeadBase = $match[$DB] Or $match[$LB]
If $checkDeadBase Then
$dbBase = checkDeadBase()
EndIf
If(IsWeakBaseActive($DB) And $dbBase And($match[$DB] Or $g_abFilterMeetOneConditionEnable[$DB])) Or(IsWeakBaseActive($LB) And($match[$LB] Or $g_abFilterMeetOneConditionEnable[$LB])) Then
Local $maxTry = 1
For $i = 0 To $g_iModeCount - 2
If $g_abFilterMaxEagleEnable[$i] Then $maxTry = 2
Next
For $try = 1 To $maxTry
If($g_iSearchTH <> "-") Then
$weakBaseValues = IsWeakBase($g_iImglocTHLevel, $g_sImglocRedline, False)
Else
$weakBaseValues = IsWeakBase($g_iMaxTHLevel, "", False)
EndIf
Local $bIsWeak = False
For $i = 0 To $g_iModeCount - 2
If IsWeakBaseActive($i) And(($i = $DB And $dbBase) Or $i <> $DB) And($match[$i] Or $g_abFilterMeetOneConditionEnable[$i]) Then
If getIsWeak($weakBaseValues, $i) Then
$match[$i] = True
$bIsWeak = True
Else
$match[$i] = False
$noMatchTxt &= ", Not a Weak Base for " & $g_asModeText[$i]
$try = 2
EndIf
EndIf
Next
If $bIsWeak And $try = 1 Then
ResumeAndroid()
If _Sleep(3000) Then Return
ForceCaptureRegion()
_CaptureRegion2()
SuspendAndroid()
EndIf
Next
EndIf
ResumeAndroid()
If $match[$DB] And $dbBase Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Dead Base Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$LB] And Not $dbBase Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Live Base Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $LB
ExitLoop
ElseIf $match[$LB] And $g_bCollectorFilterDisable Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Live Base Found!*", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $LB
ExitLoop
ElseIf $g_abAttackTypeEnable[$TB] = 1 And($g_iSearchCount >= $g_iAtkTBEnableCount) Then
If $g_iSearchTHLResult = 1 Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Not a match, but TH Bully Level Found! ", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $g_iAtkTBMode
ExitLoop
EndIf
EndIf
If SearchTownHallLoc() And $match[$TS] Then
If CompareResources($TS) Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "TH Outside Found! ", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $TS
ExitLoop
Else
$noMatchTxt &= ", Not a " & $g_asModeText[$TS] & ", fails resource min"
EndIf
EndIf
If $match[$DB] And Not $dbBase Then
$noMatchTxt &= ", Not a " & $g_asModeText[$DB]
ElseIf $match[$LB] And $dbBase Then
$noMatchTxt &= ", Not a " & $g_asModeText[$LB]
EndIf
If $noMatchTxt <> "" Then
SetLog($GetResourcesTXT, $COLOR_BLACK, "Lucida Console", 7.5)
SetLog("      " & StringMid($noMatchTxt, 3), $COLOR_ACTION, "Lucida Console", 7.5)
$logwrited = True
EndIf
If Not($logwrited) Then
SetLog($GetResourcesTXT, $COLOR_BLACK, "Lucida Console", 7.5)
EndIf
If $g_bSearchRestartPickupHero Then
For $i = 0 To 2
If Not $abHeroUse[$i] Or Not _DateIsValid($g_asHeroHealTime[$i]) Then ContinueLoop
Local $iTimeTillHeroHealed = Int(_DateDiff('s', _NowCalc(), $g_asHeroHealTime[$i]))
SetDebugLog($g_asHeroNames[$i] & " will be ready in " & $iTimeTillHeroHealed & " seconds")
If $iTimeTillHeroHealed <= 0 Then
$bReturnToPickupHero = True
$g_asHeroHealTime[$i] = ""
SetLog($g_asHeroNames[$i] & " is ready. Return home to pick " &($i <> 1 ? "him" : "her") & " up to join the attack")
ExitLoop
EndIf
Next
EndIf
If SearchLimit($iSkipped + 1, $bReturnToPickupHero) Then Return True
If CheckAndroidReboot() = True Then
$g_bRestart = True
$g_bIsClientSyncError = True
Return
EndIf
If $g_iSearchDelayMin > 0 And $g_iSearchDelayMax > 0 Then
If $g_iSearchDelayMin <> $g_iSearchDelayMax Then
If _Sleep(Round(1000 * Random($g_iSearchDelayMin, $g_iSearchDelayMax))) Then Return
Else
If _Sleep(1000 * $g_iSearchDelayMin) Then Return
EndIf
EndIf
If _Sleep($DELAYRESPOND) Then Return
If $g_bSearchAttackNowEnable And $g_iSearchAttackNowDelay > 0 Then
If _Sleep(1000 * $g_iSearchAttackNowDelay) Then Return
EndIf
If $g_bBtnAttackNowPressed = True Then ExitLoop
If $checkDeadBase And Not $g_bDebugDeadBaseImage And $g_iSearchCount > $g_aiSearchEnableDebugDeadBaseImage Then
SetLog("Enabled collecting debug images of dead bases (zombies)", $COLOR_DEBUG)
SetLog("- Save skipped dead base when available Elixir with empty storage > " &(($g_aZombie[8] > -1) ?($g_aZombie[8] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save skipped dead base when available Elixir > " &(($g_aZombie[9] > -1) ?($g_aZombie[9] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save dead base when available Elixir < " &(($g_aZombie[10] > -1) ?($g_aZombie[10] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save dead base when raided Elixir < " &(($g_aZombie[7] > -1) ?($g_aZombie[7] & "%") :("is disabled")), $COLOR_DEBUG)
$g_bDebugDeadBaseImage = True
EndIf
If $g_bDebugDeadBaseImage Then setZombie()
Local $i = 0
While $i < 100
If _Sleep($DELAYVILLAGESEARCH2) Then Return
$i += 1
_CaptureRegions()
If( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1]), Hex($NextBtn[2], 6), $NextBtn[3])) And IsAttackPage(False) Then
$g_bCloudsActive = True
If $g_bUseRandomClick = False Then
ClickP($NextBtn, 1, 0, "#0155")
Else
ClickR($NextBtnRND, $NextBtn[0], $NextBtn[1], 1, 0)
EndIf
ExitLoop
Else
If $g_bDebugSetlog Then SetDebugLog("Wait to see Next Button... " & $i, $COLOR_DEBUG)
EndIf
If $i >= 99 Or isProblemAffect() Or(Mod($i, 10) = 0 And checkObstacles_Network(False, False)) Then
$g_bIsClientSyncError = True
checkMainScreen()
If $g_bRestart Then
$g_iNbrOfOoS += 1
UpdateStats()
SetLog("Couldn't locate Next button", $COLOR_ERROR)
PushMsg("OoSResources")
Else
SetLog("Have strange problem Couldn't locate Next button, Restarting CoC and Bot...", $COLOR_ERROR)
$g_bIsClientSyncError = False
CloseCoC(True)
EndIf
Return
EndIf
WEnd
If _Sleep($DELAYRESPOND) Then Return
$Result = getAttackDisable(346, 182)
checkAttackDisable($g_iTaBChkAttack, $Result)
If $g_bRestart = True Then Return
If isGemOpen(True) = True Then
SetLog(" Not enough gold to keep searching.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0156")
If _Sleep($DELAYVILLAGESEARCH3) Then Return
$g_bOutOfGold = True
ReturnHome(False, False)
Return
EndIf
$iSkipped = $iSkipped + 1
$g_iSkippedVillageCount += 1
If $g_iTownHallLevel <> "" And $g_iTownHallLevel > 0 Then
$g_iSearchCost += $g_aiSearchCost[$g_iTownHallLevel - 1]
$g_iStatsTotalGain[$eLootGold] -= $g_aiSearchCost[$g_iTownHallLevel - 1]
EndIf
UpdateStats()
WEnd
If $g_bBtnAttackNowPressed = True Then
SetLogCentered(" Attack Now Pressed! ", "~", $COLOR_SUCCESS)
EndIf
If $g_bSearchAlertMe Then
TrayTip($g_sProfileCurrentName & ": " & $g_asModeText[$g_iMatchMode] & " Match Found!", "Gold: " & $g_iSearchGold & "; Elixir: " & $g_iSearchElixir & "; Dark: " & $g_iSearchDark & "; Trophy: " & $g_iSearchTrophy, "", 0)
If FileExists(@WindowsDir & "\media\Festival\Windows Exclamation.wav") Then
SoundPlay(@WindowsDir & "\media\Festival\Windows Exclamation.wav", 1)
ElseIf FileExists(@WindowsDir & "\media\Windows Exclamation.wav") Then
SoundPlay(@WindowsDir & "\media\Windows Exclamation.wav", 1)
EndIf
EndIf
SetLogCentered(" Search Complete ", Default, $COLOR_INFO)
PushMsg("MatchFound")
$g_bIsClientSyncError = False
EndFunc
Func SearchLimit($iSkipped, $bReturnToPickupHero = False)
If $bReturnToPickupHero Or($g_bSearchRestartEnable And $iSkipped >= Number($g_iSearchRestartLimit)) Then
Local $Wcount = 0
While _CheckPixel($aSurrenderButton, $g_bCapturePixel) = False
If _Sleep($DELAYSEARCHLIMIT) Then Return
$Wcount += 1
If $g_bDebugSetlog Then SetDebugLog("wait surrender button " & $Wcount, $COLOR_DEBUG)
If $Wcount >= 50 Or isProblemAffect(True) Then
checkMainScreen()
$g_bIsClientSyncError = False
$g_bRestart = True
Return True
EndIf
WEnd
$g_bIsSearchLimit = True
ReturnHome(False, False)
getArmyTroopCapacity(True, True)
$g_bRestart = True
$g_bIsClientSyncError = True
Return True
Else
Return False
EndIf
EndFunc
Func WriteLogVillageSearch($x)
Local $MeetGxEtext = "", $MeetGorEtext = "", $MeetGplusEtext = "", $MeetDEtext = "", $MeetTrophytext = "", $MeetTHtext = "", $MeetTHOtext = "", $MeetWeakBasetext = "", $EnabledAftertext = ""
If $g_aiFilterMeetGE[$x] = 0 Then $MeetGxEtext = "- Meet: Gold and Elixir"
If $g_aiFilterMeetGE[$x] = 1 Then $MeetGorEtext = "- Meet: Gold or Elixir"
If $g_aiFilterMeetGE[$x] = 2 Then $MeetGplusEtext = "- Meet: Gold + Elixir"
If $g_abFilterMeetDEEnable[$x] Then $MeetDEtext = "- Dark"
If $g_abFilterMeetTrophyEnable[$x] Then $MeetTrophytext = "- Trophy"
If $g_abFilterMeetTH[$x] Then $MeetTHtext = "- Max TH " & $g_aiMaxTH[$x]
If $g_abFilterMeetTHOutsideEnable[$x] Then $MeetTHOtext = "- TH Outside"
If IsWeakBaseActive($x) Then $MeetWeakBasetext = "- Weak Base"
If Not($g_bIsSearchLimit) And $g_bDebugSetlog Then
SetLogCentered(" Searching For " & $g_asModeText[$x] & " ", Default, $COLOR_INFO)
SetLog("Enable " & $g_asModeText[$x] & " search IF ", $COLOR_INFO)
If $g_abSearchSearchesEnable[$x] Then SetLog("- Numbers of searches range " & $g_aiSearchSearchesMin[$x] & " - " & $g_aiSearchSearchesMax[$x], $COLOR_INFO)
If $g_abSearchTropiesEnable[$x] Then SetLog("- Search tropies range " & $g_aiSearchTrophiesMin[$x] & " - " & $g_aiSearchTrophiesMax[$x], $COLOR_INFO)
If $g_abSearchCampsEnable[$x] Then SetLog("- Army Camps % >  " & $g_aiSearchCampsPct[$x], $COLOR_INFO)
SetLog("Match " & $g_asModeText[$x] & "  village IF ", $COLOR_INFO)
If $MeetGxEtext <> "" Then SetLog($MeetGxEtext, $COLOR_INFO)
If $MeetGorEtext <> "" Then SetLog($MeetGorEtext, $COLOR_INFO)
If $MeetGplusEtext <> "" Then SetLog($MeetGplusEtext, $COLOR_INFO)
If $MeetDEtext <> "" Then SetLog($MeetDEtext, $COLOR_INFO)
If $MeetTrophytext <> "" Then SetLog($MeetTrophytext, $COLOR_INFO)
If $MeetTHtext <> "" Then SetLog($MeetTHtext, $COLOR_INFO)
If $MeetTHOtext <> "" Then SetLog($MeetTHOtext, $COLOR_INFO)
If $MeetWeakBasetext <> "" Then SetLog($MeetWeakBasetext, $COLOR_INFO)
If $g_abFilterMeetOneConditionEnable[$x] Then SetLog("Meet One and Attack!")
SetLogCentered(" RESOURCE CONDITIONS ", "~", $COLOR_INFO)
EndIf
If Not($g_bIsSearchLimit) Then
Local $txtTrophies = "", $txtTownhall = ""
If $g_abFilterMeetTrophyEnable[$x] Then $txtTrophies = " [T]:" & StringFormat("%2s", $g_iAimTrophy[$x]) & "-" & StringFormat("%2s", $g_iAimTrophyMax[$x])
If $g_abFilterMeetTH[$x] Then $txtTownhall = " [TH]:" & StringFormat("%2s", $g_aiMaxTH[$x])
If $g_abFilterMeetTHOutsideEnable[$x] Then $txtTownhall &= ", Out"
If $g_aiFilterMeetGE[$x] = 2 Then
SetLog("Aim:           [G+E]:" & StringFormat("%7s", $g_iAimGoldPlusElixir[$x]) & " [D]:" & StringFormat("%5s", $g_iAimDark[$x]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$x], $COLOR_SUCCESS, "Lucida Console", 7.5)
Else
SetLog("Aim: [G]:" & StringFormat("%7s", $g_iAimGold[$x]) & " [E]:" & StringFormat("%7s", $g_iAimElixir[$x]) & " [D]:" & StringFormat("%5s", $g_iAimDark[$x]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$x], $COLOR_SUCCESS, "Lucida Console", 7.5)
EndIf
EndIf
EndFunc
Func CheckZoomOut($sSource = "CheckZoomOut", $bCheckOnly = False, $bForecCapture = True)
If $bForecCapture = True Then
_CaptureRegion2()
EndIf
Local $aVillageResult = SearchZoomOut(False, True, $sSource, False)
If IsArray($aVillageResult) = 0 Or $aVillageResult[0] = "" Then
If $bCheckOnly = False Then
SetLog("Not Zoomed Out! Exiting to MainScreen...", $COLOR_ERROR)
checkMainScreen()
$g_bRestart = True
$g_bIsClientSyncError = True
EndIf
Return False
EndIf
Return True
EndFunc
Func SearchTownHallLoc()
Local $addtiles = 0
Switch $g_iMatchMode
Case $TS
If $g_iArmyCapacity < 100 Then
$addtiles = $g_iAtkTSAddTilesWhileTrain
Else
$addtiles = $g_iAtkTSAddTilesFullTroops
EndIf
Case $LB
$addtiles = $g_iTHSnipeBeforeTiles[$LB]
Case $DB
$addtiles = $g_iTHSnipeBeforeTiles[$DB]
EndSwitch
If $g_iSearchTH <> "-" Then
If isInsideDiamondXY($g_iTHx, $g_iTHy) = False Then Return False
For $i = 0 To 22
If $g_iTHx < 114 + $i * 16 + Ceiling(($addtiles - 2) / 2 * 16) And $g_iTHy < 359 - $i * 12 + Ceiling(($addtiles - 2) / 2 * 12) Then
$g_iTHi = $i
$g_iTHside = 0
Return True
EndIf
If $g_iTHx < 117 + $i * 16 + Ceiling(($addtiles - 2) / 2 * 16) And $g_iTHy > 268 + $i * 12 - Floor(($addtiles - 2) / 2 * 12) Then
$g_iTHi = $i
$g_iTHside = 1
Return True
EndIf
If $g_iTHx > 743 - $i * 16 - Floor(($addtiles - 2) / 2 * 16) And $g_iTHy < 358 - $i * 12 + Ceiling(($addtiles - 2) / 2 * 12) Then
$g_iTHi = $i
$g_iTHside = 2
Return True
EndIf
If $g_iTHx > 742 - $i * 16 - Floor(($addtiles - 2) / 2 * 16) And $g_iTHy > 268 + $i * 12 - Floor(($addtiles - 2) / 2 * 12) Then
$g_iTHi = $i
$g_iTHside = 3
Return True
EndIf
Next
EndIf
Return False
EndFunc
Func FindTownHall($check = True, $forceCaptureRegion = True)
$g_iSearchTH = "-"
$g_iTHx = 0
$g_iTHy = 0
If $check = True Or IsSearchModeActive($TS) Or($isModeActive[$DB] And($g_abFilterMeetTH[$DB] Or $g_abFilterMeetTHOutsideEnable[$DB])) Or($isModeActive[$LB] And($g_abFilterMeetTH[$LB] Or $g_abFilterMeetTHOutsideEnable[$LB])) Then
$g_iSearchTH = imgloccheckTownHallADV2(0, 0, $forceCaptureRegion)
If $g_iSearchTH <> "-" And SearchTownHallLoc() = False Then
$g_sTHLoc = "In"
ElseIf $g_iSearchTH <> "-" Then
$g_sTHLoc = "Out"
Else
$g_sTHLoc = $g_iSearchTH
$g_iTHx = 0
$g_iTHy = 0
EndIf
Return " [TH]:" & StringFormat("%2s", $g_iSearchTH) & ", " & $g_sTHLoc
EndIf
$g_sTHLoc = $g_iSearchTH
$g_iTHx = 0
$g_iTHy = 0
Return ""
EndFunc
Func IsSearchModeActive($g_iMatchMode, $nocheckHeroes = False, $bNoLog = False)
Local $currentSearch = $g_iSearchCount + 1
Local $currentTropies = $g_aiCurrentLoot[$eLootTrophy]
Local $currentArmyCamps = Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
Local $bMatchModeEnabled = False
Local $checkSearches = Int($currentSearch) >= Int($g_aiSearchSearchesMin[$g_iMatchMode]) And Int($currentSearch) <= Int($g_aiSearchSearchesMax[$g_iMatchMode]) And $g_abSearchSearchesEnable[$g_iMatchMode]
Local $checkTropies = Int($currentTropies) >= Int($g_aiSearchTrophiesMin[$g_iMatchMode]) And Int($currentTropies) <= Int($g_aiSearchTrophiesMax[$g_iMatchMode]) And $g_abSearchTropiesEnable[$g_iMatchMode]
Local $checkArmyCamps = Int($currentArmyCamps) >= Int($g_aiSearchCampsPct[$g_iMatchMode]) And $g_abSearchCampsEnable[$g_iMatchMode]
Local $checkHeroes = Not($g_aiSearchHeroWaitEnable[$g_iMatchMode] > $eHeroNone And(BitAND($g_aiAttackUseHeroes[$g_iMatchMode], $g_aiSearchHeroWaitEnable[$g_iMatchMode], $g_iHeroAvailable) = $g_aiSearchHeroWaitEnable[$g_iMatchMode]) = False) Or $nocheckHeroes
If $checkHeroes = False Then
If Abs($g_aiSearchHeroWaitEnable[$g_iMatchMode] - $g_iHeroUpgradingBit) <= $eHeroNone Then $checkHeroes = True
EndIf
Local $g_bCheckSpells =($g_bFullArmySpells And $g_abSearchSpellsWaitEnable[$g_iMatchMode]) Or $g_abSearchSpellsWaitEnable[$g_iMatchMode] = False
Local $totalSpellsToBrew = 0
For $i = 0 To $eSpellCount - 1
$totalSpellsToBrew += $g_aiArmyCompSpells[$i]
Next
If GetCurTotalSpell() = $totalSpellsToBrew And $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then
$g_bCheckSpells = True
ElseIf $g_bFullArmySpells And $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then
$g_bCheckSpells = True
ElseIf $g_abSearchSpellsWaitEnable[$g_iMatchMode] = False Then
$g_bCheckSpells = True
Else
$g_bCheckSpells = False
EndIf
Switch $g_iMatchMode
Case $DB
$bMatchModeEnabled = $g_abAttackTypeEnable[$DB]
Case $LB
$bMatchModeEnabled = $g_abAttackTypeEnable[$LB]
Case $TS
$bMatchModeEnabled = $g_abAttackTypeEnable[$TS]
Case Else
$bMatchModeEnabled = False
EndSwitch
Local $bcheckSiege = False
If $g_abSearchSiegeWaitEnable[$g_iMatchMode] Then
If(($g_aiAttackUseSiege[$g_iMatchMode] = 1 And($g_aiCurrentSiegeMachines[$eSiegeWallWrecker] > 0 Or $g_aiCurrentCCSiegeMachines[$eSiegeWallWrecker] > 0)) Or($g_aiAttackUseSiege[$g_iMatchMode] = 2 And($g_aiCurrentSiegeMachines[$eSiegeBattleBlimp] > 0 Or $g_aiCurrentCCSiegeMachines[$eSiegeBattleBlimp] > 0)) Or($g_aiAttackUseSiege[$g_iMatchMode] = 3 And($g_aiCurrentSiegeMachines[$eSiegeStoneSlammer] > 0 Or $g_aiCurrentCCSiegeMachines[$eSiegeStoneSlammer] > 0)) Or $g_aiAttackUseSiege[$g_iMatchMode] = 0) Then
$bcheckSiege = True
EndIf
Else
$bcheckSiege = True
EndIf
If Not $bMatchModeEnabled Then Return False
If $checkHeroes And $g_bCheckSpells And $bcheckSiege Then
If($checkSearches Or $g_abSearchSearchesEnable[$g_iMatchMode] = False) And($checkTropies Or $g_abSearchTropiesEnable[$g_iMatchMode] = False) And($checkArmyCamps Or $g_abSearchCampsEnable[$g_iMatchMode] = False) Then
If $g_bDebugSetlog And Not $bNoLog Then SetLog($g_asModeText[$g_iMatchMode] & " active! ($checkSearches=" & $checkSearches & ",$checkTropies=" & $checkTropies & ",$checkArmyCamps=" & $checkArmyCamps & ",$checkHeroes=" & $checkHeroes & ",$g_bCheckSpells=" & $g_bCheckSpells & ",$bcheckSiege=" & $bcheckSiege & ")", $COLOR_INFO)
Return True
Else
If $g_bDebugSetlog And Not $bNoLog Then
SetLog($g_asModeText[$g_iMatchMode] & " not active!", $COLOR_INFO)
Local $txtsearches = "Fail"
If $checkSearches Then $txtsearches = "Success"
Local $txttropies = "Fail"
If $checkTropies Then $txttropies = "Success"
Local $txtArmyCamp = "Fail"
If $checkArmyCamps Then $txtArmyCamp = "Success"
Local $txtHeroes = "Fail"
If $checkHeroes Then $txtHeroes = "Success"
If $g_abSearchSearchesEnable[$g_iMatchMode] Then SetLog("searches range: " & $g_aiSearchSearchesMin[$g_iMatchMode] & "-" & $g_aiSearchSearchesMax[$g_iMatchMode] & "  actual value: " & $currentSearch & " - " & $txtsearches, $COLOR_INFO)
If $g_abSearchTropiesEnable[$g_iMatchMode] Then SetLog("tropies range: " & $g_aiSearchTrophiesMin[$g_iMatchMode] & "-" & $g_aiSearchTrophiesMax[$g_iMatchMode] & "  actual value: " & $currentTropies & " | " & $txttropies, $COLOR_INFO)
If $g_abSearchCampsEnable[$g_iMatchMode] Then SetLog("Army camps % range >=: " & $g_aiSearchCampsPct[$g_iMatchMode] & " actual value: " & $currentArmyCamps & " | " & $txtArmyCamp, $COLOR_INFO)
If $g_aiSearchHeroWaitEnable[$g_iMatchMode] > $eHeroNone Then SetLog("Hero status " & BitAND($g_aiAttackUseHeroes[$g_iMatchMode], $g_aiSearchHeroWaitEnable[$g_iMatchMode], $g_iHeroAvailable) & " " & $g_iHeroAvailable & " | " & $txtHeroes, $COLOR_INFO)
Local $txtSpells = "Fail"
If $g_bCheckSpells Then $txtSpells = "Success"
If $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then SetLog("Full spell status: " & $g_bFullArmySpells & " | " & $txtSpells, $COLOR_INFO)
If $g_abSearchSiegeWaitEnable[$g_iMatchMode] Then SetLog("Siege status: " & $bcheckSiege, $COLOR_INFO)
EndIf
Return False
EndIf
ElseIf $checkHeroes = 0 Then
If $g_bDebugSetlog And Not $bNoLog Then SetLog("Heroes not ready", $COLOR_DEBUG)
Return False
ElseIf Not $bcheckSiege Then
If $g_bDebugSetlog And Not $bNoLog Then SetLog("Siege not ready", $COLOR_DEBUG)
Else
If $g_bDebugSetlog And Not $bNoLog Then SetLog("Spells not ready", $COLOR_DEBUG)
Return False
EndIf
EndFunc
Func IsSearchModeActiveMini(Const $iMatchMode)
Return $g_abAttackTypeEnable[$iMatchMode]
EndFunc
Func IsWaitforSpellsActive()
For $i = $DB To $g_iModeCount - 1
If $g_abAttackTypeEnable[$i] And $g_abSearchSpellsWaitEnable[$i] Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforSpellsActive = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforSpellsActive = False", $COLOR_DEBUG)
Return False
EndFunc
Func IsWaitforHeroesActive()
For $i = $DB To $g_iModeCount - 1
If $g_abAttackTypeEnable[$i] And($g_aiSearchHeroWaitEnable[$i] > $eHeroNone And(BitAND($g_aiAttackUseHeroes[$i], $g_aiSearchHeroWaitEnable[$i]) = $g_aiSearchHeroWaitEnable[$i]) And(Abs($g_aiSearchHeroWaitEnable[$i] - $g_iHeroUpgradingBit) > $eHeroNone)) Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforHeroesActive = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforHeroesActive = False", $COLOR_DEBUG)
Return False
EndFunc
Func IsWaitforSiegeMachine()
For $i = $DB To $g_iModeCount - 1
If $g_abAttackTypeEnable[$i] And $g_abSearchSiegeWaitEnable[$i] Then
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforSiegeMachine = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $g_bDebugSetlogTrain Or $g_bDebugSetlog Then SetLog("IsWaitforSiegeMachine = False", $COLOR_DEBUG)
Return False
EndFunc
Func IsSearchAttackEnabled()
If $g_bDebugSetlog Then SetDebugLog("Begin IsSearchAttackScheduled:", $COLOR_DEBUG1)
If $g_bAttackPlannerEnable = False Then Return True
Local $sStartTime = "", $sEndTime = ""
Local $aNoAttackTimes[2] = [$sStartTime, $sEndTime]
Local $iWaitTime = 0
Local $bCloseGame = $g_bAttackPlannerCloseCoC = True Or $g_bAttackPlannerCloseAll = True Or $g_bAttackPlannerSuspendComputer = True
If $g_bDebugSetlog Then SetDebugLog("$bCloseGame:" & $bCloseGame, $COLOR_DEBUG)
If $g_bAttackPlannerDayLimit = True And _OverAttackLimit() Then
SetLog("Daily attack limit reached, skip attacks till new day starts!", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return True
If $bCloseGame Then
$iWaitTime = _getTimeRemainTimeToday()
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $g_bAttackPlannerCloseAll, True, $g_bAttackPlannerSuspendComputer)
$g_bRestart = True
Return
Else
Return False
EndIf
EndIf
If $g_bAttackPlannerRandomEnable = True Then
$aNoAttackTimes = _getDailyRandomStartEnd($g_iAttackPlannerRandomTime)
If @error Then
SetLog(@extended, $COLOR_ERROR)
Return True
EndIf
If _IsTimeInRange($aNoAttackTimes[0], $aNoAttackTimes[1]) Then
SetLog("Attack schedule random skip time found....", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return True
If $bCloseGame Then
$iWaitTime = _DateDiff("s", _NowCalc(), $aNoAttackTimes[1])
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not find NoAttack wait time", True)
Return True
EndIf
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $g_bAttackPlannerCloseAll, True, $g_bAttackPlannerSuspendComputer)
$g_bRestart = True
Return
Else
Return False
EndIf
Else
Return True
EndIf
Else
If IsPlannedTimeNow() = False Then
SetLog("Attack schedule planned skip time found...", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return True
If $bCloseGame Then
If $g_abPlannedAttackWeekDays[@WDAY - 1] = False Then
$iWaitTime = _getTimeRemainTimeToday()
For $i = @WDAY To 6
If $g_abPlannedAttackWeekDays[$i] = False Then $iWaitTime += 86400
If $g_abPlannedAttackWeekDays[$i] = True Then ExitLoop
If $g_bDebugSetlog Then SetDebugLog("Subtotal wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
Next
EndIf
If $iWaitTime = 0 Then
If $g_abPlannedAttackWeekDays[@WDAY - 1] = True And $g_abPlannedattackHours[@HOUR] = False Then
$iWaitTime +=(59 - @MIN) * 60
For $i = @HOUR + 1 To 23
If $g_abPlannedattackHours[$i] = False Then $iWaitTime += 3600
If $g_abPlannedattackHours[$i] = True Then ExitLoop
If $g_bDebugSetlog Then SetDebugLog("Subtotal wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
Next
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog("Stop attack wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $g_bAttackPlannerCloseAll, True, $g_bAttackPlannerSuspendComputer)
$g_bRestart = True
Return
Else
Return False
EndIf
EndIf
EndIf
Return True
EndFunc
Func _getTimeRemainTimeToday()
Local $iTimeRemain = _DateDiff("s", _NowCalc(), _NowCalcDate() & " 23:59:59")
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not determine time remaining today", 0)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("getTimeRemainToday= " & $iTimeRemain & " Seconds", $COLOR_DEBUG)
Return $iTimeRemain
EndFunc
Func _IsTimeAfter($sCompareTime, $sCurrentTime = _NowCalc())
Local $bResult = _DateDiff("s", $sCurrentTime, $sCompareTime) < 0
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not check if time is after", False)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("IsTimeAfter: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _IsTimeBefore($sCompareTime, $sCurrentTime = _NowCalc())
Local $bResult = _DateDiff("s", $sCurrentTime, $sCompareTime) > 0
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not check if time is before", False)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("IsTimeBefore: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _IsTimeInRange($sStartTime, $sEndTime)
Local $sCurrentTime = _NowCalc()
Local $bResult = _IsTimeAfter($sStartTime, $sCurrentTime) And _IsTimeBefore($sEndTime, $sCurrentTime)
If $g_bDebugSetlog Then SetDebugLog("IsTimeInRange: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _getDailyRandomStartEnd($iDuration = 4)
Local $iStartHour, $iEndHour
Local Static $iNowDay = @YDAY
If Not($iDuration >= 0 And $iDuration <= 24) Then
SetError(1, "Invalid duration for _getDailyRandomStartEnd")
Return
EndIf
Local $sStartTime = _DateAdd("h", Int(_getDailyRandom() *(23 - @HOUR)), _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(2, "Can not create initial random start time")
Return
EndIf
Local $sEndTime = _DateAdd("h", Int($iDuration), $sStartTime)
If @error Then
_logErrorDateDiff(@error)
SetError(3, "Can not create initial random end time")
Return
EndIf
Local Static $aNoAttackTimes[2] = [$sStartTime, $sEndTime]
If $iNowDay <> @YDAY Then
$iStartHour = _getDailyRandom() * 24
If $iStartHour <= @HOUR Then $iStartHour = @HOUR + 1.166
$iEndHour = $iStartHour + $iDuration
If $g_bDebugSetlog Then SetDebugLog("StartHour: " & $iStartHour & "EndHour: " & $iEndHour, $COLOR_DEBUG)
$aNoAttackTimes[0] = _DateAdd("h", Int($iStartHour), _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(4, "Can not create random start time")
Return
EndIf
$aNoAttackTimes[1] = _DateAdd("h", Int($iEndHour), _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(5, "Can not create random end time")
Return
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog("NoAttackStart: " & $aNoAttackTimes[0] & "NoAttackEnd: " & $aNoAttackTimes[1], $COLOR_DEBUG)
Return $aNoAttackTimes
EndFunc
Func _getDailyRandom()
Local Static $iDailyRandomValue = Random(0.001, 1, 4)
Local Static $iNowDay = @YDAY
If $iNowDay <> @YDAY Then
$iDailyRandomValue = Round(Random(0.001, 1), 4)
$iNowDay = @YDAY
If $g_bDebugSetlog Then SetDebugLog("New day = new random value!", $COLOR_DEBUG)
EndIf
If $g_bDebugSetlog Then SetDebugLog("DailyRandomValue=" & StringFormat("%0.5f", $iDailyRandomValue), $COLOR_DEBUG)
Return $iDailyRandomValue
EndFunc
Func IsPlannedTimeNow()
Local $hour, $hourloot
If $g_abPlannedAttackWeekDays[@WDAY - 1] = True Then
$hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
$hourloot = $hour[0]
If $g_abPlannedattackHours[$hourloot] = True Then
If $g_bDebugSetlog Then SetDebugLog("Attack plan enabled for now..", $COLOR_DEBUG)
Return True
Else
SetLog("Attack plan enabled today, but not this hour", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return False
Return False
EndIf
Else
SetLog("Attack plan not enabled today", $COLOR_INFO)
If _Sleep($DELAYRESPOND) Then Return False
Return False
EndIf
EndFunc
Func _OverAttackLimit()
Local Static $iAttackCountToday = 0
Local Static $iTotalAttackCount = $g_aiAttackedCount
Local Static $iNowDay = @YDAY
If $iNowDay <> @YDAY Then
$iAttackCountToday = 0
$iNowDay = @YDAY
$iTotalAttackCount = $g_aiAttackedCount
Else
$iAttackCountToday = $g_aiAttackedCount - $iTotalAttackCount
EndIf
If $g_bDebugSetlog Then SetDebugLog("AttackCountToday: " & $iAttackCountToday & ", AttackedCount: " & $g_aiAttackedCount & "TotalAttackCount: " & $iTotalAttackCount, $COLOR_DEBUG)
Local $iRandomAttackCountToday = Ceiling(Int($g_iAttackPlannerDayMin) +(_getDailyRandom() *(Int($g_iAttackPlannerDayMax) - Int($g_iAttackPlannerDayMin))))
If $iRandomAttackCountToday > Int($g_iAttackPlannerDayMax) Then $iRandomAttackCountToday = Int($g_iAttackPlannerDayMax)
If $g_bDebugSetlog Then SetDebugLog("RandomAttackCountToday: " & $iRandomAttackCountToday, $COLOR_DEBUG)
If $iAttackCountToday > $iRandomAttackCountToday Then Return True
Return False
EndFunc
Func WaitForClouds()
If $g_bDebugSetlog Then SetDebugLog("Begin WaitForClouds:", $COLOR_DEBUG1)
$g_bCloudsActive = True
Local $iCount = 0
Local $bigCount = 0, $iLastTime = 0
Local $hMinuteTimer, $iSearchTime
Local $bEnabledGUI = False
Local $maxSearchCount = 720
Local $maxLongSearchCount = 7
Switch Int($g_aiCurrentLoot[$eLootTrophy])
Case 3700 To 4099
$maxSearchCount = Random(480, 840, 1)
$maxLongSearchCount = Random(10, 12, 1)
Case 4100 To 4399
$maxSearchCount = Random(480, 840, 1)
$maxLongSearchCount = Random(15, 25, 1)
Case 4400 To 4699
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(24, 42, 1)
Case 4700 To 4999
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(36, 50, 1)
Case 5000 To 6500
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(80, 85, 1)
EndSwitch
If $g_bDebugSetlog Then
SetLog("RANDOM: $maxSearchCount= " & $maxSearchCount & "= " & Round($maxSearchCount / $DELAYGETRESOURCES1, 2) & " min between cloud chk", $COLOR_DEBUG)
SetLog("RANDOM: $maxLongSearchCount= " & $maxLongSearchCount & "= " & Round(($maxSearchCount / $DELAYGETRESOURCES1) * $maxLongSearchCount, 2) & " min max search time", $COLOR_DEBUG)
EndIf
ForceCaptureRegion()
Local $hMinuteTimer = __TimerInit()
While $g_bRestart = False And _CaptureRegions() And _CheckPixel($aNoCloudsAttack) = False
If _Sleep($DELAYGETRESOURCES1) Then ExitLoop
$iCount += 1
If isProblemAffect(True) Then
resetAttackSearch()
ExitLoop
EndIf
If $iCount >= $maxSearchCount Then
If EnableLongSearch() = False Then
resetAttackSearch()
ExitLoop
Else
$bigCount += 1
If $bigCount > $maxLongSearchCount Then
$iSearchTime = __TimerDiff($hMinuteTimer) / 60000
SetLog("Spent " & $iSearchTime & " minutes in Clouds searching, Restarting CoC and Bot...", $COLOR_ERROR)
$g_bIsClientSyncError = False
$g_bRestart = True
CloseCoC(True)
ExitLoop
EndIf
$iCount = 0
EndIf
EndIf
If(Mod($iCount, 10) = 0 And checkObstacles_Network(False, False)) Then
$g_bIsClientSyncError = True
$g_bRestart = True
CloseCoC(True)
ExitLoop
EndIf
If $g_bDebugSetlog Then _GUICtrlStatusBar_SetTextEx($g_hStatusBar, " Status: Loop to clean screen without Clouds, # " & $iCount)
$iSearchTime = __TimerDiff($hMinuteTimer) / 60000
If $iSearchTime >= $iLastTime + 1 Then
$g_iTotalSearchTime += 1
SetLog("Cloud wait time " & StringFormat("%.1f", $iSearchTime) & " minute(s), Total Searchtime = " & $g_iTotalSearchTime & " minute(s)", $COLOR_INFO)
If $g_bIsSearchTimeout Then
If $iSearchTime > $g_iSearchTimeout Then
$g_bIsSearchTimeout = True
ClickP($aReturnHomeOnSearchButton, 1, 0, "RETURN HOME")
getArmyTroopCapacity(True, True)
$g_bRestart = True
$g_bIsClientSyncError = True
ExitLoop
EndIf
EndIf
$iLastTime += 1
If chkAttackSearchFail() = 2 Or chkAttackSearchPersonalBreak() = True Or GetAndroidProcessPID() = 0 Then
resetAttackSearch()
ExitLoop
EndIf
If _CheckPixel($aIsMain, $g_bCapturePixel) Then
SetLog("Strange error detected! 'WaitforClouds' returned to main base unexpectedly, OOS restart initiated", $COLOR_ERROR)
$g_bRestart = True
resetAttackSearch()
ExitLoop
EndIf
If $iSearchTime > 2 And Not $bEnabledGUI Then
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
$bEnabledGUI = True
EndIf
EndIf
If Not $g_bRunState Then ExitLoop
ForceCaptureRegion()
WEnd
If $bEnabledGUI = True Then
SetLog("Disable bot controls after long wait time", $COLOR_SUCCESS)
AndroidShieldForceDown(False)
DisableGuiControls()
SaveConfig()
readConfig()
applyConfig()
EndIf
If _Sleep($DELAYCLOUDSCLEARED) Then Return
EndFunc
Func EnableLongSearch()
Local $iCount
If $g_bDebugSetlog Then SetDebugLog("Begin EnableLongSearch:", $COLOR_DEBUG1)
If Int($g_aiCurrentLoot[$eLootTrophy]) < 3700 Then
If $g_bDebugSetlog Then SetDebugLog("Long cloud search not enabled due trophy count: " & $g_aiCurrentLoot[$eLootTrophy], $COLOR_DEBUG)
Return False
EndIf
$iCount = 0
While 1
If chkSurrenderBtn() = True Then Return True
If chkAttackSearchPersonalBreak() = True Then Return False
If chkAttackSearchFail() = 1 Then Return True
If chkSearchText() = False Then
If $g_bDebugSetlog Then SetDebugLog("Cloud Search Text not found...", $COLOR_DEBUG)
Return False
Else
Local $KeepAlive[2] = [271, 351 + $g_iMidOffsetY]
ClickP($KeepAlive, 1, 0, "#0514")
EndIf
If _Sleep(5000) Then Return
$iCount += 1
If $iCount > 6 Then Return True
WEnd
EndFunc
Func chkSearchText()
Local $result
$result = getCloudTextShort(388, 348 + $g_iMidOffsetY, "Cloud Search Text: for=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "for", $STR_NOCASESENSEBASIC) <> 0 Then
Return True
EndIf
Return False
EndFunc
Func chkAttackSearchFail()
If _Sleep($DELAYCLOUDSCLEARED) Then Return
Local $result
$result = getCloudFailShort(271, 351 + $g_iMidOffsetY, "Cloud Search Fail Text: unable=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "unable", $STR_NOCASESENSEBASIC) > 0 Then
If btnSearchFailRetry() = True Then
SetLog("Search Fail? Retry search button pushed, continue...", $COLOR_SUCCESS)
Return 1
Else
SetLog("Warning, failed to find/press retry search button", $COLOR_WARNING)
Return 2
EndIf
EndIf
EndFunc
Func chkAttackSearchPersonalBreak()
Local $result
$result = getCloudFailShort(499, 350 + $g_iMidOffsetY, "Cloud Search PB Text: Break=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "break", $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Prepare base before Personal Break in clouds..", $COLOR_INFO)
CheckBaseQuick(True, "cloud")
Return True
EndIf
If $g_bForceSinglePBLogoff And _DateIsValid($g_sPBStartTime) Then
Local $iTimeTillPBTstartSec = Int(_DateDiff('s', $g_sPBStartTime, _NowCalc()))
If $g_bDebugSetlog Then SetDebugLog("PB starts in: " & $iTimeTillPBTstartSec & " Seconds", $COLOR_DEBUG)
If $iTimeTillPBTstartSec >= 0 Then
SetLog("Prepare base before user forced Break..", $COLOR_INFO)
CheckBaseQuick(True, "cloud")
Return True
EndIf
EndIf
Return False
EndFunc
Func btnSearchFailRetry()
Local $aRetrySearchButton = decodeSingleCoord(findImage("Retry Search", $g_sImgRetrySearchButton, GetDiamondFromRect("270,400,600,500"), 1, True))
If IsArray($aRetrySearchButton) And UBound($aRetrySearchButton) = 2 Then
Click($aRetrySearchButton[0], $aRetrySearchButton[1], 1, 0, "#0512")
Return True
EndIf
Return False
EndFunc
Func chkSurrenderBtn()
Local $wCount = 0
While 1
If _CheckPixel($aSurrenderButton, $g_bCapturePixel, Default, "Surrender btn wait #" & $wCount, $COLOR_DEBUG) = True Then
If $g_bDebugSetlog Then SetDebugLog("Surrender button found, clouds gone, continue...", $COLOR_DEBUG)
Return True
EndIf
If _Sleep($DELAYSLEEP) Then Return
$wCount += 1
If $wCount >= 30 Or isProblemAffect(True) Then
Return False
EndIf
WEnd
EndFunc
Func BoostStructure($sName, $sOcrName, $aPos, ByRef $icmbBoostValue, $cmbBoostCtrl)
Local $boosted = False
Local $ok = False
If UBound($aPos) > 1 And $aPos[0] > 0 And $aPos[1] > 0 Then
BuildingClickP($aPos, "#0462")
If _Sleep($DELAYBOOSTHEROES2) Then Return
ForceCaptureRegion()
Local $aResult = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If $aResult[0] > 1 Then
Local $sN = $aResult[1]
Local $sL = $aResult[2]
If $sOcrName = "" Or StringInStr($sN, $sOcrName, $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Boosting " & $sN & " (Level " & $sL & ") located at " & $aPos[0] & ", " & $aPos[1], $COLOR_SUCCESS)
$ok = True
Else
SetLog("Cannot boost " & $sN & " (Level " & $sL & ") located at " & $aPos[0] & ", " & $aPos[1], $COLOR_ERROR)
EndIf
EndIf
EndIf
If $ok = True Then
Local $Boost = findButton("BoostOne")
If IsArray($Boost) Then
If $g_bDebugSetlog Then SetDebugLog("Boost Button X|Y = " & $Boost[0] & "|" & $Boost[1], $COLOR_DEBUG)
Click($Boost[0], $Boost[1], 1, 0, "#0463")
If _Sleep($DELAYBOOSTHEROES1) Then Return
$Boost = findButton("GEM")
If IsArray($Boost) Then
Click($Boost[0], $Boost[1], 1, 0, "#0464")
If _Sleep($DELAYBOOSTHEROES4) Then Return
If IsArray(findButton("EnterShop")) Then
SetLog("Not enough gems to boost " & $sName, $COLOR_ERROR)
Else
If $icmbBoostValue <= 24 Then
$icmbBoostValue -= 1
SetLog($sName & ' Boost completed. Remaining iterations: ' & $icmbBoostValue, $COLOR_SUCCESS)
_GUICtrlComboBox_SetCurSel($cmbBoostCtrl, $icmbBoostValue)
Else
SetLog($sName & ' Boost completed. Remaining iterations: Unlimited', $COLOR_SUCCESS)
EndIf
$boosted = True
EndIf
Else
SetLog($sName & " is already Boosted", $COLOR_SUCCESS)
EndIf
If _Sleep($DELAYBOOSTHEROES3) Then Return
ClickP($aAway, 1, 0, "#0465")
Else
SetLog($sName & " Boost Button not found", $COLOR_ERROR)
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
Else
SetLog("Abort boosting " & $sName & ", bad location", $COLOR_ERROR)
EndIf
Return $boosted
EndFunc
Func AllowBoosting($sName, $icmbBoost)
If($g_bTrainEnabled = True And $icmbBoost > 0) = False Then Return False
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abBoostBarracksHours[$hour[0]] = False Then
SetLog("Boosting " & $sName & " is not planned and skipped...", $COLOR_SUCCESS)
Return False
EndIf
Return True
EndFunc
Func BoostPotion($sName, $sOcrName, $aPos, ByRef $icmbBoostValue, $cmbBoostCtrl)
Local $boosted = False
Local $ok = False
If UBound($aPos) > 1 And $aPos[0] > 0 And $aPos[1] > 0 Then
BuildingClickP($aPos, "#0462")
If _Sleep($DELAYBOOSTHEROES2) Then Return
ForceCaptureRegion()
Local $aResult = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If $aResult[0] > 1 Then
Local $sN = $aResult[1]
If $sOcrName = "" Or StringInStr($sN, $sOcrName, $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Boosting everything using potion")
$ok = True
Else
SetLog("Cannot boost using potion some error occured", $COLOR_ERROR)
EndIf
EndIf
EndIf
If $ok = True Then
Local $sRegionToSearch = "172,238,684,469"
Local $Boost = findButton("MagicItems")
Local $sTile1 = "", $sTile2 = ""
If $sName = "Training Potion" Then
$sTile1 = "BoostTrainingPotion*"
$sTile2 = "BoostTrainingPotionBtn"
ElseIf $sName = "Resource Potion" Then
$sTile1 = "BoostResourcePotion*"
$sTile2 = "BoostResourcePotionBtn"
Else
SetDebugLog("BoostPotion(): $sName called with a wrong Value.", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0161")
_Sleep($DELAYBOOSTBARRACKS2)
Return $boosted
EndIf
If UBound($Boost) > 1 Then
If $g_bDebugSetlog Then SetDebugLog("Magic Items Button X|Y = " & $Boost[0] & "|" & $Boost[1], $COLOR_DEBUG)
Click($Boost[0], $Boost[1], 1, 0, "#0463")
If _Sleep($DELAYBOOSTHEROES1) Then Return
$Boost = decodeSingleCoord(FindImageInPlace($sTile1, @ScriptDir & "\imgxml\imglocbuttons\" & $sTile1, $sRegionToSearch))
If UBound($Boost) > 1 Then
If $g_bDebugSetlog Then SetDebugLog("Boost Potion Button X|Y = " & $Boost[0] & "|" & $Boost[1], $COLOR_DEBUG)
ClickP($Boost)
If _Sleep($DELAYBOOSTHEROES1) Then Return
If Not _ColorCheck(_GetPixelColor(255, 550, True), Hex(0xFFFFFF, 6), 25) Then
SetLog("Cannot find/verify 'Use' Button", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#000000")
Return False
EndIf
Click(305, 556)
If _Sleep($DELAYBOOSTHEROES2) Then Return
$Boost = findButton($sTile2)
If IsArray($Boost) Then
Click($Boost[0], $Boost[1], 1, 0, "#0465")
If _Sleep($DELAYBOOSTHEROES4) Then Return
If $icmbBoostValue <= 5 Then
$icmbBoostValue -= 1
SetLog($sName & ' Boost completed. Remaining iterations: ' & $icmbBoostValue, $COLOR_SUCCESS)
_GUICtrlComboBox_SetCurSel($cmbBoostCtrl, $icmbBoostValue)
EndIf
$boosted = True
Else
SetLog($sName & " is already Boosted", $COLOR_SUCCESS)
EndIf
Else
SetLog($sName & " Boost Button not found!", $COLOR_ERROR)
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
If _Sleep($DELAYBOOSTHEROES3) Then Return
ClickP($aAway, 1, 0, "#0465")
Else
SetLog("Abort boosting " & $sName & ", bad location", $COLOR_ERROR)
EndIf
EndIf
Return $boosted
EndFunc
Func BoostBarracks()
Return BoostTrainBuilding("Barracks", $g_iCmbBoostBarracks, $g_hCmbBoostBarracks)
EndFunc
Func BoostSpellFactory()
Return BoostTrainBuilding("Spell Factory", $g_iCmbBoostSpellFactory, $g_hCmbBoostSpellFactory)
EndFunc
Func BoostWorkshop()
Return BoostTrainBuilding("Workshop", $g_iCmbBoostWorkshop, $g_hCmbBoostWorkshop)
EndFunc
Func BoostTrainBuilding($sName, $iCmbBoost, $iCmbBoostCtrl)
Local $boosted = False
If Not $g_bTrainEnabled Or $iCmbBoost <= 0 Then Return $boosted
Local $aHours = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abBoostBarracksHours[$aHours[0]] Then
SetLog("Boosting " & $sName & " isn't planned, skipping", $COLOR_INFO)
Return $boosted
EndIf
Local $sIsAre = "are"
SetLog("Boosting " & $sName, $COLOR_INFO)
If OpenArmyOverview(True, "BoostTrainBuilding()") Then
If $sName = "Barracks" Then
If Not OpenTroopsTab(True, "BoostTrainBuilding()") Then Return
ElseIf $sName = "Spell Factory" Then
If Not OpenSpellsTab(True, "BoostTrainBuilding()") Then Return
$sIsAre = "is"
ElseIf $sName = "Workshop" Then
If Not OpenSiegeMachinesTab(True, "BoostTrainBuilding()") Then Return
$sIsAre = "is"
Else
SetDebugLog("BoostTrainBuilding(): $sName called with a wrong Value.", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0161")
_Sleep($DELAYBOOSTBARRACKS2)
Return $boosted
EndIf
Local $aBoostBtn = findButton("BoostBarrack")
If IsArray($aBoostBtn) Then
ClickP($aBoostBtn)
_Sleep($DELAYBOOSTBARRACKS1)
Local $aGemWindowBtn = findButton("GEM")
If IsArray($aGemWindowBtn) Then
ClickP($aGemWindowBtn)
_Sleep($DELAYBOOSTBARRACKS2)
If IsArray(findButton("EnterShop")) Then
SetLog("Not enough gems to boost " & $sName, $COLOR_ERROR)
Else
If $iCmbBoost >= 1 And $iCmbBoost <= 24 Then
$iCmbBoost -= 1
_GUICtrlComboBox_SetCurSel($iCmbBoostCtrl, $iCmbBoost)
SetLog("Remaining " & $sName & " Boosts: " & $iCmbBoost, $COLOR_SUCCESS)
ElseIf $iCmbBoost = 25 Then
SetLog("Remain " & $sName & " Boosts: Unlimited", $COLOR_SUCCESS)
EndIf
$boosted = True
If $sName = "Barracks" Then
$g_aiTimeTrain[0] = 0
Else
$g_aiTimeTrain[1] = 0
EndIf
EndIf
EndIf
Else
If IsArray(findButton("BarrackBoosted")) Then
SetLog($sName & " " & $sIsAre & " already boosted", $COLOR_SUCCESS)
Else
SetLog($sName & "boost button not found", $COLOR_ERROR)
EndIf
EndIf
EndIf
ClickP($aAway, 1, 0, "#0161")
_Sleep($DELAYBOOSTBARRACKS2)
Return $boosted
EndFunc
Func BoostTrainingPotion()
If AllowBoosting("Training Potion", $g_iCmbBoostTrainingPotion) = False Then Return
SetLog("Boosting Training Potion .....", $COLOR_INFO)
If $g_aiTownHallPos[0] = "" Or $g_aiTownHallPos[0] = -1 Then
LocateTownHall()
SaveConfig()
If _Sleep($DELAYBOOSTBARRACKS2) Then Return
EndIf
Local Static $iLastTimeChecked[8] = [0, 0, 0, 0, 0, 0, 0, 0], $iDateCalc
$iDateCalc = _DateDiff('n', $iLastTimeChecked[$g_iCurAccount], _NowCalc())
If $iLastTimeChecked[$g_iCurAccount] = 0 Or $iDateCalc > 50 Then
If OpenArmyOverview(True, "BoostTrainingPotion()") Then
If Not OpenTroopsTab(True, "BoostTrainingPotion()") Then Return
Local $aBoostBtn = findButton("BoostBarrack")
If IsArray($aBoostBtn) Then
ClickP($aAway, 2, 0, "#0161")
If _Sleep(1000) Then Return
Local $bChecked = BoostPotion("Training Potion", "Town", $g_aiTownHallPos, $g_iCmbBoostTrainingPotion, $g_hCmbBoostTrainingPotion) = _NowCalc()
If Not $bChecked Then Return False
$g_aiTimeTrain[0] = 0
$g_aiTimeTrain[1] = 0
$g_aiTimeTrain[2] = 0
$iLastTimeChecked[$g_iCurAccount] = _NowCalc()
Return True
Else
SetLog("Training Potion is already Boosted", $COLOR_INFO)
EndIf
ClickP($aAway, 2, 0, "#0161")
EndIf
EndIf
If _Sleep($DELAYBOOSTBARRACKS3) Then Return
checkMainScreen(False)
Return False
EndFunc
Func BoostResourcePotion()
If AllowBoosting("Resource Potion", $g_iCmbBoostResourcePotion) = False Then Return
SetLog("Boosting Resource Potion .....", $COLOR_INFO)
If $g_aiTownHallPos[0] = "" Or $g_aiTownHallPos[0] = -1 Then
LocateTownHall()
SaveConfig()
If _Sleep($DELAYBOOSTBARRACKS2) Then Return
EndIf
Local Static $iLastTimeChecked[8] = [0, 0, 0, 0, 0, 0, 0, 0], $iDateCalc
$iDateCalc = _DateDiff('n', $iLastTimeChecked[$g_iCurAccount], _NowCalc())
Local $ok = False
If $iLastTimeChecked[$g_iCurAccount] = 0 Or $iDateCalc > 50 Then
If UBound($g_aiResourcesPos) > 1 And $g_aiResourcesPos[0] > 0 And $g_aiResourcesPos[1] > 0 Then
ClickP($g_aiResourcesPos, 1, 0, "#Resources")
If _Sleep($DELAYBOOSTHEROES2) Then Return
ForceCaptureRegion()
Local $aResult = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If $aResult[0] > 1 Then
Local $sN = $aResult[1]
Local $sL = $aResult[2]
If StringInStr($sN, "Mine", $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Find " & $sN & " (Level " & $sL & ") located at " & $g_aiResourcesPos[0] & ", " & $g_aiResourcesPos[1], $COLOR_SUCCESS)
$ok = True
ElseIf StringInStr($sN, "Collector", $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Find " & $sN & " (Level " & $sL & ") located at " & $g_aiResourcesPos[0] & ", " & $g_aiResourcesPos[1], $COLOR_SUCCESS)
$ok = True
ElseIf StringInStr($sN, "Drill", $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Find " & $sN & " (Level " & $sL & ") located at " & $g_aiResourcesPos[0] & ", " & $g_aiResourcesPos[1], $COLOR_SUCCESS)
$ok = True
Else
SetLog("Cannot find " & $sN & " (Level " & $sL & ") located at " & $g_aiResourcesPos[0] & ", " & $g_aiResourcesPos[1], $COLOR_ERROR)
EndIf
EndIf
EndIf
If $ok = True Then
Local $aCheckBoosted = findButton("Boostleft")
If Not IsArray($aCheckBoosted) Then
ClickP($aAway, 2, 0, "#0161")
If _Sleep($DELAYBOOSTBARRACKS1) Then Return
Local $bChecked = BoostPotion("Resource Potion", "Town", $g_aiTownHallPos, $g_iCmbBoostResourcePotion, $g_hCmbBoostResourcePotion) = _NowCalc()
If Not $bChecked Then Return False
$iLastTimeChecked[$g_iCurAccount] = _NowCalc()
Return True
Else
SetLog("Resource Potion is already Boosted", $COLOR_INFO)
EndIf
ClickP($aAway, 2, 0, "#0161")
EndIf
EndIf
If _Sleep($DELAYBOOSTBARRACKS3) Then Return
checkMainScreen(False)
Return False
EndFunc
Func BotDetectFirstTime()
If $g_bIsClientSyncError Then Return
ClickP($aAway, 1, 0, "#0166")
If _Sleep($DELAYBOTDETECT1) Then Return
SetLog("Detecting your Buildings", $COLOR_INFO)
If Not isInsideDiamond($g_aiTownHallPos) Then
checkMainScreen()
Collect(False)
_CaptureRegion2()
Local $PixelTHHere = GetLocationItem("getLocationTownHall")
If UBound($PixelTHHere) > 0 Then
Local $pixel = $PixelTHHere[0]
$g_aiTownHallPos[0] = $pixel[0]
$g_aiTownHallPos[1] = $pixel[1]
If $g_bDebugSetlog Then SetDebugLog("DLLc# Townhall: (" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_ERROR)
EndIf
If $g_aiTownHallPos[1] = "" Or $g_aiTownHallPos[1] = -1 Then
imglocTHSearch(True, True)
$g_aiTownHallPos[0] = $g_iTHx
$g_aiTownHallPos[1] = $g_iTHy
If $g_bDebugSetlog Then SetDebugLog("OldDDL Townhall: (" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_ERROR)
EndIf
SetLog("Townhall: (" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_DEBUG)
EndIf
If Number($g_iTownHallLevel) < 2 Then
Local $aTownHallLevel = GetTownHallLevel(True)
If IsArray($aTownHallLevel) Then $g_iTownHallLevel = 0
EndIf
If Number($g_iTownHallLevel) > 1 And Number($g_iTownHallLevel) < 6 Then
SetLog("Warning: TownHall level below 6 NOT RECOMMENDED!", $COLOR_ERROR)
SetLog("Proceed with caution as errors may occur.", $COLOR_ERROR)
EndIf
If $g_iTownHallLevel < 2 Or($g_aiTownHallPos[1] = "" Or $g_aiTownHallPos[1] = -1) Then LocateTownHall(False, False)
If _Sleep($DELAYBOTDETECT1) Then Return
CheckImageType()
If _Sleep($DELAYBOTDETECT1) Then Return
If GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED Or $g_bScreenshotHideName Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiClanCastlePos[0] = -1 Then
LocateClanCastle(False)
SaveConfig()
EndIf
EndIf
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiLaboratoryPos[0] = "" Or $g_aiLaboratoryPos[0] = -1 Then
LocateLab(False)
SaveConfig()
EndIf
If(GUICtrlRead($g_hCmbBoostBarbarianKing) > 0) Or $g_bUpgradeKingEnable Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiKingAltarPos[0] = -1 Then
LocateKingAltar(False)
SaveConfig()
EndIf
EndIf
If(GUICtrlRead($g_hCmbBoostArcherQueen) > 0) Or $g_bUpgradeQueenEnable Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiQueenAltarPos[0] = -1 Then
LocateQueenAltar(False)
SaveConfig()
EndIf
EndIf
If Number($g_iTownHallLevel) > 10 And((GUICtrlRead($g_hCmbBoostWarden) > 0) Or $g_bUpgradeWardenEnable) Then
If _Sleep($DELAYBOTDETECT3) Then Return
If $g_aiWardenAltarPos[0] = -1 Then
LocateWardenAltar(False)
SaveConfig()
EndIf
EndIf
GUICtrlSetData($g_hLblTHLevels, "")
_GUI_Value_STATE("HIDE", $g_aGroupListTHLevels)
If $g_bDebugSetlog Then SetDebugLog("Select TH Level:" & Number($g_iTownHallLevel), $COLOR_DEBUG)
GUICtrlSetState($g_ahPicTHLevels[$g_iTownHallLevel], $GUI_SHOW)
GUICtrlSetData($g_hLblTHLevels, $g_iTownHallLevel)
EndFunc
Func BotCommand()
Static $TimeToStop = -1
Local $bChkBotStop, $iCmbBotCond, $iCmbBotCommand
If $g_bOutOfElixir Or $g_bOutOfGold Then
$bChkBotStop = True
$iCmbBotCond = 18
$iCmbBotCommand = 0
Local $sOutOf =($g_bOutOfGold ? "Gold" : "") &(($g_bOutOfGold And $g_bOutOfElixir)? " and " : "") &($g_bOutOfElixir ? "Elixir" : "")
SetLog("Out of " & $sOutOf & " condition detected, force HALT mode!", $COLOR_WARNING)
Else
$bChkBotStop = $g_bChkBotStop
$iCmbBotCond = $g_iCmbBotCond
$iCmbBotCommand = $g_iCmbBotCommand
EndIf
$g_bMeetCondStop = False
$g_bTrainEnabled = True
$g_bDonationEnabled = True
If $bChkBotStop = True Then
If $iCmbBotCond = 15 And $g_iCmbHoursStop <> 0 Then $TimeToStop = $g_iCmbHoursStop * 3600000
Switch $iCmbBotCond
Case 0
If isGoldFull() And isElixirFull() And isTrophyMax() Then $g_bMeetCondStop = True
Case 1
If(isGoldFull() And isElixirFull()) Or isTrophyMax() Then $g_bMeetCondStop = True
Case 2
If(isGoldFull() Or isElixirFull()) And isTrophyMax() Then $g_bMeetCondStop = True
Case 3
If isGoldFull() Or isElixirFull() Or isTrophyMax() Then $g_bMeetCondStop = True
Case 4
If isGoldFull() And isElixirFull() Then $g_bMeetCondStop = True
Case 5
If isGoldFull() Or isElixirFull() Then $g_bMeetCondStop = True
Case 6
If isGoldFull() And isTrophyMax() Then $g_bMeetCondStop = True
Case 7
If isElixirFull() And isTrophyMax() Then $g_bMeetCondStop = True
Case 8
If isGoldFull() Or isTrophyMax() Then $g_bMeetCondStop = True
Case 9
If isElixirFull() Or isTrophyMax() Then $g_bMeetCondStop = True
Case 10
If isGoldFull() Then $g_bMeetCondStop = True
Case 11
If isElixirFull() Then $g_bMeetCondStop = True
Case 12
If isTrophyMax() Then $g_bMeetCondStop = True
Case 13
If isDarkElixirFull() Then $g_bMeetCondStop = True
Case 14
If isGoldFull() And isElixirFull() And isDarkElixirFull() Then $g_bMeetCondStop = True
Case 15
If Round(__TimerDiff($g_hTimerSinceStarted)) > $TimeToStop Then $g_bMeetCondStop = True
Case 16
$g_bMeetCondStop = True
Case 17
$g_bMeetCondStop = True
$g_bTrainEnabled = False
Case 18
$g_bMeetCondStop = True
$g_bTrainEnabled = False
$g_bDonationEnabled = False
Case 19
If $g_bWaitShield = True Then $g_bMeetCondStop = True
Case 20
If $g_bWaitShield = True Then
$g_bMeetCondStop = True
$g_bTrainEnabled = False
EndIf
Case 21
If $g_bWaitShield = True Then
$g_bMeetCondStop = True
$g_bTrainEnabled = False
$g_bDonationEnabled = False
EndIf
EndSwitch
If $g_bMeetCondStop Then
Switch $iCmbBotCommand
Case 0
If $g_bDonationEnabled = False Then
SetLog("Halt Attack, Stay Online/Collect...", $COLOR_INFO)
ElseIf $g_bTrainEnabled = False Then
SetLog("Halt Attack, Stay Online/Collect/Donate...", $COLOR_INFO)
Else
SetLog("Halt Attack, Stay Online/Train/Collect/Donate...", $COLOR_INFO)
EndIf
$g_iCommandStop = 0
If _Sleep($DELAYBOTCOMMAND1) Then Return
Case 1
SetLog("MyBot.run Bot Stop as requested!!", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Return True
Case 2
SetLog("MyBot.run Close Bot as requested!!", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
BotClose()
Return True
Case 3
SetLog("Close Android and Bot as requested!!", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
CloseAndroid("BotCommand")
BotClose()
Return True
Case 4
SetLog("Force Shutdown of PC...", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Shutdown(BitOR($SD_SHUTDOWN, $SD_FORCE))
Return True
Case 5
SetLog("PC Sleep Mode Start now ...", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Shutdown($SD_STANDBY)
Return True
Case 6
SetLog("Rebooting PC...", $COLOR_INFO)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Shutdown(BitOR($SD_REBOOT, $SD_FORCE))
Return True
EndSwitch
EndIf
EndIf
Return False
EndFunc
Func isTrophyMax()
Local $iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If Number($iTrophyCurrent) > Number($g_iDropTrophyMax) Then
SetLog("Max. Trophy Reached!", $COLOR_SUCCESS)
If _Sleep($DELAYBOTCOMMAND1) Then Return
Return True
EndIf
Return False
EndFunc
Func BreakPersonalShield()
If $g_bDebugSetlog Then SetDebugLog("Begin BreakPersonalShield:", $COLOR_DEBUG1)
If $g_bDebugSetlog Then
SetDebugLog("Checking if Shield available", $COLOR_INFO)
SetDebugLog("Have shield pixel color: " & _GetPixelColor($aHaveShield, $g_bCapturePixel) & " :" & _CheckPixel($aHaveShield, $g_bCapturePixel), $COLOR_DEBUG)
EndIf
If _CheckPixel($aHaveShield, $g_bCapturePixel) Then
If IsMainPage() Then
PureClickP($aShieldInfoButton)
If _Sleep($DELAYPERSONALSHIELD1) Then
SetError(2)
Return
EndIf
Local $result = ClickRemove("Shield")
If($result = False) Or @error Then
SetError(3, "shield remove button not found", "")
Return
EndIf
$result = ClickOkay("Shield")
If($result = False) Or @error Then
SetError(4, "shield Okay button not found", "")
Return
EndIf
SetLog("Shield removed", $COLOR_SUCCESS)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("No shield available", $COLOR_SUCCESS)
EndIf
If _Sleep($DELAYPERSONALSHIELD1) Then
SetError(2)
Return
EndIf
If $g_bDebugSetlog Then
SetDebugLog("Checking if Personal Guard available", $COLOR_INFO)
SetDebugLog("Have guard pixel color: " & _GetPixelColor($aHavePerGuard, $g_bCapturePixel) & " :" & _CheckPixel($aHavePerGuard, $g_bCapturePixel), $COLOR_DEBUG)
EndIf
If _CheckPixel($aHavePerGuard, $g_bCapturePixel) Then
If IsMainPage() Then
PureClickP($aShieldInfoButton)
If _Sleep($DELAYPERSONALSHIELD1) Then
SetError(2)
Return
EndIf
Local $result = ClickRemove("Guard")
If($result = False) Or @error Then
SetError(5, "guard remove button not found")
Return
EndIf
$result = ClickOkay("Guard")
If($result = False) Or @error Then
SetError(6, "guard Okay button not found")
Return
EndIf
SetLog("Personal Guard removed", $COLOR_SUCCESS)
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("No guard available", $COLOR_SUCCESS)
EndIf
EndFunc
Func CheckImageType()
SetLog("Detecting your Village Theme", $COLOR_INFO)
ClickP($aAway, 2, 20, "#0467")
If _Sleep($DELAYCHECKIMAGETYPE1) Then Return
If Not IsMainPage() Then ClickP($aAway, 2, 20, "#0467")
Local $x = 150
Local $y = 150
Local $x1 = $x + 50
Local $y1 = $y + 50
Local $directory = @ScriptDir & "\imgxml\SnowTheme"
Local $temp = SearchImgloc($directory, $x, $y, $x1, $y1)
If IsArray($temp) Then
If StringInStr($temp[0], "Snow") > 0 Then
$g_iDetectedImageType = 1
SetLog("Snow Theme detected")
Else
$g_iDetectedImageType = 0
SetLog("Normal Theme detected")
EndIf
Else
$g_iDetectedImageType = 0
SetLog("Normal Theme detected", $COLOR_ERROR)
EndIf
EndFunc
Func CheckBaseQuick($bStopRecursion = False, $sReturnHome = "")
If $bStopRecursion = True Then $g_bDisableBreakCheck = True
Switch $sReturnHome
Case "cloud"
If _CheckPixel($aRtnHomeCloud1, $g_bCapturePixel, Default, "Return Home Btn chk1", $COLOR_DEBUG) And  _CheckPixel($aRtnHomeCloud2, $g_bCapturePixel, Default, "Return Home Btn chk2", $COLOR_DEBUG) Then
ClickP($aRtnHomeCloud1, 1, 0, "#0513")
Local $wCount = 0
While IsMainPage() = False
If _Sleep($DELAYGETRESOURCES1) Then Return
$wCount += 1
If $wCount > 40 Then
SetLog("Warning, Main page not found", $COLOR_WARNING)
ExitLoop
EndIf
WEnd
EndIf
EndSwitch
If IsMainPage() Then
If $g_bDebugSetlog Then SetDebugLog("CheckBaseQuick now...", $COLOR_DEBUG)
RequestCC()
If _Sleep($DELAYRUNBOT1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then
If $bStopRecursion = True Then $g_bDisableBreakCheck = False
Return
EndIf
DonateCC()
If _Sleep($DELAYRUNBOT1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then
If $bStopRecursion = True Then $g_bDisableBreakCheck = False
Return
EndIf
CheckOverviewFullArmy(True)
If Not($g_bFullArmy) And $g_bTrainEnabled = True Then
If $g_iActualTrainSkip < $g_iMaxTrainSkip Then
TrainSystem()
If $g_bRestart Then Return
Else
If $g_bDebugSetlogTrain Then SetLog("skip train. " & $g_iActualTrainSkip + 1 & "/" & $g_iMaxTrainSkip, $color_purple)
$g_iActualTrainSkip = $g_iActualTrainSkip + 1
CheckOverviewFullArmy(True, False)
getArmySpells()
getArmyHeroCount(False, True)
If $g_iActualTrainSkip >= $g_iMaxTrainSkip Then
$g_iActualTrainSkip = 0
EndIf
If $bStopRecursion = True Then $g_bDisableBreakCheck = False
Return
EndIf
EndIf
Collect()
If _Sleep($DELAYRUNBOT1) Then Return
Else
If $g_bDebugSetlog Then SetDebugLog("Not on main page, CheckBaseQuick skipped", $COLOR_WARNING)
EndIf
If $bStopRecursion = True Then $g_bDisableBreakCheck = False
EndFunc
Func chkShieldStatus($bChkShield = True, $bForceChkPBT = False)
If($g_bForceSinglePBLogoff = False And($g_bChkBotStop = True And $g_iCmbBotCond >= 19) = False) And $g_bCloseWhileTrainingEnable = False And Not $g_bRequestCCDefense Or Not(IsMainPage()) Then Return
Local $Result, $iTimeTillPBTstartSec, $ichkTime = 0, $ichkSTime = 0, $ichkPBTime = 0
If $bChkShield Or $g_asShieldStatus[0] = "" Or $g_asShieldStatus[1] = "" Or $g_asShieldStatus[2] = "" Or $g_sPBStartTime = "" Or $g_bGForcePBTUpdate = True Then
$Result = getShieldInfo()
If @error Then SetLog("chkShieldStatus Shield OCR error= " & @error & "Extended= " & @extended, $COLOR_ERROR)
If _Sleep($DELAYRESPOND) Then Return
If IsArray($Result) Then
Local $iShieldExp = _DateDiff('n', $Result[2], _NowCalc())
If Abs($iShieldExp) > 0 Then
Local $sFormattedDiff = _Date_Difference(_NowCalc(), $Result[2], 4)
SetLog("Shield expires in: " & $sFormattedDiff)
Else
SetLog("Shield has expired")
EndIf
If _DateIsValid($g_asShieldStatus[2]) Then
$ichkTime = Abs(Int(_DateDiff('s', $g_asShieldStatus[2], $Result[2])))
If $ichkTime > 60 Then
$bForceChkPBT = True
If $g_bDebugSetlog Then SetDebugLog("Shield time changed: " & $ichkTime & " Sec, Force PBT OCR: " & $bForceChkPBT, $COLOR_WARNING)
EndIf
EndIf
$g_asShieldStatus = $Result
If $g_bChkBotStop = True And $g_iCmbBotCond >= 19 Then
If $g_asShieldStatus[0] = "shield" Then
SetLog("Shield found, Halt Attack Now!", $COLOR_INFO)
$g_bWaitShield = True
$g_bIsClientSyncError = False
$g_bIsSearchLimit = False
Else
$g_bWaitShield = False
If $g_bMeetCondStop = True Then
SetLog("Shield expired, resume attacking", $COLOR_INFO)
$g_bTrainEnabled = True
$g_bDonationEnabled = True
$g_bMeetCondStop = False
Else
If $g_bDebugSetlog Then SetDebugLog("Halt With Shield: Shield not found...", $COLOR_DEBUG)
EndIf
EndIf
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Bad getShieldInfo() return value: " & $Result, $COLOR_ERROR)
If _Sleep($DELAYRESPOND) Then Return
For $i = 0 To UBound($g_asShieldStatus) - 1
$g_asShieldStatus[$i] = ""
Next
EndIf
EndIf
If Not $g_bForceSinglePBLogoff And Not $g_bRequestCCDefense Then Return
If _DateIsValid($g_sPBStartTime) Then
$ichkPBTime = Int(_DateDiff('s', $g_sPBStartTime, _NowCalc()))
If $ichkPBTime >= 295 Then
$bForceChkPBT = True
If $g_bDebugSetlog Then SetDebugLog("Found old PB time= " & $ichkPBTime & " Seconds, Force update:" & $bForceChkPBT, $COLOR_WARNING)
EndIf
EndIf
If $bForceChkPBT Or $g_bGForcePBTUpdate Or $g_sPBStartTime = "" Then
$g_bGForcePBTUpdate = False
$Result = getPBTime()
If @error Then SetLog("chkShieldStatus getPBTime OCR error= " & @error & ", Extended= " & @extended, $COLOR_ERROR)
If _Sleep($DELAYRESPOND) Then Return
If _DateIsValid($Result) Then
Local $iTimeTillPBTstartMin = Int(_DateDiff('n', $Result, _NowCalc()))
If Abs($iTimeTillPBTstartMin) > 0 Then
Local $sFormattedDiff = _Date_Difference(_DateAdd("n", -1, _NowCalc()), $Result, 4)
SetLog("Personal Break starts in: " & $sFormattedDiff)
Local $CorrectstringPB_GUI = StringReplace($sFormattedDiff, StringInStr($sFormattedDiff, " hours ") >= 1 ? " hours " : " hour ", "h")
$CorrectstringPB_GUI = StringReplace($CorrectstringPB_GUI, StringInStr($CorrectstringPB_GUI, " minutes ") >= 1 ? " minutes " : " minute ", "'")
EndIf
If $iTimeTillPBTstartMin < -(Int($g_iSinglePBForcedEarlyExitTime)) Then
$g_sPBStartTime = _DateAdd('n', -(Int($g_iSinglePBForcedEarlyExitTime)), $Result)
ElseIf $iTimeTillPBTstartMin < 0 Then
$g_sPBStartTime = $Result
Else
$g_sPBStartTime = ""
EndIf
If $g_bDebugSetlog Then SetDebugLog("Early Log Off time=" & $g_sPBStartTime & ", In " & _DateDiff('n', $g_sPBStartTime, _NowCalc()) & " Minutes", $COLOR_DEBUG)
Else
SetLog("Bad getPBTtime() return value: " & $Result, $COLOR_ERROR)
$g_sPBStartTime = ""
EndIf
EndIf
If checkObstacles() Then checkMainScreen(False)
EndFunc
Func _Date_Difference($sStartDate, Const $sEndDate, Const $iGrain)
Local $aUnit[6] = ["Y", "M", "D", "h", "n", "s"]
Local $aType[6] = ["year", "month", "day", "hour", "minute", "second"]
Local $sReturn = "", $iUnit
For $i = 0 To $iGrain
$iUnit = _DateDiff($aUnit[$i], $sStartDate, $sEndDate)
If $iUnit <> 0 Then
$sReturn &= $iUnit & " " & $aType[$i] &($iUnit > 1 ? "s" : "") & " "
EndIf
$sStartDate = _DateAdd($aUnit[$i], Int($iUnit), $sStartDate)
Next
Return $sReturn
EndFunc
Func Collect($bCheckTreasury = True)
If Not $g_bChkCollect Or Not $g_bRunState Then Return
ClickP($aAway, 1, 0, "#0332")
StartGainCost()
checkAttackDisable($g_iTaBChkIdle)
If $g_bChkCollectCartFirst And($g_iTxtCollectGold = 0 Or $g_aiCurrentLoot[$eLootGold] < Number($g_iTxtCollectGold) Or $g_iTxtCollectElixir = 0 Or $g_aiCurrentLoot[$eLootElixir] < Number($g_iTxtCollectElixir) Or $g_iTxtCollectDark = 0 Or $g_aiCurrentLoot[$eLootDarkElixir] < Number($g_iTxtCollectDark)) Then CollectLootCart()
SetLog("Collecting Resources", $COLOR_INFO)
If _Sleep($DELAYCOLLECT2) Then Return
Local $sFileName = ""
Local $aCollectXY, $t
Local $aResult = returnMultipleMatchesOwnVillage($g_sImgCollectRessources)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
$sFileName = $aResult[$i][1]
$aCollectXY = $aResult[$i][5]
Switch StringLower($sFileName)
Case "collectmines"
If $g_iTxtCollectGold <> 0 And $g_aiCurrentLoot[$eLootGold] >= Number($g_iTxtCollectGold) Then
SetLog("Gold is high enough, skip collecting", $COLOR_ACTION)
ContinueLoop
EndIf
Case "collectelix"
If $g_iTxtCollectElixir <> 0 And $g_aiCurrentLoot[$eLootElixir] >= Number($g_iTxtCollectElixir) Then
SetLog("Elixir is high enough, skip collecting", $COLOR_ACTION)
ContinueLoop
EndIf
Case "collectdelix"
If $g_iTxtCollectDark <> 0 And $g_aiCurrentLoot[$eLootDarkElixir] >= Number($g_iTxtCollectDark) Then
SetLog("Dark Elixier is high enough, skip collecting", $COLOR_ACTION)
ContinueLoop
EndIf
EndSwitch
If IsArray($aCollectXY) Then
$t = Random(0, UBound($aCollectXY) - 1, 1)
If $g_bDebugSetlog Then SetDebugLog($sFileName & " found, random pick(" & $aCollectXY[$t][0] & "," & $aCollectXY[$t][1] & ")", $COLOR_GREEN)
If IsMainPage() Then Click($aCollectXY[$t][0], $aCollectXY[$t][1], 1, 0, "#0430")
$g_aiResourcesPos[0] = $aCollectXY[$t][0]
$g_aiResourcesPos[1] = $aCollectXY[$t][1] + 29
If _Sleep($DELAYCOLLECT3) Then Return
EndIf
Next
EndIf
BoostResourcePotion()
If _Sleep($DELAYCOLLECT3) Then Return
checkMainScreen(False)
If Not $g_bChkCollectCartFirst And($g_iTxtCollectGold = 0 Or $g_aiCurrentLoot[$eLootGold] < Number($g_iTxtCollectGold) Or $g_iTxtCollectElixir = 0 Or $g_aiCurrentLoot[$eLootElixir] < Number($g_iTxtCollectElixir) Or $g_iTxtCollectDark = 0 Or $g_aiCurrentLoot[$eLootDarkElixir] < Number($g_iTxtCollectDark)) Then CollectLootCart()
If $g_bChkTreasuryCollect And $bCheckTreasury Then TreasuryCollect()
EndGainCost("Collect")
EndFunc
Func CollectLootCart()
SetLog("Searching for a Loot Cart", $COLOR_INFO)
Local $aLootCart = decodeSingleCoord(findImage("LootCart", $g_sImgCollectLootCart, "ECD", 1, True))
If UBound($aLootCart) > 1 Then
If isInsideDiamond($aLootCart) Then
If IsMainPage() Then ClickP($aLootCart, 1, 0, "#0330")
If _Sleep($DELAYCOLLECT1) Then Return
Local $sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep($DELAYCOLLECT1) Then Return
$CountGetInfo += 1
If $CountGetInfo >= 5 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Loot") = 0 Then
If $g_bDebugSetlog Then SetDebugLog("Bad Loot Cart location", $COLOR_ACTION)
Else
If IsMainPage() Then Click($aLootCartBtn[0], $aLootCartBtn[1], 1, 0, "#0331")
EndIf
EndIf
Else
SetLog("LootCart Coordinates are not inside the Village (X: " & $aLootCart[0] & " | Y: " & $aLootCart[1] & ")", $COLOR_INFO)
EndIf
Else
SetLog("No Loot Cart found on your Village", $COLOR_SUCCESS)
EndIf
EndFunc
Func TreasuryCollect()
If $g_bDebugSetlog Then SetDebugLog("Begin CollectTreasury:", $COLOR_DEBUG1)
If Not $g_bRunState Then Return
ClickP($aAway, 1, 0, "#0441")
If _Sleep($DELAYRESPOND) Then Return
If($g_aiClanCastlePos[0] = "-1" Or $g_aiClanCastlePos[1] = "-1") Then
SetLog("Need Clan Castle location for the Treasury, Please locate your Clan Castle.", $COLOR_WARNING)
LocateClanCastle()
If($g_aiClanCastlePos[0] = "-1" Or $g_aiClanCastlePos[1] = "-1") Then
SetLog("Treasury skipped, bad Clan Castle location", $COLOR_ERROR)
If _Sleep($DELAYRESPOND) Then Return
Return
EndIf
EndIf
ClickP($aAway, 1, 0, "#0440")
If _Sleep($DELAYCOLLECT3) Then Return
BuildingClick($g_aiClanCastlePos[0], $g_aiClanCastlePos[1], "#0250")
If _Sleep($DELAYTREASURY2) Then Return
Local $aTreasuryButton = findButton("Treasury", Default, 1, True)
If IsArray($aTreasuryButton) And UBound($aTreasuryButton, 1) = 2 Then
If IsMainPage() Then ClickP($aTreasuryButton, 1, 0, "#0330")
If _Sleep($DELAYTREASURY1) Then Return
Else
SetLog("Cannot find the Treasury Button", $COLOR_ERROR)
EndIf
If Not _WaitForCheckPixel($aTreasuryWindow, $g_bCapturePixel, Default, "Wait treasury window:") Then
SetLog("Treasury window not found!", $COLOR_ERROR)
Return
EndIf
Local $bForceCollect = False
Local $aResult = _PixelSearch(689, 237 + $g_iMidOffsetY, 691, 325 + $g_iMidOffsetY, Hex(0x50BD10, 6), 20)
If IsArray($aResult) Then
SetLog("Found full Treasury, collecting loot...", $COLOR_SUCCESS)
$bForceCollect = True
Else
SetLog("Treasury not full yet", $COLOR_INFO)
EndIf
If $bForceCollect Or($g_bChkTreasuryCollect And((Number($g_aiCurrentLoot[$eLootGold]) <= $g_iTxtTreasuryGold) Or(Number($g_aiCurrentLoot[$eLootElixir]) <= $g_iTxtTreasuryElixir) Or(Number($g_aiCurrentLoot[$eLootDarkElixir]) <= $g_iTxtTreasuryDark))) Then
Local $aCollectButton = findButton("Collect", Default, 1, True)
If IsArray($aCollectButton) And UBound($aCollectButton, 1) = 2 Then
ClickP($aCollectButton, 1, 0, "#0330")
If _Sleep($DELAYTREASURY2) Then Return
If ClickOkay("ConfirmCollectTreasury") Then
SetLog("Treasury collected successfully.", $COLOR_SUCCESS)
Else
SetLog("Cannot Click Okay Button on Treasury Collect screen", $COLOR_ERROR)
EndIf
Else
SetDebugLog("Error in TreasuryCollect(): Cannot find the Collect Button", $COLOR_ERROR)
EndIf
Else
ClickP($aAway, 1, 0, "#0438")
If _Sleep($DELAYTREASURY4) Then Return
EndIf
ClickP($aAway, 1, 0, "#0438")
If _Sleep($DELAYTREASURY4) Then Return
EndFunc
Global $g_aiPrepDon[6] = [0, 0, 0, 0, 0, 0]
Global $g_iTotalDonateTroopCapacity, $g_iTotalDonateSpellCapacity, $g_iTotalDonateSiegeMachineCapacity
Global $g_iDonTroopsLimit = 8, $iDonSpellsLimit = 1, $g_iDonTroopsAv = 0, $g_iDonSpellsAv = 0
Global $g_iDonTroopsQuantityAv = 0, $g_iDonTroopsQuantity = 0, $g_iDonSpellsQuantityAv = 0, $g_iDonSpellsQuantity = 0
Global $g_bSkipDonTroops = False, $g_bSkipDonSpells = False, $g_bSkipDonSiege = False
Global $g_bDonateAllRespectBlk = False
Global $g_aiDonatePixel
Global $g_aiAvailQueuedTroop[$eTroopCount], $g_aiAvailQueuedSpell[$eSpellCount]
Func PrepareDonateCC()
$g_aiPrepDon[0] = 0
$g_aiPrepDon[1] = 0
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
$g_aiPrepDon[0] = BitOR($g_aiPrepDon[0],($g_abChkDonateTroop[$i] ? 1 : 0))
$g_aiPrepDon[1] = BitOR($g_aiPrepDon[1],($g_abChkDonateAllTroop[$i] ? 1 : 0))
Next
$g_aiPrepDon[2] = 0
$g_aiPrepDon[3] = 0
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$g_aiPrepDon[2] = BitOR($g_aiPrepDon[2],($g_abChkDonateSpell[$i] ? 1 : 0))
$g_aiPrepDon[3] = BitOR($g_aiPrepDon[3],($g_abChkDonateAllSpell[$i] ? 1 : 0))
EndIf
Next
$g_aiPrepDon[4] = 0
$g_aiPrepDon[5] = 0
For $i = $eSiegeWallWrecker To $eSiegeMachineCount - 1
$g_aiPrepDon[4] = BitOR($g_aiPrepDon[4],($g_abChkDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $i] ? 1 : 0))
$g_aiPrepDon[5] = BitOR($g_aiPrepDon[5],($g_abChkDonateAllTroop[$eTroopCount + $g_iCustomDonateConfigs + $i] ? 1 : 0))
Next
$g_iActiveDonate = BitOR($g_aiPrepDon[0], $g_aiPrepDon[1], $g_aiPrepDon[2], $g_aiPrepDon[3], $g_aiPrepDon[4], $g_aiPrepDon[5])
EndFunc
Func IsDonateQueueOnly(ByRef $abDonateQueueOnly)
If Not $abDonateQueueOnly[0] And Not $abDonateQueueOnly[1] Then Return
For $i = 0 To $eTroopCount - 1
$g_aiAvailQueuedTroop[$i] = 0
If $i < $eSpellCount Then $g_aiAvailQueuedSpell[$i] = 0
Next
If Not OpenArmyOverview(True, "IsDonateQueueOnly()") Then Return
For $i = 0 To 1
If Not $g_aiPrepDon[$i * 2] And Not $g_aiPrepDon[$i * 2 + 1] Then $abDonateQueueOnly[$i] = False
If $abDonateQueueOnly[$i] Then
SetLog("Checking queued " &($i = 0 ? "troops" : "spells") & " for donation", $COLOR_ACTION)
If IsQueueEmpty($i = 0 ? "Troops" : "Spells", False, False) Then
SetLog("2nd army is not prepared. Donate whatever exists in 1st army.")
$abDonateQueueOnly[$i] = False
ContinueLoop
EndIf
If Not OpenTrainTab($i = 0 ? "Train Troops Tab" : "Brew Spells Tab", True, "IsDonateQueueOnly()") Then ContinueLoop
Local $xQueue = 829
For $j = 0 To 10
$xQueue -= 70.5 * $j
If _ColorCheck(_GetPixelColor($xQueue, 186, True), Hex(0xD7AFA9, 6), 20) Then
ExitLoop
ElseIf _ColorCheck(_GetPixelColor($xQueue, 196, True), Hex(0xD0D0C8, 6), 20) Then
SetLog("2nd army is not prepared. Donate whatever exists in 1st army!!")
$abDonateQueueOnly[$i] = False
ContinueLoop 2
EndIf
Next
If $i = 0 Then
Local $aSearchResult = CheckQueueTroops(True, False, $xQueue + 10, True)
Else
Local $aSearchResult = CheckQueueSpells(True, False, $xQueue + 6, True)
EndIf
If Not IsArray($aSearchResult) Then ContinueLoop
For $j = 0 To(UBound($aSearchResult) - 1)
Local $TroopIndex = TroopIndexLookup($aSearchResult[$j][0], "IsDonateQueueOnly()")
If $TroopIndex < 0 Then ContinueLoop
If _ColorCheck(_GetPixelColor($xQueue - $j * 70.5, 237, True), Hex(0xB9B747, 6), 20) Then
If $i = 0 Then
If _ArrayIndexValid($g_aiAvailQueuedTroop, $TroopIndex) Then
$g_aiAvailQueuedTroop[$TroopIndex] += $aSearchResult[$j][1]
SetLog("  - " & $g_asTroopNames[$TroopIndex] & " x" & $aSearchResult[$j][1])
EndIf
Else
If _ArrayIndexValid($g_aiAvailQueuedSpell, $TroopIndex - $eLSpell) Then
$g_aiAvailQueuedSpell[$TroopIndex - $eLSpell] += $aSearchResult[$j][1]
SetLog("  - " & $g_asSpellNames[$TroopIndex - $eLSpell] & " x" & $aSearchResult[$j][1])
EndIf
EndIf
ElseIf $j = 0 Or($j = 1 And $aSearchResult[1][0] = $aSearchResult[0][0]) Then
If $i = 0 Then
If _ArrayIndexValid($g_aiAvailQueuedTroop, $TroopIndex) Then
$g_aiAvailQueuedTroop[$TroopIndex] += $aSearchResult[$j][1]
SetLog("  - " & $g_asTroopNames[$TroopIndex] & " x" & $aSearchResult[$j][1] & " (training)")
EndIf
Else
If _ArrayIndexValid($g_aiAvailQueuedSpell, $TroopIndex - $eLSpell) Then
$g_aiAvailQueuedSpell[$TroopIndex - $eLSpell] += $aSearchResult[$j][1]
SetLog("  - " & $g_asSpellNames[$TroopIndex - $eLSpell] & " x" & $aSearchResult[$j][1] & " (training)")
EndIf
EndIf
ExitLoop
ElseIf $j >= 2 Then
ExitLoop
EndIf
Next
If _Sleep(250) Then ContinueLoop
EndIf
Next
ClickP($aAway, 1, 0, "#0818")
If _Sleep($DELAYDONATECC2) Then Return
EndFunc
Func DonateCC($bCheckForNewMsg = False)
Local $bDonateTroop =($g_aiPrepDon[0] = 1)
Local $bDonateAllTroop =($g_aiPrepDon[1] = 1)
Local $bDonateSpell =($g_aiPrepDon[2] = 1)
Local $bDonateAllSpell =($g_aiPrepDon[3] = 1)
Local $bDonateSiege =($g_aiPrepDon[4] = 1)
Local $bDonateAllSiege =($g_aiPrepDon[5] = 1)
Local $bDonate =($g_iActiveDonate = 1)
Local $bOpen = True, $bClose = False
Local $ClanString = ""
If Not $bDonate Or Not $g_bDonationEnabled Then
If $g_bDebugSetlog Then SetDebugLog("Donate Clan Castle troops skip", $COLOR_DEBUG)
Return
EndIf
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abDonateHours[$hour[0]] And $g_bDonateHoursEnable Then
If $g_bDebugSetlog Then SetDebugLog("Donate Clan Castle troops not planned, Skipped..", $COLOR_DEBUG)
Return
EndIf
Local $y = 90
If $bCheckForNewMsg Then
If Not _ColorCheck(_GetPixelColor(26, 312 + $g_iMidOffsetY, True), Hex(0xf00810, 6), 20) Then Return
EndIf
Local $abDonateQueueOnly = $g_abChkDonateQueueOnly
IsDonateQueueOnly($abDonateQueueOnly)
If $abDonateQueueOnly[0] And _ArrayMax($g_aiAvailQueuedTroop) = 0 Then
SetLog("Failed to read queue, skip donating troops")
$bDonateTroop = False
$bDonateAllTroop = False
EndIf
If $abDonateQueueOnly[1] And _ArrayMax($g_aiAvailQueuedSpell) = 0 Then
SetLog("Failed to read queue, skip donating spells")
$bDonateSpell = False
$bDonateAllSpell = False
EndIf
$bDonate = BitOR($bDonateTroop, $bDonateAllTroop, $bDonateSpell, $bDonateAllSpell, $bDonateSiege, $bDonateAllSiege)
If Not $bDonate Then Return
ClickP($aAway, 1, 0, "#0167")
ForceCaptureRegion()
If Not _CheckPixel($aChatTab, $g_bCapturePixel) Or Not _CheckPixel($aChatTab2, $g_bCapturePixel) Or Not _CheckPixel($aChatTab3, $g_bCapturePixel) Then ClickP($aOpenChat, 1, 0, "#0168")
If _Sleep($DELAYDONATECC4) Then Return
Local $iLoopCount = 0
While 1
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x706C50, 6), 20) Then
ExitLoop
EndIf
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x383828, 6), 20) Then
If _Sleep($DELAYDONATECC1) Then Return
ClickP($aClanTab, 1, 0, "#0169")
ExitLoop
EndIf
$iLoopCount += 1
If $iLoopCount >= 15 Then
SetLog("Clan Chat Did Not Open - Abandon Donate")
AndroidPageError("DonateCC")
Return
EndIf
If _Sleep($DELAYDONATECC1) Then Return
WEnd
Local $aCoord = decodeSingleCoord(findImage("I Understand", $g_sImgChatIUnterstand, GetDiamondFromRect("50,400,280,550")))
If UBound($aCoord) > 1 Then
SetLog("Clicking 'I Understand' button", $COLOR_ACTION)
ClickP($aCoord)
If _Sleep($DELAYDONATECC2) Then Return
EndIf
Local $Scroll
While 1
ForceCaptureRegion()
$y = 90
$Scroll = _PixelSearch(293, 8 + $y, 295, 23 + $y, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) And _ColorCheck(_GetPixelColor(300, 110, True), Hex(0x509808, 6), 20) Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 90
If _Sleep($DELAYDONATECC2 + 100) Then ExitLoop
ContinueLoop
EndIf
ExitLoop
WEnd
If $g_iCommandStop <> 0 And $g_iCommandStop <> 3 Then SetLog("Checking for Donate Requests in Clan Chat", $COLOR_INFO)
Local $itime = TimerInit()
Local $iBenchmark
Local $Buttons = 0
While $bDonate
checkAttackDisable($g_iTaBChkIdle)
$ClanString = ""
$itime = TimerInit()
If _Sleep($DELAYDONATECC2) Then ExitLoop
ForceCaptureRegion()
$g_aiDonatePixel = _MultiPixelSearch(200, $y, 230, 660 + $g_iBottomOffsetY, -2, 1, Hex(0x6da725, 6), $aChatDonateBtnColors, 20)
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get all Buttons in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If IsArray($g_aiDonatePixel) Then
$Buttons += 1
If $g_bDebugSetlog Then SetDebugLog("***** Donate Request Number " & $Buttons & " *****", $COLOR_ACTION)
If $g_bDebugSetlog Then SetDebugLog("$g_aiDonatePixel: (" & $g_aiDonatePixel[0] & "," & $g_aiDonatePixel[1] & ")", $COLOR_DEBUG)
If Not donateCCWBLUserImageCollect($g_aiDonatePixel[0], $g_aiDonatePixel[1]) Then
SetLog("Skip Donation at this Clan Mate...", $COLOR_ACTION)
$y = $g_aiDonatePixel[1] + 50
ContinueLoop
EndIf
$bDonate = False
$g_bSkipDonTroops = False
$g_bSkipDonSpells = False
$g_bSkipDonSiege = False
If $bDonateTroop Or $bDonateSpell Or $bDonateSiege Then
Local $Alphabets[4] = [$g_bChkExtraAlphabets, $g_bChkExtraChinese, $g_bChkExtraKorean, $g_bChkExtraPersian]
Local $Yaxis[4] = [50, 26, 26, 31]
Local $TextAlphabetsNames[4] = ["Cyrillic and Latin", "Chinese", "Korean", "Persian"]
Local $AlphabetFunctions[4] = ["getChatString", "getChatStringChinese", "getChatStringKorean", "getChatStringPersian"]
Local $BlankSpaces = ""
For $i = 0 To UBound($Alphabets) - 1
If $i = 0 Then
Local $coordinates[3] = [50, 36, 23]
Local $OcrName =($Alphabets[$i] = True) ?("coc-latin-cyr") :("coc-latinA")
Local $log = "Latin"
If $Alphabets[$i] Then $log = $TextAlphabetsNames[$i]
$ClanString = ""
SetLog("Using OCR to read " & $log & " derived alphabets.", $COLOR_ACTION)
For $j = 0 To 2
If $ClanString = "" Or $ClanString = " " Then
$ClanString &= $BlankSpaces & getChatString(30, $g_aiDonatePixel[1] - $coordinates[$j], $OcrName)
If $g_bDebugSetlog Then SetDebugLog("$OcrName: " & $OcrName)
If $g_bDebugSetlog Then SetDebugLog("$coordinates: " & $coordinates[$j])
If $g_bDebugSetlog Then SetDebugLog("$ClanString: " & $ClanString)
If $ClanString <> "" And $ClanString <> " " Then ExitLoop
EndIf
If $ClanString <> "" Then $BlankSpaces = " "
Next
Else
If $Alphabets[$i] Then
If $ClanString = "" Or $ClanString = " " Then
SetLog("Using OCR to read " & $TextAlphabetsNames[$i] & " alphabets.", $COLOR_ACTION)
#Au3Stripper_Off
$ClanString &= $BlankSpaces & Call($AlphabetFunctions[$i], 30, $g_aiDonatePixel[1] - $Yaxis[$i])
#Au3Stripper_On
If @error = 0xDEAD And @extended = 0xBEEF Then SetLog("[DonatCC] Function " & $AlphabetFunctions[$i] & "() had a problem.")
If $g_bDebugSetlog Then SetDebugLog("$OcrName: " & $OcrName)
If $g_bDebugSetlog Then SetDebugLog("$Yaxis: " & $Yaxis[$i])
If $g_bDebugSetlog Then SetDebugLog("$ClanString: " & $ClanString)
If $ClanString <> "" And $ClanString <> " " Then ExitLoop
EndIf
EndIf
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Request OCR in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If $ClanString = "" Or $ClanString = " " Then
SetLog("Unable to read Chat Request!", $COLOR_ERROR)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
ContinueLoop
Else
If $g_bChkExtraAlphabets Then
ClipPut($ClanString)
Local $tempClip = ClipGet()
SetLog("Chat Request: " & $tempClip)
Else
SetLog("Chat Request: " & $ClanString)
EndIf
If Not $bDonateAllTroop And Not $bDonateAllSpell And Not $bDonateAllSiege Then
Local $Checked = False
For $i = 0 To UBound($g_abChkDonateTroop) - 1
If $g_abChkDonateTroop[$i] Then
If $i < $eTroopCount + $g_iCustomDonateConfigs Then
If $g_bDebugSetlog Then SetDebugLog("Troop: [" & $i & "] checking!", $COLOR_DEBUG)
If CheckDonateTroop($i >= $eTroopCount ? 99 : $i, $g_asTxtDonateTroop[$i], $g_asTxtBlacklistTroop[$i], $ClanString) Then $Checked = True
Else
If $g_bDebugSetlog Then SetDebugLog("Siege: [" & $i - $eTroopCount - $g_iCustomDonateConfigs & "] checking!", $COLOR_DEBUG)
If CheckDonateSiege($i - $eTroopCount - $g_iCustomDonateConfigs, $g_asTxtDonateTroop[$i], $g_asTxtBlacklistTroop[$i], $ClanString) Then $Checked = True
EndIf
EndIf
If $Checked = False And $i < UBound($g_abChkDonateSpell) And $g_abChkDonateSpell[$i] And CheckDonateSpell($i, $g_asTxtDonateSpell[$i], $g_asTxtBlacklistSpell[$i], $ClanString) Then $Checked = True
If $Checked Then ExitLoop
Next
If $Checked = False Then
SetDebugLog("Chat Request does not match any donate keyword, go to next request")
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
ContinueLoop
EndIf
SetDebugLog("Chat Request matches a donate keyword, proceed with donating")
EndIf
EndIf
ElseIf $bDonateAllTroop Or $bDonateAllSpell Or $bDonateAllSiege Then
SetLog("Skip reading chat requests. Donate all is enabled!", $COLOR_ACTION)
EndIf
RemainingCCcapacity()
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get remaining CC capacity in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If $g_iTotalDonateTroopCapacity <= 0 Then
SetLog("Clan Castle troops are full, skip troop donation...", $COLOR_ACTION)
$g_bSkipDonTroops = True
EndIf
If $g_iCurrentSpells = 0 And $g_iCurrentSpells <> "" Then
SetLog("No spells available, skip spell donation...", $COLOR_ORANGE)
$g_bSkipDonSpells = True
ElseIf $g_iTotalDonateSpellCapacity = 0 Then
SetLog("Clan Castle spells are full, skip spell donation...", $COLOR_ACTION)
$g_bSkipDonSpells = True
ElseIf $g_iTotalDonateSpellCapacity = -1 Then
If $g_bDebugSetlog Then SetDebugLog("This CC cannot accept spells, skip spell donation...", $COLOR_DEBUG)
$g_bSkipDonSpells = True
EndIf
If Not $bDonateSiege And Not $bDonateAllSiege Then
SetLog("Siege donation is not enabled, skip siege donation...", $COLOR_ACTION)
$g_bSkipDonSiege = True
ElseIf $g_aiCurrentSiegeMachines[$eSiegeWallWrecker] = 0 And $g_aiCurrentSiegeMachines[$eSiegeBattleBlimp] = 0 And $g_aiCurrentSiegeMachines[$eSiegeStoneSlammer] = 0 Then
SetLog("No siege machines available, skip siege donation...", $COLOR_ORANGE)
$g_bSkipDonSiege = True
ElseIf $g_iTotalDonateSiegeMachineCapacity = -1 Then
SetLog("This CC cannot accept Siege, skip Siege donation...", $COLOR_ACTION)
$g_bSkipDonSiege = True
ElseIf $g_iTotalDonateSiegeMachineCapacity = 0 Then
SetLog("Clan Castle Siege is full, skip Siege donation...", $COLOR_ACTION)
$g_bSkipDonSiege = True
EndIf
If $g_bSkipDonTroops And $g_bSkipDonSpells And $g_bSkipDonSiege Then
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
ContinueLoop
EndIf
If _Sleep($DELAYDONATECC3) Then Return
If Not DonateWindow($bOpen) Then
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
SetLog("Donate Window did not open - Exiting Donate", $COLOR_ERROR)
ExitLoop
EndIf
Local $eCustom[4] = [$eCustomA, $eCustomB, $eCustomC, $eCustomD]
Local $eDonateCustom[4] = [$g_aiDonateCustomTrpNumA, $g_aiDonateCustomTrpNumB, $g_aiDonateCustomTrpNumC, $g_aiDonateCustomTrpNumD]
If $bDonateTroop Or $bDonateSpell Or $bDonateSiege Then
If $g_bDebugSetlog Then SetDebugLog("Troop/Spell/Siege checkpoint.", $COLOR_DEBUG)
DonateWindowCap($g_bSkipDonTroops, $g_bSkipDonSpells)
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get available donate cap in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If $g_bSkipDonTroops And $g_bSkipDonSpells And $g_bSkipDonSiege Then
DonateWindow($bClose)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
EndIf
If $bDonateTroop And Not $g_bSkipDonTroops Then
If $g_bDebugSetlog Then SetDebugLog("Troop checkpoint.", $COLOR_DEBUG)
For $x = 0 To UBound($eDonateCustom) - 1
If $g_abChkDonateTroop[$eCustom[$x]] And CheckDonateTroop(99, $g_asTxtDonateTroop[$eCustom[$x]], $g_asTxtBlacklistTroop[$eCustom[$x]], $ClanString) Then
Local $CorrectDonateCustom = $eDonateCustom[$x]
For $i = 0 To 2
If $CorrectDonateCustom[$i][0] < $eBarb Then
$CorrectDonateCustom[$i][0] = $eArch
ElseIf $CorrectDonateCustom[$i][0] > $eIceG Then
ContinueLoop
EndIf
If $CorrectDonateCustom[$i][1] < 1 Then
ContinueLoop
ElseIf $CorrectDonateCustom[$i][1] > 8 Then
$CorrectDonateCustom[$i][1] = 8
EndIf
DonateTroopType($CorrectDonateCustom[$i][0], $CorrectDonateCustom[$i][1], $abDonateQueueOnly[0])
If _Sleep($DELAYDONATECC3) Then ExitLoop
Next
EndIf
Next
If Not $g_bSkipDonTroops Then
For $i = 0 To UBound($g_aiDonateTroopPriority) - 1
Local $iTroopIndex = $g_aiDonateTroopPriority[$i]
If $g_abChkDonateTroop[$iTroopIndex] Then
If CheckDonateTroop($iTroopIndex, $g_asTxtDonateTroop[$iTroopIndex], $g_asTxtBlacklistTroop[$iTroopIndex], $ClanString) Then
DonateTroopType($iTroopIndex, 0, $abDonateQueueOnly[0])
If _Sleep($DELAYDONATECC3) Then ExitLoop
EndIf
EndIf
Next
EndIf
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated troops in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
If Not $g_bSkipDonSiege And $bDonateSiege Then
If $g_bDebugSetlog Then SetDebugLog("Siege checkpoint.", $COLOR_DEBUG)
For $SiegeIndex = $eSiegeWallWrecker To $eSiegeMachineCount - 1
Local $index = $eTroopCount + $g_iCustomDonateConfigs + $SiegeIndex
If $g_abChkDonateTroop[$index] Then
If CheckDonateSiege($SiegeIndex, $g_asTxtDonateTroop[$index], $g_asTxtBlacklistTroop[$index], $ClanString) Then
DonateSiegeType($SiegeIndex)
EndIf
EndIf
Next
EndIf
If $bDonateSpell And Not $g_bSkipDonSpells Then
If $g_bDebugSetlog Then SetDebugLog("Spell checkpoint.", $COLOR_DEBUG)
For $i = 0 To UBound($g_aiDonateSpellPriority) - 1
Local $iSpellIndex = $g_aiDonateSpellPriority[$i]
If $g_abChkDonateSpell[$iSpellIndex] Then
If CheckDonateSpell($iSpellIndex, $g_asTxtDonateSpell[$iSpellIndex], $g_asTxtBlacklistSpell[$iSpellIndex], $ClanString) Then
DonateSpellType($iSpellIndex, $abDonateQueueOnly[1])
If _Sleep($DELAYDONATECC3) Then ExitLoop
EndIf
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated Spells in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
EndIf
If $bDonateAllTroop Or $bDonateAllSpell Or $bDonateAllSiege Then
If $g_bDebugSetlog Then SetDebugLog("Troop/Spell/Siege All checkpoint.", $COLOR_DEBUG)
$g_bDonateAllRespectBlk = True
If $bDonateAllTroop And Not $g_bSkipDonTroops Then
DonateWindowCap($g_bSkipDonTroops, $g_bSkipDonSpells)
$iBenchmark = TimerDiff($itime)
Setlog("Get available donate cap (to all) in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
If $g_bSkipDonTroops And $g_bSkipDonSpells Then
DonateWindow($bClose)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
EndIf
If $g_bDebugSetlog Then SetDebugLog("Troop All checkpoint.", $COLOR_DEBUG)
For $x = 0 To 4
If $x <> 4 Then
If $g_abChkDonateAllTroop[$eCustom[$x]] Then
Local $CorrectDonateCustom = $eDonateCustom[$x]
For $i = 0 To 2
If $CorrectDonateCustom[$i][0] < $eBarb Then
$CorrectDonateCustom[$i][0] = $eArch
ElseIf $CorrectDonateCustom[$i][0] > $eIceG Then
DonateWindow($bClose)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
EndIf
If $CorrectDonateCustom[$i][1] < 1 Then
DonateWindow($bClose)
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
ElseIf $CorrectDonateCustom[$i][1] > 8 Then
$CorrectDonateCustom[$i][1] = 8
EndIf
DonateTroopType($CorrectDonateCustom[$i][0], $CorrectDonateCustom[$i][1], $abDonateQueueOnly[0], $bDonateAllTroop)
Next
EndIf
Else
For $i = 0 To UBound($g_aiDonateTroopPriority) - 1
Local $iTroopIndex = $g_aiDonateTroopPriority[$i]
If $g_abChkDonateAllTroop[$iTroopIndex] Then
If CheckDonateTroop($iTroopIndex, $g_asTxtDonateTroop[$iTroopIndex], $g_asTxtBlacklistTroop[$iTroopIndex], $ClanString) Then
DonateTroopType($iTroopIndex, 0, $abDonateQueueOnly[0], $bDonateAllTroop)
EndIf
ExitLoop
EndIf
Next
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated troops (to all) in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
If $bDonateAllSpell And Not $g_bSkipDonSpells Then
If $g_bDebugSetlog Then SetDebugLog("Spell All checkpoint.", $COLOR_DEBUG)
For $i = 0 To UBound($g_aiDonateSpellPriority) - 1
Local $iSpellIndex = $g_aiDonateSpellPriority[$i]
If $g_abChkDonateAllSpell[$iSpellIndex] Then
If CheckDonateSpell($iSpellIndex, $g_asTxtDonateSpell[$iSpellIndex], $g_asTxtBlacklistSpell[$iSpellIndex], $ClanString) Then
DonateSpellType($iSpellIndex, $abDonateQueueOnly[1], $bDonateAllSpell)
EndIf
ExitLoop
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated Spells (to all)  in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
If $bDonateAllSiege And Not $g_bSkipDonSiege Then
If $g_bDebugSetlog Then SetDebugLog("Siege All checkpoint.", $COLOR_DEBUG)
For $SiegeIndex = $eSiegeWallWrecker To $eSiegeMachineCount - 1
Local $Index = $eTroopCount + $g_iCustomDonateConfigs + $SiegeIndex
If $g_abChkDonateAllTroop[$Index] Then
If CheckDonateSiege($SiegeIndex, $g_asTxtDonateTroop[$Index], $g_asTxtBlacklistTroop[$Index], $ClanString) Then
DonateSiegeType($SiegeIndex, True)
EndIf
ExitLoop
EndIf
Next
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get Donated Sieges (to all)  in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
$itime = TimerInit()
EndIf
$g_bDonateAllRespectBlk = False
EndIf
$bDonate = True
$y = $g_aiDonatePixel[1] + 50
ClickP($aAway, 1, 0, "#0171")
If _Sleep($DELAYDONATEWINDOW1) Then ExitLoop
EndIf
ForceCaptureRegion()
$g_aiDonatePixel = _MultiPixelSearch(200, $y, 230, 660 + $g_iBottomOffsetY, -2, 1, Hex(0x6da725, 6), $aChatDonateBtnColors, 20)
$iBenchmark = TimerDiff($itime)
If $g_bDebugSetlog Then SetDebugLog("Get more donate buttons in " & StringFormat("%.2f", $iBenchmark) & "'ms", $COLOR_DEBUG)
If IsArray($g_aiDonatePixel) Then
If $g_bDebugSetlog Then SetDebugLog("More Donate buttons found, new $g_aiDonatePixel: (" & $g_aiDonatePixel[0] & "," & $g_aiDonatePixel[1] & ")", $COLOR_DEBUG)
ContinueLoop
Else
If $g_bDebugSetlog Then SetDebugLog("No more Donate buttons found, closing chat ($y=" & $y & ")", $COLOR_DEBUG)
EndIf
ForceCaptureRegion()
$Scroll = _PixelSearch(293, 687 - 30, 295, 693 - 30, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 600
If _Sleep($DELAYDONATECC2) Then ExitLoop
ContinueLoop
EndIf
$bDonate = False
WEnd
ClickP($aAway, 1, 0, "#0176")
If _Sleep($DELAYDONATECC2) Then Return
$i = 0
While 1
If _Sleep(100) Then Return
If _ColorCheck(_GetPixelColor($aCloseChat[0], $aCloseChat[1], True), Hex($aCloseChat[2], 6), $aCloseChat[3]) Then
Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0173")
ExitLoop
Else
If _Sleep(100) Then Return
$i += 1
If $i > 30 Then
SetLog("Error finding Clan Tab to close...", $COLOR_ERROR)
AndroidPageError("DonateCC")
ExitLoop
EndIf
EndIf
WEnd
UpdateStats()
If _Sleep($DELAYDONATECC2) Then Return
EndFunc
Func CheckDonateTroop(Const $iTroopIndex, Const $sDonateTroopString, Const $sBlacklistTroopString, Const $sClanString)
Local $sName =($iTroopIndex = 99 ? "Custom" : $g_asTroopNames[$iTroopIndex])
Return CheckDonate($sName, $sDonateTroopString, $sBlacklistTroopString, $sClanString)
EndFunc
Func CheckDonateSpell(Const $iSpellIndex, Const $sDonateSpellString, Const $sBlacklistSpellString, Const $sClanString)
Local $sName = $g_asSpellNames[$iSpellIndex]
Return CheckDonate($sName, $sDonateSpellString, $sBlacklistSpellString, $sClanString)
EndFunc
Func CheckDonateSiege(Const $iSiegeIndex, Const $sDonateSpellString, Const $sBlacklistSpellString, Const $sClanString)
Local $sName = $g_asSiegeMachineNames[$iSiegeIndex]
Return CheckDonate($sName, $sDonateSpellString, $sBlacklistSpellString, $sClanString)
EndFunc
Func CheckDonate(Const $sName, Const $sDonateString, Const $sBlacklistString, Const $sClanString)
Local $asSplitDonate = StringSplit($sDonateString, @CRLF, $STR_ENTIRESPLIT)
Local $asSplitBlacklist = StringSplit($sBlacklistString, @CRLF, $STR_ENTIRESPLIT)
Local $asSplitGeneralBlacklist = StringSplit($g_sTxtGeneralBlacklist, @CRLF, $STR_ENTIRESPLIT)
For $i = 1 To UBound($asSplitGeneralBlacklist) - 1
If CheckDonateString($asSplitGeneralBlacklist[$i], $sClanString) Then
SetLog("General Blacklist Keyword found: " & $asSplitGeneralBlacklist[$i], $COLOR_ERROR)
Return False
EndIf
Next
For $i = 1 To UBound($asSplitBlacklist) - 1
If CheckDonateString($asSplitBlacklist[$i], $sClanString) Then
SetLog($sName & " Blacklist Keyword found: " & $asSplitBlacklist[$i], $COLOR_ERROR)
Return False
EndIf
Next
If Not $g_bDonateAllRespectBlk Then
For $i = 1 To UBound($asSplitDonate) - 1
If CheckDonateString($asSplitDonate[$i], $sClanString) Then
SetLog($sName & " Keyword found: " & $asSplitDonate[$i], $COLOR_SUCCESS)
Return True
EndIf
Next
EndIf
If $g_bDonateAllRespectBlk Then Return True
If $g_bDebugSetlog Then SetDebugLog("Bad call of CheckDonateTroop: " & $sName, $COLOR_DEBUG)
Return False
EndFunc
Func CheckDonateString($String, $ClanString)
Local $Contains = StringMid($String, 1, 1) & StringMid($String, StringLen($String), 1)
If $Contains = "[]" Then
If $ClanString = StringMid($String, 2, StringLen($String) - 2) Then
Return True
Else
Return False
EndIf
Else
If StringInStr($ClanString, $String, 2) Then
Return True
Else
Return False
EndIf
EndIf
EndFunc
Func DonateTroopType(Const $iTroopIndex, $Quant = 0, Const $bDonateQueueOnly = False, Const $bDonateAll = False)
Local $Slot = -1, $detectedSlot = -1
Local $YComp = 0, $donaterow = -1
Local $donateposinrow = -1
Local $sTextToAll = ""
If $g_iTotalDonateTroopCapacity = 0 Then Return
If $g_bDebugSetlog Then SetDebugLog("$DonateTroopType Start: " & $g_asTroopNames[$iTroopIndex], $COLOR_DEBUG)
$g_iDonTroopsQuantityAv = Floor($g_iTotalDonateTroopCapacity / $g_aiTroopSpace[$iTroopIndex])
If $g_iDonTroopsQuantityAv < 1 Then
SetLog("Sorry Chief! " & $g_asTroopNamesPlural[$iTroopIndex] & " don't fit in the remaining space!")
Return
EndIf
If $Quant = 0 Or $Quant > _Min(Number($g_iDonTroopsQuantityAv), Number($g_iDonTroopsLimit)) Then $Quant = _Min(Number($g_iDonTroopsQuantityAv), Number($g_iDonTroopsLimit))
If $bDonateQueueOnly Then
If $g_aiAvailQueuedTroop[$iTroopIndex] <= 0 Then
SetLog("Sorry Chief! " & $g_asTroopNames[$iTroopIndex] & " is not ready in queue for donation!")
Return
ElseIf $g_aiAvailQueuedTroop[$iTroopIndex] < $Quant Then
SetLog("Queue available for donation: " & $g_aiAvailQueuedTroop[$iTroopIndex] & "x " & $g_asTroopNames[$iTroopIndex])
$Quant = $g_aiAvailQueuedTroop[$iTroopIndex]
EndIf
EndIf
If $g_bDebugOCRdonate Then
Local $oldDebugOcr = $g_bDebugOcr
$g_bDebugOcr = True
EndIf
$Slot = DetectSlotTroop($iTroopIndex)
$detectedSlot = $Slot
If $g_bDebugOCRdonate Then $g_bDebugOcr = $oldDebugOcr
If $Slot = -1 Then Return
If $Slot < 0 Or $Slot > 13 Then
SetLog("Invalid slot # found = " & $Slot & " for " & $g_asTroopNames[$iTroopIndex], $COLOR_ERROR)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("slot found = " & $Slot & ", " & $g_asTroopNames[$iTroopIndex], $COLOR_DEBUG)
$donaterow = 1
$donateposinrow = $Slot
If $Slot >= 7 And $Slot <= 13 Then
$donaterow = 2
$Slot = $Slot - 7
$donateposinrow = $Slot
$YComp = 88
EndIf
SetLog("Troops Condition Matched", $COLOR_ORANGE)
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
If $bDonateAll Then $sTextToAll = " (to all requests)"
SetLog("Donating " & $Quant & " " &($Quant > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]) & $sTextToAll, $COLOR_SUCCESS)
If $g_bDebugOCRdonate Then
SetLog("donate", $COLOR_ERROR)
SetLog("row: " & $donaterow, $COLOR_ERROR)
SetLog("pos in row: " & $donateposinrow, $COLOR_ERROR)
SetLog("coordinate: " & 365 +($Slot * 68) & "," & $g_iDonationWindowY + 100 + $YComp, $COLOR_ERROR)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asTroopNames[$iTroopIndex] & "_")
EndIf
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $g_iDonationWindowY + 100 + $YComp, $Quant, $DELAYDONATECC3, "#0175")
$g_aiDonateStatsTroops[$iTroopIndex][0] += $Quant
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$g_bFullArmy = False
EndIf
EndIf
If $iTroopIndex >= $eTroopBarbarian And $iTroopIndex <= $eTroopIceGolem Then
$g_iTotalDonateTroopCapacity -=($Quant * $g_aiTroopSpace[$iTroopIndex])
If $g_iDonTroopsLimit = $Quant Then
$g_bSkipDonTroops = True
EndIf
EndIf
$g_aiDonateTroops[$iTroopIndex] += $Quant
If $bDonateQueueOnly Then $g_aiAvailQueuedTroop[$iTroopIndex] -= $Quant
Else
Local $Text = "Unable to donate " &($g_iDonTroopsQuantity > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]) & ".Donate screen not visible, will retry next run.", $LocalColor = $COLOR_ERROR
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x5e5e5e, 6), 10) Or  _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0xdadad5, 6), 10) Then
$Text = "No " &($g_iDonTroopsQuantity > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]) & " available to donate.."
$LocalColor = $COLOR_INFO
EndIf
SetLog($Text, $LocalColor)
EndIf
EndFunc
Func DonateSpellType(Const $iSpellIndex, Const $bDonateQueueOnly = False, Const $bDonateAll = False)
Local $Slot = -1, $detectedSlot = -1
Local $YComp = 0, $donaterow = -1
Local $donateposinrow = -1
If $g_iTotalDonateSpellCapacity = 0 Then Return
If $g_bDebugSetlog Then SetDebugLog("DonateSpellType Start: " & $g_asSpellNames[$iSpellIndex], $COLOR_DEBUG)
$g_iDonSpellsQuantityAv = Floor($g_iTotalDonateSpellCapacity / $g_aiSpellSpace[$iSpellIndex])
If $g_iDonSpellsQuantityAv < 1 Then
SetLog("Sorry Chief! " & $g_asSpellNames[$iSpellIndex] & " spells don't fit in the remaining space!")
Return
EndIf
If $g_iDonSpellsQuantityAv >= $iDonSpellsLimit Then
$g_iDonSpellsQuantity = $iDonSpellsLimit
Else
$g_iDonSpellsQuantity = $g_iDonSpellsQuantityAv
EndIf
If $bDonateQueueOnly And $g_aiAvailQueuedSpell[$iSpellIndex] = 0 Then
SetLog("Sorry Chief! " & $g_asSpellNames[$iSpellIndex] & " is not ready in queue for donation!")
Return
EndIf
If $g_bDebugOCRdonate Then
Local $oldDebugOcr = $g_bDebugOcr
$g_bDebugOcr = True
EndIf
$Slot = DetectSlotSpell($iSpellIndex)
$detectedSlot = $Slot
If $g_bDebugSetlog Then SetDebugLog("slot found = " & $Slot, $COLOR_DEBUG)
If $g_bDebugOCRdonate Then $g_bDebugOcr = $oldDebugOcr
If $Slot = -1 Then Return
If $Slot < 14 Or $Slot > 20 Then
SetLog("Invalid slot # found = " & $Slot & " for " & $g_asSpellNames[$iSpellIndex], $COLOR_ERROR)
Return
EndIf
$donaterow = 3
$Slot = $Slot - 14
$donateposinrow = $Slot
$YComp = 203
SetLog("Spells Condition Matched", $COLOR_ORANGE)
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x6038B0, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x6038B0, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x6038B0, 6), 20) Then
If $g_bDebugOCRdonate Then
SetLog("donate", $COLOR_ERROR)
SetLog("row: " & $donaterow, $COLOR_ERROR)
SetLog("pos in row: " & $donateposinrow, $COLOR_ERROR)
SetLog("coordinate: " & 365 +($Slot * 68) & "," & $g_iDonationWindowY + 100 + $YComp, $COLOR_ERROR)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asSpellNames[$iSpellIndex] & "_")
EndIf
If Not $g_bDebugOCRdonate Then
Click(365 +($Slot * 68), $g_iDonationWindowY + 100 + $YComp, $g_iDonSpellsQuantity, $DELAYDONATECC3, "#0600")
$g_bFullArmySpells = False
$g_bFullArmy = False
$g_aiDonateSpells[$iSpellIndex] += 1
If $bDonateQueueOnly Then $g_aiAvailQueuedTroop[$iSpellIndex] -= 1
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$g_bFullArmySpells = False
EndIf
$g_aiDonateStatsSpells[$iSpellIndex][0] += $g_iDonSpellsQuantity
EndIf
SetLog("Donating " & $g_iDonSpellsQuantity & " " & $g_asSpellNames[$iSpellIndex] & " Spell.", $COLOR_GREEN)
Else
Local $Text = "Unable to donate " & $g_asSpellNames[$iSpellIndex] & ".Donate screen not visible, will retry next run.", $LocalColor = $COLOR_ERROR
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x5e5e5e, 6), 10) Or  _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0xdadad5, 6), 10) Then
$Text = "No " & $g_asSpellNames[$iSpellIndex] & " available to donate.."
$LocalColor = $COLOR_INFO
EndIf
SetLog($Text, $LocalColor)
EndIf
EndFunc
Func DonateSiegeType(Const $iSiegeIndex, $bDonateAll = False)
Local $Slot = -1, $detectedSlot = -1
Local $YComp = 0, $donaterow = -1
Local $donateposinrow = -1
If $g_iTotalDonateSiegeMachineCapacity < 1 Then Return
If $g_bDebugSetlog Then SetDebugLog("DonateSiegeType Start: " & $g_asSiegeMachineNames[$iSiegeIndex], $COLOR_DEBUG)
$Slot = DetectSlotSiege($iSiegeIndex)
If $Slot = -1 Then
SetLog("No " & $g_asSiegeMachineNames[$iSiegeIndex] & " available to donate..", $COLOR_ERROR)
Return
EndIf
If $Slot < 0 Or $Slot > 13 Then
SetLog("Invalid slot # found = " & $Slot & " for " & $g_asSiegeMachineNames[$iSiegeIndex], $COLOR_ERROR)
Return
EndIf
If $g_bDebugSetlog Then SetDebugLog("slot found = " & $Slot & ", " & $g_asSiegeMachineNames[$iSiegeIndex], $COLOR_DEBUG)
$donaterow = 1
$donateposinrow = $Slot
If $Slot >= 7 And $Slot <= 13 Then
$donaterow = 2
$Slot = $Slot - 7
$donateposinrow = $Slot
$YComp = 88
EndIf
If $g_bDebugOCRdonate Then
SetLog("donate", $COLOR_ERROR)
SetLog("row: " & $donaterow, $COLOR_ERROR)
SetLog("pos in row: " & $donateposinrow, $COLOR_ERROR)
SetLog("coordinate: " & 365 +($Slot * 68) & "," & $g_iDonationWindowY + 100 + $YComp, $COLOR_ERROR)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asSiegeMachineNames[$iSiegeIndex] & "_")
EndIf
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $g_iDonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $g_iDonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $g_iDonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $g_iDonationWindowY + 100 + $YComp, 1, $DELAYDONATECC3, "#0175")
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$g_bFullArmy = False
EndIf
SetLog("Donating 1 " &($g_asSiegeMachineNames[$iSiegeIndex]) &($bDonateAll ? " (to all requests)" : ""), $COLOR_GREEN)
$g_aiDonateSiegeMachines[$iSiegeIndex] += 1
$g_aiDonateStatsSieges[$iSiegeIndex][0] += 1
Else
SetLog("No " & $g_asSiegeMachineNames[$iSiegeIndex] & " available to donate..", $COLOR_ERROR)
EndIf
EndFunc
Func DonateWindow($bOpen = True)
If $g_bDebugSetlog And $bOpen Then SetLog("DonateWindow Open Start", $COLOR_DEBUG)
If $g_bDebugSetlog And Not $bOpen Then SetLog("DonateWindow Close Start", $COLOR_DEBUG)
If Not $bOpen Then
ClickP($aAway, 1, 0, "#0176")
If _Sleep($DELAYDONATEWINDOW1) Then Return
If $g_bDebugSetlog Then SetDebugLog("DonateWindow Close Exit", $COLOR_DEBUG)
Return
EndIf
Local $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $i
For $i = 0 To UBound($aChatDonateBtnColors) - 1
If $aChatDonateBtnColors[$i][1] < $iLeft Then $iLeft = $aChatDonateBtnColors[$i][1]
If $aChatDonateBtnColors[$i][1] > $iRight Then $iRight = $aChatDonateBtnColors[$i][1]
If $aChatDonateBtnColors[$i][2] < $iTop Then $iTop = $aChatDonateBtnColors[$i][2]
If $aChatDonateBtnColors[$i][2] > $iBottom Then $iBottom = $aChatDonateBtnColors[$i][2]
Next
$iLeft += $g_aiDonatePixel[0]
$iTop += $g_aiDonatePixel[1]
$iRight += $g_aiDonatePixel[0] + 1
$iBottom += $g_aiDonatePixel[1] + 1
ForceCaptureRegion()
Local $g_aiDonatePixelCheck = _MultiPixelSearch($iLeft, $iTop, $iRight, $iBottom, -2, 1, Hex(0x6da725, 6), $aChatDonateBtnColors, 20)
If IsArray($g_aiDonatePixelCheck) Then
Click($g_aiDonatePixel[0] + 50, $g_aiDonatePixel[1] + 10, 1, 0, "#0174")
Else
If $g_bDebugSetlog Then SetDebugLog("Could not find the Donate Button!", $COLOR_DEBUG)
Return False
EndIf
If _Sleep($DELAYDONATEWINDOW1) Then Return
Local $icount = 0
While Not(_ColorCheck(_GetPixelColor(331, $g_aiDonatePixel[1], True, "DonateWindow"), Hex(0xffffff, 6), 0))
If _Sleep($DELAYDONATEWINDOW2) Then Return
ForceCaptureRegion()
$icount += 1
If $icount = 20 Then ExitLoop
WEnd
$g_iDonationWindowY = 0
ForceCaptureRegion()
Local $aDonWinOffColors[1][3] = [[0xFFFFFF, 0, 2]]
Local $aDonationWindow = _MultiPixelSearch(628, 0, 630, $g_iDEFAULT_HEIGHT, 1, 1, Hex(0xFFFFFF, 6), $aDonWinOffColors, 10)
If IsArray($aDonationWindow) Then
$g_iDonationWindowY = $aDonationWindow[1]
If $g_bDebugSetlog Then SetDebugLog("$g_iDonationWindowY: " & $g_iDonationWindowY, $COLOR_DEBUG)
Else
SetLog("Could not find the Donate Window!", $COLOR_ERROR)
Return False
EndIf
If $g_bDebugSetlog Then SetDebugLog("DonateWindow Open Exit", $COLOR_DEBUG)
Return True
EndFunc
Func DonateWindowCap(ByRef $g_bSkipDonTroops, ByRef $g_bSkipDonSpells)
If $g_bDebugSetlog Then SetDebugLog("DonateCapWindow Start", $COLOR_DEBUG)
If Not $g_bSkipDonTroops Then
Local $sReadCCTroopsCap = getCastleDonateCap(427, $g_iDonationWindowY + 12)
If $g_bDebugSetlog Then SetDebugLog("$sReadCCTroopsCap: " & $sReadCCTroopsCap, $COLOR_DEBUG)
Local $aTempReadCCTroopsCap = StringSplit($sReadCCTroopsCap, "#")
If $aTempReadCCTroopsCap[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempReadCCTroopsCap splitted :" & $aTempReadCCTroopsCap[1] & "/" & $aTempReadCCTroopsCap[2], $COLOR_DEBUG)
If $aTempReadCCTroopsCap[2] > 0 Then
$g_iDonTroopsAv = $aTempReadCCTroopsCap[1]
$g_iDonTroopsLimit = $aTempReadCCTroopsCap[2]
EndIf
Else
SetLog("Error reading the Castle Troop Capacity", $COLOR_ERROR)
$g_iDonTroopsAv = 0
$g_iDonTroopsLimit = 0
EndIf
EndIf
If Not $g_bSkipDonSpells Then
Local $sReadCCSpellsCap = getCastleDonateCap(420, $g_iDonationWindowY + 218)
If $g_bDebugSetlog Then SetDebugLog("$sReadCCSpellsCap: " & $sReadCCSpellsCap, $COLOR_DEBUG)
Local $aTempReadCCSpellsCap = StringSplit($sReadCCSpellsCap, "#")
If $aTempReadCCSpellsCap[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempReadCCSpellsCap splitted :" & $aTempReadCCSpellsCap[1] & "/" & $aTempReadCCSpellsCap[2], $COLOR_DEBUG)
If $aTempReadCCSpellsCap[2] > 0 Then
$g_iDonSpellsAv = $aTempReadCCSpellsCap[1]
$iDonSpellsLimit = $aTempReadCCSpellsCap[2]
EndIf
Else
SetLog("Are you able to donate Spells? ", $COLOR_ERROR)
$g_iDonSpellsAv = 0
$iDonSpellsLimit = 0
EndIf
EndIf
If $g_iDonTroopsAv = $g_iDonTroopsLimit Then
$g_bSkipDonTroops = True
SetLog("Donate Troop Limit Reached")
EndIf
If $g_iDonSpellsAv = $iDonSpellsLimit Then
$g_bSkipDonSpells = True
SetLog("Donate Spell Limit Reached")
EndIf
If $g_bSkipDonTroops = True And $g_bSkipDonSpells = True And $g_iDonTroopsAv < $g_iDonTroopsLimit And $g_iDonSpellsAv < $iDonSpellsLimit Then
SetLog("Donate Troops: " & $g_iDonTroopsAv & "/" & $g_iDonTroopsLimit & ", Spells: " & $g_iDonSpellsAv & "/" & $iDonSpellsLimit)
EndIf
If Not $g_bSkipDonSpells And $g_iDonTroopsAv < $g_iDonTroopsLimit And $g_iDonSpellsAv = $iDonSpellsLimit Then SetLog("Donate Troops: " & $g_iDonTroopsAv & "/" & $g_iDonTroopsLimit)
If Not $g_bSkipDonTroops And $g_iDonTroopsAv = $g_iDonTroopsLimit And $g_iDonSpellsAv < $iDonSpellsLimit Then SetLog("Donate Spells: " & $g_iDonSpellsAv & "/" & $iDonSpellsLimit)
If $g_bDebugSetlog Then
SetDebugLog("$g_bSkipDonTroops: " & $g_bSkipDonTroops, $COLOR_DEBUG)
SetDebugLog("$g_bSkipDonSpells: " & $g_bSkipDonSpells, $COLOR_DEBUG)
SetDebugLog("DonateCapWindow End", $COLOR_DEBUG)
EndIf
EndFunc
Func RemainingCCcapacity()
Local $sCapTroops = "", $aTempCapTroops, $sCapSpells = "", $aTempCapSpells, $sCapSiegeMachine = "", $aTempCapSiegeMachine
Local $iDonatedTroops = 0, $iDonatedSpells = 0, $iDonatedSiegeMachine = 0
Local $iCapTroopsTotal = 0, $iCapSpellsTotal = 0, $iCapSiegeMachineTotal = 0
$g_iTotalDonateTroopCapacity = -1
$g_iTotalDonateSpellCapacity = -1
$g_iTotalDonateSiegeMachineCapacity = -1
Local $bDonateSpell =($g_aiPrepDon[2] = 1 Or $g_aiPrepDon[3] = 1) And($g_iCurrentSpells > 0 Or $g_iCurrentSpells = "")
Local $bDonateSiege =($g_aiPrepDon[4] = 1 Or $g_aiPrepDon[5] = 1) And($g_aiCurrentSiegeMachines[$eSiegeWallWrecker] > 0 Or $g_aiCurrentSiegeMachines[$eSiegeBattleBlimp] > 0 Or $g_aiCurrentSiegeMachines[$eSiegeStoneSlammer] > 0)
SetDebugLog("$g_aiPrepDon[2]: " & $g_aiPrepDon[2] & ", $g_aiPrepDon[3]: " & $g_aiPrepDon[3] & ", $g_iCurrentSpells: " & $g_iCurrentSpells & ", $bDonateSpell: " & $bDonateSpell)
SetDebugLog("$g_aiPrepDon[4]: " & $g_aiPrepDon[4] & "$g_aiPrepDon[5]: " & $g_aiPrepDon[5] & ", $bDonateSiege: " & $bDonateSiege)
If $g_bDebugSetLog Then SetDebugLog("Start dual getOcrSpaceCastleDonate", $COLOR_DEBUG)
$sCapTroops = getOcrSpaceCastleDonate(27, $g_aiDonatePixel[1])
If StringInStr($sCapTroops, "#") Then
$sCapSpells = $bDonateSpell ? getOcrSpaceCastleDonate(110, $g_aiDonatePixel[1]) : -1
$sCapSiegeMachine = $bDonateSiege ? getOcrSpaceCastleDonate(170, $g_aiDonatePixel[1]) : -1
Else
$sCapTroops = getOcrSpaceCastleDonate(60, $g_aiDonatePixel[1])
If StringRegExp($sCapTroops, "#([0-9]{2})") = 1 Then
$sCapSpells = $bDonateSpell ? getOcrSpaceCastleDonate(160, $g_aiDonatePixel[1]) : -1
$sCapSiegeMachine = -1
Else
$sCapTroops = getOcrSpaceCastleDonate(82, $g_aiDonatePixel[1])
$sCapSpells = -1
$sCapSiegeMachine = -1
EndIf
EndIf
If $g_bDebugSetLog Then
SetDebugLog("$sCapTroops :" & $sCapTroops, $COLOR_DEBUG)
SetDebugLog("$sCapSpells :" & $sCapSpells, $COLOR_DEBUG)
SetDebugLog("$sCapSiegeMachine :" & $sCapSiegeMachine, $COLOR_DEBUG)
EndIf
If $sCapTroops <> "" And StringInStr($sCapTroops, "#") Then
$aTempCapTroops = StringSplit($sCapTroops, "#")
If $aTempCapTroops[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempCapTroops splitted :" & $aTempCapTroops[1] & "/" & $aTempCapTroops[2], $COLOR_DEBUG)
If $aTempCapTroops[2] > 0 Then
$iDonatedTroops = $aTempCapTroops[1]
$iCapTroopsTotal = $aTempCapTroops[2]
If $iCapTroopsTotal = 0 Then
$iCapTroopsTotal = 30
EndIf
If $iCapTroopsTotal = 5 Then
$iCapTroopsTotal = 35
EndIf
EndIf
Else
SetLog("Error reading the Castle Troop Capacity[1]...", $COLOR_ERROR)
$iDonatedTroops = 0
$iCapTroopsTotal = 0
EndIf
Else
SetLog("Error reading the Castle Troop Capacity[2]...", $COLOR_ERROR)
$iDonatedTroops = 0
$iCapTroopsTotal = 0
EndIf
If $sCapSpells <> -1 Then
If $sCapSpells <> "" Then
$aTempCapSpells = StringSplit($sCapSpells, "#")
If $aTempCapSpells[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempCapSpells splitted :" & $aTempCapSpells[1] & "/" & $aTempCapSpells[2], $COLOR_DEBUG)
If $aTempCapSpells[2] > 0 Then
$iDonatedSpells = $aTempCapSpells[1]
$iCapSpellsTotal = $aTempCapSpells[2]
EndIf
Else
SetLog("Error reading the Castle Spell Capacity[1]...", $COLOR_ERROR)
$iDonatedSpells = 0
$iCapSpellsTotal = 0
EndIf
Else
SetLog("Error reading the Castle Spell Capacity[2]...", $COLOR_ERROR)
$iDonatedSpells = 0
$iCapSpellsTotal = 0
EndIf
EndIf
If $sCapSiegeMachine <> -1 Then
If $sCapSiegeMachine <> "" Then
$aTempCapSiegeMachine = StringSplit($sCapSiegeMachine, "#")
If $aTempCapSiegeMachine[0] >= 2 Then
If $g_bDebugSetlog Then SetDebugLog("$aTempCapSiegeMachine splitted :" & $aTempCapSiegeMachine[1] & "/" & $aTempCapSiegeMachine[2], $COLOR_DEBUG)
If $aTempCapSiegeMachine[2] > 0 Then
$iDonatedSiegeMachine = $aTempCapSiegeMachine[1]
$iCapSiegeMachineTotal = $aTempCapSiegeMachine[2]
EndIf
Else
SetLog("Error reading the Castle Siege Machine Capacity[1]...", $COLOR_ERROR)
$iDonatedSiegeMachine = 0
$iCapSiegeMachineTotal = 0
EndIf
Else
SetLog("Error reading the Castle Siege Machine Capacity[2]...", $COLOR_ERROR)
$iDonatedSiegeMachine = 0
$iCapSiegeMachineTotal = 0
EndIf
EndIf
$g_iTotalDonateTroopCapacity =($iCapTroopsTotal - $iDonatedTroops)
If $sCapSpells <> -1 Then $g_iTotalDonateSpellCapacity =($iCapSpellsTotal - $iDonatedSpells)
If $sCapSiegeMachine <> -1 Then $g_iTotalDonateSiegeMachineCapacity =($iCapSiegeMachineTotal - $iDonatedSiegeMachine)
If $g_iTotalDonateTroopCapacity < 0 Then
SetLog("Unable to read Clan Castle Capacity!", $COLOR_ERROR)
Else
Local $sSpellText = $sCapSpells <> -1 ? ", Spells: " & $iDonatedSpells & "/" & $iCapSpellsTotal : ""
Local $sSiegeMachineText = $sCapSiegeMachine <> -1 ? ", Siege Machine: " & $iDonatedSiegeMachine & "/" & $iCapSiegeMachineTotal : ""
SetLog("Chat Troops: " & $iDonatedTroops & "/" & $iCapTroopsTotal & $sSpellText & $sSiegeMachineText)
EndIf
EndFunc
Func DetectSlotTroop(Const $iTroopIndex)
Local $FullTemp
For $Slot = 0 To 6
Local $x = 343 +(68 * $Slot)
Local $y = $g_iDonationWindowY + 37
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc($g_sImgDonateTroops, $x, $y, $x1, $y1)
If $g_bDebugSetlog Then SetDebugLog("Troop Slot: " & $Slot & " SearchImgloc returned:" & $FullTemp[0] & ".", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
Local $iFoundTroopIndex = TroopIndexLookup($FullTemp[0])
For $i = $eTroopBarbarian To $eTroopIceGolem
If $iFoundTroopIndex = $i Then
If $g_bDebugSetlog Then SetDebugLog("Detected " & $g_asTroopNames[$i], $COLOR_DEBUG)
If $iTroopIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eTroopIceGolem Then
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
For $Slot = 7 To 13
Local $x = 343 +(68 *($Slot - 7))
Local $y = $g_iDonationWindowY + 124
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc($g_sImgDonateTroops, $x, $y, $x1, $y1)
If $g_bDebugSetlog Then SetDebugLog("Troop Slot: " & $Slot & " SearchImgloc returned:" & $FullTemp[0] & ".", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eTroopBalloon To $eTroopBowler
Local $iFoundTroopIndex = TroopIndexLookup($FullTemp[0])
If $iFoundTroopIndex = $i Then
If $g_bDebugSetlog Then SetDebugLog("Detected " & $g_asTroopNames[$i], $COLOR_DEBUG)
If $iTroopIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eTroopIceGolem Then
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
Return -1
EndFunc
Func DetectSlotSpell(Const $iSpellIndex)
Local $FullTemp
For $Slot = 14 To 20
Local $x = 343 +(68 *($Slot - 14))
Local $y = $g_iDonationWindowY + 241
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc($g_sImgDonateSpells, $x, $y, $x1, $y1)
If $g_bDebugSetlog Then SetDebugLog("Spell Slot: " & $Slot & " SearchImgloc returned:" & $FullTemp[0] & ".", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eSpellLightning To $eSpellBat
Local $sTmp = StringLeft($g_asSpellNames[$i], 4)
If StringInStr($FullTemp[0] & " ", $sTmp) > 0 Then
If $g_bDebugSetlog Then SetDebugLog("Detected " & $g_asSpellNames[$i], $COLOR_DEBUG)
If $iSpellIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eSpellBat Then
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $Slot & "Spell Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
Return -1
EndFunc
Func DetectSlotSiege(Const $iSiegeIndex)
Local $FullTemp
For $Slot = 0 To 6
Local $x = 343 +(68 * $Slot)
Local $y = $g_iDonationWindowY + 37
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc($g_sImgDonateSiege, $x, $y, $x1, $y1)
If $g_bDebugSetlog Then SetDebugLog("Siege Slot: " & $Slot & " SearchImgloc returned:" & $FullTemp[0] & ".", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eSiegeWallWrecker To $eSiegeMachineCount - 1
If $FullTemp[0] = $g_asSiegeMachineShortNames[$i] Then
If $g_bDebugSetlog Then SetDebugLog("Detected " & $g_asSiegeMachineNames[$i], $COLOR_DEBUG)
If $iSiegeIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eSiegeMachineCount - 1 Then
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
For $Slot = 7 To 13
Local $x = 343 +(68 *($Slot - 7))
Local $y = $g_iDonationWindowY + 124
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc($g_sImgDonateSiege, $x, $y, $x1, $y1)
If $g_bDebugSetlog Then SetDebugLog("Siege Slot: " & $Slot & " SearchImgloc returned:" & $FullTemp[0] & ".", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eSiegeWallWrecker To $eSiegeMachineCount - 1
If $FullTemp[0] = $g_asSiegeMachineShortNames[$i] Then
If $g_bDebugSetlog Then SetDebugLog("Detected " & $g_asSiegeMachineNames[$i], $COLOR_DEBUG)
If $iSiegeIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eSiegeMachineCount - 1 Then
If $g_bDebugSetlog Then SetDebugLog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
Return -1
EndFunc
Func SkipDonateNearFullTroops($bSetLog = False, $aHeroResult = Default)
If Not $g_bDonationEnabled Then Return True
If Not $g_bDonateSkipNearFullEnable Then Return False
If $g_iCommandStop = 0 And $g_bTrainEnabled Then Return False
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abDonateHours[$hour[0]] And $g_bDonateHoursEnable Then Return True
If $g_bDonateSkipNearFullEnable Then
If $g_iArmyCapacity > $g_iDonateSkipNearFullPercent Then
Local $rIsWaitforHeroesActive = IsWaitforHeroesActive()
If $rIsWaitforHeroesActive Then
If $aHeroResult = Default Or Not IsArray($aHeroResult) Then
$aHeroResult = getArmyHeroTime("all", True, True)
EndIf
If @error Or UBound($aHeroResult) < 3 Then
SetLog("getArmyHeroTime return error: #" & @error & "|IA:" & IsArray($aHeroResult) & "," & UBound($aHeroResult) & ", exit SkipDonateNearFullTroops!", $COLOR_ERROR)
Return False
EndIf
If $g_bDebugSetlog Then SetDebugLog("getArmyHeroTime returned: " & $aHeroResult[0] & ":" & $aHeroResult[1] & ":" & $aHeroResult[2], $COLOR_DEBUG)
Local $iActiveHero = 0
Local $iHighestTime = -1
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $g_iModeCount - 1
$iActiveHero = -1
If IsSearchModeActiveMini($pMatchMode) And IsUnitUsed($pMatchMode, $pTroopType) And $g_iHeroUpgrading[$pTroopType - $eKing] <> 1 And $g_iHeroWaitAttackNoBit[$pMatchMode][$pTroopType - $eKing] = 1 Then
$iActiveHero = $pTroopType - $eKing
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $aHeroResult[$iActiveHero] > $iHighestTime Then
$iHighestTime = $aHeroResult[$iActiveHero]
EndIf
EndIf
Next
If _Sleep($DELAYRESPOND) Then Return
Next
If $g_bDebugSetlog Then SetDebugLog("$iHighestTime = " & $iHighestTime & "|" & String($iHighestTime > 5), $COLOR_DEBUG)
If $iHighestTime > 5 Then
If $bSetLog Then SetLog("Donations enabled, Heroes recover time is long", $COLOR_INFO)
Return False
Else
If $bSetLog Then SetLog("Donation disabled, available troops " & $g_iArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return True
EndIf
Else
If $bSetLog Then SetLog("Donation disabled, available troops " & $g_iArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return True
EndIf
Else
If $bSetLog Then SetLog("Donations enabled, available troops " & $g_iArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func BalanceDonRec($bSetLog = False)
If Not $g_bDonationEnabled Then Return False
If Not $g_bUseCCBalanced Then Return True
If $g_iCommandStop = 0 And $g_bTrainEnabled Then Return True
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abDonateHours[$hour[0]] And $g_bDonateHoursEnable Then Return False
If $g_bUseCCBalanced Then
If $g_iTroopsDonated = 0 And $g_iTroopsReceived = 0 Then ProfileReport()
If Number($g_iTroopsReceived) <> 0 Then
If Number(Number($g_iTroopsDonated) / Number($g_iTroopsReceived)) >=(Number($g_iCCDonated) / Number($g_iCCReceived)) Then
If $bSetLog Then SetLog("Skipping Donation because Donate/Recieve Ratio is wrong", $COLOR_INFO)
Return False
Else
Return True
EndIf
EndIf
Else
Return True
EndIf
EndFunc
Func SearchImgloc($directory = "", $x = 0, $y = 0, $x1 = 0, $y1 = 0)
Local $aResult[1], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
Local $Redlines = "FV"
_CaptureRegion2($x, $y, $x1, $y1)
Local $res = DllCallMyBot("SearchMultipleTilesBetweenLevels", "handle", $g_hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", $Redlines, "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i] = RetrieveImglocProperty($aKeys[$i], "objectname")
Next
Return $aResult
EndIf
$aResult[0] = "queued"
Return $aResult
EndFunc
Func donateCCWBLUserImageCollect($x, $y)
Local $imagematch = False
_CaptureRegion2()
If $g_bDebugSetlog Then SetDebugLog("Search into whitelist...", $color_purple)
Local $xyz = _FileListToArrayRec($g_sProfileDonateCaptureWhitelistPath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyz) > 1 Then
For $i = 1 To UBound($xyz) - 1
Local $result = FindImageInPlace("DCCWBL", $g_sProfileDonateCaptureWhitelistPath & $xyz[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($result, ",") > 0 Then
If $g_iCmbDonateFilter = 2 Then SetLog("WHITE LIST: image match! " & $xyz[$i], $COLOR_SUCCESS)
$imagematch = True
If $g_iCmbDonateFilter = 2 Then Return True
ExitLoop
EndIf
Next
EndIf
If $g_bDebugSetlog Then SetDebugLog("Search into blacklist...", $color_purple)
Local $xyz1 = _FileListToArrayRec($g_sProfileDonateCaptureBlacklistPath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyz1) > 1 Then
For $i = 1 To UBound($xyz1) - 1
Local $result1 = FindImageInPlace("DCCWBL", $g_sProfileDonateCaptureBlacklistPath & $xyz1[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($result1, ",") > 0 Then
If $g_iCmbDonateFilter = 3 Then SetLog("BLACK LIST: image match! " & $xyz1[$i], $COLOR_SUCCESS)
$imagematch = True
If $g_iCmbDonateFilter = 3 Then Return False
ExitLoop
Else
If $g_bDebugSetlog Then SetDebugLog("Image not found", $COLOR_ERROR)
EndIf
Next
EndIf
If $imagematch = False And $g_iCmbDonateFilter > 0 Then
If $g_bDebugSetlog Then SetDebugLog("Search into images to assign...", $color_purple)
Local $xyzw = _FileListToArrayRec($g_sProfileDonateCapturePath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyzw) > 1 Then
For $i = 1 To UBound($xyzw) - 1
Local $resultxyzw = FindImageInPlace("DCCWBL", $g_sProfileDonateCapturePath & $xyzw[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($resultxyzw, ",") > 0 Then
If $g_iCmbDonateFilter = 1 Or $g_bDebugSetlog Then SetLog("IMAGES TO ASSIGN: image match! " & $xyzw[$i], $COLOR_SUCCESS)
$imagematch = True
ExitLoop
EndIf
Next
EndIf
If $imagematch = False Then
If $g_bDebugSetlog Then SetDebugLog("save image in images to assign...", $color_purple)
Local $iAllFilesCount = 0
Local $res = FindImageInPlace("DCCWBL", $g_sImgChatDivider, "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If $res = "" Then
Local $reshidden = FindImageInPlace("DCCWBL", $g_sImgChatDividerHidden, "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If $reshidden = "" Then
If $g_bDebugSetlog Then SetDebugLog("No Chat divider hidden found", $COLOR_ERROR)
Else
Local $xfound = Int(StringSplit($reshidden, ",", 2)[0])
Local $yfound = Int(StringSplit($reshidden, ",", 2)[1])
If $g_bDebugSetlog Then SetDebugLog("ChatDivider hidden found (" & $xfound & "," & $yfound & ")", $COLOR_SUCCESS)
Local $oBitmap = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hClone = _GDIPlus_BitmapCloneArea($oBitmap, 31, $yfound + 14, 100, 11, $GDIP_PXF24RGB)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
$iAllFilesCount = _FileListToArrayRec($g_sProfileDonateCapturePath, "*", 1, 0, 0, 0)
If IsArray($iAllFilesCount) Then
$iAllFilesCount = $iAllFilesCount[0]
Else
$iAllFilesCount = 0
EndIf
Local $filename = String("ClanMate-" & $Date & "_" & Number($iAllFilesCount) + 1 & "_98.png")
_GDIPlus_ImageSaveToFile($hClone, $g_sProfileDonateCapturePath & $filename)
If $g_iCmbDonateFilter = 1 Then SetLog("Clan Mate image Stored: " & $filename, $COLOR_SUCCESS)
_GDIPlus_BitmapDispose($hClone)
_GDIPlus_BitmapDispose($oBitmap)
EndIf
Else
Local $xfound = Int(StringSplit($res, ",", 2)[0])
Local $yfound = Int(StringSplit($res, ",", 2)[1])
If $g_bDebugSetlog Then SetDebugLog("ChatDivider found (" & $xfound & "," & $yfound & ")", $COLOR_SUCCESS)
Local $oBitmap = _GDIPlus_BitmapCreateFromHBITMAP($g_hHBitmap2)
Local $hClone = _GDIPlus_BitmapCloneArea($oBitmap, 31, $yfound + 14, 100, 11, $GDIP_PXF24RGB)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
$iAllFilesCount = _FileListToArrayRec($g_sProfileDonateCapturePath, "*", 1, 0, 0, 0)
If IsArray($iAllFilesCount) Then
$iAllFilesCount = $iAllFilesCount[0]
Else
$iAllFilesCount = 0
EndIf
Local $filename = String("ClanMate--" & $Date & "_" & Number($iAllFilesCount) + 1 & "_98.png")
_GDIPlus_ImageSaveToFile($hClone, $g_sProfileDonateCapturePath & $filename)
_GDIPlus_BitmapDispose($hClone)
_GDIPlus_BitmapDispose($oBitmap)
If $g_iCmbDonateFilter = 1 Then SetLog("IMAGES TO ASSIGN: stored!", $COLOR_SUCCESS)
Deletefiles($g_sProfileDonateCapturePath, "*.png", 2, 0)
EndIf
EndIf
EndIf
If $g_iCmbDonateFilter <= 1 Then
Return True
ElseIf $g_iCmbDonateFilter = 3 Then
Return True
Else
Return False
EndIf
EndFunc
Func DropTrophy()
If $g_bDropTrophyEnable Then
SetDebugLog("Drop Trophy()", $COLOR_DEBUG)
If $g_bDebugDeadBaseImage Then
DirCreate($g_sProfileTempDebugPath & "\SkippedZombies\")
DirCreate($g_sProfileTempDebugPath & "\Zombies\")
setZombie()
EndIf
For $i = 0 To 5
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
SetDebugLog("Current Trophy Count: " & $g_aiCurrentLoot[$eLootTrophy], $COLOR_DEBUG)
If $g_aiCurrentLoot[$eLootTrophy] <> "" Then ExitLoop
If _Sleep(1000) Then Return
ClickP($aAway, 1, 0, "#0000")
Next
If Number($g_aiCurrentLoot[$eLootTrophy]) <= Number($g_iDropTrophyMax) Then Return
Local $bHaveTroops = False
For $i = 0 To UBound($g_avDTtroopsToBeUsed, 1) - 1
If $g_avDTtroopsToBeUsed[$i][1] > 0 Then
$bHaveTroops = True
If $g_bDebugSetlog Then
SetDebugLog("Drop Trophy Found " & StringFormat("%3s", $g_avDTtroopsToBeUsed[$i][1]) & " " & $g_avDTtroopsToBeUsed[$i][0], $COLOR_DEBUG)
ContinueLoop
Else
ExitLoop
EndIf
EndIf
Next
If $g_bDropTrophyUseHeroes And $g_iHeroAvailable > 0 Then
If $g_bDebugSetlog Then SetDebugLog("Drop Trophy Found Hero BK|AQ|GW: " & BitOR($g_iHeroAvailable, $eHeroKing) & "|" & BitOR($g_iHeroAvailable, $eHeroQueen) & "|" & BitOR($g_iHeroAvailable, $eHeroWarden), $COLOR_DEBUG)
$bHaveTroops = True
EndIf
If Not $bHaveTroops Then
SetLog("Drop Trophy temporarily disabled, missing proper troop type", $COLOR_ERROR)
SetDebugLog("Drop Trophy(): No troops in $g_avDTtroopsToBeUsed array", $COLOR_DEBUG)
Return
EndIf
Local $iCount, $aRandomEdge, $iRandomXY
Local Const $DTArmyPercent = Round(Int($g_iDropTrophyArmyMinPct) / 100, 2)
Local $g_iDropTrophyMaxNeedCheck = $g_iDropTrophyMax
Local Const $iWaitTime = 3
Local $iDateCalc, $sWaitToDate
$sWaitToDate = _DateAdd('n', Int($iWaitTime), _NowCalc())
SetDebugLog("ChkBaseQuick delay time= " & $sWaitToDate & " Now= " & _NowCalc() & " Diff= " & _DateDiff('s', _NowCalc(), $sWaitToDate), $COLOR_DEBUG)
While Number($g_aiCurrentLoot[$eLootTrophy]) > Number($g_iDropTrophyMaxNeedCheck)
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
SetLog("Trophy Count : " & $g_aiCurrentLoot[$eLootTrophy], $COLOR_SUCCESS)
If Number($g_aiCurrentLoot[$eLootTrophy]) > Number($g_iDropTrophyMaxNeedCheck) Then
If $g_bDropTrophyAtkDead Then
If($g_CurrentCampUtilization <=($g_iTotalCampSpace * $DTArmyPercent)) Then
SetLog("Drop Trophy is waiting for " & $g_iDropTrophyArmyMinPct & "% full army to also attack Deadbases.", $COLOR_ACTION)
SetDebugLog("Drop Trophy(): Drop Trophy + Dead Base skipped, army < " & $g_iDropTrophyArmyMinPct & "%.", $COLOR_DEBUG)
ExitLoop
EndIf
Else
If($g_CurrentCampUtilization < 5) And($g_bDropTrophyUseHeroes And $g_iHeroAvailable = $eHeroNone) Then
SetLog("No troops available to use on Drop Trophy", $COLOR_ERROR)
SetDebugLog("Drop Trophy(): Drop Trophy skipped, no army.", $COLOR_DEBUG)
ExitLoop
EndIf
EndIf
$g_iDropTrophyMaxNeedCheck = $g_iDropTrophyMin
SetLog("Dropping Trophies to " & $g_iDropTrophyMin, $COLOR_INFO)
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
ZoomOut()
PrepareSearch($DT)
If $g_bOutOfGold Or $g_bRestart Then Return
WaitForClouds()
If $g_bRestart Then Return
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
$g_iSearchCount = 0
GetResources(False, $DT)
If $g_bRestart Then Return
If $g_bDropTrophyAtkDead Then
$g_iAimGold[$DB] = $g_aiFilterMinGold[$DB]
$g_iAimElixir[$DB] = $g_aiFilterMinElixir[$DB]
$g_iAimGoldPlusElixir[$DB] = $g_aiFilterMinGoldPlusElixir[$DB]
Local $G =(Number($g_iSearchGold) >= Number($g_iAimGold[$DB]))
Local $E =(Number($g_iSearchElixir) >= Number($g_iAimElixir[$DB]))
Local $GPE =((Number($g_iSearchElixir) + Number($g_iSearchGold)) >= Number($g_iAimGoldPlusElixir[$DB]))
If $G = True And $E = True And $GPE = True Then
SetLog("Found [G]:" & StringFormat("%7s", $g_iSearchGold) & " [E]:" & StringFormat("%7s", $g_iSearchElixir) & " [D]:" & StringFormat("%5s", $g_iSearchDark) & " [T]:" & StringFormat("%2s", $g_iSearchTrophy), $COLOR_BLACK, "Lucida Console", 7.5)
If $g_bDebugDeadBaseImage Then setZombie()
ForceCaptureRegion()
_CaptureRegion2()
If checkDeadBase() Then
SetLog("      " & "Dead Base Found while dropping Trophies!", $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("Identification of your troops:", $COLOR_INFO)
PrepareAttack($DB)
If $g_bRestart Then Return
Attack()
$g_bFirstStart = True
ReturnHome($g_bTakeLootSnapShot)
$g_bIsClientSyncError = False
$g_bIsSearchLimit = False
$g_bRestart = True
If $g_bDebugSetlog Then SetDebugLog("Drop Trophy END: Dead Base was attacked, reset army and return to Village.", $COLOR_DEBUG)
ExitLoop
Else
SetLog("      " & "Not a Dead Base, resuming Trophy Dropping.", $COLOR_BLACK, "Lucida Console", 7.5)
EndIf
EndIf
EndIf
SetLog("Identification of your troops:", $COLOR_INFO)
PrepareAttack($DT)
If $g_bRestart Then Return
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
If $g_bDropTrophyUseHeroes Then
SetSlotSpecialTroops()
$aRandomEdge = $g_aaiEdgeDropPoints[Round(Random(0, 3))]
$iRandomXY = Round(Random(0, 4))
If $g_bDebugSetlog Then SetDebugLog("Hero Loc = " & $iRandomXY & ", X:Y= " & $aRandomEdge[$iRandomXY][0] & "|" & $aRandomEdge[$iRandomXY][1], $COLOR_DEBUG)
If($g_iQueenSlot <> -1 Or $g_iKingSlot <> -1 Or $g_iWardenSlot <> -1) Then
Local $sHeroPriority
Switch $g_iDropTrophyHeroesPriority
Case 0
$sHeroPriority = "QKW"
Case 1
$sHeroPriority = "QWK"
Case 2
$sHeroPriority = "KQW"
Case 3
$sHeroPriority = "KWQ"
Case 4
$sHeroPriority = "WKQ"
Case 5
$sHeroPriority = "WQK"
EndSwitch
Local $t
For $i = 1 To 3
$t = StringMid($sHeroPriority, $i, 1)
Switch $t
Case "Q"
If $g_iQueenSlot <> -1 Then
SetTrophyLoss()
SetLog("Deploying Queen", $COLOR_INFO)
SelectDropTroop($g_iQueenSlot)
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0180")
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
SelectDropTroop($g_iQueenSlot)
ReturnfromDropTrophies()
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
ExitLoop
EndIf
Case "K"
If $g_iKingSlot <> -1 Then
SetTrophyLoss()
SetLog("Deploying King", $COLOR_INFO)
SelectDropTroop($g_iKingSlot)
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0178")
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
SelectDropTroop($g_iKingSlot)
ReturnfromDropTrophies()
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
ExitLoop
EndIf
Case "W"
If $g_iWardenSlot <> -1 Then
SetTrophyLoss()
SetLog("Deploying Warden", $COLOR_INFO)
SelectDropTroop($g_iWardenSlot)
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0000")
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
SelectDropTroop($g_iWardenSlot)
ReturnfromDropTrophies()
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
ExitLoop
EndIf
EndSwitch
Next
EndIf
EndIf
If($g_iQueenSlot = -1 And $g_iKingSlot = -1 And $g_iWardenSlot = -1) Or Not $g_bDropTrophyUseHeroes Then
$aRandomEdge = $g_aaiEdgeDropPoints[Round(Random(0, 3))]
$iRandomXY = Round(Random(0, 4))
If $g_bDebugSetlog Then SetDebugLog("Troop Loc = " & $iRandomXY & ", X:Y= " & $aRandomEdge[$iRandomXY][0] & "|" & $aRandomEdge[$iRandomXY][1], $COLOR_DEBUG)
For $i = 0 To UBound($g_avAttackTroops) - 1
If($g_avAttackTroops[$i][0] >= $eBarb And $g_avAttackTroops[$i][0] <= $eWiza) Or $g_avAttackTroops[$i][0] = $eMini Then
SelectDropTroop($i)
If _Sleep($DELAYDROPTROPHY4) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0181")
SetLog("Deploying 1 " & $g_asTroopNames[$g_avAttackTroops[$i][0]], $COLOR_INFO)
$g_aiCurrentTroops[$g_avAttackTroops[$i][0]] -= 1
ExitLoop
EndIf
If $g_avAttackTroops[$i][0] = -1 Or $g_avAttackTroops[$i][0] >= $eTroopCount Then
SetLog("You don't have Tier 1/2 Troops, Stop dropping trophies.", $COLOR_INFO)
ExitLoop 2
EndIf
Next
SetTrophyLoss()
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
ReturnHome(False, False)
If _Sleep($DELAYDROPTROPHY1) Then ExitLoop
EndIf
$iDateCalc = _DateDiff('s', _NowCalc(), $sWaitToDate)
If $g_bDebugSetlog Then SetDebugLog("ChkBaseQuick delay= " & $sWaitToDate & " Now= " & _NowCalc() & " Diff= " & $iDateCalc, $COLOR_DEBUG)
If $iDateCalc <= 0 Then
SetLog(" Checking base during long drop cycle", $COLOR_INFO)
CheckBaseQuick()
$sWaitToDate = _DateAdd('n', Int($iWaitTime), _NowCalc())
If $g_bDebugSetlog Then SetDebugLog("ChkBaseQuick new delay time= " & $sWaitToDate, $COLOR_DEBUG)
EndIf
Else
SetLog("Trophy Drop Complete", $COLOR_INFO)
EndIf
WEnd
If $g_bDebugSetlog Then SetDebugLog("DropTrophy(): End", $COLOR_DEBUG)
Else
If $g_bDebugSetlog Then SetDebugLog("Drop Trophy SKIP", $COLOR_DEBUG)
EndIf
EndFunc
Func SetTrophyLoss()
Local $sTrophyLoss
If _ColorCheck(_GetPixelColor(33, 148, True), Hex(0x000000, 6), 10) Or _CheckPixel($aAtkHasDarkElixir, $g_bCapturePixel, Default, "HasDarkElixir") Then
$sTrophyLoss = getTrophyLossAttackScreen(48, 214)
Else
$sTrophyLoss = getTrophyLossAttackScreen(48, 184)
EndIf
SetLog(" Trophy loss = " & $sTrophyLoss, $COLOR_DEBUG)
$g_iDroppedTrophyCount -= Number($sTrophyLoss)
UpdateStats()
EndFunc
Func GetTownHallLevel($bFirstTime = False)
Local $aTHInfo[3] = ["", "", ""]
If $g_bDebugSetlog Then SetDebugLog("Town Hall Position: " & $g_aiTownHallPos[0] & ", " & $g_aiTownHallPos[1], $COLOR_DEBUG)
If isInsideDiamond($g_aiTownHallPos) = False Then
LocateTownHall(True)
If isInsideDiamond($g_aiTownHallPos) Then SaveConfig()
If _Sleep($DELAYGETTHLEVEL1) Then Return
EndIf
If $bFirstTime = True Then
BuildingClickP($g_aiTownHallPos, "#0349")
If _Sleep($DELAYGETTHLEVEL2) Then Return
EndIf
If $g_bDebugImageSave Then DebugImageSave("GetTHLevelView")
$g_iTownHallLevel = 0
$aTHInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If $g_bDebugSetlog Then SetDebugLog("$aTHInfo[0]=" & $aTHInfo[0] & ", $aTHInfo[1]=" & $aTHInfo[1] & ", $aTHInfo[2]=" & $aTHInfo[2], $COLOR_DEBUG)
If $aTHInfo[0] > 1 Then
If StringInStr($aTHInfo[1], "Town") = 0 Then
SetLog("Town Hall not found! I detected a " & $aTHInfo[1] & "! Please locate again!", $COLOR_WARNING)
Return $aTHInfo
EndIf
If $aTHInfo[2] <> "" Then
$g_iTownHallLevel = $aTHInfo[2]
SetLog("Your Town Hall Level read as: " & $g_iTownHallLevel, $COLOR_SUCCESS)
chkUpgradeKing()
chkUpgradeQueen()
chkUpgradeWarden()
cmbHeroReservedBuilder()
chkDBKingWait()
chkDBQueenWait()
chkDBWardenWait()
chkABKingWait()
chkABQueenWait()
chkABWardenWait()
saveConfig()
Else
SetLog("Your Town Hall Level was not found! Please Manually Locate", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0350")
Return False
EndIf
Else
SetLog("Your Town Hall Level was not found! Please Manually Locate", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0351")
Return False
EndIf
ClickP($aAway, 2, $DELAYGETTHLEVEL3, "#0352")
Return True
EndFunc
Func isAtkDarkElixirFull()
If isAttackPage() And _CheckPixel($aIsAtkDarkElixirFull, $g_bCapturePixel) Then
SetLog("Dark Elixir Storages is full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func isDarkElixirFull()
If _CheckPixel($aIsDarkElixirFull, $g_bCapturePixel) Then
SetLog("Dark Elixir Storages is full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func isGoldFull()
If _CheckPixel($aIsGoldFull, $g_bCapturePixel) Then
SetLog("Gold Storages are full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func isElixirFull()
If _CheckPixel($aIsElixirFull, $g_bCapturePixel) Then
SetLog("Elixir Storages are full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func LocateUpgrades()
If $g_bBotPaused Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $stext = GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_BotPaused", "Cannot locate Upgrades when bot is paused!")
Local $MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Notice", "Notice"), $stext, 15, $g_hFrmBot)
Return
EndIf
WinGetAndroidHandle()
If $g_hAndroidWindow <> 0 And $g_bAndroidBackgroundLaunched = True Then
SetLog("Reboot " & $g_sAndroidEmulator & " for Window access", $COLOR_ERROR)
RebootAndroid(True)
EndIf
If $g_hAndroidWindow = 0 Then
SetLog($g_sAndroidEmulator & " is not open", $COLOR_ERROR)
SetError(1)
Return
EndIf
AndroidToFront(Default, "LocateUpgrades")
Local $wasDown = AndroidShieldForcedDown()
AndroidShield("LocateUpgrades")
Local $MsgBox, $stext
Local $icount = 0
Local $hGraphic = 0
Local $bInitGraphics = True
While 1
_CaptureRegion(0, 0, $g_iDEFAULT_WIDTH, 2)
If _GetPixelColor(1, 1) <> Hex(0x000000, 6) Or _GetPixelColor(850, 1) <> Hex(0x000000, 6) Then
ZoomOut()
$g_bDisableBreakCheck = True
Collect()
$g_bDisableBreakCheck = False
EndIf
$g_bDisableBreakCheck = True
Collect()
$g_bDisableBreakCheck = False
If $bInitGraphics Then
$bInitGraphics = False
$hGraphic = AndroidGraphicsGdiBegin()
If $hGraphic <> 0 Then
Local $hPen = AndroidGraphicsGdiAddObject("Pen", _GDIPlus_PenCreate(0xFFFFFF00, 2))
SetDebugLog("LocateUpgrades: $hGraphic=" & $hGraphic & ", $hPen=" & $hPen)
For $icount = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $hGraphic <> 0 And $g_avBuildingUpgrades[$icount][0] > 0 And $g_avBuildingUpgrades[$icount][0] > 0 Then
Local $xUpgrade = $g_avBuildingUpgrades[$icount][0]
Local $yUpgrade = $g_avBuildingUpgrades[$icount][1]
ConvertToVillagePos($xUpgrade, $yUpgrade)
Local $bMarkerDrawn = _GDIPlus_GraphicsDrawEllipse($hGraphic, $xUpgrade - 10, $yUpgrade - 10, 20, 20, $hPen)
AndroidGraphicsGdiUpdate()
SetDebugLog("Existing Updgrade #" & $icount & " found at " & $g_avBuildingUpgrades[$icount][0] & "/" & $g_avBuildingUpgrades[$icount][1] & ", marker drawn: " & $bMarkerDrawn)
EndIf
Next
EndIf
EndIf
For $icount = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abUpgradeRepeatEnable[$icount] = True And(GUICtrlRead($g_hTxtUpgradeName[$icount]) <> "") Then
_GUICtrlSetImage($g_hPicUpgradeStatus[$icount], $g_sLibIconPath, $eIcnYellowLight)
GUICtrlSetState($g_hChkUpgrade[$icount], $GUI_CHECKED)
ContinueLoop
EndIf
AndroidShieldForceDown(True, True)
$stext = GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_01", "Click 'Locate Building' button then click on your Building/Hero to upgrade.") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_02", "Click 'Finished' button when done locating all upgrades.") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_03", "Click on Cancel to exit finding buildings.") & @CRLF & @CRLF
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 10, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_04", "Locate Building|Finished|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_05", "Locate Upgrades"), $stext, 0, $g_hFrmBot)
Switch $MsgBox
Case 1
Local $aPos = FindPos()
$g_avBuildingUpgrades[$icount][0] = $aPos[0]
$g_avBuildingUpgrades[$icount][1] = $aPos[1]
If isInsideDiamondXY($g_avBuildingUpgrades[$icount][0], $g_avBuildingUpgrades[$icount][1]) Then
Local $bMarkerDrawn = False
If $hGraphic <> 0 Then
Local $xUpgrade = $g_avBuildingUpgrades[$icount][0]
Local $yUpgrade = $g_avBuildingUpgrades[$icount][1]
ConvertToVillagePos($xUpgrade, $yUpgrade)
$bMarkerDrawn = _GDIPlus_GraphicsDrawEllipse($hGraphic, $xUpgrade - 10, $yUpgrade - 10, 20, 20, $hPen)
AndroidGraphicsGdiUpdate()
EndIf
SetDebugLog("Updgrade #" & $icount & " added at " & $g_avBuildingUpgrades[$icount][0] & "/" & $g_avBuildingUpgrades[$icount][1] & ", marker drawn: " & $bMarkerDrawn)
_GUICtrlSetImage($g_hPicUpgradeStatus[$icount], $g_sLibIconPath, $eIcnYellowLight)
$g_aiPicUpgradeStatus[$icount] = $eIcnYellowLight
_Sleep(750)
Else
SetLog("Bad location recorded, location skipped?", $COLOR_ERROR)
$g_avBuildingUpgrades[$icount][0] = -1
$g_avBuildingUpgrades[$icount][1] = -1
ContinueLoop
EndIf
Case 2
If $icount = 0 Then
SetLog("Locate Upgrade Cancelled", $COLOR_WARNING)
btnResetUpgrade()
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
Return False
EndIf
ExitLoop
Case 3
SetLog("Locate Upgrade Cancelled", $COLOR_WARNING)
btnResetUpgrade()
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
Return False
Case Else
SetLog("Impossible value (" & $MsgBox & ") from Msgbox, you have been a bad programmer!", $COLOR_DEBUG)
EndSwitch
ClickP($aAway, 1, 0, "#0210")
Next
ExitLoop
WEnd
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
CheckUpgrades()
EndFunc
Func CheckUpgrades()
If AndroidShielded() = False Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $stext = GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_06", "Keep Mouse OUT of Android Emulator Window While I Check Your Upgrades, Thanks!!")
Local $MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Notice", "Notice"), $stext, 15, $g_hFrmBot)
If _Sleep($DELAYCHECKUPGRADES) Then Return
If $MsgBox <> 1 Then
SetLog("Something weird happened in getting upgrade values, try again", $COLOR_ERROR)
Return False
EndIf
EndIf
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If isInsideDiamondXY($g_avBuildingUpgrades[$iz][0], $g_avBuildingUpgrades[$iz][1]) = False Then
_GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $eIcnRedLight)
GUICtrlSetState($g_hChkUpgrade[$iz], $GUI_UNCHECKED)
If $g_abUpgradeRepeatEnable[$iz] = True Then GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $GUI_UNCHECKED)
ContinueLoop
EndIf
If UpgradeValue($iz) = False Then
If $g_abUpgradeRepeatEnable[$iz] = True And $g_avBuildingUpgrades[$iz][4] <> "" Then ContinueLoop
SetLog("Locate Upgrade #" & $iz + 1 & " Value Error, try again", $COLOR_ERROR)
_GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $eIcnRedLight)
GUICtrlSetData($g_hTxtUpgradeName[$iz], "")
GUICtrlSetData($g_hTxtUpgradeLevel[$iz], "")
GUICtrlSetData($g_hTxtUpgradeValue[$iz], "")
GUICtrlSetData($g_hTxtUpgradeTime[$iz], "")
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], "")
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnBlank)
If $g_abUpgradeRepeatEnable[$iz] = True Then GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $GUI_UNCHECKED)
ContinueLoop
EndIf
Next
EndFunc
Func UpgradeValue($inum, $bRepeat = False)
Local $inputbox, $iLoot, $aString, $aResult, $ButtonPixel
Local $bOopsFlag = False
If $bRepeat Or $g_abUpgradeRepeatEnable[$inum] Then
ClickP($aAway, 1, 0, "#0999")
If _Sleep($DELAYUPGRADEVALUE1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1])
If _Sleep($DELAYUPGRADEVALUE4) Then Return
If $bOopsFlag = True Then DebugImageSave("ButtonView")
If StringInStr($g_avBuildingUpgrades[$inum][4], "collect", $STR_NOCASESENSEBASIC) Or StringInStr($g_avBuildingUpgrades[$inum][4], "mine", $STR_NOCASESENSEBASIC) Or StringInStr($g_avBuildingUpgrades[$inum][4], "drill", $STR_NOCASESENSEBASIC) Then
ClickP($aAway, 1, 0, "#0999")
If _Sleep($DELAYUPGRADEVALUE1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1])
If _Sleep($DELAYUPGRADEVALUE4) Then Return
EndIf
Local $offColors[3][3] = [[0x000000, 44, 17], [0xE07740, 69, 31], [0xF2F7F1, 81, 0]]
Local $ButtonPixel = _MultiPixelSearch(284, 572, 570, 615, 1, 1, Hex(0x000000, 6), $offColors, 25)
If $g_bDebugSetlog Then SetDebugLog("Pixel Color #1: " & _GetPixelColor(389, 572, True) & ", #2: " & _GetPixelColor(433, 589, True) & ", #3: " & _GetPixelColor(458, 603, True) & ", #4: " & _GetPixelColor(470, 572, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Or $bOopsFlag Then
SetLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetLog("Pixel Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 44, $ButtonPixel[1] + 17, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 69, $ButtonPixel[1] + 31, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 81, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
SetLog("Selection #" & $inum + 1 & " Upgrade in process - Skipped!", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0999")
Return False
EndIf
Else
If $g_avBuildingUpgrades[$inum][0] <= 0 Or $g_avBuildingUpgrades[$inum][1] <= 0 Then Return False
$g_avBuildingUpgrades[$inum][2] = 0
GUICtrlSetData($g_hTxtUpgradeValue[$inum], "")
$g_avBuildingUpgrades[$inum][3] = ""
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnBlank)
$g_avBuildingUpgrades[$inum][4] = ""
GUICtrlSetData($g_hTxtUpgradeName[$inum], "")
$g_avBuildingUpgrades[$inum][5] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], "")
$g_avBuildingUpgrades[$inum][6] = ""
GUICtrlSetData($g_hTxtUpgradeTime[$inum], "")
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0211")
SetLog("-$Upgrade #" & $inum + 1 & " Location =  " & "(" & $g_avBuildingUpgrades[$inum][0] & "," & $g_avBuildingUpgrades[$inum][1] & ")", $COLOR_DEBUG1)
If _Sleep($DELAYUPGRADEVALUE1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0212")
If _Sleep($DELAYUPGRADEVALUE2) Then Return
If $bOopsFlag = True Then DebugImageSave("ButtonView")
EndIf
If $bOopsFlag And $g_bDebugImageSave Then DebugImageSave("ButtonView")
$aResult = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If $aResult[0] > 0 Then
$g_avBuildingUpgrades[$inum][4] = $aResult[1]
GUICtrlSetData($g_hTxtUpgradeName[$inum], $g_avBuildingUpgrades[$inum][4])
If $aResult[0] > 1 Then
$g_avBuildingUpgrades[$inum][5] = $aResult[2]
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5])
Else
SetLog("Error: Level for Upgrade not found?", $COLOR_ERROR)
EndIf
Else
SetLog("Error: Name & Level for Upgrade not found?", $COLOR_ERROR)
EndIf
SetLog("Upgrade Name = " & $g_avBuildingUpgrades[$inum][4] & ", Level = " & $g_avBuildingUpgrades[$inum][5], $COLOR_INFO)
Local $aUpgradeButton = findButton("Upgrade", Default, 1, True)
If IsArray($aUpgradeButton) And UBound($aUpgradeButton, 1) = 2 Then
ClickP($aUpgradeButton, 1, 0, "#0213")
If _Sleep($DELAYUPGRADEVALUE5) Then Return
If $bOopsFlag And $g_bDebugImageSave Then DebugImageSave("UpgradeView")
_CaptureRegion()
Select
Case _ColorCheck(_GetPixelColor(687, 161 + $g_iMidOffsetY), Hex(0xCD1419, 6), 20)
If _ColorCheck(_GetPixelColor(351, 485 + $g_iMidOffsetY), Hex(0xE0403D, 6), 20) Then
If $g_abUpgradeRepeatEnable[$inum] = True Then
SetLog("Selection #" & $inum + 1 & " can not repeat upgrade, need TH upgrade - Skipped!", $COLOR_ERROR)
$g_abUpgradeRepeatEnable[$inum] = False
GUICtrlSetState($g_hChkUpgradeRepeat[$inum], $GUI_UNCHECKED)
Else
SetLog("Selection #" & $inum + 1 & " upgrade not available, need TH upgrade - Skipped!", $COLOR_ERROR)
EndIf
ClearUpgradeInfo($inum)
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnRedLight)
_GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnTroops)
$g_abBuildingUpgradeEnable[$inum] = False
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0214")
Return False
EndIf
If _ColorCheck(_GetPixelColor(485, 500 + $g_iMidOffsetY), Hex(0xFFD115, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Gold"
If _ColorCheck(_GetPixelColor(480, 500 + $g_iMidOffsetY), Hex(0xBD21EF, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Elixir"
$g_avBuildingUpgrades[$inum][2] = Number(getResourcesBonus(366, 487 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" Then $g_avBuildingUpgrades[$inum][2] = Number(getUpgradeResource(366, 487 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then $bOopsFlag = True
$g_avBuildingUpgrades[$inum][6] = getBldgUpgradeTime(195, 307 + $g_iMidOffsetY)
SetLog("Upgrade #" & $inum + 1 & " Time = " & $g_avBuildingUpgrades[$inum][6], $COLOR_INFO)
If $g_avBuildingUpgrades[$inum][6] <> "" Then $g_avBuildingUpgrades[$inum][7] = ""
Case _ColorCheck(_GetPixelColor(719, 118 + $g_iMidOffsetY), Hex(0xDF0408, 6), 20)
If _ColorCheck(_GetPixelColor(400, 485 + $g_iMidOffsetY), Hex(0xE0403D, 6), 20) Then
If $g_abUpgradeRepeatEnable[$inum] = True Then
SetLog("Selection #" & $inum + 1 & " can not repeat upgrade, need TH upgrade - Skipped!", $COLOR_ERROR)
$g_abUpgradeRepeatEnable[$inum] = False
GUICtrlSetState($g_hChkUpgradeRepeat[$inum], $GUI_UNCHECKED)
Else
SetLog("Selection #" & $inum + 1 & " upgrade not available, need TH upgrade - Skipped!", $COLOR_ERROR)
EndIf
ClearUpgradeInfo($inum)
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnRedLight)
_GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnTroops)
$g_abBuildingUpgradeEnable[$inum] = False
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0215")
Return False
EndIf
If _ColorCheck(_GetPixelColor(710, 535 + $g_iMidOffsetY), Hex(0x3C3035, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Dark"
$g_avBuildingUpgrades[$inum][2] = Number(getResourcesBonus(598, 519 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" Then $g_avBuildingUpgrades[$inum][2] = Number(getUpgradeResource(598, 519 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then $bOopsFlag = True
$g_avBuildingUpgrades[$inum][6] = getHeroUpgradeTime(464, 527 + $g_iMidOffsetY)
SetLog("Upgrade #" & $inum + 1 & " Time = " & $g_avBuildingUpgrades[$inum][6], $COLOR_INFO)
If $g_avBuildingUpgrades[$inum][6] <> "" Then $g_avBuildingUpgrades[$inum][7] = ""
Case Else
If isGemOpen(True) Then ClickP($aAway, 1, 0, "#0216")
SetLog("Selected Upgrade Window Opening Error, try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
ClickP($aAway, 1, 0, "#0217")
Return False
EndSelect
If StringInStr($g_avBuildingUpgrades[$inum][4], "Warden") > 0 Then $g_avBuildingUpgrades[$inum][3] = "Elixir"
If $g_avBuildingUpgrades[$inum][3] <> "" And $bOopsFlag = True And $bRepeat = False Then
$iLoot = $g_avBuildingUpgrades[$inum][2]
If $iLoot = "" Then $iLoot = 8000000
Local $aBotLoc = WinGetPos($g_hFrmBot)
$inputbox = InputBox(GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_07", "Text Read Error"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_08", "Enter the cost of the upgrade"), $iLoot, "", -1, -1, $aBotLoc[0] + 125, $aBotLoc[1] + 225, -1, $g_hFrmBot)
If @error Then
SetLog("InputBox error, data reset. Try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
Return False
EndIf
$g_avBuildingUpgrades[$inum][2] = Int($inputbox)
SetLog("User input value = " & $g_avBuildingUpgrades[$inum][2], $COLOR_DEBUG)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $stext = GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_09", "Save copy of upgrade image for developer analysis ?")
Local $MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "YES_NO", "YES|NO"), GetTranslatedFileIni("MBR Popups", "Notice", "Notice"), $stext, 60, $g_hFrmBot)
If $MsgBox = 1 And $g_bDebugImageSave Then DebugImageSave("UpgradeReadError_")
EndIf
If $g_avBuildingUpgrades[$inum][3] = "" And $bOopsFlag = True And $bRepeat = False Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 10, "Comic Sans MS", 500)
$inputbox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_10", "   GOLD   |  ELIXIR  |DARK ELIXIR"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_11", "Need User Help"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Building_12", "Select Upgrade Type:"), 0, $g_hFrmBot)
If $g_bDebugSetlog Then SetDebugLog(" _MsgBox returned = " & $inputbox, $COLOR_DEBUG)
Switch $inputbox
Case 1
$g_avBuildingUpgrades[$inum][3] = "Gold"
Case 2
$g_avBuildingUpgrades[$inum][3] = "Elixir"
Case 3
$g_avBuildingUpgrades[$inum][3] = "Dark"
Case Else
SetLog("Silly programmer made an error!", $COLOR_WARNING)
$g_avBuildingUpgrades[$inum][3] = "HaHa"
EndSwitch
SetLog("User selected type = " & $g_avBuildingUpgrades[$inum][3], $COLOR_DEBUG)
EndIf
If $g_avBuildingUpgrades[$inum][2] = "" Or $g_avBuildingUpgrades[$inum][3] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then
SetLog("Error finding loot info " & $inum & ", Loot = " & $g_avBuildingUpgrades[$inum][2] & ", Type= " & $g_avBuildingUpgrades[$inum][3], $COLOR_ERROR)
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
ClickP($aAway, 2, 0, "#0218")
Return False
EndIf
SetLog("Upgrade #" & $inum + 1 & " Value = " & _NumberFormat($g_avBuildingUpgrades[$inum][2]) & " " & $g_avBuildingUpgrades[$inum][3], $COLOR_INFO)
Else
If $g_abUpgradeRepeatEnable[$inum] = False Then
SetLog("Upgrade selection problem - data cleared, please try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
SetLog("Repeat upgrade problem - will retry value update later", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0219")
Return False
EndIf
ClickP($aAway, 2, 200, "#0220")
Switch $g_avBuildingUpgrades[$inum][3]
Case "Gold"
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnGold)
Case "Elixir"
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnElixir)
Case "Dark"
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnDark)
Case Else
_GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnBlank)
EndSwitch
GUICtrlSetData($g_hTxtUpgradeValue[$inum], _NumberFormat($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeTime[$inum], StringStripWS($g_avBuildingUpgrades[$inum][6], $STR_STRIPALL))
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], $g_avBuildingUpgrades[$inum][7])
Return True
EndFunc
Func ClearUpgradeInfo($inum)
$g_aiPicUpgradeStatus[$inum] = $eIcnTroops
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][2] = 0
$g_avBuildingUpgrades[$inum][3] = ""
$g_avBuildingUpgrades[$inum][4] = ""
$g_avBuildingUpgrades[$inum][5] = ""
$g_avBuildingUpgrades[$inum][6] = ""
$g_avBuildingUpgrades[$inum][7] = ""
EndFunc
Func LocateClanCastle($bCollect = True)
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
SetLog("Locating Clan Castle", $COLOR_INFO)
WinGetAndroidHandle()
checkMainScreen()
If $bCollect Then Collect(False)
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Clan_Castle_01", "Click OK then click on your Clan Castle") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", "Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", "Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Clan_Castle_02", "Locate Clan Castle"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0373")
Local $aPos = FindPos()
$g_aiClanCastlePos[0] = $aPos[0]
$g_aiClanCastlePos[1] = $aPos[1]
If Not isInsideDiamond($g_aiClanCastlePos) Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Clan Castle Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0374")
Return False
Case Else
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")", $COLOR_ERROR)
$g_aiClanCastlePos[0] = -1
$g_aiClanCastlePos[1] = -1
ClickP($aAway, 1, 0, "#0375")
Return False
EndSelect
EndIf
SetLog("Clan Castle: " & "(" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Clan Castle Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0376")
Return
EndIf
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If IsArray($sInfo) and($sInfo[0] > 1 Or $sInfo[0] = "") Then
If StringInStr($sInfo[1], "clan") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Clan Castle?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Clan Castle, or restart bot and try again", $COLOR_ERROR)
$g_aiClanCastlePos[0] = -1
$g_aiClanCastlePos[1] = -1
ClickP($aAway, 1, 0, "#0377")
Return False
EndSelect
EndIf
If $sInfo[2] = "Broken" Then
SetLog("You did not rebuild your Clan Castle yet", $COLOR_ACTION)
Else
SetLog("Your Clan Castle is at level: " & $sInfo[2], $COLOR_SUCCESS)
EndIf
Else
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $g_aiClanCastlePos[0] & "," & $g_aiClanCastlePos[1] & ")", $COLOR_ERROR)
$g_aiClanCastlePos[0] = -1
$g_aiClanCastlePos[1] = -1
ClickP($aAway, 1, 0, "#0378")
Return False
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 200, "#0327")
EndFunc
Func LocateLab($bCollect = True)
Local $stext, $MsgBox, $iStupid = 0, $iSilly = 0, $sErrorText = ""
SetLog("Locating Laboratory", $COLOR_INFO)
WinGetAndroidHandle()
checkMainScreen()
If $bCollect Then Collect(False)
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Laboratory_01", "Click OK then click on your Laboratory building") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", -1) & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Laboratory_02", "Locate Laboratory"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0379")
Local $aPos = FindPos()
$g_aiLaboratoryPos[0] = Int($aPos[0])
$g_aiLaboratoryPos[1] = Int($aPos[1])
If isInsideDiamond($g_aiLaboratoryPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Laboratory Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Laboratory Location.", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0380")
Return False
EndSelect
EndIf
Else
SetLog("Locate Laboratory Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0382")
Return
EndIf
Local $sLabInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If $sLabInfo[0] > 1 Or $sLabInfo[0] = "" Then
If StringInStr($sLabInfo[1], "Lab") = 0 Then
Local $sLocMsg =($sLabInfo[0] = "" ? "Nothing" : $sLabInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the laboratory?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Ok, you really think that's a Laboratory?" & @CRLF & "I don't care anymore, go ahead with it!", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0383")
ExitLoop
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Laboratory Location: " & "(" & $g_aiLaboratoryPos[0] & "," & $g_aiLaboratoryPos[1] & ")", $COLOR_ERROR)
$g_aiLaboratoryPos[0] = -1
$g_aiLaboratoryPos[1] = -1
ClickP($aAway, 1, 0, "#0384")
Return False
EndIf
SetLog("Locate Laboratory Success: " & "(" & $g_aiLaboratoryPos[0] & "," & $g_aiLaboratoryPos[1] & ")", $COLOR_SUCCESS)
ExitLoop
WEnd
Clickp($aAway, 2, 0, "#0207")
EndFunc
Func LocateTownHall($bLocationOnly = False, $bCollect = True)
Local $sMsgBoxText, $MsgBox, $bGotTHLevel, $sLocMsg
Local $iStupid = 0, $iSilly = 0, $sErrorText = ""
SetLog("Locating Town Hall", $COLOR_INFO)
WinGetAndroidHandle()
checkMainScreen()
If $bCollect Then Collect(False)
While 1
_ExtMsgBoxSet(1 + 64, 1, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$sMsgBoxText = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_TownHall_01", "Click OK then click on your Town Hall") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", -1) & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_TownHall_02", "Locate TownHall"), $sMsgBoxText, 30)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0391")
Local $aPos = FindPos()
$g_aiTownHallPos[0] = $aPos[0]
$g_aiTownHallPos[1] = $aPos[1]
If _Sleep($DELAYLOCATETH1) Then Return
If Not isInsideDiamond($g_aiTownHallPos) Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "TownHall Location not valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")?" & @CRLF & "Please stop!" & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Townhall Location: " & "(" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_ERROR)
$g_aiTownHallPos[0] = -1
$g_aiTownHallPos[1] = -1
ClickP($aAway, 1, 0, "#0392")
Return False
EndSelect
EndIf
SetLog("Townhall: " & "(" & $g_aiTownHallPos[0] & "," & $g_aiTownHallPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate TownHall Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0393")
Return
EndIf
If Not $bLocationOnly Then
$bGotTHLevel = GetTownHallLevel()
$iSilly += 1
If IsArray($bGotTHLevel) Or Not $bGotTHLevel Then
If Not $bGotTHLevel Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $bGotTHLevel[1]
EndIf
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not a TownHall?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click on the TH, or restart bot and try again", $COLOR_ERROR)
$g_aiTownHallPos[0] = -1
$g_aiTownHallPos[1] = -1
ClickP($aAway, 1, 0, "#0394")
Return False
EndSelect
Else
SetLog("Locate TH Success!", $COLOR_SUCCESS)
EndIf
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 50, "#0209")
EndFunc
Func LocateQueenAltar($bCollect = True)
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateQueenAltar 1")
Local $Result = _LocateQueenAltar($bCollect)
$g_bRunState = $wasRunState
AndroidShield("LocateQueenAltar 2")
Return $Result
EndFunc
Func _LocateQueenAltar($bCollect = True)
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
WinGetAndroidHandle()
checkMainScreen(False)
If $bCollect Then Collect(False)
SetLog("Locating Queen Altar", $COLOR_INFO)
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Queen_Altar_01", "Click OK then click on your Queen Altar") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", -1) & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", -1) & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Queen_Altar_02", "Locate Queen Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway)
Local $aPos = FindPos()
$g_aiQueenAltarPos[0] = $aPos[0]
$g_aiQueenAltarPos[1] = $aPos[1]
If Not isInsideDiamond($g_aiQueenAltarPos) Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Queen Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aAway)
Return False
Case Else
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")", $COLOR_ERROR)
$g_aiQueenAltarPos[0] = -1
$g_aiQueenAltarPos[1] = -1
ClickP($aAway)
Return False
EndSelect
EndIf
SetLog("Queen Altar: " & "(" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Queen Altar Cancelled", $COLOR_INFO)
ClickP($aAway)
Return
EndIf
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While Not IsArray($sInfo)
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If @error Then Return SetError(0, 0, 0)
If StringInStr($sInfo[1], "Quee") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Queen Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Queen Altar, or restart bot and try again", $COLOR_ERROR)
$g_aiQueenAltarPos[0] = -1
$g_aiQueenAltarPos[1] = -1
ClickP($aAway)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $g_aiQueenAltarPos[0] & "," & $g_aiQueenAltarPos[1] & ")", $COLOR_ERROR)
$g_aiQueenAltarPos[0] = -1
$g_aiQueenAltarPos[1] = -1
ClickP($aAway)
Return False
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslatedFileIni("MBR Popups", "Locate_building_03", "Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Locate_building_04", "Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xQueenAltarPos", $g_aiQueenAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yQueenAltarPos", $g_aiQueenAltarPos[1])
EndFunc
Func LocateKingAltar($bCollect = True)
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateKingAltar 1")
Local $Result = _LocateKingAltar($bCollect)
$g_bRunState = $wasRunState
AndroidShield("LocateKingAltar 2")
Return $Result
EndFunc
Func _LocateKingAltar($bCollect = True)
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
WinGetAndroidHandle()
checkMainScreen(False)
If $bCollect Then Collect(False)
SetLog("Locating King Altar", $COLOR_INFO)
While 1
ClickP($aAway)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_King_Altar_01", "Click OK then click on your King Altar") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", "Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", "Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_King_Altar_02", "Locate King Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
Local $aPos = FindPos()
$g_aiKingAltarPos[0] = $aPos[0]
$g_aiKingAltarPos[1] = $aPos[1]
If Not isInsideDiamond($g_aiKingAltarPos) Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "King Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aAway)
Return False
Case Else
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")", $COLOR_ERROR)
$g_aiKingAltarPos[0] = -1
$g_aiKingAltarPos[1] = -1
ClickP($aAway)
Return False
EndSelect
EndIf
SetLog("King Altar: " & "(" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate King Altar Cancelled", $COLOR_INFO)
ClickP($aAway)
Return
EndIf
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While Not IsArray($sInfo)
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If(StringInStr($sInfo[1], "Barb") = 0) And(StringInStr($sInfo[1], "King") = 0) Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the King Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the King Altar, or restart bot and try again", $COLOR_ERROR)
$g_aiKingAltarPos[0] = -1
$g_aiKingAltarPos[1] = -1
ClickP($aAway)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $g_aiKingAltarPos[0] & "," & $g_aiKingAltarPos[1] & ")", $COLOR_ERROR)
$g_aiKingAltarPos[0] = -1
$g_aiKingAltarPos[1] = -1
ClickP($aAway)
Return False
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslatedFileIni("MBR Popups", "Locate_building_03", "Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Locate_building_04", "Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xKingAltarPos", $g_aiKingAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yKingAltarPos", $g_aiKingAltarPos[1])
EndFunc
Func LocateWardenAltar($bCollect = True)
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateWardenAltar 1")
Local $Result = _LocateWardenAltar($bCollect)
$g_bRunState = $wasRunState
AndroidShield("LocateWardenAltar 2")
Return $Result
EndFunc
Func _LocateWardenAltar($bCollect = True)
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
If Number($g_iTownHallLevel) < 11 Then
SetLog("Grand Warden requires TH11! Stop locating Altar", $COLOR_ERROR)
Return
EndIf
WinGetAndroidHandle()
checkMainScreen(False)
If $bCollect Then Collect(False)
SetLog("Locating Grand Warden Altar", $COLOR_INFO)
While 1
ClickP($aAway)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslatedFileIni("MBR Popups", "Func_Locate_Warden_Altar_01", "Click OK then click on your Grand Warden Altar") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_01", "Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslatedFileIni("MBR Popups", "Locate_building_02", "Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslatedFileIni("MBR Popups", "Ok_Cancel", "Ok|Cancel"), GetTranslatedFileIni("MBR Popups", "Func_Locate_Warden_Altar_02", "Locate Grand Warden Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
Local $aPos = FindPos()
$g_aiWardenAltarPos[0] = $aPos[0]
$g_aiWardenAltarPos[1] = $aPos[1]
If Not isInsideDiamond($g_aiWardenAltarPos) Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Grand Warden Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aAway)
Return False
Case Else
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")", $COLOR_ERROR)
$g_aiWardenAltarPos[0] = -1
$g_aiWardenAltarPos[1] = -1
ClickP($aAway)
Return False
EndSelect
EndIf
SetLog("Grand Warden Altar: " & "(" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Grand Warden Altar Cancelled", $COLOR_INFO)
ClickP($aAway)
Return
EndIf
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While Not IsArray($sInfo)
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If @error Then Return SetError(0, 0, 0)
If StringInStr($sInfo[1], "Warden") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Grand Warden Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Grand Warden Altar, or restart bot and try again", $COLOR_ERROR)
$g_aiWardenAltarPos[0] = -1
$g_aiWardenAltarPos[1] = -1
ClickP($aAway)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $g_aiWardenAltarPos[0] & "," & $g_aiWardenAltarPos[1] & ")", $COLOR_ERROR)
$g_aiWardenAltarPos[0] = -1
$g_aiWardenAltarPos[1] = -1
ClickP($aAway)
Return False
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslatedFileIni("MBR Popups", "Locate_building_03", "Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslatedFileIni("MBR Popups", "Ok", "Ok"), GetTranslatedFileIni("MBR Popups", "Locate_building_04", "Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xWardenAltarPos", $g_aiWardenAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yWardenAltarPos", $g_aiWardenAltarPos[1])
EndFunc
Func ProfileReport()
Local $iAttacksWon = 0, $iDefensesWon = 0
Local $iCount
ClickP($aAway, 1, 0, "#0221")
If _Sleep($DELAYPROFILEREPORT1) Then Return
SetLog("Profile Report", $COLOR_INFO)
SetLog("Opening Profile page to read Attacks, Defenses, Donations and Recieved Troops", $COLOR_INFO)
Click(30, 40, 1, 0, "#0222")
If _Sleep($DELAYPROFILEREPORT2) Then Return
While Not _ColorCheck(_GetPixelColor(252, 69, True), Hex(0xEEEEE9, 6), 5)
$iCount += 1
If _Sleep($DELAYPROFILEREPORT1) Then Return
If $iCount >= 25 Then ExitLoop
WEnd
If $iCount >= 25 Then SetDebugLog("Profile Page did not open after " & $iCount & " Loops", $COLOR_DEBUG)
Local $aSearchResult
For $i = 0 to 1
$aSearchResult = decodeSingleCoord(findImage("CollectReward", $g_sImgCollectReward, GetDiamondFromRect("680,165,855,680"), 1, True))
If IsArray($aSearchResult) And UBound($aSearchResult) = 2 Then
Click($aSearchResult[0], $aSearchResult[1])
SetLog("Reward collected", $COLOR_SUCCESS)
For $i = 0 To 9
ClickDrag(421, 200, 421, 630, 2000)
If _Sleep(2000) Then Return
If _ColorCheck(_GetPixelColor($aCheckTopProfile[0], $aCheckTopProfile[1], True), Hex($aCheckTopProfile[2], 6), $aCheckTopProfile[3])= True And _ColorCheck(_GetPixelColor($aCheckTopProfile2[0], $aCheckTopProfile2[1], True), Hex($aCheckTopProfile2[2], 6), $aCheckTopProfile2[3]) = True Then ExitLoop
Next
ExitLoop
EndIf
If _Sleep($DELAYPROFILEREPORT1) Then Return
Next
If _Sleep($DELAYPROFILEREPORT1) Then Return
$iAttacksWon = ""
If _ColorCheck(_GetPixelColor($aProfileReport[0], $aProfileReport[1], True), Hex($aProfileReport[2], 6), $aProfileReport[3]) Then
SetDebugLog("Profile seems to be currently unranked", $COLOR_DEBUG)
$iAttacksWon = 0
$iDefensesWon = 0
Else
$iAttacksWon = getProfile(575, 346)
If $g_bDebugSetlog Then SetDebugLog("$iAttacksWon: " & $iAttacksWon, $COLOR_DEBUG)
$iCount = 0
While $iAttacksWon = ""
If _Sleep($DELAYPROFILEREPORT1) Then Return
$iAttacksWon = getProfile(575, 346)
If $g_bDebugSetlog Then SetDebugLog("Read Loop $iAttacksWon: " & $iAttacksWon & ", Count: " & $iCount, $COLOR_DEBUG)
$iCount += 1
If $iCount >= 20 Then ExitLoop
WEnd
If $g_bDebugSetlog And $iCount >= 20 Then SetLog("Excess wait time for reading $AttacksWon: " & getProfile(578, 347), $COLOR_DEBUG)
$iDefensesWon = getProfile(789, 346)
EndIf
$g_iTroopsDonated = getProfile(156, 346)
$g_iTroopsReceived = getProfile(357, 346)
SetLog(" [ATKW]: " & _NumberFormat($iAttacksWon) & " [DEFW]: " & _NumberFormat($iDefensesWon) & " [TDON]: " & _NumberFormat($g_iTroopsDonated) & " [TREC]: " & _NumberFormat($g_iTroopsReceived), $COLOR_SUCCESS)
Click(830, 80, 1, 0, "#0223")
If _Sleep($DELAYPROFILEREPORT3) Then Return
$iCount = 0
While Not _CheckPixel($aIsMain, $g_bCapturePixel)
If _Sleep($DELAYPROFILEREPORT3) Then Return
$iCount += 1
If $iCount > 50 Then
SetDebugLog("Main Window did not appear after " & $iCount & " Loops", $COLOR_DEBUG)
ExitLoop
EndIf
WEnd
EndFunc
Func IsRequestDefense()
If Not $g_bRequestCCDefense Then Return
Local $bRequestDefense = False
Local $sTime = $g_bRequestCCDefenseWhenPB ? $g_sPBStartTime : $g_asShieldStatus[2]
If Not $g_bRequestCCDefenseWhenPB And $g_asShieldStatus[0] = "none" Then
$bRequestDefense = True
SetLog("No shield!", $COLOR_INFO)
ElseIf _DateIsValid($sTime) Then
Local $iTime = Int(_DateDiff('n', _NowCalc(), $sTime))
If Not $g_bRequestCCDefenseWhenPB And $g_asShieldStatus[0] = "shield" Then $iTime += 30
SetDebugLog(($g_bRequestCCDefenseWhenPB ? "Personal Break time: " : "Guard time: ") & $sTime & "(" & $iTime & " minutes)")
If $iTime <= $g_iRequestDefenseTime Then
SetLog(($g_bRequestCCDefenseWhenPB ? "P.Break is about to come!" : "Guard is about to expire!"), $COLOR_INFO)
$bRequestDefense = True
EndIf
EndIf
If $bRequestDefense Then
SetDebugLog("Loading defense CC request variable: ")
$g_sRequestTroopsText = $g_sRequestCCDefenseText
SetDebugLog("    $g_sRequestTroopsText: " & $g_sRequestTroopsText)
$g_abRequestType[0] = True
$g_abRequestType[1] = False
$g_abRequestType[2] = False
$g_iRequestCountCCTroop = 0
$g_aiClanCastleTroopWaitType = $g_aiCCTroopDefenseType
SetDebugLog("    Expecting troops (" & _ArrayToString($g_aiClanCastleTroopWaitType)& "):")
For $i = 0 To $eTroopCount - 1
$g_aiCCTroopsExpected[$i] = $g_aiCCTroopsExpectedForDefense[$i]
If $g_aiCCTroopsExpected[$i] > 0 Then SetDebugLog("      - " & $g_asTroopNames[$i] & " x" & $g_aiCCTroopsExpected[$i])
Next
If $g_bSaveCCTroopForDefense Then
For $i = 0 To $g_iModeCount - 1
If $g_abAttackDropCC[$i] Then $g_abAttackDropCC[$i] = False
Next
SetDebugLog("    Disable $g_abAttackDropCC (" & _ArrayToString($g_abAttackDropCC)& ")")
EndIf
ElseIf $g_sRequestTroopsText = $g_sRequestCCDefenseText Then
SetDebugLog("Reloading offense CC request variable: ")
ReadConfig_600_11()
SetDebugLog("    $g_sRequestTroopsText: " & $g_sRequestTroopsText)
SetDebugLog("    $g_abRequestType: " & _ArrayToString($g_abRequestType))
SetDebugLog("    Expecting troops (" & _ArrayToString($g_aiClanCastleTroopWaitType)& "):")
If $g_abRequestType[0] Or _ArrayMin($g_aiClanCastleTroopWaitType) < $eTroopCount Then
For $i = 0 To $eTroopCount - 1
If $g_aiCCTroopsExpected[$i] > 0 Then SetDebugLog("      - " & $g_asTroopNames[$i] & " x" & $g_aiCCTroopsExpected[$i])
Next
EndIf
If $g_bSaveCCTroopForDefense Then
IniReadS($g_abAttackDropCC[$DB], $g_sProfileConfigPath, "attack", "DBDropCC", False, "Bool")
IniReadS($g_abAttackDropCC[$LB], $g_sProfileConfigPath, "attack", "ABDropCC", False, "Bool")
SetDebugLog("    Reloading $g_abAttackDropCC (" & _ArrayToString($g_abAttackDropCC)& ")")
EndIf
EndIf
Return $bRequestDefense
EndFunc
Func RequestCC($bClickPAtEnd = True, $sText = "")
If(Not $g_bRequestTroopsEnable Or Not $g_bDonationEnabled) And(Not $g_bRequestCCDefense) Then
Return
Else
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abRequestCCHours[$hour[0]] = False Then
SetLog("Request Clan Castle troops not planned, Skipped..", $COLOR_ACTION)
Return
EndIf
EndIf
If $sText <> "IsFullClanCastle" Then
If Not OpenArmyOverview(True, "RequestCC()") Then Return
If IsRequestDefense() Then SetLog("Time for defense")
EndIf
If _Sleep($DELAYREQUESTCC1) Then Return
SetLog("Requesting Clan Castle reinforcements", $COLOR_INFO)
checkAttackDisable($g_iTaBChkIdle)
If $bClickPAtEnd Then CheckCCArmy()
Local $sSearchDiamond = GetDiamondFromRect("600,430,850,620")
Local Static $aRequestButtonPos[2] = [-1, -1]
Local $aRequestButton = findMultiple($g_sImgRequestCCButton, $sSearchDiamond, $sSearchDiamond, 0, 1000, 1, "objectname,objectpoints", True)
If Not IsArray($aRequestButton) Then
SetLog("Error in RequestCC(): $aRequestButton is no Array")
Return
EndIf
If UBound($aRequestButton, 1) >= 1 Then
Local $sButtonState
Local $aRequestButtonSubResult = $aRequestButton[0]
$sButtonState = $aRequestButtonSubResult[0]
If $aRequestButtonPos[0] = -1 Then
$aRequestButtonPos = StringSplit($aRequestButtonSubResult[1], ",", $STR_NOCOUNT)
EndIf
If StringInStr($sButtonState, "Available", 0) > 0 Then
Local $bNeedRequest = False
If Not $g_abRequestType[0] And Not $g_abRequestType[1] And Not $g_abRequestType[2] Then
SetDebugLog("Request for Specific CC is not enable")
$bNeedRequest = True
ElseIf Not $bClickPAtEnd Then
$bNeedRequest = True
Else
For $i = 0 To 2
If Not IsFullClanCastleType($i) Then
$bNeedRequest = True
ExitLoop
EndIf
Next
EndIf
If $bNeedRequest Then
Local $x = _makerequest($aRequestButtonPos)
EndIf
ElseIf StringInStr($sButtonState, "Already", 0) > 0 Then
SetLog("Clan Castle Request has already been made", $COLOR_INFO)
ElseIf StringInStr($sButtonState, "Full", 0) > 0 Then
SetLog("Clan Castle is full or not available", $COLOR_INFO)
Else
SetLog("Error in RequestCC(): Couldn't detect Request Button State", $COLOR_ERROR)
EndIf
Else
SetLog("Error in RequestCC(): $aRequestButton did not return a Button State", $COLOR_ERROR)
EndIf
If _Sleep($DELAYREQUESTCC1) Then Return
If $bClickPAtEnd Then ClickP($aAway, 2, 0, "#0335")
EndFunc
Func _makerequest($aButtonPosition)
ClickP($aButtonPosition, 1, 0, "0336")
Local $iCount = 0
While Not( _ColorCheck(_GetPixelColor($aCancRequestCCBtn[0], $aCancRequestCCBtn[1], True), Hex($aCancRequestCCBtn[2], 6), $aCancRequestCCBtn[3]))
If _Sleep($DELAYMAKEREQUEST1) Then ExitLoop
$iCount += 1
If $g_bDebugSetlog Then SetDebugLog("$icount2 = " & $iCount & ", " & _GetPixelColor($aCancRequestCCBtn[0], $aCancRequestCCBtn[1], True), $COLOR_DEBUG)
If $iCount > 20 Then ExitLoop
WEnd
If $iCount > 20 Then
SetLog("Request has already been made, or request window not available", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0257")
If _Sleep($DELAYMAKEREQUEST2) Then Return
Else
If $g_sRequestTroopsText <> "" Then
If Not $g_bChkBackgroundMode And Not $g_bNoFocusTampering Then ControlFocus($g_hAndroidWindow, "", "")
AndroidSendText($g_sRequestTroopsText, True)
Click($atxtRequestCCBtn[0], $atxtRequestCCBtn[1], 1, 0, "#0254")
_Sleep($DELAYMAKEREQUEST2)
If SendText($g_sRequestTroopsText) = 0 Then
SetLog(" Request text entry failed, try again", $COLOR_ERROR)
Return
EndIf
EndIf
If _Sleep($DELAYMAKEREQUEST2) Then Return
$iCount = 0
While Not _ColorCheck(_GetPixelColor($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], True), Hex(0x5fac10, 6), 20)
If _Sleep($DELAYMAKEREQUEST1) Then ExitLoop
$iCount += 1
If $g_bDebugSetlog Then SetDebugLog("$icount3 = " & $iCount & ", " & _GetPixelColor($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], True), $COLOR_DEBUG)
If $iCount > 25 Then ExitLoop
WEnd
If $iCount > 25 Then
If $g_bDebugSetlog Then SetDebugLog("Send request button not found", $COLOR_DEBUG)
CheckMainScreen(False)
EndIf
If $g_bChkBackgroundMode = False And $g_bNoFocusTampering = False Then ControlFocus($g_hAndroidWindow, "", "")
Click($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], 1, 100, "#0256")
$g_bCanRequestCC = False
EndIf
EndFunc
Func IsFullClanCastleType($CCType = 0)
Local $aCheckCCNotFull[3] = [24, 455, 631], $sLog[3] = ["Troop", "Spell", "Siege Machine"]
Local $aiRequestCountCC[3] = [Number($g_iRequestCountCCTroop), Number($g_iRequestCountCCSpell), 0]
Local $bCheckOnlyTroop = $g_abRequestType[0] = False And $g_abRequestType[1] = False And $g_abRequestType[2] = False
If Not $g_abRequestType[$CCType] And($g_abRequestType[0] Or $g_abRequestType[1] Or $g_abRequestType[2] Or($bCheckOnlyTroop And $CCType <> 0)) Then
If $g_bDebugSetlog Then SetLog($sLog[$CCType] & " not cared about.")
Return True
Else
If _ColorCheck(_GetPixelColor($aCheckCCNotFull[$CCType], 470, True), Hex(0xDC363A, 6), 30) Then
SetDebugLog("Found CC " & $sLog[$CCType] & " not full")
Local $iTotalExpectedTroop = 0, $iTotalExpectedSpell = 0
For $i = 0 To $eTroopCount - 1
$iTotalExpectedTroop += $g_aiCCTroopsExpected[$i] * $g_aiTroopSpace[$i]
If $i <= $eSpellCount - 1 Then $iTotalExpectedSpell += $g_aiCCSpellsExpected[$i] * $g_aiSpellSpace[$i]
Next
If $aiRequestCountCC[0] > $iTotalExpectedTroop And $iTotalExpectedTroop > 0 Then $aiRequestCountCC[0] = $iTotalExpectedTroop
If $aiRequestCountCC[1] > $iTotalExpectedSpell And $iTotalExpectedSpell > 0 Then $aiRequestCountCC[1] = $iTotalExpectedSpell
If $aiRequestCountCC[$CCType] = 0 Or $aiRequestCountCC[$CCType] >= 40 - $CCType * 38 Then
Return False
Else
Local $sCCReceived = getOcrAndCapture("coc-ms", 289 + $CCType * 183, 468, 60, 16, True, False, True)
SetDebugLog("Read CC " & $sLog[$CCType] & "s: " & $sCCReceived)
Local $aCCReceived = StringSplit($sCCReceived, "#", $STR_NOCOUNT)
If IsArray($aCCReceived) Then
If $g_bDebugSetlog Then SetLog("Already received " & Number($aCCReceived[0]) & " CC " & $sLog[$CCType] &(Number($aCCReceived[0]) <= 1 ? "." : "s."))
If Number($aCCReceived[0]) >= $aiRequestCountCC[$CCType] Then
SetLog("CC " & $sLog[$CCType] & " is sufficient as required (" & Number($aCCReceived[0]) & "/" & $aiRequestCountCC[$CCType] & ")")
Return True
EndIf
EndIf
EndIf
Else
SetLog("CC " & $sLog[$CCType] & " is full" &($CCType > 0 ? " or not available." : "."))
Return True
EndIf
EndIf
EndFunc
Func IsFullClanCastle()
Local $bNeedRequest = False
If Not $g_bRunState Then Return
If Not $g_abSearchCastleWaitEnable[$DB] And Not $g_abSearchCastleWaitEnable[$LB] Then
Return True
EndIf
If($g_abAttackTypeEnable[$DB] And $g_abSearchCastleWaitEnable[$DB]) Or($g_abAttackTypeEnable[$LB] And $g_abSearchCastleWaitEnable[$LB]) Then
Local $bRequestDefense = IsRequestDefense()
CheckCCArmy()
For $i = 0 To 2
If Not IsFullClanCastleType($i) Then
$bNeedRequest = True
ExitLoop
EndIf
Next
If $bNeedRequest Then
$g_bCanRequestCC = True
RequestCC(False, "IsFullClanCastle")
If $bRequestDefense Then
SetLog("Time for defense, skip waiting full CC to attack")
Return True
Else
Return False
EndIf
EndIf
EndIf
Return True
EndFunc
Func CheckCCArmy()
Local $bSkipTroop = Not $g_abRequestType[0] Or _ArrayMin($g_aiClanCastleTroopWaitType) = $eTroopCount
Local $bSkipSpell = Not $g_abRequestType[1] Or _ArrayMin($g_aiClanCastleSpellWaitType) = $eSpellCount
Local $bSkipSiege = Not $g_abRequestType[2] Or _ArrayMin($g_aiClanCastleSiegeWaitType) = $eSiegeMachineCount
If $bSkipTroop And $bSkipSpell And $bSkipSiege Then Return
Local $bNeedRemove = False, $aToRemove[8][2]
Local $aTroopWSlot, $aSpellWSlot
For $i = 0 To 2
If $g_aiClanCastleTroopWaitQty[$i] = 0 And $g_aiClanCastleTroopWaitType[$i] < $eTroopCount Then $g_aiCCTroopsExpected[$g_aiClanCastleTroopWaitType[$i]] = 40
Next
SetLog("Getting current army in Clan Castle...")
If Not $bSkipTroop Then $aTroopWSlot = getArmyCCTroops(False, False, False, True, True, True)
If Not $bSkipSpell Then $aSpellWSlot = getArmyCCSpells(False, False, False, True, True, True)
If Not $bSkipSiege Then getArmyCCSiegeMachines()
If IsArray($aTroopWSlot) Then
For $i = 0 To $eTroopCount - 1
Local $iUnwanted = $g_aiCurrentCCTroops[$i] - $g_aiCCTroopsExpected[$i]
If $g_aiCurrentCCTroops[$i] > 0 Then SetDebugLog("Expecting " & $g_asTroopNames[$i] & ": " & $g_aiCCTroopsExpected[$i] & "x. Received: " & $g_aiCurrentCCTroops[$i])
If $iUnwanted > 0 Then
If Not $bNeedRemove Then
SetLog("Removing unexpected CC army:")
$bNeedRemove = True
EndIf
For $j = 0 To UBound($aTroopWSlot) - 1
If $j > 4 Then ExitLoop
If $aTroopWSlot[$j][1] = $i Then
$aToRemove[$j][0] = $aTroopWSlot[$j][0]
$aToRemove[$j][1] = _Min($aTroopWSlot[$j][2], $iUnwanted)
$iUnwanted -= $aToRemove[$j][1]
SetLog(" - " & $aToRemove[$j][1] & "x " &($aToRemove[$j][1] > 1 ? $g_asTroopNamesPlural[$i] : $g_asTroopNames[$i]) &($g_bDebugSetlog ?(", at slot " & $j & ", x" & $aToRemove[$j][0] + 35) : ""))
EndIf
Next
EndIf
Next
EndIf
If IsArray($aSpellWSlot) Then
For $i = 0 To $eSpellCount - 1
Local $iUnwanted = $g_aiCurrentCCSpells[$i] - $g_aiCCSpellsExpected[$i]
If $g_aiCurrentCCSpells[$i] > 0 Then SetDebugLog("Expecting " & $g_asSpellNames[$i] & ": " & $g_aiCCSpellsExpected[$i] & "x. Received: " & $g_aiCurrentCCSpells[$i])
If $iUnwanted > 0 Then
If Not $bNeedRemove Then
SetLog("Removing unexpected CC spells/siege machine:")
$bNeedRemove = True
EndIf
For $j = 0 To UBound($aSpellWSlot) - 1
If $j > 1 Then ExitLoop
If $aSpellWSlot[$j][1] = $i Then
$aToRemove[$j + 5][0] = $aSpellWSlot[$j][0]
$aToRemove[$j + 5][1] = _Min($aSpellWSlot[$j][2], $iUnwanted)
$iUnwanted -= $aToRemove[$j + 5][1]
SetLog(" - " & $aToRemove[$j + 5][1] & "x " & $g_asSpellNames[$i] &($aToRemove[$j + 5][1] > 1 ? " spells" : " spell") &($g_bDebugSetlog ?(", at slot " & $j + 5 & ", x" & $aToRemove[$j + 5][0] + 35) : ""))
EndIf
Next
EndIf
Next
EndIf
If Not $bSkipSiege Then
For $i = 0 To $eSiegeMachineCount - 1
If $g_aiCurrentCCSiegeMachines[$i] > 0 Then SetDebugLog("Expecting " & $g_asSiegeMachineNames[$i] & ": " & $g_aiCCSiegeExpected[$i] & "x. Received: " & $g_aiCurrentCCSiegeMachines[$i])
If $g_aiCurrentCCSiegeMachines[$i] > $g_aiCCSiegeExpected[$i] Then
If Not $bNeedRemove Then
SetLog("Removing unexpected CC siege machine:")
$bNeedRemove = True
EndIf
$aToRemove[7][1] = 1
SetLog(" - " & $aToRemove[7][1] & "x " & $g_asSiegeMachineNames[$i])
ExitLoop
EndIf
Next
EndIf
If $bNeedRemove Then
RemoveCastleArmy($aToRemove)
If _Sleep(1000) Then Return
EndIf
EndFunc
Func RemoveCastleArmy($aToRemove)
If _ArrayMax($aToRemove, 0, -1, -1, 1) = 0 Then Return
If Not _CheckPixel($aButtonEditArmy, True) Then
SetLog("Cannot find/verify 'Edit Army' Button in Army tab", $COLOR_WARNING)
Return False
EndIf
ClickP($aButtonEditArmy, 1)
If Not $g_bRunState Then Return
If _Sleep(500) Then Return
Local $aPos[2] = [35, 575]
For $i = 0 To UBound($aToRemove) - 1
If $aToRemove[$i][1] > 0 Then
$aPos[0] = $aToRemove[$i][0] + 35
If $i = 7 Then $aPos[0] = 685
SetDebugLog(" - Click at slot " & $i & ". (" & $aPos[0] & ") x " & $aToRemove[$i][1])
ClickRemoveTroop($aPos, $aToRemove[$i][1], $g_iTrainClickDelay)
EndIf
Next
If _Sleep(400) Then Return
Local $counter = 0
While Not _CheckPixel($aButtonRemoveTroopsOK1, True)
If _Sleep(200) Then Return
$counter += 1
If $counter <= 5 Then ContinueLoop
SetLog("Cannot find/verify 'Okay' Button in Army tab", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(400) Then OpenArmyOverview(True, "RemoveCastleSpell()")
Return False
WEnd
ClickP($aButtonRemoveTroopsOK1, 1)
If _Sleep(400) Then Return
$counter = 0
While Not _CheckPixel($aButtonRemoveTroopsOK2, True)
If _Sleep(200) Then Return
$counter += 1
If $counter <= 5 Then ContinueLoop
SetLog("Cannot find/verify 'Okay #2' Button in Army tab", $COLOR_WARNING)
ClickP($aAway, 2, 0, "#0346")
Return False
WEnd
ClickP($aButtonRemoveTroopsOK2, 1)
SetLog("Clan Castle army removed", $COLOR_SUCCESS)
If _Sleep(200) Then Return
Return True
EndFunc
Func VillageReport($bBypass = False, $bSuppressLog = False)
PureClickP($aAway, 1, 0, "#0319")
If _Sleep($DELAYVILLAGEREPORT1) Then Return
Switch $bBypass
Case False
If Not $bSuppressLog Then SetLog("Village Report", $COLOR_INFO)
Case True
If Not $bSuppressLog Then SetLog("Updating Village Resource Values", $COLOR_INFO)
Case Else
If Not $bSuppressLog Then SetLog("Village Report Error, You have been a BAD programmer!", $COLOR_ERROR)
EndSwitch
getBuilderCount($bSuppressLog)
If _Sleep($DELAYRESPOND) Then Return
If Not $bBypass Then getBuilderTime()
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If Not $bSuppressLog Then SetLog(" [T]: " & _NumberFormat($g_aiCurrentLoot[$eLootTrophy]), $COLOR_SUCCESS)
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$g_aiCurrentLoot[$eLootGold] = getResourcesMainScreen(696, 23)
$g_aiCurrentLoot[$eLootElixir] = getResourcesMainScreen(696, 74)
$g_aiCurrentLoot[$eLootDarkElixir] = getResourcesMainScreen(728, 123)
$g_iGemAmount = getResourcesMainScreen(740, 171)
If Not $bSuppressLog Then SetLog(" [G]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & " [E]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir]) & " [D]: " & _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir]) & " [GEM]: " & _NumberFormat($g_iGemAmount), $COLOR_SUCCESS)
Else
$g_aiCurrentLoot[$eLootGold] = getResourcesMainScreen(701, 23)
$g_aiCurrentLoot[$eLootElixir] = getResourcesMainScreen(701, 74)
$g_iGemAmount = getResourcesMainScreen(719, 123)
If Not $bSuppressLog Then SetLog(" [G]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & " [E]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir]) & " [GEM]: " & _NumberFormat($g_iGemAmount), $COLOR_SUCCESS)
If ProfileSwitchAccountEnabled() Then $g_aiCurrentLoot[$eLootDarkElixir] = ""
EndIf
If $bBypass = False Then
UpdateStats()
EndIf
Local $i = 0
While _ColorCheck(_GetPixelColor(819, 39, True), Hex(0xF8FCFF, 6), 20) = True
$i += 1
If _Sleep($DELAYVILLAGEREPORT1) Then Return
If $i >= 20 Then ExitLoop
WEnd
EndFunc
Func getBuilderTime()
Local $iBuilderTime = -1
Static $sBuilderTimeLastCheck = ""
Static $asBuilderTimeLastCheck[8] = ["", "", "", "", "", "", "", ""]
If ProfileSwitchAccountEnabled() Then $sBuilderTimeLastCheck = $asBuilderTimeLastCheck[$g_iCurAccount]
If _DateIsValid($sBuilderTimeLastCheck) And _DateIsValid($g_sNextBuilderReadyTime) And Not $g_bFirstStart Then
Local $iTimeFromLastCheck = Int(_DateDiff('n', $sBuilderTimeLastCheck, _NowCalc()))
Local $iTimeTillNextBuilderReady = Int(_DateDiff('n', _NowCalc(), $g_sNextBuilderReadyTime))
SetDebugLog("Next Builder will be ready in " & $iTimeTillNextBuilderReady & "m, (" & $g_sNextBuilderReadyTime & ")")
SetDebugLog("It has been " & $iTimeFromLastCheck & "m since last check (" & $sBuilderTimeLastCheck & ")")
If $iTimeFromLastCheck <= 6 * 60 And $iTimeTillNextBuilderReady > 0 Then
SetDebugLog("Next time to check: " & _Min(360 - Number($iTimeFromLastCheck), Number($iTimeTillNextBuilderReady)) & "m")
Return
EndIf
EndIf
If $g_iFreeBuilderCount >= $g_iTotalBuilderCount Then Return
SetLog("Getting Builder Time", $COLOR_INFO)
If IsMainPage() Then Click(293, 32)
If _Sleep(1000) Then Return
Local $sBuilderTime = QuickMIS("OCR", @ScriptDir & "\imgxml\BuilderTime", 375, 109, 447, 125, True, $g_bDebugImageSave)
If $sBuilderTime <> "none" Then
$iBuilderTime = ConvertOCRTime("Builder Time", $sBuilderTime, False)
If $g_bDebugSetlog Then SetDebugLog("$sResult QuickMIS OCR: " & $sBuilderTime & " (" & Round($iBuilderTime,2) & " minutes)")
EndIf
If $iBuilderTime > 0 Then
$g_sNextBuilderReadyTime = _DateAdd("n", $iBuilderTime, _NowCalc())
$sBuilderTimeLastCheck = _NowCalc()
Else
$g_sNextBuilderReadyTime = ""
$sBuilderTimeLastCheck = ""
EndIf
If ProfileSwitchAccountEnabled() Then
$asBuilderTimeLastCheck[$g_iCurAccount] = $sBuilderTimeLastCheck
SwitchAccountVariablesReload("Save")
EndIf
ClickP($aAway, 2, 0, "#0000")
EndFunc
Global $g_aiUpgradeLevel[$g_iUpgradeSlots] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Func UpgradeBuilding()
Local $iz = 0
Local $iUpgradeAction = -1
Local $iAvailBldr, $iAvailGold, $iAvailElixir, $iAvailDark
Local $iUpGrdEndTimeDiff = 0
Local $aCheckFrequency[10] = [5, 15, 20, 30, 60, 60, 120, 240, 240, 240]
Local $iDTDiff
Local $bChkAllRptUpgrade = False
Local $sTime
Static Local $sNextCheckTime = _DateAdd("n", -1, _NowCalc())
If @error Then _logErrorDateAdd(@error)
$g_iUpgradeMinGold = Number($g_iUpgradeMinGold)
$g_iUpgradeMinElixir = Number($g_iUpgradeMinElixir)
$g_iUpgradeMinDark = Number($g_iUpgradeMinDark)
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abBuildingUpgradeEnable[$iz] = True Then
$iUpgradeAction += 2 ^($iz + 1)
EndIf
Next
If $iUpgradeAction < 0 Then Return False
$iUpgradeAction = 0
SetLog("Checking Upgrades", $COLOR_INFO)
VillageReport(True, True)
$iAvailGold = Number($g_aiCurrentLoot[$eLootGold])
$iAvailElixir = Number($g_aiCurrentLoot[$eLootElixir])
$iAvailDark = Number($g_aiCurrentLoot[$eLootDarkElixir])
$iAvailBldr = $g_iFreeBuilderCount -($g_bAutoUpgradeWallsEnable And $g_bUpgradeWallSaveBuilder ? 1 : 0) - ReservedBuildersForHeroes()
If $iAvailBldr <= 0 Then
SetLog("No builder available for upgrade process")
Return False
EndIf
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_bDebugSetlog Then SetlogUpgradeValues($iz)
If Not $g_abBuildingUpgradeEnable[$iz] Then ContinueLoop
If $g_avBuildingUpgrades[$iz][0] <= 0 Or $g_avBuildingUpgrades[$iz][1] <= 0 Or $g_avBuildingUpgrades[$iz][3] = "" Then ContinueLoop
If $iAvailBldr <= 0 And Not $bChkAllRptUpgrade Then
SetLog("No builder available for #" & $iz + 1 & ", " & $g_avBuildingUpgrades[$iz][4])
Return False
EndIf
If $g_abUpgradeRepeatEnable[$iz] Then
If $bChkAllRptUpgrade = False Then
$iDTDiff = Int(_DateDiff("n", _NowCalc(), $sNextCheckTime))
If @error Then _logErrorDateDiff(@error)
If $g_bDebugSetlog Then
SetDebugLog("Delay time between repeat upgrade checks = " & $aCheckFrequency[($g_iTownHallLevel < 3 ? 0 : $g_iTownHallLevel - 3)] & " Min", $COLOR_DEBUG)
SetDebugLog("Delay time remaining = " & $iDTDiff & " Min", $COLOR_DEBUG)
EndIf
If $iDTDiff < 0 Then
$sNextCheckTime = _DateAdd("n", $aCheckFrequency[($g_iTownHallLevel < 3 ? 0 : $g_iTownHallLevel - 3)], _NowCalc())
If @error Then _logErrorDateAdd(@error)
$bChkAllRptUpgrade = True
If $g_bDebugSetlog Then SetDebugLog("New delayed check time=  " & $sNextCheckTime, $COLOR_DEBUG)
EndIf
EndIf
If _DateIsValid($g_avBuildingUpgrades[$iz][7]) Then
$iUpGrdEndTimeDiff = Int(_DateDiff("n", _NowCalc(), $g_avBuildingUpgrades[$iz][7]))
If @error Then
_logErrorDateDiff(@error)
$iUpGrdEndTimeDiff = 0
EndIf
If $g_bDebugSetlog Then SetDebugLog("Difference between upgrade end and NOW= " & $iUpGrdEndTimeDiff & " Min", $COLOR_DEBUG)
EndIf
If $bChkAllRptUpgrade = True Or $iUpGrdEndTimeDiff < 0 Then
If UpgradeValue($iz, True) = False Then
If $g_bDebugSetlog Then SetlogUpgradeValues($iz)
SetLog("Repeat upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " not ready yet", $COLOR_ERROR)
ContinueLoop
ElseIf($iAvailBldr <= 0) Then
SetLog("No builder available for " & $g_avBuildingUpgrades[$iz][4])
ContinueLoop
EndIf
EndIf
EndIf
SetLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Selected", $COLOR_SUCCESS)
If $g_bDebugSetlog Then SetDebugLog("-Upgrade location =  " & "(" & $g_avBuildingUpgrades[$iz][0] & "," & $g_avBuildingUpgrades[$iz][1] & ")", $COLOR_DEBUG)
If _Sleep($DELAYUPGRADEBUILDING1) Then Return
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
If $iAvailGold < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinGold Then
SetLog("Insufficent Gold for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinGold, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeNormal($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
SetLog("Gold used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfBuildingsUppedGold += 1
$g_iCostGoldBuilding += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailGold -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case "Elixir"
If $iAvailElixir < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinElixir Then
SetLog("Insufficent Elixir for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinElixir, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeNormal($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
SetLog("Elixir used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfBuildingsUppedElixir += 1
$g_iCostElixirBuilding += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailElixir -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case "Dark"
If $iAvailDark < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinDark Then
SetLog("Insufficent Dark for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeHero($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
SetLog("Dark Elixir used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfHeroesUpped += 1
$g_iCostDElixirHero += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailDark -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case Else
SetLog("Something went wrong with loot type on Upgradebuilding module on #" & $iz + 1, $COLOR_ERROR)
ExitLoop
EndSwitch
$g_avBuildingUpgrades[$iz][7] = _NowCalc()
If $g_bDebugSetlog Then SetDebugLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Started @ " & $g_avBuildingUpgrades[$iz][7], $COLOR_SUCCESS)
Local $aArray = StringSplit($g_avBuildingUpgrades[$iz][6], ' ', BitOR($STR_CHRSPLIT, $STR_NOCOUNT))
If IsArray($aArray) Then
Local $iRemainingTimeMin = 0
For $i = 0 To UBound($aArray) - 1
$sTime = ""
Select
Case StringInStr($aArray[$i], "d", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 24 * 60) - 7
Case StringInStr($aArray[$i], "h", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 60) - 3
Case StringInStr($aArray[$i], "m", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime)
Case Else
SetLog("Upgrade #" & $iz + 1 & " OCR time invalid" & $aArray[$i], $COLOR_WARNING)
EndSelect
If $g_bDebugSetlog Then SetDebugLog("Upgrade Time: " & $aArray[$i] & ", Minutes= " & $iRemainingTimeMin, $COLOR_DEBUG)
Next
$g_avBuildingUpgrades[$iz][7] = _DateAdd('n', Floor($iRemainingTimeMin), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Finishes @ " & $g_avBuildingUpgrades[$iz][7], $COLOR_SUCCESS)
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], $g_avBuildingUpgrades[$iz][7])
Else
SetLog("Non critical error processing upgrade time for " & "#" & $iz + 1 & ": " & $g_avBuildingUpgrades[$iz][4], $COLOR_WARNING)
EndIf
Next
If $iUpgradeAction <= 0 Then
SetLog("No Upgrades Available", $COLOR_SUCCESS)
Else
saveConfig()
EndIf
If _Sleep($DELAYUPGRADEBUILDING2) Then Return
checkMainScreen(False)
Return $iUpgradeAction
EndFunc
Func UpgradeNormal($iUpgradeNumber)
ClickP($aAway, 1, 0, "#0211")
If _Sleep($DELAYUPGRADENORMAL1) Then Return
BuildingClick($g_avBuildingUpgrades[$iUpgradeNumber][0], $g_avBuildingUpgrades[$iUpgradeNumber][1], "#0296")
If _Sleep($DELAYUPGRADENORMAL1) Then Return
Local $aResult = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If UBound($aResult) < 2 Then Return False
If StringStripWS($aResult[1], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> StringStripWS($g_avBuildingUpgrades[$iUpgradeNumber][4], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) Then
SetLog("#" & $iUpgradeNumber + 1 & ":" & $g_avBuildingUpgrades[$iUpgradeNumber][4] & ": Not same as :" & $aResult[1] & ":? Retry now...", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0211")
If _Sleep($DELAYUPGRADENORMAL1) Then Return
BuildingClick($g_avBuildingUpgrades[$iUpgradeNumber][0], $g_avBuildingUpgrades[$iUpgradeNumber][1], "#0296")
If _Sleep($DELAYUPGRADENORMAL1) Then Return
$aResult = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If $aResult[0] > 1 Then
If StringStripWS($aResult[1], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> StringStripWS($g_avBuildingUpgrades[$iUpgradeNumber][4], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) Then
SetLog("Found #" & $iUpgradeNumber + 1 & ":" & $g_avBuildingUpgrades[$iUpgradeNumber][4] & ": Not same as : " & $aResult[1] & ":, May need new location?", $COLOR_ERROR)
Return False
EndIf
EndIf
EndIf
Local $aUpgradeButton = findButton("Upgrade", Default, 1, True)
If IsArray($aUpgradeButton) And UBound($aUpgradeButton, 1) = 2 Then
If _Sleep($DELAYUPGRADENORMAL2) Then Return
ClickP($aUpgradeButton, 1, 0, "#0297")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeRegBtn1")
Local $aBldgUpgradeWinChk[4] = [687, 161 + $g_iMidOffsetY, 0xCD1419, 20]
If _WaitForCheckPixel($aBldgUpgradeWinChk, $g_bCapturePixel,Default, "BldgUpgradeWinChk", Default, Default, 100) Then
If _ColorCheck(_GetPixelColor(459, 490 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(459, 494 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Upgrade Fail #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & ", No Loot!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0298")
Return False
Else
Click(440, 480 + $g_iMidOffsetY, 1, 0, "#0299")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeRegBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & " No Loot!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0300")
Return False
EndIf
SetLog("Upgrade #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & " started", $COLOR_SUCCESS)
_GUICtrlSetImage($g_hPicUpgradeStatus[$iUpgradeNumber], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$iUpgradeNumber] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$iUpgradeNumber], -($g_avBuildingUpgrades[$iUpgradeNumber][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$iUpgradeNumber], $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+")
$g_aiUpgradeLevel[$iUpgradeNumber] = $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+"
If Not $g_abUpgradeRepeatEnable[$iUpgradeNumber] Then
GUICtrlSetState($g_hChkUpgrade[$iUpgradeNumber], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$iUpgradeNumber] = False
$g_avBuildingUpgrades[$iUpgradeNumber][0] = -1
$g_avBuildingUpgrades[$iUpgradeNumber][1] = -1
$g_avBuildingUpgrades[$iUpgradeNumber][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$iUpgradeNumber], $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+")
$g_avBuildingUpgrades[$iUpgradeNumber][5] = $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$iUpgradeNumber] Then
GUICtrlSetState($g_hChkUpgrade[$iUpgradeNumber], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$iUpgradeNumber] = True
EndIf
ClickP($aAway, 2, 0, "#0301")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
Return True
EndIf
ElseIf _ColorCheck(_GetPixelColor(721, 118 + $g_iMidOffsetY, True), Hex(0xDF0408, 6), 20) Then
If _ColorCheck(_GetPixelColor(459, 490 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(459, 494 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Upgrade Fail #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & ", No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0298")
Return False
Else
Click(670, 510 + $g_iMidOffsetY, 1, 0, "#0299")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeRegBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & " No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0300")
Return False
EndIf
SetLog("Upgrade #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & " started", $COLOR_GREEN)
_GUICtrlSetImage($g_hPicUpgradeStatus[$iUpgradeNumber], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$iUpgradeNumber] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$iUpgradeNumber], -($g_avBuildingUpgrades[$iUpgradeNumber][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$iUpgradeNumber], $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+")
$g_aiUpgradeLevel[$iUpgradeNumber] = $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+"
If Not $g_abUpgradeRepeatEnable[$iUpgradeNumber] Then
GUICtrlSetState($g_hChkUpgrade[$iUpgradeNumber], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$iUpgradeNumber] = False
$g_avBuildingUpgrades[$iUpgradeNumber][0] = -1
$g_avBuildingUpgrades[$iUpgradeNumber][1] = -1
$g_avBuildingUpgrades[$iUpgradeNumber][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$iUpgradeNumber], $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+")
$g_avBuildingUpgrades[$iUpgradeNumber][5] = $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$iUpgradeNumber] Then
GUICtrlSetState($g_hChkUpgrade[$iUpgradeNumber], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$iUpgradeNumber] = True
EndIf
ClickP($aAway, 2, 0, "#0301")
If _Sleep($DELAYUPGRADENORMAL3) Then Return
Return True
EndIf
Else
SetLog("Upgrade #" & $iUpgradeNumber + 1 & " window open fail", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0302")
EndIf
Else
SetLog("Upgrade #" & $iUpgradeNumber + 1 & " Error finding button", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0303")
Return False
EndIf
EndFunc
Func UpgradeHero($iUpgradeNumber)
BuildingClick($g_avBuildingUpgrades[$iUpgradeNumber][0], $g_avBuildingUpgrades[$iUpgradeNumber][1], "#0304")
If _Sleep($DELAYUPGRADEHERO1) Then Return
Local $aUpgradeButton = findButton("Upgrade", Default, 1, True)
If IsArray($aUpgradeButton) And UBound($aUpgradeButton, 1) = 2 Then
If _Sleep($DELAYUPGRADEHERO2) Then Return
ClickP($aUpgradeButton, 1, 0, "#0305")
If _Sleep($DELAYUPGRADEHERO3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn1")
Local $aHeroUpgradeWinChk[4] = [729, 128 + $g_iMidOffsetY, 0xCD161D, 20]
If _WaitForCheckPixel($aHeroUpgradeWinChk, $g_bCapturePixel,Default, "HeroUpgradeWinChk", Default, Default, 100) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Hero Upgrade Fail #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & " No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return False
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($DELAYUPGRADEHERO1) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & " No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return False
EndIf
SetLog("Hero Upgrade #" & $iUpgradeNumber + 1 & " " & $g_avBuildingUpgrades[$iUpgradeNumber][4] & " started", $COLOR_SUCCESS)
_GUICtrlSetImage($g_hPicUpgradeStatus[$iUpgradeNumber], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$iUpgradeNumber] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$iUpgradeNumber], -($g_avBuildingUpgrades[$iUpgradeNumber][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$iUpgradeNumber], $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+")
$g_aiUpgradeLevel[$iUpgradeNumber] = $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+"
If Not $g_abUpgradeRepeatEnable[$iUpgradeNumber] Then
GUICtrlSetState($g_hChkUpgrade[$iUpgradeNumber], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$iUpgradeNumber] = False
$g_avBuildingUpgrades[$iUpgradeNumber][0] = -1
$g_avBuildingUpgrades[$iUpgradeNumber][1] = -1
$g_avBuildingUpgrades[$iUpgradeNumber][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$iUpgradeNumber], $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+")
$g_avBuildingUpgrades[$iUpgradeNumber][5] = $g_avBuildingUpgrades[$iUpgradeNumber][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$iUpgradeNumber] Then
GUICtrlSetState($g_hChkUpgrade[$iUpgradeNumber], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$iUpgradeNumber] = True
EndIf
ClickP($aAway, 2, 0, "#0310")
If _Sleep($DELAYUPGRADEHERO2) Then Return
Return True
EndIf
Else
SetLog("Upgrade #" & $iUpgradeNumber + 1 & " window open fail", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0311")
EndIf
Else
SetLog("Upgrade #" & $iUpgradeNumber + 1 & " Error finding button", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0312")
Return False
EndIf
EndFunc
Func SetlogUpgradeValues($i)
Local $j
For $j = 0 To UBound($g_avBuildingUpgrades, 2) - 1
SetLog("$g_avBuildingUpgrades[" & $i & "][" & $j & "]= " & $g_avBuildingUpgrades[$i][$j], $COLOR_DEBUG)
Next
SetLog("$g_hChkUpgrade= " & $g_abBuildingUpgradeEnable[$i], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeName= " & $g_avBuildingUpgrades[$i][4], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeLevel= " & $g_aiUpgradeLevel[$i], $COLOR_DEBUG)
SetLog("$g_hPicUpgradeType= " & $g_aiPicUpgradeStatus[$i], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeValue= " & $g_avBuildingUpgrades[$i][2], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeTime= " & $g_avBuildingUpgrades[$i][6], $COLOR_DEBUG)
SetLog("$g_hTxtUpgradeEndTime= " & $g_avBuildingUpgrades[$i][7], $COLOR_DEBUG)
SetLog("$g_hChkUpgradeRepeat= " & $g_abUpgradeRepeatEnable, $COLOR_DEBUG)
EndFunc
Func AutoUpgrade($bTest = False)
Local $bWasRunState = $g_bRunState
$g_bRunState = True
Local $Result = _AutoUpgrade()
$g_bRunState = $bWasRunState
Return $Result
EndFunc
Func _AutoUpgrade()
If Not $g_bAutoUpgradeEnabled Then Return
SetLog("Starting Auto Upgrade", $COLOR_INFO)
Local $iLoopAmount = 0
Local $iLoopMax = 6
While 1
$iLoopAmount += 1
If $iLoopAmount >= $iLoopMax Or $iLoopAmount >= 12 Then ExitLoop
ClickP($aAway, 1, 0, "#0000")
If _sleep($DELAYAUTOUPGRADEBUILDING1) Then Return
VillageReport(True, True)
If($g_iFreeBuilderCount -($g_bAutoUpgradeWallsEnable And $g_bUpgradeWallSaveBuilder ? 1 : 0) - ReservedBuildersForHeroes()) <= 0 Then
SetLog("No builder available. Skipping Auto Upgrade!", $COLOR_WARNING)
ExitLoop
EndIf
If Not(_ColorCheck(_GetPixelColor(275, 15, True), "F5F5ED", 20) = True) Then
SetLog("Unable to find the Builder menu button... Exiting Auto Upgrade...", $COLOR_ERROR)
ExitLoop
EndIf
Click(295, 30)
If _Sleep($DELAYAUTOUPGRADEBUILDING1) Then Return
If QuickMIS("BC1", $g_sImgAUpgradeZero, 180, 80 + $g_iNextLineOffset, 480, 350) Then
SetLog("Possible upgrade found !", $COLOR_SUCCESS)
$g_iCurrentLineOffset = $g_iNextLineOffset + $g_iQuickMISY
Else
SetLog("No upgrade available... Exiting Auto Upgrade...", $COLOR_INFO)
ExitLoop
EndIf
If QuickMIS("NX",$g_sImgAUpgradeObst, 180, 80 + $g_iCurrentLineOffset - 15, 480, 80 + $g_iCurrentLineOffset + 15) <> "none" Then
SetLog("This is a New Building or an Equipment, looking next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Click(180 + $g_iQuickMISX, 80 + $g_iCurrentLineOffset)
If _Sleep($DELAYAUTOUPGRADEBUILDING1) Then Return
If Not QuickMIS("BC1", $g_sImgAUpgradeUpgradeBtn, 140, 590, 720, 670) Then
SetLog("No upgrade here... Wrong click, looking next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
$g_aUpgradeNameLevel = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If $g_aUpgradeNameLevel[0] = "" Then
SetLog("Error when trying to get upgrade name and level, looking next...", $COLOR_ERROR)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Local $bMustIgnoreUpgrade = False
Switch $g_aUpgradeNameLevel[1]
Case "Town Hall"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[0] = 1) ? True : False
Case "Barbarian King"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[1] = 1 Or $g_bUpgradeKingEnable = True) ? True : False
Case "Archer Queen"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[2] = 1 Or $g_bUpgradeQueenEnable = True) ? True : False
Case "Grand Warden"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[3] = 1 Or $g_bUpgradeWardenEnable = True) ? True : False
Case "Clan Castle"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[4] = 1) ? True : False
Case "Laboratory"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[5] = 1) ? True : False
Case "Wall"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[6] = 1) ? True : False
Case "Barracks"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[7] = 1) ? True : False
Case "Dark Barracks"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[8] = 1) ? True : False
Case "Spell Factory"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[9] = 1) ? True : False
Case "Dark Spell Factory"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[10] = 1) ? True : False
Case "Gold Mine"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[11] = 1) ? True : False
Case "Elixir Collector"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[12] = 1) ? True : False
Case "Dark Elixir Drill"
$bMustIgnoreUpgrade =($g_iChkUpgradesToIgnore[13] = 1) ? True : False
Case Else
$bMustIgnoreUpgrade = False
EndSwitch
If $bMustIgnoreUpgrade = True Then
SetLog("This upgrade must be ignored, looking next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Click(120 + $g_iQuickMISX, 630 + $g_iQuickMISY)
If _Sleep($DELAYAUTOUPGRADEBUILDING1) Then Return
Switch $g_aUpgradeNameLevel[1]
Case "Barbarian King", "Archer Queen", "Grand Warden"
$g_aUpgradeResourceCostDuration[0] = QuickMIS("N1", $g_sImgAUpgradeRes, 690, 540, 730, 580)
$g_aUpgradeResourceCostDuration[1] = getResourcesBonus(598, 522 + $g_iMidOffsetY)
$g_aUpgradeResourceCostDuration[2] = getHeroUpgradeTime(578, 465 + $g_iMidOffsetY)
Case Else
$g_aUpgradeResourceCostDuration[0] = QuickMIS("N1", $g_sImgAUpgradeRes, 460, 510, 500, 550)
$g_aUpgradeResourceCostDuration[1] = getResourcesBonus(366, 487 + $g_iMidOffsetY)
$g_aUpgradeResourceCostDuration[2] = getBldgUpgradeTime(195, 307 + $g_iMidOffsetY)
EndSwitch
For $i = 0 To 2
If $g_aUpgradeResourceCostDuration[$i] = "" Then
SetLog("Error when trying to get upgrade details, looking next...", $COLOR_ERROR)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop 2
EndIf
Next
Local $bMustIgnoreResource = False
Switch $g_aUpgradeResourceCostDuration[0]
Case "Gold"
$bMustIgnoreResource =($g_iChkResourcesToIgnore[0] = 1) ? True : False
Case "Elixir"
$bMustIgnoreResource =($g_iChkResourcesToIgnore[1] = 1) ? True : False
Case "Dark Elixir"
$bMustIgnoreResource =($g_iChkResourcesToIgnore[2] = 1) ? True : False
Case Else
$bMustIgnoreResource = False
EndSwitch
If $bMustIgnoreResource = True Then
SetLog("This resource must be ignored, looking next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Local $bSufficentResourceToUpgrade = False
Switch $g_aUpgradeResourceCostDuration[0]
Case "Gold"
If $g_aiCurrentLoot[$eLootGold] >=($g_aUpgradeResourceCostDuration[1] + $g_iTxtSmartMinGold) Then $bSufficentResourceToUpgrade = True
Case "Elixir"
If $g_aiCurrentLoot[$eLootElixir] >=($g_aUpgradeResourceCostDuration[1] + $g_iTxtSmartMinElixir) Then $bSufficentResourceToUpgrade = True
Case "Dark Elixir"
If $g_aiCurrentLoot[$eLootDarkElixir] >=($g_aUpgradeResourceCostDuration[1] + $g_iTxtSmartMinDark) Then $bSufficentResourceToUpgrade = True
EndSwitch
If Not $bSufficentResourceToUpgrade Then
SetLog("Unsufficent " & $g_aUpgradeResourceCostDuration[0] & " to launch this upgrade, looking Next...", $COLOR_WARNING)
$g_iNextLineOffset = $g_iCurrentLineOffset
ContinueLoop
EndIf
Switch $g_aUpgradeNameLevel[1]
Case "Barbarian King", "Archer Queen", "Grand Warden"
Click(660, 560)
Case Else
Click(440, 530)
EndSwitch
$g_iCurrentLineOffset -= $g_iQuickMISY
$iLoopMax += 1
SetLog("Launched upgrade of " & $g_aUpgradeNameLevel[1] & " to level " & $g_aUpgradeNameLevel[2] + 1 & " successfully !", $COLOR_SUCCESS)
SetLog(" - Cost : " & _NumberFormat($g_aUpgradeResourceCostDuration[1]) & " " & $g_aUpgradeResourceCostDuration[0], $COLOR_SUCCESS)
SetLog(" - Duration : " & $g_aUpgradeResourceCostDuration[2], $COLOR_SUCCESS)
_GUICtrlEdit_AppendText($g_hTxtAutoUpgradeLog, @CRLF & _NowDate() & " " & _NowTime() & " - Upgrading " & $g_aUpgradeNameLevel[1] & " to level " & $g_aUpgradeNameLevel[2] + 1 & " for " & _NumberFormat($g_aUpgradeResourceCostDuration[1]) & " " & $g_aUpgradeResourceCostDuration[0] & " - Duration : " & $g_aUpgradeResourceCostDuration[2])
_FileWriteLog($g_sProfileLogsPath & "\AutoUpgradeHistory.log", "Upgrading " & $g_aUpgradeNameLevel[1] & " to level " & $g_aUpgradeNameLevel[2] + 1 & " for " & _NumberFormat($g_aUpgradeResourceCostDuration[1]) & " " & $g_aUpgradeResourceCostDuration[0] & " - Duration : " & $g_aUpgradeResourceCostDuration[2])
WEnd
$g_iCurrentLineOffset = 0
$g_iNextLineOffset = 0
SetLog("Auto Upgrade finished", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0000")
EndFunc
Func UpgradeWall()
If $g_bAutoUpgradeWallsEnable = True Then
SetLog("Checking Upgrade Walls", $COLOR_INFO)
If SkipWallUpgrade() Then Return
If $g_iFreeBuilderCount > 0 Then
ClickP($aAway, 1, 0, "#0313")
Local $MinWallGold = Number($g_aiCurrentLoot[$eLootGold] - $g_iWallCost) > Number($g_iUpgradeWallMinGold)
Local $MinWallElixir = Number($g_aiCurrentLoot[$eLootElixir] - $g_iWallCost) > Number($g_iUpgradeWallMinElixir)
While($g_iUpgradeWallLootType = 0 And $MinWallGold) Or($g_iUpgradeWallLootType = 1 And $MinWallElixir) Or($g_iUpgradeWallLootType = 2 And($MinWallGold Or $MinWallElixir))
Switch $g_iUpgradeWallLootType
Case 0
If $MinWallGold Then
SetLog("Upgrading Wall using Gold", $COLOR_SUCCESS)
If imglocCheckWall() Then
If Not UpgradeWallGold() Then
SetLog("Upgrade with Gold failed, skipping...", $COLOR_ERROR)
Return
EndIf
ElseIf SwitchToNextWallLevel() Then
SetLog("No more walls of current level, switching to next", $COLOR_ACTION)
Else
Return
EndIf
Else
SetLog("Gold is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
Case 1
If $MinWallElixir Then
SetLog("Upgrading Wall using Elixir", $COLOR_SUCCESS)
If imglocCheckWall() Then
If Not UpgradeWallElixir() Then
SetLog("Upgrade with Elixier failed, skipping...", $COLOR_ERROR)
Return
EndIf
ElseIf SwitchToNextWallLevel() Then
SetLog("No more walls of current level, switching to next", $COLOR_ACTION)
Else
Return
EndIf
Else
SetLog("Elixir is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
Case 2
If $MinWallElixir Then
SetLog("Upgrading Wall using Elixir", $COLOR_SUCCESS)
If imglocCheckWall() Then
If Not UpgradeWallElixir() Then
SetLog("Upgrade with Elixir failed, attempt to upgrade using Gold", $COLOR_ERROR)
If Not UpgradeWallGold() Then
SetLog("Upgrade with Gold failed, skipping...", $COLOR_ERROR)
Return
EndIf
EndIf
ElseIf SwitchToNextWallLevel() Then
SetLog("No more walls of current level, switching to next", $COLOR_ACTION)
Else
Return
EndIf
Else
SetLog("Elixir is below minimum, attempt to upgrade using Gold", $COLOR_ERROR)
If $MinWallGold Then
If imglocCheckWall() Then
If Not UpgradeWallGold() Then
SetLog("Upgrade with Gold failed, skipping...", $COLOR_ERROR)
Return
EndIf
ElseIf SwitchToNextWallLevel() Then
SetLog("No more walls of current level, switching to next", $COLOR_ACTION)
Else
Return
EndIf
Else
SetLog("Gold is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
EndIf
EndSwitch
If _CheckPixel($g_aShopWindowOpen, $g_bCapturePixel, Default, "ChkShopOpen", $COLOR_DEBUG) = True Then
Click(820, 40, 1, 0, "#0315")
EndIf
ClickP($aAway, 1, 0, "#0314")
VillageReport(True, True)
If SkipWallUpgrade() Then Return
$MinWallGold = Number($g_aiCurrentLoot[$eLootGold] - $g_iWallCost) > Number($g_iUpgradeWallMinGold)
$MinWallElixir = Number($g_aiCurrentLoot[$eLootElixir] - $g_iWallCost) > Number($g_iUpgradeWallMinElixir)
WEnd
Else
SetLog("No free builder, Upgrade Walls skipped..", $COLOR_ERROR)
EndIf
EndIf
If _Sleep($DELAYUPGRADEWALL1) Then Return
checkMainScreen(False)
EndFunc
Func UpgradeWallGold()
If _Sleep($DELAYRESPOND) Then Return
Local $offColors[3][3] = [[0xE47D55, 47, 37], [0xF5E74B, 70, 0], [0xFFFFFF, 79, 0]]
Local $ButtonPixel = _MultiPixelSearch(240, 537 + $g_iBottomOffsetY, 670, 624 + $g_iBottomOffsetY, 1, 1, Hex(0xFFFFFF, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0316")
If _Sleep($DELAYUPGRADEWALLGOLD2) Then Return
If _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
If isNoUpgradeLoot(False) = True Then
SetLog("Upgrade stopped due no loot", $COLOR_ERROR)
Return False
EndIf
Click(440, 480 + $g_iMidOffsetY, 1, 0, "#0317")
If _Sleep(1000) Then Return
If isGemOpen(True) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("Upgrade stopped due no loot", $COLOR_ERROR)
Return False
ElseIf _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("unable to upgrade", $COLOR_ERROR)
Return False
Else
If _Sleep($DELAYUPGRADEWALLGOLD3) Then Return
SetLog("Upgrade complete", $COLOR_SUCCESS)
PushMsg("UpgradeWithGold")
$g_iNbrOfWallsUppedGold += 1
$g_iNbrOfWallsUpped += 1
$g_iCostGoldWall += $g_iWallCost
UpdateStats()
Return True
EndIf
EndIf
Else
SetLog("No Upgrade Gold Button", $COLOR_ERROR)
Pushmsg("NowUpgradeGoldButton")
Return False
EndIf
EndFunc
Func UpgradeWallElixir()
If _Sleep($DELAYRESPOND) Then Return
Local $offColors[3][3] = [[0xE47D55, 47, 37], [0xF84CF9, 72, 0], [0xFFFFFF, 79, 0]]
Local $ButtonPixel = _MultiPixelSearch(240, 537 + $g_iBottomOffsetY, 670, 624 + $g_iBottomOffsetY, 1, 1, Hex(0xFFFFFF, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0322")
If _Sleep($DELAYUPGRADEWALLELIXIR2) Then Return
If _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
If isNoUpgradeLoot(False) = True Then
SetLog("Upgrade stopped due to insufficient loot", $COLOR_ERROR)
Return False
EndIf
Click(440, 480 + $g_iMidOffsetY, 1, 0, "#0318")
If _Sleep(1000) Then Return
If isGemOpen(True) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("Upgrade stopped due to insufficient loot", $COLOR_ERROR)
Return False
ElseIf _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("unable to upgrade", $COLOR_ERROR)
Return False
Else
If _Sleep($DELAYUPGRADEWALLELIXIR3) Then Return
SetLog("Upgrade complete", $COLOR_SUCCESS)
PushMsg("UpgradeWithElixir")
$g_iNbrOfWallsUppedElixir += 1
$g_iNbrOfWallsUpped += 1
$g_iCostElixirWall += $g_iWallCost
UpdateStats()
Return True
EndIf
EndIf
Else
SetLog("No Upgrade Elixir Button", $COLOR_ERROR)
Pushmsg("NowUpgradeElixirButton")
Return False
EndIf
EndFunc
Func SkipWallUpgrade()
IniReadS($g_iUpgradeWallLootType, $g_sProfileConfigPath, "upgrade", "use-storage", "0")
Local $iUpgradeAction = 0
Local $iBuildingsNeedGold = 0
Local $iBuildingsNeedElixir = 0
Local $iAvailBuilderCount = 0
Switch $g_iTownHallLevel
Case 5 To 8
If $g_iTownHallLevel < $g_iCmbUpgradeWallsLevel + 4 Then
SetLog("Skip Wall upgrade -insufficient TH-Level", $COLOR_WARNING)
Return True
EndIf
Case 9 To 12
If $g_iTownHallLevel < $g_iCmbUpgradeWallsLevel + 3 Then
SetLog("Skip Wall upgrade -insufficient TH-Level", $COLOR_WARNING)
Return True
EndIf
Case Else
Return True
EndSwitch
If Not getBuilderCount() Then Return True
If _Sleep($DELAYRESPOND) Then Return True
$iAvailBuilderCount = $g_iFreeBuilderCount
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abBuildingUpgradeEnable[$iz] = True Then $iUpgradeAction += 1
Next
If $g_iFreeBuilderCount >($g_bUpgradeWallSaveBuilder ? 1 : 0) And $iUpgradeAction > 0 Then
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $iAvailBuilderCount >($g_bUpgradeWallSaveBuilder ? 1 : 0) And $g_abBuildingUpgradeEnable[$iz] = True And $g_avBuildingUpgrades[$iz][7] = "" Then
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
$iBuildingsNeedGold += Number($g_avBuildingUpgrades[$iz][2])
$iAvailBuilderCount -= 1
Case "Elixir"
$iBuildingsNeedElixir += Number($g_avBuildingUpgrades[$iz][2])
$iAvailBuilderCount -= 1
EndSwitch
EndIf
Next
SetLog("SkipWall-Upgrade Summary: G:" & $iBuildingsNeedGold & ", E:" & $iBuildingsNeedElixir & ", Wall: " & $g_iWallCost & ", MinG: " & $g_iUpgradeWallMinGold & ", MinE: " & $g_iUpgradeWallMinElixir)
If $iBuildingsNeedGold > 0 Or $iBuildingsNeedElixir > 0 Then
Switch $g_iUpgradeWallLootType
Case 0
If $g_aiCurrentLoot[$eLootGold] -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) < 0 Then
SetLog("Skip Wall upgrade -insufficient gold for selected upgrades", $COLOR_WARNING)
Return True
EndIf
Case 1
If $g_aiCurrentLoot[$eLootElixir] -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) < 0 Then
SetLog("Skip Wall upgrade - insufficient elixir for selected upgrades", $COLOR_WARNING)
Return True
EndIf
Case 2
If $g_aiCurrentLoot[$eLootGold] -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) < 0 Then
SetLog("Wall upgrade: insufficient gold for selected upgrades", $COLOR_WARNING)
If $g_aiCurrentLoot[$eLootElixir] -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) >= 0 Then
SetLog("Using Elixir only for wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 1
Else
SetLog("Skip Wall upgrade -insufficient resources for selected upgrades", $COLOR_WARNING)
Return True
EndIf
EndIf
If $g_aiCurrentLoot[$eLootElixir] -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) < 0 Then
SetLog("Wall upgrade: insufficient elixir for selected upgrades", $COLOR_WARNING)
If $g_aiCurrentLoot[$eLootGold] -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) >= 0 Then
SetLog("Using Gold only for Wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 0
Else
SetLog("Skip Wall upgrade -insufficient resources for selected upgrades", $COLOR_WARNING)
Return True
EndIf
EndIf
EndSwitch
EndIf
If _Sleep($DELAYRESPOND) Then Return True
EndIf
If($g_iWardenLevel <> -1) And($g_iWardenLevel < $g_iMaxWardenLevel) And $g_bUpgradeWardenEnable And BitAND($g_iHeroUpgradingBit, $eHeroWarden) <> $eHeroWarden And($g_iFreeBuilderCount >($g_bUpgradeWallSaveBuilder ? 1 : 0)) Then
Local $bMinWardenElixir = Number($g_aiCurrentLoot[$eLootElixir]) >($g_iWallCost + $g_afWardenUpgCost[$g_iWardenLevel] * 1000000 + Number($g_iUpgradeWallMinElixir))
If Not $bMinWardenElixir Then
Switch $g_iUpgradeWallLootType
Case 1
SetLog("Grand Warden needs " &($g_afWardenUpgCost[$g_iWardenLevel] * 1000000) & " Elixir for next Level", $COLOR_WARNING)
SetLog("Skipping Wall Upgrade", $COLOR_WARNING)
Return True
Case 2
SetLog("Grand Warden needs " &($g_afWardenUpgCost[$g_iWardenLevel] * 1000000) & " Elixir for next Level", $COLOR_SUCCESS1)
SetLog("Using Gold only for Wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 0
EndSwitch
EndIf
EndIf
Local $bMinWallElixir = Number($g_aiCurrentLoot[$eLootElixir]) >($g_iWallCost + Number($g_iLaboratoryElixirCost) + Number($g_iUpgradeWallMinElixir))
If $g_bAutoLabUpgradeEnable And $g_iLaboratoryElixirCost > 0 And Not $bMinWallElixir Then
Switch $g_iUpgradeWallLootType
Case 0
Case 1
SetLog("Laboratory needs Elixir to Upgrade :  " & $g_iLaboratoryElixirCost, $COLOR_SUCCESS1)
SetLog("Skipping Wall Upgrade", $COLOR_SUCCESS1)
Return True
Case 2
SetLog("Laboratory needs Elixir to Upgrade :  " & $g_iLaboratoryElixirCost, $COLOR_SUCCESS1)
SetLog("Using Gold only for Wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 0
EndSwitch
EndIf
Return False
EndFunc
Func SwitchToNextWallLevel()
If $g_aiWallsCurrentCount[$g_iCmbUpgradeWallsLevel + 4] = 0 And $g_iCmbUpgradeWallsLevel < 8 Then
EnableGuiControls()
_GUICtrlComboBox_SetCurSel($g_hCmbWalls, $g_iCmbUpgradeWallsLevel + 1)
cmbWalls()
If $g_iCmbUpgradeWallsLevel = 4 Then
GUICtrlSetState($g_hRdoUseElixirGold, $GUI_CHECKED)
GUICtrlSetData($g_hTxtWallMinElixir, GUICtrlRead($g_hTxtWallMinGold))
EndIf
SaveConfig()
DisableGuiControls()
Return True
EndIf
Return False
EndFunc
Global Const $TELEGRAM_URL = "https://api.telegram.org/bot"
Global Const $HTTP_STATUS_OK = 200
Func NotifyRemoteControl()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyRemoteControl()")
If $g_bNotifyRemoteEnable = True Then NotifyRemoteControlProc()
EndFunc
Func NotifyReport()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyReport()")
If $g_bNotifyAlertVillageReport = True Then
Local $text = $g_sNotifyOrigin & ":" & "%0A"
$text &= " [" & "G" & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold])
$text &= " [" & "E" & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir]) & "%0A"
$text &= " [" & "DE" & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir])
$text &= " [" & "T" & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootTrophy]) & "%0A"
$text &= " [" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_06", "No. of Free Builders") & "]: " & $g_iFreeBuilderCount
NotifyPushToTelegram($text)
EndIf
If $g_bNotifyAlertLastAttack = True Then
If Not($g_iStatsLastAttack[$eLootGold] = "" And $g_iStatsLastAttack[$eLootElixir] = "") Then
Local $text = $g_sNotifyOrigin & ":" & "%0A"
$text &= " [" & "G" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold])
$text &= " [" & "E" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & "%0A"
$text &= " [" & "DE" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir])
$text &= " [" & "T" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootTrophy])
NotifyPushToTelegram($text)
EndIf
EndIf
If _Sleep($DELAYNOTIFY1) Then Return
checkMainScreen(False)
EndFunc
Func PushMsg($Message, $Source = "")
If $g_bDebugSetlog Then SetDebugLog("Notify | PushMsg()")
NotifyPushMessageToBoth($Message, $Source)
EndFunc
Func NotifyPendingActions()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPendingActions()")
If($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
NotifyRemoteControl()
If $g_bTGRequestScreenshot = True Then
$g_bNotifyForced = True
PushMsg("RequestScreenshot")
EndIf
If $g_bTGRequestBuilderInfo = True Then
$g_bNotifyForced = True
PushMsg("BuilderInfo")
EndIf
If $g_bTGRequestShieldInfo = True Then
$g_bNotifyForced = True
PushMsg("ShieldInfo")
EndIf
PushMsg("BuilderIdle")
EndFunc
Func NotifyPushToTelegram($pMessage)
If $g_bDebugSetlog Then SetDebugLog("NotifyPushToTelegram(" & $pMessage & " ): ")
If Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "" Then Return
If Not IsPlanUseTelegram($pMessage) Then Return
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $text = $pMessage & '%0A' & $Date & '_' & $Time
Local $SdtOut = InetRead("https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendMessage?chat_id=" & $g_sTGChatID & "&text=" & $text, $INET_FORCERELOAD)
If @error Or $SdtOut = "" Then Return
Local $sCorrectStdOut = BinaryToString($SdtOut)
If @error Or $sCorrectStdOut = "" Then Return
Local $mdg = _StringBetween($sCorrectStdOut, '"message_id":', ',"from":')
If @error Or Not IsArray($mdg) Then SetDebugLog("NotifyPushToTelegram Send Error!: " & $sCorrectStdOut)
If $g_bDebugSetlog Then SetDebugLog("Telegram last sent msg number is '" & $mdg[0] & "'")
EndIf
EndFunc
Func NotifyPushFileToTelegram($File, $Folder, $FileType, $body)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushFileToTelegram($File, $Folder, $FileType, $body): " & $File & "," & $Folder & "," & $FileType & "," & $body)
If Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "" Then Return
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $sCmd = "/sendPhoto", $sCmd1 = "photo"
If $FileType = "text\/plain; charset=utf-8" Then
$sCmd = "/sendDocument"
$sCmd1 = "document"
EndIf
Local $FullTelegram_url = $TELEGRAM_URL & $g_sNotifyTGToken & $sCmd
Local $Result = RunWait($g_sCurlPath & " -i -X POST " & $FullTelegram_url & ' -F chat_id="' & $g_sTGChatID & '" -F ' & $sCmd1 & '=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
Local $SdtOut = InetRead("https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendMessage?chat_id=" & $g_sTGChatID & "&text=" & $body, $INET_FORCERELOAD)
If @error Or $SdtOut = "" Then Return
Local $sCorrectStdOut = BinaryToString($SdtOut)
If @error Or $sCorrectStdOut = "" Then Return
If $g_bDebugSetlog Then SetDebugLog("NotifyPushFileToTelegram(): " & $sCorrectStdOut)
Local $mdg = _StringBetween($sCorrectStdOut, '"message_id":', ',"from":')
If @error Or Not IsArray($mdg) Then SetDebugLog("NotifyPushFileToTelegram Send Error!")
Else
SetLog("Notify Telegram: Unable to send file " & $File, $COLOR_ERROR)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_02", "Unable to Upload File") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Uploading-File_Info_01", "Occured an error type 2 uploading file to Telegram server..."))
EndIf
EndIf
EndFunc
Func NotifyGetLastMessageFromTelegram()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyGetLastMessageFromTelegram()")
Local $TGLastMessage = ""
If Not $g_bNotifyTGEnable Or $g_sNotifyTGToken = "" Then Return
If _IsInternet() < 1 Then
SetLog("Telegram: Check your internet connection! No Connection..", $COLOR_ERROR)
Return
EndIf
Local $SdtOut = InetRead("https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getUpdates", $INET_FORCERELOAD)
If @error Or $SdtOut = "" Then Return
Local $sCorrectStdOut = BinaryToString($SdtOut)
If @error Or $sCorrectStdOut = "" Then Return
If $g_bDebugSetlog Then SetDebugLog("Notify | getUpdates(): " & $sCorrectStdOut)
Local $chat_id = _StringBetween($sCorrectStdOut, 'from":{"id":', ',"is_bot":')
If @error Or Not IsArray($chat_id) Then Return
If $g_sTGChatID = "" Or $g_sTGChatID <> $chat_id[0] Then
$g_sTGChatID = $chat_id[0]
SaveConfig_600_18()
If $g_bDebugSetlog Then SetDebugLog("Saved a new Chat_ID/User_ID for Telegram as " & $g_sTGChatID)
Else
If $g_bDebugSetlog Then SetDebugLog("Telegram Chat_ID/User_ID:" & $g_sTGChatID)
EndIf
Local $uid = _StringBetween($sCorrectStdOut, '"update_id":', ',')
If @error Or Not IsArray($uid) Then Return
If $g_bDebugSetlog Then SetDebugLog("You have " & UBound($uid) & " update_id to confirm!")
$g_sTGLast_UID = $uid[UBound($uid) - 1]
If $g_bDebugSetlog Then SetDebugLog("Telegram getting update_ID: " & $g_sTGLast_UID)
If $g_bDebugSetlog Then SetDebugLog("Telegram last update_id was: " & $g_iTGLastRemote)
Local $SdtOut = InetRead("https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates?offset=" & $g_sTGLast_UID, $INET_FORCERELOAD)
If @error Or $SdtOut = "" Then Return
Local $sCorrectStdOut = BinaryToString($SdtOut)
If $g_bDebugSetlog Then SetDebugLog("Notify | getupdates?offset=" & $g_sTGLast_UID & " : " & $sCorrectStdOut)
Local $msg = _StringBetween($sCorrectStdOut, '"text":"', '"')
If @error Or Not IsArray($msg) Then Return
If $g_bDebugSetlog Then SetDebugLog("You have " & UBound($msg) & " messages to read")
$TGLastMessage = String($msg[UBound($msg) - 1])
If $g_bDebugSetlog Then SetDebugLog("Telegram last message was '" & $TGLastMessage & "'")
Return $TGLastMessage
EndFunc
Func NotifyActivateKeyboardOnTelegram($TGMsg)
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyActivateKeyboardOnTelegram($TGMsg): " & $TGMsg)
If $TGMsg = "" Or $g_sNotifyTGToken = "" Or $g_sTGChatID = "" Then Return False
Local $ReplayMarkup = '{"keyboard": [["' & '\ud83d\udcf7 ' & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT") & '","' & '\ud83d\udd28 ' & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER") & '","' & '\ud83d\udd30 ' & GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD") & '"],["' & '\ud83d\udcc8 ' & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS") & '","' & '\ud83d\udcaa ' & GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS") & '","' & '\u2753 ' & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP") & '"],["' & '\u25aa ' & GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP") & '","' & '\u25b6 ' & GetTranslatedFileIni("MBR Func_Notify", "START", "START") & '","' & '\ud83d\udd00 ' & GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE") & '","' & '\u25b6 ' & GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME") & '","' & '\ud83d\udd01 ' & GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART") & '"],["' & '\ud83d\udccb ' & GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG") & '","' & '\ud83c\udf04 ' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID") & '","' & '\ud83d\udcc4 ' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT") & '"],["' & '\u2705 ' & GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON", "ATTACK ON") & '","' & '\u274C ' & GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF", "ATTACK OFF") & '"],["' & '\ud83d\udca4 ' & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE") & '","' & '\u26a1 ' & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN") & '","' & '\ud83d\udd06 ' & GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY") & '"]],"one_time_keyboard": false,"resize_keyboard":true}'
Local $sOUTPUT = InetRead("https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendMessage?chat_id=" & $g_sTGChatID & "&text=" & $TGMsg & "&reply_markup=" & $ReplayMarkup , $INET_FORCERELOAD)
If @error Or $sOUTPUT = "" Then Return False
$g_iTGLastRemote = $g_sTGLast_UID
Return True
EndFunc
Func NotifyRemoteControlProcBtnStart()
Local $bWasSilent = SetDebugLogSilent()
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" Then
$g_sTGLastMessage = NotifyGetLastMessageFromTelegram()
If $g_sTGLastMessage = "" Then Return
Local $TGActionMSG = StringUpper(StringStripWS($g_sTGLastMessage, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProcBtnStart $TGActionMSG : " & $TGActionMSG)
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProcBtnStart $g_iTGLastRemote : " & $g_iTGLastRemote)
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProcBtnStart $g_sTGLast_UID : " & $g_sTGLast_UID)
If $g_iTGLastRemote <> $g_sTGLast_UID Then
$g_iTGLastRemote = $g_sTGLast_UID
Switch $TGActionMSG
Case "START", '\u25b6 ' & GetTranslatedFileIni("MBR Func_Notify", "START", "START")
btnStart()
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_01", "Request to Start...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_02", "Your bot is now starting..."))
Case Else
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_04", "Start MyBot first."))
EndSwitch
EndIf
EndIf
SetDebugLogSilent($bWasSilent)
EndFunc
Func NotifyRemoteControlProc()
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyRemoteControlProc()")
Static $bShutdown = False
Static $bHibernate = False
Static $bStandby = False
If Not $g_bNotifyTGEnable Or Not $g_bNotifyRemoteEnable Then Return
If $g_bNotifyTGEnable And $g_sNotifyTGToken <> "" And $g_bRunState Then
$g_sTGLastMessage = NotifyGetLastMessageFromTelegram()
Local $TGActionMSG = StringUpper(StringStripWS($g_sTGLastMessage, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProc $TGActionMSG : " & $TGActionMSG)
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProc $g_iTGLastRemote : " & $g_iTGLastRemote)
If $g_bDebugSetlog Then SetDebugLog("Telegram | NotifyRemoteControlProc $g_sTGLast_UID : " & $g_sTGLast_UID)
If($TGActionMSG = "/START" Or $TGActionMSG = "KEYB") And $g_iTGLastRemote <> $g_sTGLast_UID Then
$g_iTGLastRemote = $g_sTGLast_UID
NotifyActivateKeyboardOnTelegram($g_sBotTitle & " | Notify " & $g_sNotifyVersion)
Else
If $g_iTGLastRemote <> $g_sTGLast_UID Then
$g_iTGLastRemote = $g_sTGLast_UID
Switch $TGActionMSG
Case "HELP", '\U2753 ' & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP")
Local $txtHelp = "Telegram " & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP") & " " & GetTranslatedFileIni("MBR Func_Notify", "Bot_Info_01", "- You can remotely control your bot sending COMMANDS from the following list:")
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "HELP", "HELP") & " " & GetTranslatedFileIni("MBR Func_Notify", "HELP_Info_01", "- send this help message")
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESTART_Info_01", "- restart the Emulator and bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "START", "START") & " " & GetTranslatedFileIni("MBR Func_Notify", "START_Info_01", "- start the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP") & " " & GetTranslatedFileIni("MBR Func_Notify", "STOP_Info_01", "- stop the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE") & " " & GetTranslatedFileIni("MBR Func_Notify", "PAUSE_Info_01", "- pause the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESUME_Info_01", "- resume the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS") & " " & GetTranslatedFileIni("MBR Func_Notify", "STATS_Info_01", "- send Village Statistics of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG") & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_01", "- send the current log file of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID") & " " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID_Info_01", "- send the last raid loot screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT") & " " & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT_Info_01", "- send the last raid loot values of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT") & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_01", "- send a screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD", "SCREENSHOTHD") & " " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD_Info_01", "- send a screenshot in high resolution of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER") & " " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER_Info_01", "- send a screenshot of builder status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '%0A' & GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD") & " " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD_Info_01", "- send a screenshot of shield status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS", "RESETSTATS") & " " & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS_Info_01", "- reset Village Statistics")
$txtHelp &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS") & " " & GetTranslatedFileIni("MBR Func_Notify", "TROOPS_Info_01", "- send Troops & Spells Stats")
$txtHelp &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKON", "HALTATTACKON") & " " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF_Info_01", "- Turn On 'Halt Attack' in the 'Misc' Tab with the 'stay online' option")
$txtHelp &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "HALTATTACKOFF", "HALTATTACKOFF") & " " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON_Info_01", "- Turn Off 'Halt Attack' in the 'Misc' Tab")
$txtHelp &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE") & " " & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE_Info_01", "- Hibernate host PC")
$txtHelp &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN") & " " & GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN_Info_01", "- Shut down host PC")
$txtHelp &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY") & " " & GetTranslatedFileIni("MBR Func_Notify", "STANDBY_Info_01", "- Standby host PC")
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Help_Info_01", "Request for Help") & "%0A" & $txtHelp)
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Help has been sent", $COLOR_SUCCESS)
Case "RESTART", '\UD83D\UDD01 ' & GetTranslatedFileIni("MBR Func_Notify", "RESTART", "RESTART")
SetLog("Notify Telegram: Your request has been received.", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Restart_Info_01", "Request to Restart...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Restart_Info_02", "Your bot and Emulator are now restarting..."))
SaveConfig()
RestartBot()
Case "START", '\u25b6 ' & GetTranslatedFileIni("MBR Func_Notify", "START", "START")
If $g_bRunState = True Then
SetLog("Notify Telegram" & ": " & "Your bot is currently started, no action was taken", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_01", "Request to Start...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Start_Info_03", "Your bot is currently started, no action was taken"))
EndIf
Case "STOP", '\U25AA ' & GetTranslatedFileIni("MBR Func_Notify", "STOP", "STOP")
SetLog("Notify Telegram: Your request has been received. Bot is now stopped", $COLOR_SUCCESS)
If $g_bRunState = True Then
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_01", "Request to Stop...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_02", "Your bot is now stopping..."))
btnStop()
Else
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_01", "Request to Stop...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Stop_Info_03", "Your bot is currently stopped, no action was taken"))
EndIf
Case "PAUSE", '\UD83D\UDD00 ' & GetTranslatedFileIni("MBR Func_Notify", "PAUSE", "PAUSE")
If $g_bBotPaused = False And $g_bRunState = True Then
If( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = False And IsAttackPage() Then
SetLog("Notify Telegram: Unable to pause during attack", $COLOR_ERROR)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Pause_Info_01", "Request to Pause...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Pause_Info_04", "Unable to pause during attack, try again later."))
ElseIf( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = True And IsAttackPage() Then
ReturnHome(False, False)
$g_bIsSearchLimit = True
$g_bIsClientSyncError = True
$g_bRestart = True
TogglePauseImpl("Push")
Return True
Else
TogglePauseImpl("Push")
EndIf
Else
SetLog("Notify Telegram: Your bot is currently paused, no action was taken", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Pause_Info_01", "Request to Pause...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Pause_Info_03", "Your bot is currently paused, no action was taken"))
EndIf
Case "RESUME", '\U25B6 ' & GetTranslatedFileIni("MBR Func_Notify", "RESUME", "RESUME")
If $g_bBotPaused = True And $g_bRunState = True Then
TogglePauseImpl("Push")
Else
SetLog("Notify Telegram: Your bot is currently resumed, no action was taken", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Resume_Info_01", "Request to Resume...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Resume_Info_03", "Your bot is currently resumed, no action was taken"))
EndIf
Case "STATS", '\UD83D\UDCC8 ' & GetTranslatedFileIni("MBR Func_Notify", "STATS", "STATS")
SetLog("Notify Telegram: Your request has been received. Statistics sent", $COLOR_SUCCESS)
Local $GoldGainPerHour = "0 / h"
Local $ElixirGainPerHour = "0 / h"
Local $DarkGainPerHour = "0 / h"
Local $TrophyGainPerHour = "0 / h"
If $g_iFirstAttack = 2 Then
$GoldGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$eLootGold] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "K / h"
$ElixirGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$eLootElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "K / h"
EndIf
If $g_iStatsStartedWith[$eLootDarkElixir] <> "" Then
$DarkGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$eLootDarkElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h"
EndIf
$TrophyGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$eLootTrophy] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h"
Local $txtStats = " | " & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_02", "Stats Village Report") & ":" & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_03", "At Start") & ":" & "%0A" & "[" & "G" & "]: " & _NumberFormat($g_iStatsStartedWith[$eLootGold])
$txtStats &= " [" & "E" & "]: " & _NumberFormat($g_iStatsStartedWith[$eLootElixir]) & "%0A" & "[" & "DE" & "]: " & _NumberFormat($g_iStatsStartedWith[$eLootDarkElixir]) & " [" & "T" & "]: " & $g_iStatsStartedWith[$eLootTrophy]
$txtStats &= "%0A%0A" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_04", "Now (Current Resources)") & ":" & "%0A" & "[" & "G" & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & " [" & "E" & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir])
$txtStats &= "%0A" & "[" & "DE" & "]: " & _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir]) & " [" & "T" & "]: " & $g_aiCurrentLoot[$eLootTrophy] & " [" & "GEM" & "]: " & $g_iGemAmount
$txtStats &= "%0A%0A" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_05", "Gain per Hour") & ":" & "%0A" & "[" & "G" & "]: " & $GoldGainPerHour & " [" & "E" & "]: " & $ElixirGainPerHour
$txtStats &= "%0A" & "[" & "DE" & "]: " & $DarkGainPerHour & " [" & "T" & "]: " & $TrophyGainPerHour
$txtStats &= "%0A%0A" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_06", "No. of Free Builders") & ": " & $g_iFreeBuilderCount & "%0A[" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_07", "No. of Wall Up") & "]: [" & "G" & "]: "
$txtStats &= $g_iNbrOfWallsUppedGold & "/ [" & "E" & "]: " & $g_iNbrOfWallsUppedElixir & "%0A%0A" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_08", "Attacked") & ": "
$txtStats &= $g_aiAttackedCount & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_09", "Skipped") & ": " & $g_iSkippedVillageCount
$txtStats &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_10", "Run Time") & ": " & GUICtrlRead($g_hLblResultRuntime)
$txtStats &= "%0A%0A" & GetTranslatedFileIni("MBR Func_Notify", "Stats_Info_11", "Clan Games") & ": "
$txtStats &= "%0A" & "[T]: " & GUICtrlRead($g_hLblRemainTime) & " [S]: " & GUICtrlRead($g_hLblYourScore)
$txtStats &= "%0A" & " "
NotifyPushToTelegram($g_sNotifyOrigin & $txtStats)
Case "LOG", '\UD83D\UDCCB ' & GetTranslatedFileIni("MBR Func_Notify", "LOG", "LOG")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Log is now sent", $COLOR_SUCCESS)
NotifyPushFileToTelegram($g_sLogFileName, "Logs", "text\/plain; charset=utf-8", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "LOG_Info_02", "Current Log") & "%0A")
Case "LASTRAID", '\UD83C\UDF04 ' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAID", "LASTRAID")
If $g_sLootFileName <> "" Then
NotifyPushFileToTelegram($g_sLootFileName, "Loots", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_02", "Last Raid") & "%0A" & $g_sLootFileName)
SetLog("Notify Telegram: Push Last Raid Snapshot...", $COLOR_SUCCESS)
Else
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_03", "There is no last raid screenshot."))
SetLog("There is no last raid screenshot.")
SetLog("Notify Telegram: Your request has been received. Last Raid txt sent", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_04", "Last Raid txt") & "%0A" & "[" & "G" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [" & "E" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [" & "DE" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [" & "T" & "]: " & $g_iStatsLastAttack[$eLootTrophy])
EndIf
Case "LASTRAIDTXT", '\UD83D\UDCC4 ' & GetTranslatedFileIni("MBR Func_Notify", "LASTRAIDTXT", "LASTRAIDTXT")
SetLog("Notify Telegram: Your request has been received. Last Raid txt sent", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_04", "Last Raid txt") & "%0A" & "[" & "G" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & " [" & "E" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & " [" & "DE" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & " [" & "T" & "]: " & $g_iStatsLastAttack[$eLootTrophy])
Case "SCREENSHOT"
SetLog("Notify Telegram: ScreenShot request received", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_03", "Chief, your request for Screenshot will be processed ASAP"))
$g_bTGRequestScreenshot = True
Case "SCREENSHOTHD", '\UD83D\UDCF7 ' & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT", "SCREENSHOT")
SetLog("Notify Telegram: ScreenShot HD request received", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOTHD_Info_03", "Chief, your request for ScreenshotHD will be processed ASAP"))
$g_bTGRequestScreenshot = True
$g_bTGRequestScreenshotHD = True
$g_bNotifyForced = False
Case "BUILDER", '\UD83D\UDD28 ' & GetTranslatedFileIni("MBR Func_Notify", "BUILDER", "BUILDER")
SetLog("Notify Telegram: Builder Status request received", $COLOR_SUCCESS)
$g_bTGRequestBuilderInfo = True
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER_Info_03", "Chief, your request for Builder Info will be processed ASAP"))
Case "SHIELD", '\UD83D\UDD30 ' & GetTranslatedFileIni("MBR Func_Notify", "SHIELD", "SHIELD")
SetLog("Notify Telegram: Shield Status request received", $COLOR_SUCCESS)
$g_bTGRequestShieldInfo = True
$g_bNotifyForced = False
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD_Info_03", "Chief, your request for Shield Info will be processed ASAP"))
Case "RESETSTATS"
btnResetStats()
SetLog("Notify Telegram: Your request has been received. Statistics resetted", $COLOR_SUCCESS)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "RESETSTATS_Info_02", "Statistics resetted."))
Case "TROOPS", '\UD83D\UDCAA ' & GetTranslatedFileIni("MBR Func_Notify", "TROOPS", "TROOPS")
SetLog("Notify Telegram: Your request has been received. Sending Troop/Spell Stats...", $COLOR_SUCCESS)
Local $txtTroopStats = " | " & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_01", "Train Status") & ": " & "%0A"
For $i = 0 To UBound($g_aiArmyCompTroops) - 1
If $g_aiArmyCompTroops[$i] > 0 Then
$txtTroopStats &= $g_asTroopShortNames[$i] & ": " & $g_aiCurrentTroops[$i] & " of " & $g_aiArmyCompTroops[$i] & "%0A"
EndIf
Next
For $i = 0 To UBound($g_aiArmyCompSpells) - 1
If $g_aiArmyCompSpells[$i] > 0 Then
$txtTroopStats &= $g_asSpellShortNames[$i] & ": " & $g_aiCurrentSpells[$i] & " of " & $g_aiArmyCompSpells[$i] & "%0A"
EndIf
Next
For $i = 0 To UBound($g_aiArmyCompSiegeMachine) - 1
If $g_aiArmyCompSiegeMachine[$i] > 0 Then
$txtTroopStats &= $g_asSiegeMachineShortNames[$i] & ": " & $g_aiArmyCompSiegeMachine[$i] & " of " & $g_aiArmyCompSiegeMachine[$i] & "%0A"
EndIf
Next
$txtTroopStats &= "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_02", "Current Capacities") & ":"
$txtTroopStats &= "%0A" & " " & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_03", "- Army Camp") & ": " & $g_CurrentCampUtilization & "/" & $g_iTotalCampSpace
$txtTroopStats &= "%0A" & " " & GetTranslatedFileIni("MBR Func_Notify", "Train_Info_04", "- Spells") & ": " & $g_iCurrentSpells & "/" & $g_iTotalTrainSpaceSpell
NotifyPushToTelegram($g_sNotifyOrigin & $txtTroopStats)
Case "HALTATTACKON", '\U274C ' & StringUpper(GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF", "ATTACK OFF"))
GUICtrlSetState($g_hChkBotStop, $GUI_CHECKED)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON_Info_02", "Set Halt Attack ON."))
btnStop()
$g_bChkBotStop = True
$g_iCmbBotCond = 18
btnStart()
Case "HALTATTACKOFF", '\U2705 ' & StringUpper(GetTranslatedFileIni("MBR Func_Notify", "ATTACK ON", "ATTACK ON"))
GUICtrlSetState($g_hChkBotStop, $GUI_UNCHECKED)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "ATTACK OFF_Info_02", "Set Halt Attack OFF."))
btnStop()
btnStart()
Case "HIBERNATE", '\UD83D\UDCA4 ' & GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE", "HIBERNATE")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Hibernate PC", $COLOR_SUCCESS)
$bHibernate = True
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "CONFIRM_Info_01", "Are you sure?, Please send") & " CONFIRM" & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "CONFIRM_Info_02", "If isn't to continue send") & " CANCEL")
Case "SHUTDOWN", '\U26A1 ' & StringUpper(GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN", "SHUTDOWN"))
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Shutdown PC", $COLOR_SUCCESS)
$bShutdown = True
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "CONFIRM_Info_01", "Are you sure?, Please send") & " CONFIRM" & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "CONFIRM_Info_02", "If isn't to continue send") & " CANCEL")
Case "STANDBY", '\UD83d\UDD06 ' & GetTranslatedFileIni("MBR Func_Notify", "STANDBY", "STANDBY")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Standby PC", $COLOR_SUCCESS)
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "CONFIRM_Info_01", "Are you sure?, Please send") & " CONFIRM" & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "CONFIRM_Info_02", "If isn't to continue send") & " CANCEL")
$bStandby = True
Case "CONFIRM"
If $bShutdown Then
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "SHUTDOWN_Info_02", "PC Shutdown sequence initiated"))
$bShutdown = False
Shutdown(5)
ElseIf $bHibernate Then
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "HIBERNATE_Info_02", "PC Hibernate sequence initiated"))
$bHibernate = False
Shutdown(64)
ElseIf $bStandby Then
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "STANDBY_Info_02", "PC Standby sequence initiated"))
$bStandby = False
Shutdown(32)
EndIf
Case "CANCEL"
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "CANCEL_Info_01", "Canceled the last sequence"))
$bShutdown = False
$bHibernate = False
$bStandby = False
Case Else
NotifyPushToTelegram(GetTranslatedFileIni("MBR Func_Notify", "ELSE_Info_01", "Sorry Chief!,") & " " & $TGActionMSG & " " & GetTranslatedFileIni("MBR Func_Notify", "ELSE_Info_02", "is not a valid command."))
EndSwitch
EndIf
EndIf
EndIf
EndFunc
Func NotifyPushMessageToBoth($Message, $Source = "")
If Not $g_bNotifyTGEnable Then Return
If $g_bDebugSetlog Then SetDebugLog("Notify | NotifyPushMessageToBoth($Message, $Source = ""): " & $Message & "," & $Source)
Static $iReportIdleBuilder = 0
If Not IsPlanUseTelegram($Message) Then Return
$g_bNotifyForced = False
Local $hBitmap_Scaled
Switch $Message
Case "Restarted"
If $g_bNotifyRemoteEnable Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Restarted_Info_01", "Bot restarted"))
Case "OutOfSync"
If $g_bNotifyAlertOutOfSync Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Out-Of-Sync_Info_01", "Restarted after Out of Sync Error") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Out-Of-Sync_Info_02", "Attacking now..."))
Case "LastRaid"
If $g_bNotifyAlerLastRaidTXT Then
$g_aiCurrentLoot[$eLootTrophy]=$g_aiCurrentLoot[$eLootTrophy] + $g_iStatsLastAttack[$eLootTrophy]
$g_iStatsLastAttack[$eLootGold]=$g_iStatsLastAttack[$eLootGold]/1000
$g_iStatsLastAttack[$eLootElixir]=$g_iStatsLastAttack[$eLootElixir]/1000
$g_iStatsLastAttack[$eLootDarkElixir]=$g_iStatsLastAttack[$eLootDarkElixir]/1000
$g_iStatsLastAttack[$eLootGold]=round($g_iStatsLastAttack[$eLootGold],-1)
$g_iStatsLastAttack[$eLootElixir]=round($g_iStatsLastAttack[$eLootElixir],-1)
$g_iStatsLastAttack[$eLootDarkElixir]=round($g_iStatsLastAttack[$eLootDarkElixir],1)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Last-Raid_Info_04", "Last Raid txt") & "%0A" & "[" & "G" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootGold]) & "k  [" & "E" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootElixir]) & "k  [" & "DE" & "]: " & _NumberFormat($g_iStatsLastAttack[$eLootDarkElixir]) & "k %0A[" & "T" & "]: " & $g_iStatsLastAttack[$eLootTrophy] & "  [" & "%" & "]: " & $g_sTotalDamage & "  [" & "*" & "]: " & $g_sStarsEarned & "  [Tr#]: " & $g_aiCurrentLoot[$eLootTrophy])
If _Sleep($DELAYPUSHMSG1) Then Return
SetLog("Notify Telegram: Last Raid Text has been sent!", $COLOR_SUCCESS)
EndIf
If $g_bNotifyAlerLastRaidIMG Then
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
If $g_bScreenshotLootInfo Then
$g_sAttackFile = $g_sLootFileName
Else
_CaptureRegion()
$g_sAttackFile = "Notify_" & $Date & "__" & $Time & ".jpg"
$hBitmap_Scaled = _GDIPlus_ImageResize($g_hBitmap, _GDIPlus_ImageGetWidth($g_hBitmap) / 2, _GDIPlus_ImageGetHeight($g_hBitmap) / 2)
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileLootsPath & $g_sAttackFile)
_GDIPlus_ImageDispose($hBitmap_Scaled)
EndIf
SetLog("Notify Telegram: Last Raid screenshot has been sent!", $COLOR_SUCCESS)
NotifyPushFileToTelegram($g_sAttackFile, "Loots", "image/jpeg", $g_sNotifyOrigin & " | " & "Last Raid" & "%0A" & $g_sAttackFile)
If _Sleep($DELAYPUSHMSG1) Then Return
Local $iDelete = FileDelete($g_sProfileLootsPath & $g_sAttackFile)
If Not $iDelete Then
SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
EndIf
EndIf
Case "FoundWalls"
If $g_bNotifyAlertUpgradeWalls Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Found-Walls_Info_01", "Found Wall level") & " " & $g_iCmbUpgradeWallsLevel + 4 & "%0A" & " " & GetTranslatedFileIni("MBR Func_Notify", "Found-Walls_Info_02", "Wall segment has been located...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Found-Walls_Info_03", "Upgrading..."))
Case "SkipWalls"
If $g_bNotifyAlertUpgradeWalls Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Skip-Walls_Info_01", "Cannot find Wall level") & $g_iCmbUpgradeWallsLevel + 4 & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Skip-Walls_Info_02", "Skip upgrade..."))
Case "AnotherDevice3600"
If $g_bNotifyAlertAnotherDevice Then NotifyPushToTelegram($g_sNotifyOrigin & " | 1. " & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_01", "Another Device has connected") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_02", "Another Device has connected, waiting") & " " & Floor(Floor($g_iAnotherDeviceWaitTime / 60) / 60) & " " & GetTranslatedFileIni("MBR Global GUI Design", "Hours", -1) & " " & Floor(Mod(Floor($g_iAnotherDeviceWaitTime / 60), 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "Min", -1) & " " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "seconds", -1))
Case "AnotherDevice60"
If $g_bNotifyAlertAnotherDevice Then NotifyPushToTelegram($g_sNotifyOrigin & " | 2. " & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_01", "Another Device has connected") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_02", "Another Device has connected, waiting") & " " & Floor(Mod(Floor($g_iAnotherDeviceWaitTime / 60), 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "Min", -1) & " " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "seconds", -1))
Case "AnotherDevice"
If $g_bNotifyAlertAnotherDevice Then NotifyPushToTelegram($g_sNotifyOrigin & " | 3. " & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_01", "Another Device has connected") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Another-Device_Info_02", "Another Device has connected, waiting") & " " & Floor(Mod($g_iAnotherDeviceWaitTime, 60)) & " " & GetTranslatedFileIni("MBR Global GUI Design", "seconds", -1))
Case "TakeBreak"
If $g_bNotifyAlertTakeBreak Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Take-Break_Info_01", "Chief, we need some rest!") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Take-Break_Info_02", "Village must take a break.."))
Case "Update"
If $g_bNotifyAlertBOTUpdate Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "New-Version_Info_01", "Chief, there is a new version of the bot available"))
Case "BuilderIdle"
If $g_bNotifyAlertBulderIdle Then
Local $iAvailBldr = $g_iFreeBuilderCount -($g_bUpgradeWallSaveBuilder ? 1 : 0)
If $iAvailBldr > 0 Then
If $iReportIdleBuilder <> $iAvailBldr Then
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Builder-Idle_Info_01", "You have") & " " & $iAvailBldr & " " & GetTranslatedFileIni("MBR Func_Notify", "Builder-Idle_Info_02", "builder(s) idle."))
SetLog("You have " & $iAvailBldr & " builder(s) idle.", $COLOR_SUCCESS)
$iReportIdleBuilder = $iAvailBldr
EndIf
Else
$iReportIdleBuilder = 0
EndIf
EndIf
Case "CocError"
If $g_bNotifyAlertOutOfSync Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Coc-Error_Info_01", "CoC Has Stopped Error....."))
Case "Pause"
If $g_bNotifyRemoteEnable And $Source = "Push" Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Pause_Info_01", "Request to Pause...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Pause_Info_02", "Your request has been received. Bot is now paused"))
Case "Resume"
If $g_bNotifyRemoteEnable And $Source = "Push" Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Request-Resume_Info_01", "Request to Resume...") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Request-Resume_Info_02", "Your request has been received. Bot is now resumed"))
Case "OoSResources"
If $g_bNotifyAlertOutOfSync Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "OoS-Resources_Info_01", "Disconnected after") & " " & StringFormat("%3s", $g_iSearchCount) & " " & GetTranslatedFileIni("MBR Func_Notify", "Skip_Info_01", "skip(s)") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "OoS-Resources_Info_02", "Cannot locate Next button, Restarting Bot..."))
Case "MatchFound"
If $g_bNotifyAlertMatchFound Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & $g_asModeText[$g_iMatchMode] & " " & GetTranslatedFileIni("MBR Func_Notify", "Match-Found_Info_01", "Match Found! after") & " " & StringFormat("%3s", $g_iSearchCount) & " " & GetTranslatedFileIni("MBR Func_Notify", "Skip_Info_01", "skip(s)") & "%0A" & "[" & "G" & "]: " & _NumberFormat($g_iSearchGold) & "; [" & "E" & "]: " & _NumberFormat($g_iSearchElixir) & "; [" & "DE" & "]: " & _NumberFormat($g_iSearchDark) & "; [" & "T" & "]: " & $g_iSearchTrophy)
Case "UpgradeWithGold"
If $g_bNotifyAlertUpgradeWalls Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_01", "Upgrade completed by using GOLD") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_02", "Complete by using GOLD..."))
Case "UpgradeWithElixir"
If $g_bNotifyAlertUpgradeWalls Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_03", "Upgrade completed by using ELIXIR") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_04", "Complete by using ELIXIR..."))
Case "NoUpgradeWallButton"
If $g_bNotifyAlertUpgradeWalls Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_05", "No Upgrade Gold Button") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_06", "Cannot find gold upgrade button..."))
Case "NoUpgradeElixirButton"
If $g_bNotifyAlertUpgradeWalls Then NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_07", "No Upgrade Elixir Button") & "%0A" & GetTranslatedFileIni("MBR Func_Notify", "Upgrading_Info_08", "Cannot find elixir upgrade button..."))
Case "RequestScreenshot"
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion()
If $g_bTGRequestScreenshotHD Then
$hBitmap_Scaled = $g_hBitmap
Else
$hBitmap_Scaled = _GDIPlus_ImageResize($g_hBitmap, _GDIPlus_ImageGetWidth($g_hBitmap) / 2, _GDIPlus_ImageGetHeight($g_hBitmap) / 2)
EndIf
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileTempPath & $Screnshotfilename)
_GDIPlus_ImageDispose($hBitmap_Scaled)
If $g_bTGRequestScreenshot Then
If $g_bTGRequestScreenshot Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SCREENSHOT_Info_04", "Screenshot of your village") & " " & "%0A" & $Screnshotfilename)
SetLog("Notify Telegram: Screenshot sent!", $COLOR_SUCCESS)
EndIf
EndIf
$g_bTGRequestScreenshot = False
$g_bTGRequestScreenshotHD = False
If _Sleep($DELAYPUSHMSG2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
EndIf
Case "BuilderInfo"
ClickP($aAway, 1, 0, "#0112")
Click(295, 30)
_Sleep(750)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion(224, 74, 446, 240)
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($g_hBitmap, $g_sProfileTempPath & $Screnshotfilename)
If $g_bTGRequestBuilderInfo Then
If $g_bTGRequestBuilderInfo Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "BUILDER_Info_04", "Builder Information") & "%0A" & $Screnshotfilename)
SetLog("Notify Telegram: Builder Information sent!", $COLOR_GREEN)
EndIf
EndIf
$g_bTGRequestBuilderInfo = False
If _Sleep($DELAYPUSHMSG2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
EndIf
ClickP($aAway, 1, 0, "#0112")
Case "ShieldInfo"
ClickP($aAway, 1, 0, "#0112")
Click(435, 8)
_Sleep(500)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion(200, 165, 660, 568)
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($g_hBitmap, $g_sProfileTempPath & $Screnshotfilename)
If $g_bTGRequestShieldInfo Then
If $g_bTGRequestShieldInfo Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "SHIELD_Info_04", "Shield Information") & "%0A" & $Screnshotfilename)
SetLog("Notify Telegram: Shield Information sent!", $COLOR_SUCCESS)
EndIf
EndIf
$g_bTGRequestShieldInfo = False
If _Sleep($DELAYPUSHMSG2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_ERROR)
EndIf
ClickP($aAway, 1, 0, "#0112")
Case "CampFull"
If $g_bNotifyAlertCampFull Then
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslatedFileIni("MBR Func_Notify", "Camps-Full_Info_01", "Your Army Camps are now Full"))
SetLog("Notify Telegram: Your Army Camps are now Full", $COLOR_SUCCESS)
EndIf
Case "Misc"
NotifyPushToTelegram($Message)
EndSwitch
EndFunc
Func IsPlanUseTelegram($Message)
If Not $g_bNotifyForced And $Message <> "DeleteAllPBMessages" Then
If $g_bNotifyScheduleWeekDaysEnable Then
If $g_abNotifyScheduleWeekDays[@WDAY - 1] Then
If $g_bNotifyScheduleHoursEnable Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abNotifyScheduleHours[$hour[0]] Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_WARNING)
SetLog($Message, $COLOR_ORANGE)
Return False
EndIf
EndIf
Else
Return False
EndIf
Else
If $g_bNotifyScheduleHoursEnable Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If Not $g_abNotifyScheduleHours[$hour[0]] Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_WARNING)
SetLog($Message, $COLOR_ORANGE)
Return False
EndIf
EndIf
EndIf
EndIf
Return True
EndFunc
Func _IsInternet()
Local $Ret = DllCall('wininet.dll', 'int', 'InternetGetConnectedState', 'dword*', 0x20, 'dword', 0)
If @error Then
Return SetError(1, 0, 0)
EndIf
Local $Error = _WinAPI_GetLastError()
Return SetError((Not($Error = 0)), $Error, $Ret[0])
EndFunc
Func __ErrFunc($oError)
SetLog("COM Error intercepted !" & @CRLF & "Scriptline is: " & $oError.scriptline & @CRLF & "Number is: " & Hex($oError.number, 8) & @CRLF & "Returncode is: " & Hex($oError.retcode, 8) & @CRLF & "WinDescription is: " & $oError.windescription & @CRLF & "Description is: " & $oError.description, $COLOR_RED)
EndFunc
Func __ObjEventIni()
$g_oCOMErrorHandler = ObjEvent("AutoIt.Error", "__ErrFunc")
EndFunc
Func __ObjEventEnds()
$g_oCOMErrorHandler = 0
EndFunc
Global Const $sColorNA = Hex(0xD3D3CB, 6)
Global Const $sColorNoLoot = Hex(0xFD877E, 6)
Global Const $sColorMaxLvl = Hex(0xFFFFFF, 6)
Global Const $sColorLabUgReq = Hex(0x838383, 6)
Global Const $sColorMaxTroop = Hex(0xFFC360, 6)
Global Const $sColorBG = Hex(0xD3D3CB, 6)
Global Const $aiCloseDefaultPOS[2] = [721, 143]
Global Const $aiIconDefaultPOS[36][2] = [ [-1, -1], [114, 337 + $g_iMidOffsetY], [114, 444 + $g_iMidOffsetY], [221, 337 + $g_iMidOffsetY], [221, 444 + $g_iMidOffsetY], [327, 337 + $g_iMidOffsetY], [327, 444 + $g_iMidOffsetY], [434, 337 + $g_iMidOffsetY], [434, 444 + $g_iMidOffsetY], [541, 337 + $g_iMidOffsetY], [541, 444 + $g_iMidOffsetY], [647, 337 + $g_iMidOffsetY], [647, 444 + $g_iMidOffsetY], [114, 337 + $g_iMidOffsetY], [114, 444 + $g_iMidOffsetY], [221, 337 + $g_iMidOffsetY], [221, 444 + $g_iMidOffsetY], [327, 337 + $g_iMidOffsetY], [327, 444 + $g_iMidOffsetY], [434, 337 + $g_iMidOffsetY], [434, 444 + $g_iMidOffsetY], [541, 337 + $g_iMidOffsetY], [541, 444 + $g_iMidOffsetY], [647, 337 + $g_iMidOffsetY], [647, 444 + $g_iMidOffsetY], [114, 337 + $g_iMidOffsetY], [114, 444 + $g_iMidOffsetY], [221, 337 + $g_iMidOffsetY], [221, 444 + $g_iMidOffsetY], [327, 337 + $g_iMidOffsetY], [327, 444 + $g_iMidOffsetY], [434, 337 + $g_iMidOffsetY], [434, 444 + $g_iMidOffsetY], [541, 337 + $g_iMidOffsetY], [541, 444 + $g_iMidOffsetY], [647, 337 + $g_iMidOffsetY]]
Func Laboratory()
Local $aUpgradeValue[36] = [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $iAvailElixir, $iAvailDark, $sElixirCount, $sDarkCount, $TimeDiff, $aArray, $Result
Local $iXMoved = 0, $iYMoved = 0, $iFirstPageOffset = 0, $iLastPageOffset = 0
Local $iSelectedUpgrade = $g_iCmbLaboratory
$g_iUpgradeMinElixir = Number($g_iUpgradeMinElixir)
$g_iUpgradeMinDark = Number($g_iUpgradeMinDark)
$g_iLaboratoryElixirCost = 0
$g_iLaboratoryDElixirCost = 0
If Not $g_bAutoLabUpgradeEnable Then Return
If $g_aiLaboratoryPos[0] = 0 Or $g_aiLaboratoryPos[1] = 0 Then
SetLog("Laboratory Location not found!", $COLOR_WARNING)
LocateLab()
If $g_aiLaboratoryPos[0] = 0 Or $g_aiLaboratoryPos[1] = 0 Then
SetLog("Problem locating Laboratory, train laboratory position before proceeding", $COLOR_ERROR)
Return False
EndIf
EndIf
If $g_sLabUpgradeTime <> "" Then $TimeDiff = _DateDiff("n", _NowCalc(), $g_sLabUpgradeTime)
If @error Then _logErrorDateDiff(@error)
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$g_iCmbLaboratory][3] & " Lab end time: " & $g_sLabUpgradeTime & ", DIFF= " & $TimeDiff, $COLOR_DEBUG)
If Not $g_bRunState Then Return
If $TimeDiff <= 0 Then
SetLog("Checking Troop Upgrade in Laboratory ...", $COLOR_INFO)
Else
SetLog("Laboratory Upgrade in progress, waiting for completion", $COLOR_INFO)
Return False
EndIf
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$sElixirCount = getResourcesMainScreen(696, 74)
$sDarkCount = getResourcesMainScreen(728, 123)
SetLog("Updating village values [E]: " & $sElixirCount & " [D]: " & $sDarkCount, $COLOR_SUCCESS)
Else
$sElixirCount = getResourcesMainScreen(701, 74)
SetLog("Updating village values [E]: " & $sElixirCount, $COLOR_SUCCESS)
EndIf
$iAvailElixir = Number($sElixirCount)
$iAvailDark = Number($sDarkCount)
BuildingClickP($g_aiLaboratoryPos, "#0197")
If _Sleep($DELAYLABORATORY3) Then Return
Local $aResearchButton = findButton("Research", Default, 1, True)
If IsArray($aResearchButton) And UBound($aResearchButton, 1) = 2 Then
If $g_bDebugImageSave Then DebugImageSave("StarLabUpgrade")
ClickP($aResearchButton)
If _Sleep($DELAYLABORATORY1) Then Return
Else
SetLog("Cannot find the Laboratory Research Button!", $COLOR_ERROR)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
Return False
EndIf
If $g_bDebugSetlog Then SetLog("_GetPixelColor(730, 200): " & _GetPixelColor(730, 200, True) & ":A2CB6C", $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(730, 200, True), Hex(0xA2CB6C, 6), 20) Then
SetLog("Laboratory Upgrade in progress, waiting for completion", $COLOR_INFO)
If _Sleep($DELAYLABORATORY2) Then Return
Local $sLabTimeOCR = getRemainTLaboratory(270, 257)
Local $iLabFinishTime = ConvertOCRTime("Lab Time", $sLabTimeOCR, False)
SetDebugLog("$sLabTimeOCR: " & $sLabTimeOCR & ", $iLabFinishTime = " & $iLabFinishTime & " m")
If $iLabFinishTime > 0 Then
$g_sLabUpgradeTime = _DateAdd('n', Ceiling($iLabFinishTime), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog("Research will finish in " & $sLabTimeOCR & " (" & $g_sLabUpgradeTime & ")")
LabStatusGUIUpdate()
ElseIf $g_bDebugSetlog Then
SetLog("Invalid getRemainTLaboratory OCR", $COLOR_DEBUG)
EndIf
ClickP($aAway, 2, $DELAYLABORATORY4, "#0328")
Return False
EndIf
For $i = 1 to UBound($aiIconDefaultPOS) - 1
$g_avLabTroops[$i][0] = $aiIconDefaultPOS[$i][0]
$g_avLabTroops[$i][1] = $aiIconDefaultPOS[$i][1]
Next
Local $aiCloseBtn = findButton("CloseWindow")
If IsArray($aiCloseBtn) Then
$iXMoved = $aiCloseBtn[0] - $aiCloseDefaultPOS[0]
$iYMoved = $aiCloseBtn[1] - $aiCloseDefaultPOS[1]
If $g_bDebugSetlog Then Setlog("Lab window off: (" & $iXMoved & ", " & $iYMoved & ")", $COLOR_DEBUG)
Else
SetLog("Trouble finding lab close button, try again...", $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
Return False
EndIf
For $x = 0 To 10
If Not(_ColorCheck(_GetPixelColor(114 + $x + $iXMoved, 410 + $iYMoved, True), $sColorBG, 10) And  _ColorCheck(_GetPixelColor(114 + $x + $iXMoved, 520 + $iYMoved, True), $sColorBG, 10)) Then
$iFirstPageOffset = $x
ExitLoop
EndIf
Next
If $g_bDebugSetlog Then Setlog("Icon Offset on First Page: " & $iFirstPageOffset & "px", $COLOR_DEBUG)
For $i = 0 To 3
ClickDrag(533, 439 + $g_iMidOffsetY, 213, 439 + $g_iMidOffsetY, 250)
Next
If _Sleep($DELAYLABORATORY5) Then Return
For $x = 0 To 5
If Not(_ColorCheck(_GetPixelColor(114 + $x + $iXMoved, 410 + $iYMoved, True), $sColorBG, 10) And  _ColorCheck(_GetPixelColor(114 + $x + $iXMoved, 520 + $iYMoved, True), $sColorBG, 10)) Then
$iLastPageOffset = $x
ExitLoop
EndIf
Next
If $g_bDebugSetlog Then Setlog("Icon Offset on Last Page: " & $iLastPageOffset & "px", $COLOR_DEBUG)
For $i = 0 To 3
ClickDrag(213, 439 + $g_iMidOffsetY, 533, 439 + $g_iMidOffsetY, 250)
Next
If _Sleep($DELAYLABORATORY5) Then Return
For $i = 1 to UBound($aiIconDefaultPOS) - 1
$g_avLabTroops[$i][0] = $aiIconDefaultPOS[$i][0] + $iXMoved +(($g_avLabTroops[$i][2] = 0) ? $iFirstPageOffset : 0) +(($g_avLabTroops[$i][2] = 2) ? $iLastPageOffset : 0)
If $g_bDebugSetlog Then Setlog("New icon X position of " & $g_avLabTroops[$i][3] & " : " & $g_avLabTroops[$i][0], $COLOR_DEBUG)
$g_avLabTroops[$i][1] = $aiIconDefaultPOS[$i][1] + $iYMoved
If $g_bDebugSetlog Then Setlog("New icon Y position of " & $g_avLabTroops[$i][3] & " : " & $g_avLabTroops[$i][1], $COLOR_DEBUG)
Next
If $g_bDebugSetlog Then LabTroopImages(1, 12)
For $i = 1 To 12
$aUpgradeValue[$i] = getLabUpgrdResourceRed($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 73)
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or Int($aUpgradeValue[$i]) < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 73)
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or Int($aUpgradeValue[$i]) < 9999 Then
$aUpgradeValue[$i] = 0
If _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 76, $g_avLabTroops[$i][1] + 76, True), $sColorMaxLvl, 20) And  _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 76, $g_avLabTroops[$i][1] + 80, True), $sColorMaxLvl, 20) Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " Is Maxed already, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
ElseIf _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0], $g_avLabTroops[$i][1] + 20, True), $sColorLabUgReq, 25) = True Or  _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 93, $g_avLabTroops[$i][1] + 20, True), $sColorLabUgReq, 25) = True Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog("Lab upgrade required for " & $g_avLabTroops[$i][3] & ", now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
ElseIf _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 47, $g_avLabTroops[$i][1] + 1, True), $sColorNA, 20) = True Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " not unlocked yet, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If Not $g_bRunState Then Return
$aUpgradeValue[$i] = Number($aUpgradeValue[$i])
Next
For $i = 0 To 1
ClickDrag(533, 439 + $g_iMidOffsetY, 213, 439 + $g_iMidOffsetY, 250)
Next
If _Sleep($DELAYLABORATORY3) Then Return
If Not ClickDragLab($g_avLabTroops[14][0]) Then
SetLog("Trouble finding 2nd page of lab, try again...", $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
Return False
EndIf
If _Sleep($DELAYLABORATORY3) Then Return
If $g_bDebugSetlog Then LabTroopImages(13, 20)
For $i = 13 To 24
$aUpgradeValue[$i] = getLabUpgrdResourceRed($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 73)
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 73)
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
$aUpgradeValue[$i] = 0
If _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 76, $g_avLabTroops[$i][1] + 76, True), $sColorMaxLvl, 20) And  _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 76, $g_avLabTroops[$i][1] + 80, True), $sColorMaxLvl, 20) Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " Is Maxed already, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
ElseIf _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0], $g_avLabTroops[$i][1] + 20, True), $sColorLabUgReq, 25) = True Or  _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 93, $g_avLabTroops[$i][1] + 20, True), $sColorLabUgReq, 25) = True Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog("Lab upgrade required for " & $g_avLabTroops[$i][3] & ", now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
ElseIf _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 47, $g_avLabTroops[$i][1] + 1, True), $sColorNA, 20) = True Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " not unlocked yet, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If Not $g_bRunState Then Return
$aUpgradeValue[$i] = Number($aUpgradeValue[$i])
Next
For $i = 0 To 1
ClickDrag(533, 439 + $g_iMidOffsetY, 213, 439 + $g_iMidOffsetY, 250)
Next
If _Sleep($DELAYLABORATORY5) Then Return
If $g_bDebugSetlog Then LabTroopImages(21, 32)
For $i = 25 To 35
$aUpgradeValue[$i] = getLabUpgrdResourceRed($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 73)
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or Int($aUpgradeValue[$i]) < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($g_avLabTroops[$i][0] + 3, $g_avLabTroops[$i][1] + 73)
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or Int($aUpgradeValue[$i]) < 9999 Then
$aUpgradeValue[$i] = 0
If _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 76, $g_avLabTroops[$i][1] + 76, True), $sColorMaxLvl, 20) And  _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 76, $g_avLabTroops[$i][1] + 80, True), $sColorMaxLvl, 20) Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " Is Maxed already, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
ElseIf _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0], $g_avLabTroops[$i][1] + 20, True), $sColorLabUgReq, 25) = True Or  _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 93, $g_avLabTroops[$i][1] + 20, True), $sColorLabUgReq, 25) = True Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog("Lab upgrade required for " & $g_avLabTroops[$i][3] & ", now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
ElseIf _ColorCheck(_GetPixelColor($g_avLabTroops[$i][0] + 47, $g_avLabTroops[$i][1] + 1, True), $sColorNA, 20) = True Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " not unlocked yet, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If Not $g_bRunState Then Return
$aUpgradeValue[$i] = Number($aUpgradeValue[$i])
Next
If $aUpgradeValue[$g_iCmbLaboratory] = -1 Then
Local $bPreferTraining = False, $iCheapestCost = 0
If $g_iCmbLaboratory = 0 Then
SetLog("No dedicated troop for upgrade selected.", $COLOR_INFO)
Else
SetLog("No upgrade for " & $g_avLabTroops[$g_iCmbLaboratory][3] & " available.", $COLOR_INFO)
EndIf
For $i = 1 To 35
If $aUpgradeValue[$i] > 0 Then
Switch $i
Case 1 To 13
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " is upgradeable; ArmyCompCount = " & $g_aiArmyCompTroops[$i - 1] & ", Value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $g_aiArmyCompTroops[$i - 1] > 0 Then
If Not $bPreferTraining Or $aUpgradeValue[$i] < $iCheapestCost Then
$bPreferTraining = True
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i]
EndIf
ElseIf Not $bPreferTraining And($iCheapestCost = 0 Or $aUpgradeValue[$i] < $iCheapestCost) Then
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i]
EndIf
Case 14 To 19
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " is upgradeable; ArmyCompCount = " & $g_aiArmyCompSpells[$i - 14] & ", Value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $g_aiArmyCompSpells[$i - 14] > 0 Then
If Not $bPreferTraining Or $aUpgradeValue[$i] < $iCheapestCost Then
$bPreferTraining = True
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i]
EndIf
ElseIf Not $bPreferTraining And($iCheapestCost = 0 Or $aUpgradeValue[$i] < $iCheapestCost) Then
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i]
EndIf
Case 20 To 24
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " is upgradeable; ArmyCompCount = " & $g_aiArmyCompSpells[$i - 14] & ", Value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $g_aiArmyCompSpells[$i - 14] > 0 Then
If Not $bPreferTraining Or $aUpgradeValue[$i] * 50 < $iCheapestCost Then
$bPreferTraining = True
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i] * 50
EndIf
ElseIf Not $bPreferTraining And($iCheapestCost = 0 Or $aUpgradeValue[$i] * 50 < $iCheapestCost) Then
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i] * 50
EndIf
Case 25 To 32
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " is upgradeable; ArmyCompCount = " & $g_aiArmyCompTroops[$i - 12] & ", Value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $g_aiArmyCompTroops[$i - 12] > 0 Then
If Not $bPreferTraining Or $aUpgradeValue[$i] * 50 < $iCheapestCost Then
$bPreferTraining = True
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i] * 50
EndIf
ElseIf Not $bPreferTraining And($iCheapestCost = 0 Or $aUpgradeValue[$i] * 50 < $iCheapestCost) Then
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i] * 50
EndIf
Case 33 To 35
If $g_bDebugSetlog Then SetLog($g_avLabTroops[$i][3] & " is upgradeable; ArmyCompCount = " & $g_aiArmyCompSiegeMachine[$i - 33] & ", Value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $g_aiArmyCompTroops[$i - 33] > 0 Then
If Not $bPreferTraining Or $aUpgradeValue[$i] < $iCheapestCost Then
$bPreferTraining = True
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i]
EndIf
ElseIf Not $bPreferTraining And($iCheapestCost = 0 Or $aUpgradeValue[$i] < $iCheapestCost) Then
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i]
EndIf
Case Else
ClickP($aAway, 2, $DELAYLABORATORY4, "#0353")
Return False
EndSwitch
If $g_bDebugSetlog Then SetLog("Army Comp is" &($bPreferTraining ? " " : " not ") & "prefered. " & $g_avLabTroops[$iSelectedUpgrade][3] & " is currently selected. Cost = " & $iCheapestCost, $COLOR_DEBUG)
EndIf
Next
If $g_iCmbLaboratory = $iSelectedUpgrade Then
SetLog("No alternate troop for upgrade found", $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0353")
Return False
Else
SetLog($g_avLabTroops[$iSelectedUpgrade][3] & " selected for upgrade, upgrade cost = " & $aUpgradeValue[$iSelectedUpgrade], $COLOR_INFO)
EndIf
EndIf
If $g_avLabTroops[$iSelectedUpgrade][2] < 2 Then
If $g_avLabTroops[$iSelectedUpgrade][2] = 1 Then
For $i = 0 To 1
ClickDrag(213, 439 + $g_iMidOffsetY, 533, 439 + $g_iMidOffsetY, 250)
Next
If _Sleep($DELAYLABORATORY3) Then Return
If Not ClickDragLab($g_avLabTroops[14][0]) Then
SetLog("Trouble finding 2nd page of lab, try again...", $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
Return False
EndIf
Else
For $i = 0 To 3
ClickDrag(213, 439 + $g_iMidOffsetY, 533, 439 + $g_iMidOffsetY, 250)
Next
EndIf
If _Sleep($DELAYLABORATORY5) Then Return
EndIf
Switch $iSelectedUpgrade
Case 1 To 19
ContinueCase
Case 33 To 35
If $iAvailElixir <($aUpgradeValue[$iSelectedUpgrade] + $g_iUpgradeMinElixir) Then
If $aUpgradeValue[$iSelectedUpgrade] > 0 Then $g_iLaboratoryElixirCost = $aUpgradeValue[$iSelectedUpgrade]
SetLog("Insufficent Elixir for " & $g_avLabTroops[$iSelectedUpgrade][3] & ", Lab requires: " & $aUpgradeValue[$iSelectedUpgrade] & " + " & $g_iUpgradeMinElixir & " user reserve, available: " & $iAvailElixir, $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0355")
Return False
EndIf
If LabUpgrade($iSelectedUpgrade) = True Then
SetLog("Elixir used = " & $aUpgradeValue[$iSelectedUpgrade], $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0356")
Return True
EndIf
Case 20 To 32
If $iAvailDark < $aUpgradeValue[$iSelectedUpgrade] + $g_iUpgradeMinDark Then
If $aUpgradeValue[$iSelectedUpgrade] > 0 Then $g_iLaboratoryDElixirCost = $aUpgradeValue[$iSelectedUpgrade]
SetLog("Insufficent Dark Elixir for " & $g_avLabTroops[$iSelectedUpgrade][3] & ", Lab requires: " & $aUpgradeValue[$iSelectedUpgrade] & " + " & $g_iUpgradeMinDark & " user reserve, available: " & $iAvailDark, $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0357")
Return False
EndIf
If LabUpgrade($iSelectedUpgrade) = True Then
SetLog("Dark Elixir used = " & $aUpgradeValue[$iSelectedUpgrade], $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0358")
Return True
EndIf
Case Else
SetLog("Something went wrong with loot value on Lab upgrade on #" & $g_avLabTroops[$iSelectedUpgrade][3], $COLOR_ERROR)
Return False
EndSwitch
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
Return False
EndFunc
Func LabUpgrade($iSelectedUpgrade)
Local $StartTime, $EndTime, $EndPeriod, $Result, $TimeAdd = 0
Select
Case _ColorCheck(_GetPixelColor($g_avLabTroops[$iSelectedUpgrade][0] + 47, $g_avLabTroops[$iSelectedUpgrade][1] + 1, True), $sColorNA, 20) = True
SetLog($g_avLabTroops[$iSelectedUpgrade][3] & " not unlocked yet, select another troop", $COLOR_WARNING)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _PixelSearch($g_avLabTroops[$iSelectedUpgrade][0] + 67, $g_avLabTroops[$iSelectedUpgrade][1] + 79, $g_avLabTroops[$iSelectedUpgrade][0] + 69, $g_avLabTroops[$iSelectedUpgrade][0] + 84, $sColorNoLoot, 20) <> 0
SetLog("Value check error and Not enough Loot to upgrade " & $g_avLabTroops[$iSelectedUpgrade][3] & "...", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _ColorCheck(_GetPixelColor($g_avLabTroops[$iSelectedUpgrade][0] + 22, $g_avLabTroops[$iSelectedUpgrade][1] + 60, True), Hex(0xFFC360, 6), 20) = True
SetLog($g_avLabTroops[$iSelectedUpgrade][3] & " already max level, select another troop", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _ColorCheck(_GetPixelColor($g_avLabTroops[$iSelectedUpgrade][0] + 3, $g_avLabTroops[$iSelectedUpgrade][1] + 19, True), Hex(0xB7B7B7, 6), 20) = True
SetLog("Laboratory upgrade not available now for " & $g_avLabTroops[$iSelectedUpgrade][3] & "...", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case Else
Click($g_avLabTroops[$iSelectedUpgrade][0] + 40, $g_avLabTroops[$iSelectedUpgrade][1] + 40, 1, 0, "#0200")
If _Sleep($DELAYLABUPGRADE1) Then Return
If $g_bDebugImageSave Then DebugImageSave("LabUpgrade")
If _ColorCheck(_GetPixelColor(258, 192, True), Hex(0xFF1919, 6), 20) And _ColorCheck(_GetPixelColor(272, 194, True), Hex(0xFF1919, 6), 20) Then
SetLog($g_avLabTroops[$iSelectedUpgrade][3] & " Previously maxxed, select another troop", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0201")
Return False
EndIf
If _PixelSearch($g_avLabTroops[$iSelectedUpgrade][0] + 67, $g_avLabTroops[$iSelectedUpgrade][1] + 79, $g_avLabTroops[$iSelectedUpgrade][0] + 69, $g_avLabTroops[$iSelectedUpgrade][0] + 84, $sColorNoLoot, 20) <> 0 Then
SetLog("Missing Loot to upgrade " & $g_avLabTroops[$iSelectedUpgrade][3] & " (secondary check after Upgrade Value read failed)", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0333")
Return False
EndIf
If _ColorCheck(_GetPixelColor(625, 250 + $g_iMidOffsetY, True), Hex(0x848484, 6), 20) And _ColorCheck(_GetPixelColor(660, 250 + $g_iMidOffsetY, True), Hex(0x848484, 6), 20) Then
SetLog("Upgrade in progress, waiting for completion of other troops", $COLOR_WARNING)
If _Sleep($DELAYLABORATORY2) Then Return
ClickP($aAway, 2, $DELAYLABORATORY4, "#0000")
Return False
Else
$Result = getLabUpgradeTime(581, 497)
Local $iLabFinishTime = ConvertOCRTime("Lab Time", $Result, False)
SetLog($g_avLabTroops[$iSelectedUpgrade][3] & " Upgrade OCR Time = " & $Result & ", $iLabFinishTime = " & $iLabFinishTime & " m", $COLOR_INFO)
$StartTime = _NowCalc()
If $g_bDebugSetlog Then SetDebugLog($g_avLabTroops[$iSelectedUpgrade][3] & " Upgrade Started @ " & $StartTime, $COLOR_SUCCESS)
If $iLabFinishTime > 0 Then
$g_sLabUpgradeTime = _DateAdd('n', Ceiling($iLabFinishTime), $StartTime)
SetLog($g_avLabTroops[$iSelectedUpgrade][3] & " Upgrade Finishes @ " & $Result & " (" & $g_sLabUpgradeTime & ")", $COLOR_SUCCESS)
Else
SetLog("Error processing upgrade time required, try again!", $COLOR_WARNING)
Return False
EndIf
LabStatusGUIUpdate()
Click(660, 520 + $g_iMidOffsetY, 1, 0, "#0202")
If _Sleep($DELAYLABUPGRADE1) Then Return
EndIf
If isGemOpen(True) = False Then
If Not(_ColorCheck(_GetPixelColor(625, 218 + $g_iMidOffsetY, True), Hex(0x6fbd1f, 6), 15) Or _ColorCheck(_GetPixelColor(660, 218 + $g_iMidOffsetY, True), Hex(0x6fbd1f, 6), 15)) Then
SetLog("Something went wrong with " & $g_avLabTroops[$iSelectedUpgrade][3] & " Upgrade, try again.", $COLOR_ERROR)
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0360")
Return False
EndIf
SetLog("Upgrade " & $g_avLabTroops[$iSelectedUpgrade][3] & " in your laboratory started with success...", $COLOR_SUCCESS)
PushMsg("LabSuccess")
If _Sleep($DELAYLABUPGRADE2) Then Return
ClickP($aAway, 2, 0, "#0204")
Return True
Else
SetLog("Oops, Gems required for " & $g_avLabTroops[$iSelectedUpgrade][3] & " Upgrade, try again.", $COLOR_ERROR)
EndIf
EndSelect
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0205")
Return False
EndFunc
Func ClickDragLab($iXTroop)
Local $iCounter = 1
Local $iDiff = CheckXPos($iXTroop)
While $iDiff <> 0
If $iDiff = 9999 Then ExitLoop
ClickDrag(426, 439 + $g_iMidOffsetY, 426 + $iDiff, 439 + $g_iMidOffsetY, 1000)
If _Sleep($DELAYLABORATORY2) Then Return False
$iDiff = CheckXPos($iXTroop)
$iCounter += 1
If $iCounter = 5 Then ExitLoop
WEnd
If $iDiff = 0 Then
Return True
ElseIf Abs($iDiff) < 10 Then
For $i = 13 to 24
$g_avLabTroops[$i][0] = $g_avLabTroops[$i][0] - $iDiff
If $g_bDebugSetlog Then Setlog("New icon X position of " & $g_avLabTroops[$i][3] & " : " & $g_avLabTroops[$i][0], $COLOR_DEBUG)
Next
Return True
Else
Return False
EndIf
EndFunc
Func CheckXPos($iXTroop)
Local $aCoor = [114, 362, 740, 575]
Local $sDirectory = "lab-lspell-bundle"
Local $sReturnProps = "objectpoints"
Local $result = ""
Local $aPosXY[0]
Local $iDiffBorder = 23
If $g_bDebugImageSave Then DebugImageSave("CheckXPos")
_CaptureRegion2($aCoor[0], $aCoor[1], $aCoor[2], $aCoor[3])
$result = findMultiple($sDirectory, "FV", "FV", 0, 0, 1, $sReturnProps, False)
If IsArray($result) then
$aPosXY = StringSplit(($result[0])[0], ",", $STR_NOCOUNT)
Local $iRBorder = Int(Number($aPosXY[0])) - $iDiffBorder
Local $iABorder = $iRBorder + $aCoor[0]
Local $iXDiff = $iXTroop - $iABorder
If $g_bDebugSetlog Then
Setlog("CheckXPos: " & $aPosXY[0] & " - " & $iDiffBorder & " = " & $iRBorder & " relative icon border", $COLOR_DEBUG)
Setlog("CheckXPos: " & $iRBorder & " + " & $aCoor[0] & " = " & $iABorder & " absolute icon border", $COLOR_DEBUG)
Setlog("CheckXPos: " & $iXTroop & " - " & $iABorder & " = " & $iXDiff & " differences to target icon border", $COLOR_DEBUG)
EndIf
Return $iXDiff
Else
If $g_bDebugSetlog Then SetLog("CheckXPos: detected X = NOT Found" , $COLOR_DEBUG)
Return 9999
EndIf
EndFunc
Func DebugIconSave($sTxtName = "Unknown", $iLeft = 0, $iTop = 0)
SetLog("Taking debug icon snapshot for later review", $COLOR_SUCCESS)
Local $iIconLength = 94
Local $Date = @MDAY & "_" & @MON & "_" & @YEAR
Local $Time = @HOUR & "_" & @MIN & "_" & @SEC
Local $sName = $g_sProfileTempDebugPath & "LabUpgrade\" & $sTxtName & "_" & $Date & "_" & $Time & ".png"
DirCreate($g_sProfileTempDebugPath & "LabUpgrade\")
ForceCaptureRegion()
_CaptureRegion($iLeft, $iTop, $iLeft + $iIconLength, $iTop + $iIconLength)
_GDIPlus_ImageSaveToFile($g_hBitmap, $sName)
If @error Then SetLog("DebugIconSave failed to save LabUpgrade image: " & $sName, $COLOR_WARNING)
If _Sleep($DELAYLABORATORY2) Then Return
EndFunc
Func LabTroopImages($iStart, $iEnd)
If $g_bDebugImageSave Then DebugImageSave("LabUpgrade")
For $i = $iStart To $iEnd
DebugIconSave($g_avLabTroops[$i][3], $g_avLabTroops[$i][0], $g_avLabTroops[$i][1])
SetDebugLog($g_avLabTroops[$i][3], $COLOR_WARNING)
SetDebugLog("_GetPixelColor(+47, +1): " & _GetPixelColor($g_avLabTroops[$i][0] + 47, $g_avLabTroops[$i][1] + 1, True) & ":D3D3CB =Not unlocked", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+68, +79): " & _GetPixelColor($g_avLabTroops[$i][0] + 68, $g_avLabTroops[$i][1] + 79, True) & ":FD877E =No Loot1", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+68, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 68, $g_avLabTroops[$i][1] + 84, True) & ":FD877E =No Loot2", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+81, +82): " & _GetPixelColor($g_avLabTroops[$i][0] + 81, $g_avLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+76, +76): " & _GetPixelColor($g_avLabTroops[$i][0] + 76, $g_avLabTroops[$i][1] + 76, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+76, +80): " & _GetPixelColor($g_avLabTroops[$i][0] + 76, $g_avLabTroops[$i][1] + 80, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+0, +20): " & _GetPixelColor($g_avLabTroops[$i][0] + 0, $g_avLabTroops[$i][1] + 20, True) & ":838383 =Lab Upgrade", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+93, +20): " & _GetPixelColor($g_avLabTroops[$i][0] + 93, $g_avLabTroops[$i][1] + 20, True) & ":838383 =Lab Upgrade", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+8, +59): " & _GetPixelColor($g_avLabTroops[$i][0] + 23, $g_avLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func ReplayShare($bShareLastReplay)
If Not $g_bShareAttackEnable Or Not $bShareLastReplay Then Return
Local Static $sLastTimeShared = ""
If $sLastTimeShared = "" Or _DateDiff("n", $sLastTimeShared, _NowCalc()) > 30 Then
SetLog("Going to share the last Attack!")
ClickP($aAway, 1, 0, "#0235")
If _Sleep($DELAYREPLAYSHARE2) Then Return
ClickP($aMessageButton, 1, 0, "#0236")
If Not _WaitForCheckPixel($aAttackLogPage, $g_bCapturePixel) Then
SetLog("Error while checking if the Attack Log Page opened up", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0235")
Return
EndIf
Click(380, 90 + $g_iMidOffsetY, 1, 0, "#0237")
If Not _WaitForCheckPixel($aAttackLogAttackTab, $g_bCapturePixel) Then
SetLog("Error while trying to open Attacks Page", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0235")
Return
EndIf
Local $asReplayText = StringSplit($g_sShareMessage, "|")
Local $sRndMessage
If @error Then
$sRndMessage = $asReplayText[1]
Else
$sRndMessage = $asReplayText[Random(1, $asReplayText[0], 1)]
EndIf
If _CheckPixel($aBlueShareReplayButton, True) Then
ClickP($aBlueShareReplayButton, 1, 0, "#0238")
If _Sleep($DELAYREPLAYSHARE1) Then Return
Click(300, 120, 1, 0, "#0239")
If _Sleep($DELAYREPLAYSHARE1) Then Return
If Not $g_bChkBackgroundMode And Not $g_bNoFocusTampering Then ControlFocus($g_hAndroidWindow, "", "")
AndroidSendText($sRndMessage, True)
If _Sleep($DELAYREPLAYSHARE1) Then Return
If SendText($sRndMessage) = 0 Then
SetLog("Failed to insert Share Replay Text!", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYREPLAYSHARE1) Then Return
Click(530, 210 + $g_iMidOffsetY, 1, 0, "#0240")
$sLastTimeShared = _NowCalc
ElseIf _CheckPixel($aGrayShareReplayButton, True) Then
SetLog("Sharing latest Attack is not enabled right now, storing it and share later!")
ClickP($aAway, 1, 0, "#0235")
Else
SetLog("Error checking Share Button State. Replay might be not available anymore or Bot made mistakes", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0235")
EndIf
Else
SetLog("Skip Replay Sharing because the 30 minutes cooldown is not over yet!")
EndIf
ClickP($aAway, 1, 0, "#0235")
EndFunc
Func BoostKing()
If AllowBoosting("Barbarian King", $g_iCmbBoostBarbarianKing) = False Then Return
SetLog("Boost Barbarian King...", $COLOR_INFO)
If $g_aiKingAltarPos[0] = "" Or $g_aiKingAltarPos[0] = -1 Then
LocateKingAltar()
SaveConfig()
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
If BoostStructure("Barbarian King", "King", $g_aiKingAltarPos, $g_iCmbBoostBarbarianKing, $g_hCmbBoostBarbarianKing) Then $g_aiHeroBoost[$eHeroBarbarianKing] = _NowCalc()
$g_aiTimeTrain[2] = 0
If _Sleep($DELAYBOOSTBARRACKS3) Then Return
checkMainScreen(False)
EndFunc
Func BoostQueen()
If AllowBoosting("Archer Queen", $g_iCmbBoostArcherQueen) = False Then Return
SetLog("Boost Archer Queen...", $COLOR_INFO)
If $g_aiQueenAltarPos[0] = "" Or $g_aiQueenAltarPos[0] = -1 Then
LocateQueenAltar()
SaveConfig()
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
If BoostStructure("Archer Queen", "Quee", $g_aiQueenAltarPos, $g_iCmbBoostArcherQueen, $g_hCmbBoostArcherQueen) Then $g_aiHeroBoost[$eHeroArcherQueen] = _NowCalc()
$g_aiTimeTrain[2] = 0
If _Sleep($DELAYBOOSTBARRACKS3) Then Return
checkMainScreen(False)
EndFunc
Func BoostWarden()
If AllowBoosting("Grand Warden", $g_iCmbBoostWarden) = False Then Return
SetLog("Boost Grand Warden...", $COLOR_INFO)
If $g_aiWardenAltarPos[0] = "" Or $g_aiWardenAltarPos[0] = -1 Then
LocateWardenAltar()
SaveConfig()
If _Sleep($DELAYBOOSTHEROES4) Then Return
EndIf
If BoostStructure("Grand Warden", "Warden", $g_aiWardenAltarPos, $g_iCmbBoostWarden, $g_hCmbBoostWarden) Then $g_aiHeroBoost[$eHeroGrandWarden] = _NowCalc()
$g_aiTimeTrain[2] = 0
If _Sleep($DELAYBOOSTBARRACKS3) Then Return
checkMainScreen(False)
EndFunc
Func UpgradeHeroes()
If Not $g_bUpgradeKingEnable And Not $g_bUpgradeQueenEnable And Not $g_bUpgradeWardenEnable Then Return
If _Sleep(500) Then Return
checkMainScreen(False)
If $g_bRestart Then Return
If $g_bUpgradeKingEnable Then
If Not isInsideDiamond($g_aiKingAltarPos) Then LocateKingAltar()
If $g_aiKingAltarPos[0] = -1 Or $g_aiKingAltarPos[1] = -1 Then LocateKingAltar()
SaveConfig()
EndIf
If $g_bUpgradeQueenEnable Then
If Not isInsideDiamond($g_aiQueenAltarPos) Then LocateQueenAltar()
If $g_aiQueenAltarPos[0] = -1 Or $g_aiQueenAltarPos[1] = -1 Then LocateQueenAltar()
SaveConfig()
EndIf
If $g_bUpgradeWardenEnable Then
If Not isInsideDiamond($g_aiWardenAltarPos) Then LocateWardenAltar()
If $g_aiWardenAltarPos[0] = -1 Or $g_aiWardenAltarPos[1] = -1 Then LocateWardenAltar()
SaveConfig()
EndIf
SetLog("Upgrading Heroes", $COLOR_INFO)
If $g_bAutoLabUpgradeEnable And $g_iLaboratoryDElixirCost > 0 Then
SetLog("Laboratory needs DE to Upgrade:  " & $g_iLaboratoryDElixirCost)
SetLog("Skipping the Queen and King Upgrade!")
Else
If $g_bUpgradeQueenEnable And BitAND($g_iHeroUpgradingBit, $eHeroQueen) <> $eHeroQueen Then
If Not getBuilderCount() Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount < 1 +($g_bAutoUpgradeWallsEnable And $g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not enough Builders available to upgrade the Archer Queen")
Return
EndIf
QueenUpgrade()
If _Sleep($DELAYUPGRADEHERO1) Then Return
EndIf
If $g_bUpgradeKingEnable And BitAND($g_iHeroUpgradingBit, $eHeroKing) <> $eHeroKing Then
If Not getBuilderCount() Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount < 1 +($g_bAutoUpgradeWallsEnable And $g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not enough Builders available to upgrade the Barbarian King")
Return
EndIf
KingUpgrade()
If _Sleep($DELAYUPGRADEHERO1) Then Return
EndIf
EndIf
If $g_bAutoLabUpgradeEnable And $g_iLaboratoryElixirCost > 0 Then
SetLog("Laboratory needs Elixir to Upgrade:  " & $g_iLaboratoryElixirCost)
SetLog("Skipping the Warden Upgrade!")
ElseIf $g_bUpgradeWardenEnable And BitAND($g_iHeroUpgradingBit, $eHeroWarden) <> $eHeroWarden Then
If Not getBuilderCount() Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCount < 1 +($g_bAutoUpgradeWallsEnable And $g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not enough Builders available to upgrade the Grand Warden")
Return
EndIf
WardenUpgrade()
EndIf
EndFunc
Func QueenUpgrade()
If Not $g_bUpgradeQueenEnable Then Return
Local $aHeroLevel = 0
SetLog("Upgrade Queen")
ClickP($aAway, 1, 0, "#0166")
If _Sleep($DELAYUPGRADEHERO2) Then Return
BuildingClickP($g_aiQueenAltarPos)
If _Sleep($DELAYUPGRADEHERO2) Then Return
Local $sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo >= 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Quee") = 0 Then
SetLog("Bad Archer Queen location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your Archer Queen level read as: " & $aHeroLevel, $COLOR_SUCCESS)
If $aHeroLevel = $g_iMaxQueenLevel Then
SetLog("Your Archer Queen is at max level, cannot upgrade anymore!", $COLOR_INFO)
$g_bUpgradeQueenEnable = False
Return
EndIf
Else
SetLog("Your Queen Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
Else
SetLog("Bad Queen OCR", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYUPGRADEHERO1) Then Return
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$g_aiCurrentLoot[$eLootDarkElixir] = Number(getResourcesMainScreen(728, 123))
If $g_bDebugSetlog Then SetDebugLog("Updating village values [D]: " & $g_aiCurrentLoot[$eLootDarkElixir], $COLOR_DEBUG)
Else
If $g_bDebugSetlog Then SetDebugLog("getResourcesMainScreen didn't get the DE value", $COLOR_DEBUG)
EndIf
If $g_aiCurrentLoot[$eLootDarkElixir] <($g_afQueenUpgCost[$aHeroLevel] * 1000) + $g_iUpgradeMinDark Then
SetLog("Insufficient DE for Upg Queen, requires: " &($g_afQueenUpgCost[$aHeroLevel] * 1000) & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
Return
EndIf
Local $aUpgradeButton = findButton("Upgrade", Default, 1, True)
If IsArray($aUpgradeButton) And UBound($aUpgradeButton, 1) = 2 Then
If _Sleep($DELAYUPGRADEHERO2) Then Return
ClickP($aUpgradeButton)
If _Sleep($DELAYUPGRADEHERO3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(721, 118 + $g_iMidOffsetY, True), Hex(0xE00408, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Queen Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return
Else
Click(665, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($DELAYUPGRADEHERO1) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("Queen Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return
EndIf
SetLog("Queen Upgrade complete", $COLOR_SUCCESS)
If _Sleep($DELAYUPGRADEHERO2) Then Return
$g_iNbrOfHeroesUpped += 1
$g_iCostDElixirHero += $g_afQueenUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
SetLog("Upgrade Queen window open fail", $COLOR_ERROR)
EndIf
Else
SetLog("Upgrade Queen error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func KingUpgrade()
If Not $g_bUpgradeKingEnable Then Return
Local $aHeroLevel = 0
SetLog("Upgrade King")
ClickP($aAway, 1, 0, "#0166")
If _Sleep($DELAYUPGRADEHERO2) Then Return
BuildingClickP($g_aiKingAltarPos)
If _Sleep($DELAYUPGRADEHERO2) Then Return
Local $sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep(100) Then Return
$CountGetInfo += 1
If $CountGetInfo >= 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Barbarian") = 0 Then
SetLog("Bad Barbarian King location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your King Level read as: " & $aHeroLevel, $COLOR_SUCCESS)
If $aHeroLevel = $g_iMaxKingLevel Then
SetLog("Your Babarian King is at max level, cannot upgrade anymore!", $COLOR_INFO)
$g_bUpgradeKingEnable = False
Return
EndIf
Else
SetLog("Your Barbarian King Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
Else
SetLog("Bad King OCR", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYUPGRADEHERO1) Then Return
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$g_aiCurrentLoot[$eLootDarkElixir] = Number(getResourcesMainScreen(728, 123))
If $g_bDebugSetlog Then SetDebugLog("Updating village values [D]: " & $g_aiCurrentLoot[$eLootDarkElixir], $COLOR_DEBUG)
Else
If $g_bDebugSetlog Then SetDebugLog("getResourcesMainScreen didn't get the DE value", $COLOR_DEBUG)
EndIf
If _Sleep(100) Then Return
If $g_aiCurrentLoot[$eLootDarkElixir] <($g_afKingUpgCost[$aHeroLevel] * 1000) + $g_iUpgradeMinDark Then
SetLog("Insufficient DE for Upg King, requires: " &($g_afKingUpgCost[$aHeroLevel] * 1000) & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
Return
EndIf
Local $aUpgradeButton = findButton("Upgrade", Default, 1, True)
If IsArray($aUpgradeButton) And UBound($aUpgradeButton, 1) = 2 Then
If _Sleep($DELAYUPGRADEHERO2) Then Return
ClickP($aUpgradeButton)
If _Sleep($DELAYUPGRADEHERO3) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(715, 120 + $g_iMidOffsetY, True), Hex(0xE01C20, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("King Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($DELAYUPGRADEHERO1) Then Return
If $g_bDebugImageSave Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("King Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return
EndIf
SetLog("King Upgrade complete", $COLOR_SUCCESS)
If _Sleep($DELAYUPGRADEHERO2) Then Return
$g_iNbrOfHeroesUpped += 1
$g_iCostDElixirHero += $g_afKingUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
SetLog("Upgrade King window open fail", $COLOR_ERROR)
EndIf
Else
SetLog("Upgrade King error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func WardenUpgrade()
If Not $g_bUpgradeWardenEnable Then Return
If Number($g_iTownHallLevel) <= 10 Then
SetLog("Must have atleast Townhall 11 for Grand Warden Upgrade", $COLOR_ERROR)
Return
EndIf
SetLog("Upgrade Grand Warden")
ClickP($aAway, 1, 0, "#0166")
If _Sleep($DELAYUPGRADEHERO2) Then Return
ClickP($g_aiWardenAltarPos, 1, 0, "#8888")
If _Sleep($DELAYUPGRADEHERO2) Then Return
Local $sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 491 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep(100) Then Return
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_bDebugSetlog Then SetDebugLog(_ArrayToString($sInfo, " "))
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Grand") = 0 Then
SetLog("Bad Warden location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$g_iWardenLevel = Number($sInfo[2])
SetLog("Your Grand Warden Warden Level read as: " & $g_iWardenLevel, $COLOR_SUCCESS)
If $g_iWardenLevel = $g_iMaxWardenLevel Then
SetLog("Your Grand Warden is at max level, cannot upgrade anymore!", $COLOR_INFO)
$g_bUpgradeWardenEnable = False
Return
EndIf
Else
SetLog("Your Grand Warden Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
Else
SetLog("Bad Warden OCR", $COLOR_ERROR)
Return
EndIf
If _Sleep($DELAYUPGRADEHERO1) Then Return
If _CheckPixel($aVillageHasDarkElixir, $g_bCapturePixel) Then
$g_aiCurrentLoot[$eLootElixir] = getResourcesMainScreen(705, 74)
If $g_bDebugSetlog Then SetDebugLog("Updating village values [E]: " & $g_aiCurrentLoot[$eLootElixir], $COLOR_DEBUG)
Else
$g_aiCurrentLoot[$eLootElixir] = getResourcesMainScreen(710, 74)
EndIf
If _Sleep(100) Then Return
If $g_aiCurrentLoot[$eLootElixir] <($g_afWardenUpgCost[$g_iWardenLevel] * 1000000) + $g_iUpgradeMinElixir Then
SetLog("Insufficient Elixir for Warden Upgrade, requires: " &($g_afWardenUpgCost[$g_iWardenLevel] * 1000000) & " + " & $g_iUpgradeMinElixir, $COLOR_INFO)
Return
EndIf
If _Sleep($DELAYUPGRADEHERO2) Then Return
Local $aUpgradeButton = findButton("Upgrade", Default, 1, True)
If IsArray($aUpgradeButton) And UBound($aUpgradeButton, 1) = 2 Then
If _Sleep($DELAYUPGRADEHERO2) Then Return
ClickP($aUpgradeButton)
If _Sleep($DELAYUPGRADEHERO3) Then Return
If $g_bDebugSetlog Then DebugImageSave("UpgradeElixirBtn1")
If $g_bDebugSetlog Then SetDebugLog("pixel: " & _GetPixelColor(718, 120 + $g_iMidOffsetY, True) & " expected " & Hex(0xDD0408, 6) & " result: " & _ColorCheck(_GetPixelColor(718, 120 + $g_iMidOffsetY, True), Hex(0xDD0408, 6), 20), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(718, 120 + $g_iMidOffsetY, True), Hex(0xDD0408, 6), 20) Then
If $g_bDebugSetlog Then SetDebugLog("pixel1: " & _GetPixelColor(692, 525 + $g_iMidOffsetY, True) & " expected " & Hex(0xFFFFFF, 6) & " result: " &(_ColorCheck(_GetPixelColor(692, 525 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20)), $COLOR_DEBUG)
If Not(_ColorCheck(_GetPixelColor(692, 525 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20)) Then
SetLog("Warden Upgrade Fail! No Elixir!", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0306")
Return
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($DELAYUPGRADEHERO1) Then Return
If $g_bDebugSetlog Then DebugImageSave("UpgradeElixirBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("Warden Upgrade Fail! No Elixir!", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0309")
Return
EndIf
SetLog("Warden Upgrade Started", $COLOR_SUCCESS)
If _Sleep($DELAYUPGRADEHERO2) Then Return
$g_iNbrOfHeroesUpped += 1
$g_iCostElixirBuilding += $g_afWardenUpgCost[$g_iWardenLevel - 1] * 1000
$g_iWardenLevel += 1
UpdateStats()
EndIf
Else
SetLog("Upgrade Warden window open fail", $COLOR_ERROR)
EndIf
Else
SetLog("Upgrade Warden error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func ReservedBuildersForHeroes()
Local $iUsedBuildersForHeroes = Number(BitAND($g_iHeroUpgradingBit, $eHeroKing) = $eHeroKing ? 1 : 0) + Number(BitAND($g_iHeroUpgradingBit, $eHeroQueen) = $eHeroQueen ? 1 : 0) + Number(BitAND($g_iHeroUpgradingBit, $eHeroWarden) = $eHeroWarden ? 1 : 0)
If $iUsedBuildersForHeroes = 1 Then
SetLog($iUsedBuildersForHeroes & " builder is upgrading your heroes.", $COLOR_INFO)
Else
SetLog($iUsedBuildersForHeroes & " builders are upgrading your heroes.", $COLOR_INFO)
EndIf
Local $iFreeBuildersReservedForHeroes = _Max(Number($g_iHeroReservedBuilder) - $iUsedBuildersForHeroes, 0)
If $iFreeBuildersReservedForHeroes = 1 Then
SetLog($iFreeBuildersReservedForHeroes & " free builder is reserved for heroes.", $COLOR_INFO)
Else
SetLog($iFreeBuildersReservedForHeroes & " free builders are reserved for heroes.", $COLOR_INFO)
EndIf
If $g_bDebugSetlog Then SetLog("HeroBuilders R|Rn|W|F: " & $g_iHeroReservedBuilder & "|" & Number($g_iHeroReservedBuilder) & "|" & $iUsedBuildersForHeroes & "|" & $iFreeBuildersReservedForHeroes, $COLOR_DEBUG)
Return $iFreeBuildersReservedForHeroes
EndFunc
Func StarBonus()
If $g_bDebugSetlog Then SetDebugLog("Begin Star Bonus window check", $COLOR_DEBUG1)
If _CheckPixel($aIsMainGrayed, $g_bCapturePixel, Default, "IsMainGrayed") = False Then Return
Local $aWindowChk1[4] = [640, 184 + $g_iMidOffsetY, 0xCD1A1F, 15]
Local $aWindowChk2[4] = [650, 462 + $g_iBottomOffsetY, 0xE8E8E0, 10]
If _Sleep($DELAYSTARBONUS100) Then Return
If _CheckPixel($aWindowChk1, $g_bCapturePixel, Default, "Starbonus1") And _CheckPixel($aWindowChk2, $g_bCapturePixel, Default, "Starbonus2") Then
Local $offColors[3][3] = [[0x1E1E1E, 139, 0], [0xFFFFFF, 53, 20], [0xDEF885, 53, 10]]
Local $ButtonPixel = _MultiPixelSearch(352, 438 + $g_iMidOffsetY, 501, 474 + $g_iMidOffsetY, 1, 1, Hex(0x373737, 6), $offColors, 20)
If $g_bDebugSetlog Then SetDebugLog("Okay btn chk-#1: " & _GetPixelColor(352, 442 + $g_iMidOffsetY, $g_bCapturePixel) & ", #2: " & _GetPixelColor(352 + 139, 438 + $g_iMidOffsetY, $g_bCapturePixel) & ", #3: " & _GetPixelColor(352 + 53, 438 + 20 + $g_iMidOffsetY, $g_bCapturePixel) & ", #4: " & _GetPixelColor(352 + 53, 438 + 10 + $g_iMidOffsetY, $g_bCapturePixel), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_bDebugSetlog Then
SetDebugLog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
SetDebugLog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], $g_bCapturePixel) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 139, $ButtonPixel[1], $g_bCapturePixel) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 53, $ButtonPixel[1] + 20, $g_bCapturePixel) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 53, $ButtonPixel[1] + 10, $g_bCapturePixel), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
If _Sleep($DELAYSTARBONUS500) Then Return
Return True
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog("Star Bonus window not found?", $COLOR_DEBUG)
Return False
EndFunc
Func AddIdleTime()
If $g_bTrainAddRandomDelayEnable = False Then Return
Local $iTimeToWait
If $g_iTrainAddRandomDelayMin < $g_iTrainAddRandomDelayMax Then
$iTimeToWait = Random($g_iTrainAddRandomDelayMin, $g_iTrainAddRandomDelayMax, 1)
Else
$iTimeToWait = Random($g_iTrainAddRandomDelayMax, $g_iTrainAddRandomDelayMin, 1)
EndIf
SetLog("Waiting, Add random delay of " & $iTimeToWait & " seconds.", $COLOR_INFO)
If _SleepStatus($iTimeToWait * 1000) Then Return
_GUICtrlStatusBar_SetTextEx($g_hStatusBar, "")
EndFunc
Func GetVillageSize($DebugLog = False, $sStonePrefix = Default, $sTreePrefix = Default)
If $sStonePrefix = Default Then $sStonePrefix = "stone"
If $sTreePrefix = Default Then $sTreePrefix = "tree"
Local $aResult = 0
Local $sDirectory
Local $stone[6] = [0, 0, 0, 0, 0, ""], $tree[6] = [0, 0, 0, 0, 0, ""]
Local $x0, $y0, $d0, $x, $y, $x1, $y1, $right, $bottom, $a
Local $iAdditionalY = 75
Local $iAdditionalX = 100
If isOnBuilderBase(True) Then
$sDirectory = $g_sImgZoomOutDirBB
Else
$sDirectory = $g_sImgZoomOutDir
EndIf
Local $aStoneFiles = _FileListToArray($sDirectory, $sStonePrefix & "*.*", $FLTA_FILES)
If @error Then
SetLog("Error: Missing stone files (" & @error & ")", $COLOR_ERROR)
Return $aResult
EndIf
Local $iNewIdx = 1
For $i = 1 To $aStoneFiles[0]
If StringInStr($aStoneFiles[$i], "stoneBlueStacks2A") = 1 Then
Local $s = $aStoneFiles[$iNewIdx]
$aStoneFiles[$iNewIdx] = $aStoneFiles[$i]
$aStoneFiles[$i] = $s
$iNewIdx += 1
EndIf
Next
Local $aTreeFiles = _FileListToArray($sDirectory, $sTreePrefix & "*.*", $FLTA_FILES)
If @error Then
SetLog("Error: Missing tree (" & @error & ")", $COLOR_ERROR)
Return $aResult
EndIf
Local $i, $findImage, $sArea, $a
For $i = 1 To $aStoneFiles[0]
$findImage = $aStoneFiles[$i]
$a = StringRegExp($findImage, ".*-(\d+)-(\d+)-(\d*,*\d+)_.*[.](xml|png|bmp)$", $STR_REGEXPARRAYMATCH)
If UBound($a) = 4 Then
$x0 = $a[0]
$y0 = $a[1]
$d0 = StringReplace($a[2], ",", ".")
$x1 = $x0 - $iAdditionalX
$y1 = $y0 - $iAdditionalY
$right = $x0 + $iAdditionalX
$bottom = $y0 + $iAdditionalY
$sArea = Int($x1) & "," & Int($y1) & "|" & Int($right) & "," & Int($y1) & "|" & Int($right) & "," & Int($bottom) & "|" & Int($x1) & "," & Int($bottom)
$a = decodeSingleCoord(findImage($findImage, $sDirectory & $findImage, $sArea, 1, True))
If UBound($a) = 2 Then
$x = Int($a[0])
$y = Int($a[1])
$stone[0] = $x
$stone[1] = $y
$stone[2] = $x0
$stone[3] = $y0
$stone[4] = $d0
$stone[5] = $findImage
ExitLoop
EndIf
Else
EndIf
Next
If $stone[0] = 0 Then
SetDebugLog("GetVillageSize cannot find stone", $COLOR_WARNING)
Return $aResult
EndIf
For $i = 1 To $aTreeFiles[0]
$findImage = $aTreeFiles[$i]
$a = StringRegExp($findImage, ".*-(\d+)-(\d+)-(\d*,*\d+)_.*[.](xml|png|bmp)$", $STR_REGEXPARRAYMATCH)
If UBound($a) = 4 Then
$x0 = $a[0]
$y0 = $a[1]
$d0 = StringReplace($a[2], ",", ".")
$x1 = $x0 - $iAdditionalX
$y1 = $y0 - $iAdditionalY
$right = $x0 + $iAdditionalX
$bottom = $y0 + $iAdditionalY
$sArea = Int($x1) & "," & Int($y1) & "|" & Int($right) & "," & Int($y1) & "|" & Int($right) & "," & Int($bottom) & "|" & Int($x1) & "," & Int($bottom)
$a = decodeSingleCoord(findImage($findImage, $sDirectory & "\" & $findImage, $sArea, 1, False))
If UBound($a) = 2 Then
$x = Int($a[0])
$y = Int($a[1])
$tree[0] = $x
$tree[1] = $y
$tree[2] = $x0
$tree[3] = $y0
$tree[4] = $d0
$tree[5] = $findImage
ExitLoop
EndIf
Else
EndIf
Next
If $tree[0] = 0 Then
SetDebugLog("GetVillageSize cannot find tree", $COLOR_WARNING)
Return $aResult
EndIf
Local $a = $tree[0] - $stone[0]
Local $b = $stone[1] - $tree[1]
Local $c = Sqrt($a * $a + $b * $b) - $stone[4] - $tree[4]
Local $z = $c / 458
Local $stone_x_exp = $stone[2]
Local $stone_y_exp = $stone[3]
ConvertVillagePos($stone_x_exp, $stone_y_exp, $z)
$x = $stone[0] - $stone_x_exp
$y = $stone[1] - $stone_y_exp
If $DebugLog Then SetDebugLog("GetVillageSize measured: " & $c & ", Zoom factor: " & $z & ", Offset: " & $x & ", " & $y, $COLOR_INFO)
Dim $aResult[10]
$aResult[0] = $c
$aResult[1] = $z
$aResult[2] = $x
$aResult[4] = $stone[0]
$aResult[3] = $y
$aResult[5] = $stone[1]
$aResult[6] = $stone[5]
$aResult[7] = $tree[0]
$aResult[8] = $tree[1]
$aResult[9] = $tree[5]
Return $aResult
EndFunc
Func UpdateGlobalVillageOffset($x, $y)
Local $updated = False
If $g_sImglocRedline <> "" Then
Local $newReadLine = ""
Local $aPoints = StringSplit($g_sImglocRedline, "|", $STR_NOCOUNT)
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, ",")
$aPoint[0] += $x
$aPoint[1] += $y
If StringLen($newReadLine) > 0 Then $newReadLine &= "|"
$newReadLine &=($aPoint[0] & "," & $aPoint[1])
Next
$g_sImglocRedline = $newReadLine
$updated = True
EndIf
If $g_aiTownHallDetails[0] <> 0 And $g_aiTownHallDetails[1] <> 0 Then
$g_aiTownHallDetails[0] += $x
$g_aiTownHallDetails[1] += $y
$updated = True
EndIf
If $g_iTHx <> 0 And $g_iTHy <> 0 Then
$g_iTHx += $x
$g_iTHy += $y
$updated = True
EndIf
ConvertInternalExternArea()
Return $updated
EndFunc
Global $g_aiTempGainCost[3] = [0, 0, 0]
Func StartGainCost()
$g_aiTempGainCost[0] = 0
$g_aiTempGainCost[1] = 0
$g_aiTempGainCost[2] = 0
VillageReport(True, True)
Local $tempCounter = 0
While($g_aiCurrentLoot[$eLootGold] = "" Or $g_aiCurrentLoot[$eLootElixir] = "" Or($g_aiCurrentLoot[$eLootDarkElixir] = "" And $g_iStatsStartedWith[$eLootDarkElixir] <> "")) And $tempCounter < 5
$tempCounter += 1
If _Sleep(100) Then Return
VillageReport(True, True)
WEnd
$g_aiTempGainCost[0] = $g_aiCurrentLoot[$eLootGold]
$g_aiTempGainCost[1] = $g_aiCurrentLoot[$eLootElixir]
$g_aiTempGainCost[2] = $g_aiCurrentLoot[$eLootDarkElixir]
EndFunc
Func EndGainCost($Type)
VillageReport(True, True)
Local $tempCounter = 0
While($g_aiCurrentLoot[$eLootGold] = "" Or $g_aiCurrentLoot[$eLootElixir] = "" Or($g_aiCurrentLoot[$eLootDarkElixir] = "" And $g_iStatsStartedWith[$eLootDarkElixir] <> "")) And $tempCounter < 5
$tempCounter += 1
VillageReport(True, True)
WEnd
Switch $Type
Case "Collect"
Local $tempGoldCollected = 0
Local $tempElixirCollected = 0
Local $tempDElixirCollected = 0
If $g_aiTempGainCost[0] <> "" And $g_aiCurrentLoot[$eLootGold] <> "" And $g_aiTempGainCost[0] <> $g_aiCurrentLoot[$eLootGold] Then
$tempGoldCollected = $g_aiCurrentLoot[$eLootGold] - $g_aiTempGainCost[0]
$g_iGoldFromMines += $tempGoldCollected
$g_iStatsTotalGain[$eLootGold] += $tempGoldCollected
EndIf
If $g_aiTempGainCost[1] <> "" And $g_aiCurrentLoot[$eLootElixir] <> "" And $g_aiTempGainCost[1] <> $g_aiCurrentLoot[$eLootElixir] Then
$tempElixirCollected = $g_aiCurrentLoot[$eLootElixir] - $g_aiTempGainCost[1]
$g_iElixirFromCollectors += $tempElixirCollected
$g_iStatsTotalGain[$eLootElixir] += $tempElixirCollected
EndIf
If $g_aiTempGainCost[2] <> "" And $g_aiCurrentLoot[$eLootDarkElixir] <> "" And $g_aiTempGainCost[2] <> $g_aiCurrentLoot[$eLootDarkElixir] Then
$tempDElixirCollected = $g_aiCurrentLoot[$eLootDarkElixir] - $g_aiTempGainCost[2]
$g_iDElixirFromDrills += $tempDElixirCollected
$g_iStatsTotalGain[$eLootDarkElixir] += $tempDElixirCollected
EndIf
Case "Train"
Local $tempGoldSpent = 0
Local $tempElixirSpent = 0
Local $tempDElixirSpent = 0
If $g_aiTempGainCost[0] <> "" And $g_aiCurrentLoot[$eLootGold] <> "" And $g_aiTempGainCost[0] <> $g_aiCurrentLoot[$eLootGold] Then
$tempGoldSpent =($g_aiTempGainCost[0] - $g_aiCurrentLoot[$eLootGold])
$g_iTrainCostGold += $tempGoldSpent
$g_iStatsTotalGain[$eLootGold] -= $tempGoldSpent
EndIf
If $g_aiTempGainCost[1] <> "" And $g_aiCurrentLoot[$eLootElixir] <> "" And $g_aiTempGainCost[1] <> $g_aiCurrentLoot[$eLootElixir] Then
$tempElixirSpent =($g_aiTempGainCost[1] - $g_aiCurrentLoot[$eLootElixir])
$g_iTrainCostElixir += $tempElixirSpent
$g_iStatsTotalGain[$eLootElixir] -= $tempElixirSpent
EndIf
If $g_aiTempGainCost[2] <> "" And $g_aiCurrentLoot[$eLootDarkElixir] <> "" And $g_aiTempGainCost[2] <> $g_aiCurrentLoot[$eLootDarkElixir] Then
$tempDElixirSpent =($g_aiTempGainCost[2] - $g_aiCurrentLoot[$eLootDarkElixir])
$g_iTrainCostDElixir += $tempDElixirSpent
$g_iStatsTotalGain[$eLootDarkElixir] -= $tempDElixirSpent
EndIf
EndSwitch
UpdateStats()
EndFunc
Func ConvertOCRTime($WhereRead, $ToConvert, $bSetLog = True)
Local $iRemainTimer = 0, $aResult, $iDay = 0, $iHour = 0, $iMinute = 0, $iSecond = 0
If $ToConvert <> "" Then
If StringInStr($ToConvert, "d") > 1 Then
$aResult = StringSplit($ToConvert, "d", $STR_NOCOUNT)
$iDay = Number($aResult[0])
$ToConvert = $aResult[1]
EndIf
If StringInStr($ToConvert, "h") > 1 Then
$aResult = StringSplit($ToConvert, "h", $STR_NOCOUNT)
$iHour = Number($aResult[0])
$ToConvert = $aResult[1]
EndIf
If StringInStr($ToConvert, "m") > 1 Then
$aResult = StringSplit($ToConvert, "m", $STR_NOCOUNT)
$iMinute = Number($aResult[0])
$ToConvert = $aResult[1]
EndIf
If StringInStr($ToConvert, "s") > 1 Then
$aResult = StringSplit($ToConvert, "s", $STR_NOCOUNT)
$iSecond = Number($aResult[0])
EndIf
$iRemainTimer = Round($iDay * 24 * 60 + $iHour * 60 + $iMinute + $iSecond / 60, 0)
If $iRemainTimer = 0 And $g_bDebugSetlog Then SetDebugLog($WhereRead & ": Bad OCR string", $COLOR_ERROR)
If $bSetLog Then SetLog($WhereRead & " time: " & StringFormat("%.2f", $iRemainTimer) & " min", $COLOR_INFO)
Else
If $g_bDebugSetlog Then SetDebugLog("Can not read remaining time for " & $WhereRead, $COLOR_ERROR)
EndIf
Return $iRemainTimer
EndFunc
Func ClickR($boundingBox, $x, $y, $times = 1, $speed = 0, $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $AncVal = " ValIn: X=" & $x & " Y=" & $y
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = __TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If __TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $times <> 1 Then
For $i = 0 To($times - 1)
If $g_bDebugClick Then SetLog("_ControlClick " & "X=" & $x & " Y=" & $y & " ,t" & $times & ",s" & $speed & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
Click($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If $g_bDebugClick Then SetLog("_ControlClick " & "X=" & $x & " Y=" & $y & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
Click($x, $y)
EndIf
EndFunc
Func PureClickR($boundingBox, $x, $y, $times = 1, $speed = 0, $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $AncVal = " ValIn: X=" & $x & " Y=" & $y
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = __TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If __TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $times <> 1 Then
For $i = 0 To($times - 1)
If $g_bDebugClick Then SetLog("PureClick " & "X=" & $x & " Y=" & $y & " ,t" & $times & ",s" & $speed & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
PureClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If $g_bDebugClick Then SetLog("PureClick " & "X=" & $x & " Y=" & $y & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
PureClick($x, $y)
EndIf
EndFunc
Func GemClickR($boundingBox,$x, $y, $times = 1, $speed = 0, $debugtxt = "", $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = __TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If __TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $g_bDebugClick Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If $g_bAndroidAdbClick = True Then
If isGemOpen(True) Then
Return False
EndIf
AndroidClick($x, $y, $times, $speed)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
Local $i
If $times <> 1 Then
For $i = 0 To($times - 1)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick($i) Then
If $g_bDebugClick Then SetLog("VOIDED GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick() Then
If $g_bDebugClick Then SetLog("VOIDED GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func CheckNeedOpenTrain($TimeBeforeTrain)
Local $bToReturn = False
Local $QuickArmyCamps = 100
If $g_abSearchCampsEnable[$DB] Then
If $g_aiSearchCampsPct[$DB] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$DB]
If $g_aiSearchCampsPct[$DB] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$DB] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
EndIf
If $g_abSearchCampsEnable[$LB] Then
If $g_aiSearchCampsPct[$LB] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$LB]
If $g_aiSearchCampsPct[$LB] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$LB] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
EndIf
If $g_abSearchCampsEnable[$TS] Then
If $g_aiSearchCampsPct[$TS] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$TS]
If $g_aiSearchCampsPct[$TS] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$TS] - Int($g_CurrentCampUtilization / $g_iTotalCampSpace * 100)
EndIf
If $g_aiTimeTrain[0] = 0 Then $bToReturn = True
Local $sNowTime = ""
Local $iTimeBeforeTrain1, $iTimeBeforeTrain2
$sNowTime = _NowCalc()
If $TimeBeforeTrain = "" Then $TimeBeforeTrain = $sNowTime
$iTimeBeforeTrain1 = _DateAdd("s", Int(($g_aiTimeTrain[0] * 60) *($QuickArmyCamps / 100)), $TimeBeforeTrain)
$iTimeBeforeTrain2 = _DateDiff("s", $sNowTime, $iTimeBeforeTrain1)
If $g_bDebugSetlogTrain Then
SetLog("Start Train: " & $TimeBeforeTrain)
SetLog("Now: " & $sNowTime)
SetLog("Train end time: " & $iTimeBeforeTrain1)
SetLog("Next Train in S: " & $iTimeBeforeTrain2)
EndIf
If $iTimeBeforeTrain2 <= 0 Then $bToReturn = True
If($g_iActiveDonate Or $g_bDonationEnabled) And $g_bChkDonate Then $bToReturn = True
If Not $bToReturn Then SetLog("Train end time: " & $iTimeBeforeTrain1, $COLOR_DEBUG)
If Not $bToReturn Then ClickP($aAway, 1, 0, "#0332")
Return $bToReturn
EndFunc
Func SwitchBetweenBases($bCheckMainScreen = True)
Local $sSwitchFrom, $sSwitchTo, $bIsOnBuilderBase = False, $aButtonCoords
Local $sTile, $sTileDir, $sRegionToSearch
Local $bSwitched = False
If Not $g_bRunState Then Return
For $i = 0 To 1
If isOnBuilderBase(True) Then
$sSwitchFrom = "Builder Base"
$sSwitchTo = "Normal Village"
$bIsOnBuilderBase = True
$sTile = "BoatBuilderBase"
$sTileDir = $g_sImgBoatBB
$sRegionToSearch = "487,44,708,242"
Else
$sSwitchFrom = "Normal Village"
$sSwitchTo = "Builder Base"
$bIsOnBuilderBase = False
$sTile = "BoatNormalVillage"
$sTileDir = $g_sImgBoat
$sRegionToSearch = "66,432,388,627"
EndIf
If $i = 1 Then
For $j = 0 To 6
AndroidShield("AndroidOnlyZoomOut")
AndroidZoomOut($j, Default,($g_iAndroidZoomoutMode <> 2))
If Not $g_bRunState Then Return
If _sleep(100) Then Return
Next
Else
ZoomOut()
EndIf
If _sleep(1000) Then Return
If Not $g_bRunState Then Return
$aButtonCoords = decodeSingleCoord(findImageInPlace($sTile, $sTileDir, $sRegionToSearch))
If UBound($aButtonCoords) > 1 Then
SetLog("[" & $i & "] Going to " & $sSwitchTo, $COLOR_INFO)
ClickP($aButtonCoords)
If _Sleep($DELAYSWITCHBASES1) Then Return
Local $hTimerHandle = __TimerInit()
$bSwitched = False
While __TimerDiff($hTimerHandle) < 3000 And Not $bSwitched
If _Sleep(250) Then Return
If Not $g_bRunState Then Return
ForceCaptureRegion()
$bSwitched = isOnBuilderBase(True) <> $bIsOnBuilderBase
WEnd
If $bSwitched Then
If $bCheckMainScreen Then checkMainScreen(True, Not $bIsOnBuilderBase)
Return True
Else
SetLog("Failed to go to the " & $sSwitchTo, $COLOR_ERROR)
EndIf
Else
Setlog("[" & $i & "] SwitchBetweenBases Tile: " & $sTile, $COLOR_ERROR)
Setlog("[" & $i & "] SwitchBetweenBases isOnBuilderBase: " & isOnBuilderBase(True), $COLOR_ERROR)
If $bIsOnBuilderBase Then
SetLog("Cannot find the Boat on the Coast", $COLOR_ERROR)
Else
SetLog("Cannot find the Boat on the Coast. Maybe it is still broken or not visible", $COLOR_ERROR)
EndIf
EndIf
Next
Return False
EndFunc
Func ProfileSwitchAccountEnabled()
If Not $g_bChkSwitchAcc Or Not aquireSwitchAccountMutex() Then Return False
Return SetError(0, 0, _ArraySearch($g_asProfileName, $g_sProfileCurrentName) >= 0)
EndFunc
Func SwitchAccountEnabled($IdxOrProfilename = $g_sProfileCurrentName)
Local $sProfile
Local $iIdx
If IsInt($IdxOrProfilename) Then
$iIdx = $IdxOrProfilename
$sProfile = $g_asProfileName[$iIdx]
Else
$sProfile = $IdxOrProfilename
$iIdx = _ArraySearch($g_asProfileName, $sProfile)
EndIf
If Not $sProfile Or $iIdx < 0 Or Not $g_abAccountNo[$iIdx] Then
Return False
EndIf
Return aquireProfileMutex($sProfile) <> 0
EndFunc
Func AccountNoActive()
Local $a[UBound($g_abAccountNo)]
For $i = 0 To UBound($g_abAccountNo) - 1
$a[$i] = SwitchAccountEnabled($i)
Next
Return $a
EndFunc
Func InitiateSwitchAcc()
If Not ProfileSwitchAccountEnabled() Or Not $g_bInitiateSwitchAcc Then Return
UpdateMultiStats()
$g_iNextAccount = -1
SetLog("Switch Account enable for " & $g_iTotalAcc + 1 & " accounts")
SetSwitchAccLog("Initiating: " & $g_iTotalAcc + 1 & " acc", $COLOR_SUCCESS)
For $i = 0 To $g_iTotalAcc
Local $sBotType = "Idle"
If $g_abAccountNo[$i] Then
If SwitchAccountEnabled($i) Then
$sBotType = "Active"
If $g_abDonateOnly[$i] Then $sBotType = "Donate"
If $g_iNextAccount = -1 Then $g_iNextAccount = $i
If $g_asProfileName[$i] = $g_sProfileCurrentName Then $g_iNextAccount = $i
Else
$sBotType = "Other bot"
EndIf
EndIf
SetLog("  - Account [" & $i + 1 & "]: " & $g_asProfileName[$i] & " - " & $sBotType)
SetSwitchAccLog("  - Acc. " & $i + 1 & ": " & $sBotType)
$g_abPBActive[$i] = False
Next
$g_iCurAccount = $g_iNextAccount
SwitchAccountVariablesReload("Reset")
SetLog("Let's start with Account [" & $g_iNextAccount + 1 & "]")
SwitchCOCAcc($g_iNextAccount)
EndFunc
Func CheckSwitchAcc()
Local $abAccountNo = AccountNoActive()
Local $aActiveAccount = _ArrayFindAll($abAccountNo, True)
If UBound($aActiveAccount) <= 1 Then Return
Local $aDonateAccount = _ArrayFindAll($g_abDonateOnly, True)
Local $bReachAttackLimit =($g_aiAttackedCountSwitch[$g_iCurAccount] <= $g_aiAttackedCount - 2)
Local $bForceSwitch = False
Local $nMinRemainTrain, $iWaitTime
Local $aActibePBTaccounts = _ArrayFindAll($g_abPBActive, True)
SetLog("Start Switch Account!", $COLOR_INFO)
If $g_abPBActive[$g_iCurAccount] = True Then $bForceSwitch = True
If $g_iCommandStop = 0 Or $g_iCommandStop = 3 Then
SetLog("This account is in halt attack mode, switching to another account", $COLOR_ACTION)
SetSwitchAccLog(" - Halt Attack, Force switch")
$bForceSwitch = True
ElseIf $g_bWaitForCCTroopSpell Then
SetLog("Still waiting for CC Troops/Spells, switching to another Account", $COLOR_ACTION)
SetSwitchAccLog(" - Waiting for CC")
$bForceSwitch = True
Else
getArmyTroopTime(True, False)
$g_aiTimeTrain[1] = 0
If IsWaitforSpellsActive() Then getArmySpellTime()
$g_aiTimeTrain[2] = 0
If IsWaitforHeroesActive() Then CheckWaitHero()
ClickP($aAway, 1, 0, "#0000")
$iWaitTime = _ArrayMax($g_aiTimeTrain, 1, 0, 2)
If $bReachAttackLimit And $iWaitTime <= 0 Then
SetLog("This account has attacked twice in a row, switching to another account", $COLOR_INFO)
SetSwitchAccLog(" - Reach attack limit: " & $g_aiAttackedCount - $g_aiAttackedCountSwitch[$g_iCurAccount])
$bForceSwitch = True
EndIf
EndIf
Local $sLogSkip = ""
If Not $g_abDonateOnly[$g_iCurAccount] And $iWaitTime <= $g_iTrainTimeToSkip And Not $bForceSwitch Then
If $iWaitTime > 0 Then $sLogSkip = " in " & Round($iWaitTime, 1) & " mins"
SetLog("Army is ready" & $sLogSkip & ", skip switching account", $COLOR_INFO)
SetSwitchAccLog(" - Army is ready" & $sLogSkip)
SetSwitchAccLog("Stay at [" & $g_iCurAccount + 1 & "]", $COLOR_SUCCESS)
If _Sleep(500) Then Return
Else
If $g_bChkSmartSwitch = True Then
SetDebugLog("-Smart Switch-")
$nMinRemainTrain = CheckTroopTimeAllAccount($bForceSwitch)
If $nMinRemainTrain <= 1 And Not $bForceSwitch And Not $g_bDonateLikeCrazy Then
If $g_bDebugSetlog Then SetDebugLog("Switch to or Stay at Active Account: " & $g_iNextAccount + 1, $COLOR_DEBUG)
$g_iDonateSwitchCounter = 0
Else
If $g_iDonateSwitchCounter < UBound($aDonateAccount) Then
$g_iNextAccount = $aDonateAccount[$g_iDonateSwitchCounter]
$g_iDonateSwitchCounter += 1
If $g_bDebugSetlog Then SetDebugLog("Switch to Donate Account " & $g_iNextAccount + 1 & ". $g_iDonateSwitchCounter = " & $g_iDonateSwitchCounter, $COLOR_DEBUG)
SetSwitchAccLog(" - Donate Acc [" & $g_iNextAccount + 1 & "]")
Else
$g_iDonateSwitchCounter = 0
EndIf
EndIf
Else
SetDebugLog("-Normal Switch-")
$g_iNextAccount = $g_iCurAccount + 1
If $g_iNextAccount > $g_iTotalAcc Then $g_iNextAccount = 0
While $abAccountNo[$g_iNextAccount] = False
$g_iNextAccount += 1
If $g_iNextAccount > $g_iTotalAcc Then $g_iNextAccount = 0
SetDebugLog("- While Account: " & $g_asProfileName[$g_iNextAccount] & " number: " & $g_iNextAccount + 1)
WEnd
EndIf
SetDebugLog("- Current Account: " & $g_asProfileName[$g_iCurAccount] & " number: " & $g_iCurAccount + 1)
SetDebugLog("- Next Account: " & $g_asProfileName[$g_iNextAccount] & " number: " & $g_iNextAccount + 1)
If $g_abPBActive[$g_iNextAccount] And _DateDiff("n", _NowCalc(), $g_asTrainTimeFinish[$g_iNextAccount]) > 2 Then
SetLog("Account " & $g_iNextAccount + 1 & " is in a Personal Break Time!", $COLOR_INFO)
SetSwitchAccLog(" - Account " & $g_iNextAccount + 1 & " is in PTB")
$g_iNextAccount = $g_iNextAccount + 1
If $g_iNextAccount > $g_iTotalAcc Then $g_iNextAccount = 0
While $abAccountNo[$g_iNextAccount] = False
$g_iNextAccount += 1
If $g_iNextAccount > $g_iTotalAcc Then $g_iNextAccount = 0
WEnd
EndIf
If UBound($aActibePBTaccounts) + UBound($aDonateAccount) = UBound($aActiveAccount) Then
SetLog("All accounts set to Donate and/or are in PBT!", $COLOR_INFO)
SetSwitchAccLog("All accounts in PBT/Donate:")
For $i = 0 To $g_iTotalAcc
If $g_abDonateOnly[$i] Then SetSwitchAccLog(" - Donate Acc [" & $i + 1 & "]")
If $g_abPBActive[$i] Then SetSwitchAccLog(" - PBT Acc [" & $i + 1 & "]")
Next
EndIf
If $g_iNextAccount <> $g_iCurAccount Then
If $g_bRequestTroopsEnable And $g_bCanRequestCC Then
If _Sleep(1000) Then Return
SetLog("Try Request troops before switching account", $COLOR_INFO)
RequestCC(True)
EndIf
If Not IsMainPage() Then checkMainScreen()
SwitchCOCAcc($g_iNextAccount)
Else
SetLog("Staying in this account")
SetSwitchAccLog("Stay at [" & $g_iCurAccount + 1 & "]", $COLOR_SUCCESS)
VillageReport()
CheckFarmSchedule()
EndIf
EndIf
EndFunc
Func SwitchCOCAcc($NextAccount)
Local $abAccountNo = AccountNoActive()
If $NextAccount < 0 And $NextAccount > $g_iTotalAcc Then $NextAccount = _ArraySearch(True, $abAccountNo)
Static $iRetry = 0
Local $bResult
SetLog("Switching to Account [" & $NextAccount + 1 & "]")
Local $bSharedPrefs = $g_bChkSharedPrefs And HaveSharedPrefs($g_asProfileName[$g_iNextAccount])
If $bSharedPrefs And $g_PushedSharedPrefsProfile = $g_asProfileName[$g_iNextAccount] Then
$bResult = True
$bSharedPrefs = False
SetLog("Profile shared_prefs already pushed")
Else
If IsMainPage() Then Click($aButtonSetting[0], $aButtonSetting[1], 1, 0, "Click Setting")
If _Sleep(500) Then Return
While 1
If Not IsSettingPage() Then ExitLoop
If $g_bChkGooglePlay Or $g_bChkSharedPrefs Then
Switch SwitchCOCAcc_DisconnectConnect($bResult, $bSharedPrefs)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ClickAccount($bResult, $NextAccount, $bSharedPrefs)
Case "OK"
If $g_bChkSharedPrefs Then
If $bSharedPrefs Then
CloseCoC(False)
$bResult = True
ExitLoop
Else
SetLog($g_asProfileName[$g_iNextAccount] & " missing shared_prefs, using normal switch account", $COLOR_WARNING)
EndIf
EndIf
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ConfirmAccount($bResult)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
ElseIf $g_bChkSuperCellID Then
Switch SwitchCOCAcc_ConnectedSCID($bResult)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ConfirmSCID($bResult)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ClickAccountSCID($bResult, $NextAccount)
Case "OK"
Case "Error"
ExitLoop
Case "Exit"
Return
EndSwitch
EndIf
ExitLoop
WEnd
If _Sleep(500) Then Return
EndIf
If $bResult Then
$iRetry = 0
$g_bReMatchAcc = False
If Not $g_bInitiateSwitchAcc Then SwitchAccountVariablesReload("Save")
If $g_ahTimerSinceSwitched[$g_iCurAccount] <> 0 Then
If Not $g_bReMatchAcc Then SetSwitchAccLog(" - Acc " & $g_iCurAccount + 1 & ", online: " & Int(__TimerDiff($g_ahTimerSinceSwitched[$g_iCurAccount]) / 1000 / 60) & "m")
SetTime(True)
$g_aiRunTime[$g_iCurAccount] += __TimerDiff($g_ahTimerSinceSwitched[$g_iCurAccount])
$g_ahTimerSinceSwitched[$g_iCurAccount] = 0
EndIf
$g_iCurAccount = $NextAccount
SwitchAccountVariablesReload()
$g_ahTimerSinceSwitched[$g_iCurAccount] = __TimerInit()
$g_bInitiateSwitchAcc = False
If $g_sProfileCurrentName <> $g_asProfileName[$g_iNextAccount] Then
If $g_iGuiMode = 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbProfile, _GUICtrlComboBox_FindStringExact($g_hCmbProfile, $g_asProfileName[$g_iNextAccount]))
cmbProfile()
DisableGUI_AfterLoadNewProfile()
Else
saveConfig()
$g_sProfileCurrentName = $g_asProfileName[$g_iNextAccount]
LoadProfile(False)
EndIf
EndIf
If $bSharedPrefs Then
SetLog("Please wait for loading CoC!")
PushSharedPrefs()
OpenCoC()
waitMainScreen()
EndIf
SetSwitchAccLog("Switched to Acc [" & $NextAccount + 1 & "]", $COLOR_SUCCESS)
If $g_bChkSharedPrefs And Not($g_bUpdateSharedPrefs And $g_bUpdateSharedPrefsGoogleDisconnected) Then
waitMainScreen()
If IsMainPage() Then
Click($aButtonSetting[0], $aButtonSetting[1], 1, 0, "Click Setting")
If _Sleep(500) Then Return
Switch SwitchCOCAcc_DisconnectConnect($bResult, $g_bChkSharedPrefs)
Case "OK"
Case "Error"
Case "Exit"
Return
EndSwitch
Switch SwitchCOCAcc_ClickAccount($bResult, $NextAccount, $g_bChkSharedPrefs, False)
Case "OK"
PullSharedPrefs()
EndSwitch
EndIf
EndIf
Else
$iRetry += 1
$g_bReMatchAcc = True
SetLog("Switching account failed!", $COLOR_ERROR)
SetSwitchAccLog("Switching to Acc " & $NextAccount + 1 & " Failed!", $COLOR_ERROR)
If $iRetry <= 3 Then
Local $ClickPoint = $aAway
If $g_bChkSuperCellID Then $ClickPoint = $aCloseTabSCID
ClickP($ClickPoint, 2, 500)
checkMainScreen()
Else
$iRetry = 0
UniversalCloseWaitOpenCoC()
EndIf
EndIf
waitMainScreen()
CheckObstacles()
If $g_bForceSinglePBLogoff Then $g_bGForcePBTUpdate = True
runBot()
EndFunc
Func SwitchCOCAcc_DisconnectConnect(ByRef $bResult, $bDisconnectOnly = $g_bChkSharedPrefs)
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aButtonConnected[0], $aButtonConnected[1], True), Hex($aButtonConnected[2], 6), $aButtonConnected[3]) Then
If $bDisconnectOnly = False Then
SetLog("   1. Click Connect & Disconnect")
Click($aButtonConnected[0], $aButtonConnected[1], 2, 1000)
If _Sleep(200) Then Return "Exit"
Else
SetLog("   1. Click Connected")
Click($aButtonConnected[0], $aButtonConnected[1], 1, 1000)
If _Sleep(200) Then Return "Exit"
EndIf
Return "OK"
ElseIf _ColorCheck(_GetPixelColor($aButtonDisconnected[0], $aButtonDisconnected[1], True), Hex($aButtonDisconnected[2], 6), $aButtonDisconnected[3]) Then
If $bDisconnectOnly = False Then
SetLog("   1. Click Disconnect")
Click($aButtonDisconnected[0], $aButtonDisconnected[1])
If _Sleep(200) Then Return "Exit"
Else
SetLog("Account already disconnected")
EndIf
Return "OK"
ElseIf _ColorCheck(_GetPixelColor($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], True), Hex($aButtonConnectedSCID[2], 6), $aButtonConnectedSCID[3]) Then
SetLog("Account connected to SuperCell ID")
Return "OK"
EndIf
If $i = 20 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func SwitchCOCAcc_ClickAccount(ByRef $bResult, $iNextAccount, $bStayDisconnected = $g_bChkSharedPrefs, $bLateDisconnectButtonCheck = True)
FuncEnter(SwitchCOCAcc_ClickAccount)
Local $aSearchForAccount, $aCoordinates[0][2], $aTempArray
For $i = 0 To 20
If _ColorCheck(_GetPixelColor($aListAccount[0], $aListAccount[1], True), Hex($aListAccount[2], 6), $aListAccount[3]) Then
If $bStayDisconnected Then
ClickP($aAway, 1, 0, "#0000")
Return FuncReturn("OK")
EndIf
If _Sleep(600) Then Return FuncReturn("Exit")
$aSearchForAccount = decodeMultipleCoords(findImage("AccountLocations", $g_sImgGoogleAccounts, GetDiamondFromRect("155,100,705,710"), 0, True, Default))
If UBound($aSearchForAccount, 1) <= 0 Then
SetLog("No GooglePlay accounts detected!", $COLOR_ERROR)
Return FuncReturn("Error")
ElseIf UBound($aSearchForAccount, 1) < $g_iTotalAcc + 1 Then
SetLog("Less GooglePlay accounts detected than configured!", $COLOR_ERROR)
SetDebugLog("Detected: " & UBound($aSearchForAccount, 1) & ", Configured: " &($g_iTotalAcc + 1), $COLOR_DEBUG)
Return FuncReturn("Error")
ElseIf UBound($aSearchForAccount, 1) > $g_iTotalAcc + 1 Then
SetLog("More GooglePlay accounts detected than configured!", $COLOR_ERROR)
SetDebugLog("Detected: " & UBound($aSearchForAccount, 1) & ", Configured: " &($g_iTotalAcc + 1), $COLOR_DEBUG)
Return FuncReturn("Error")
Else
SetDebugLog("[GooglePlay Accounts]: " & UBound($aSearchForAccount, 1), $COLOR_DEBUG)
For $j = 0 To UBound($aSearchForAccount) - 1
$aTempArray = $aSearchForAccount[$j]
_ArrayAdd($aCoordinates, $aTempArray[0] & "|" & $aTempArray[1], 0, "|", @CRLF, $ARRAYFILL_FORCE_NUMBER)
Next
_ArraySort($aCoordinates, 0, 0, 0, 1)
For $j = 0 To UBound($aCoordinates) - 1
SetDebugLog("[" & $j & "] Account coordinates: " & $aCoordinates[$j][0] & "," & $aCoordinates[$j][1] & " named: " & $g_asProfileName[$j])
Next
If $iNextAccount + 1 > UBound($aCoordinates, 1) Then
SetLog("You selected a GooglePlay undetected account!", $COLOR_ERROR)
Return FuncReturn("Error")
EndIf
SetLog("   2. Click Account [" & $iNextAccount + 1 & "]")
Click($aCoordinates[$iNextAccount][0], $aCoordinates[$iNextAccount][1], 1)
If _Sleep(600) Then Return FuncReturn("Exit")
Return FuncReturn("OK")
EndIf
If Not $g_bRunState Then Return
If _sleep(1000) Then Return FuncReturn("Exit")
Return FuncReturn("Error")
ElseIf(Not $bLateDisconnectButtonCheck Or $i = 6) And _ColorCheck(_GetPixelColor($aButtonDisconnected[0], $aButtonDisconnected[1], True), Hex($aButtonDisconnected[2], 6), $aButtonDisconnected[3]) Then
If $bStayDisconnected Then
ClickP($aAway, 1, 0, "#0000")
Return FuncReturn("OK")
EndIf
If _Sleep(250) Then Return FuncReturn("Exit")
SetLog("   1.1. Click Disconnect again")
Click($aButtonDisconnected[0], $aButtonDisconnected[1])
If _Sleep(600) Then Return FuncReturn("Exit")
ElseIf _ColorCheck(_GetPixelColor($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], True), Hex($aButtonConnectedSCID[2], 6), $aButtonConnectedSCID[3]) Then
If $bStayDisconnected Then
ClickP($aAway, 1, 0, "#0000")
Return FuncReturn("OK")
EndIf
EndIf
If $i = 20 Then
$bResult = False
Return FuncReturn("Error")
EndIf
If _Sleep(900) Then Return FuncReturn("Exit")
Next
Return FuncReturn("")
EndFunc
Func SwitchCOCAcc_ConfirmAccount(ByRef $bResult, $iStep = 3, $bDisconnectAfterSwitch = $g_bChkSharedPrefs)
For $i = 0 To 30
If _ColorCheck(_GetPixelColor($aButtonConnected[0], $aButtonConnected[1], True), Hex($aButtonConnected[2], 6), $aButtonConnected[3]) Then
SetLog("Already in current account")
If $bDisconnectAfterSwitch Then
Switch SwitchCOCAcc_DisconnectConnect($bResult)
Case "OK"
Case "Error"
Return "Error"
Case "Exit"
Return "Exit"
EndSwitch
EndIf
ClickP($aAway, 2, 0, "#0167")
If _Sleep(500) Then Return "Exit"
$bResult = True
Return "OK"
ElseIf _ColorCheck(_GetPixelColor($aButtonVillageLoad[0], $aButtonVillageLoad[1], True), Hex($aButtonVillageLoad[2], 6), $aButtonVillageLoad[3]) Then
If _Sleep(250) Then Return "Exit"
SetLog("   " & $iStep & ". Click Load button")
Click($aButtonVillageLoad[0], $aButtonVillageLoad[1], 1, 0, "Click Load")
For $j = 0 To 25
If _ColorCheck(_GetPixelColor($aButtonVillageOkay[0], $aButtonVillageOkay[1], True), Hex($aButtonVillageOkay[2], 6), $aButtonVillageOkay[3]) Then
If _Sleep(250) Then Return "Exit"
SetLog("   " &($iStep + 1) & ". Click OKAY")
Click($aButtonVillageOkay[0], $aButtonVillageOkay[1], 1, 0, "Click OKAY")
SetLog("Please wait for loading CoC...!")
$bResult = True
Return "OK"
ElseIf _ColorCheck(_GetPixelColor($aTextBox[0], $aTextBox[1], True), Hex($aTextBox[2], 6), $aTextBox[3]) Then
If _Sleep(250) Then Return "Exit"
SetLog("   " &($iStep + 1) & ". Click text box & type CONFIRM")
Click($aTextBox[0], $aTextBox[1], 1, 0, "Click Text box")
If _Sleep(500) Then Return "Exit"
AndroidSendText("CONFIRM")
ExitLoop
EndIf
If $j = 25 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
For $k = 0 To 10
If _ColorCheck(_GetPixelColor($aButtonVillageOkay[0], $aButtonVillageOkay[1], True), Hex($aButtonVillageOkay[2], 6), $aButtonVillageOkay[3]) Then
If _Sleep(250) Then Return "Exit"
SetLog("   " &($iStep + 2) & ". Click OKAY")
Click($aButtonVillageOkay[0], $aButtonVillageOkay[1], 1, 0, "Click OKAY")
SetLog("Please wait for loading CoC!")
$bResult = True
If $bDisconnectAfterSwitch Then
If Not checkMainScreen() Then
SetLog("Cannot Disconnect account", $COLOR_ERROR)
Return "Error"
EndIf
Click($aButtonSetting[0], $aButtonSetting[1], 1, 0, "Click Setting")
If _Sleep(500) Then Return
Switch SwitchCOCAcc_DisconnectConnect($bResult)
Case "OK"
Case "Error"
Return "Error"
Case "Exit"
Return "Exit"
EndSwitch
EndIf
Return "OK"
EndIf
If $k = 10 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
EndIf
If $i = 30 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func SwitchCOCAcc_ConnectedSCID(ByRef $bResult)
For $x = 0 To 20
If _ColorCheck(_GetPixelColor($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], True), Hex($aButtonConnectedSCID[2], 6), $aButtonConnectedSCID[3]) Then
Click($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], 1, 0, "Click Connected SC_ID")
SetLog("   1. Click Connected Supercell ID")
If _Sleep(600) Then Return "Exit"
Return "OK"
EndIf
SetDebugLog("Checking Green Connected button x:" & $aButtonConnectedSCID[0] & " y:" & $aButtonConnectedSCID[1] & " : " & _GetPixelColor($aButtonConnectedSCID[0], $aButtonConnectedSCID[1], True))
If $x = 20 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func SwitchCOCAcc_ConfirmSCID(ByRef $bResult)
For $x = 0 To 30
Local $AlternativeToMemuLogOut = [$aButtonLogOutSCID[0], 265, $aButtonLogOutSCID[2], $aButtonLogOutSCID[3]]
Local $AlternativeToMemuConfirm = [410, $aButtonConfirmSCID[1], $aButtonConfirmSCID[2], $aButtonConfirmSCID[3]]
Local $aToCheckLogOut[2] = [$AlternativeToMemuLogOut, $aButtonLogOutSCID]
Local $aToCheckConfirm = [$AlternativeToMemuConfirm, $aButtonConfirmSCID]
For $i = 0 To UBound($aToCheckLogOut) - 1
Local $Pixel = $aToCheckLogOut[$i]
If _ColorCheck(_GetPixelColor($Pixel[0], $Pixel[1], True), Hex($Pixel[2], 6), $Pixel[3]) Then
SetLog("   2. Click Log Out Supercell ID")
Click($Pixel[0], $Pixel[1], 3, 500, "Click Log Out SC_ID")
If _Sleep(500) Then Return "Exit"
Local $TempConfirm = $aToCheckConfirm[$i]
For $j = 0 To 20
If _ColorCheck(_GetPixelColor($TempConfirm[0], $TempConfirm[1], True), Hex($TempConfirm[2], 6), $TempConfirm[3]) Then
SetLog("   3. Click Confirm Supercell ID")
Click($TempConfirm[0], $TempConfirm[1], 1, 0, "Click Confirm SC_ID")
If _Sleep(500) Then Return "Exit"
Return "OK"
EndIf
If $j = 20 Then
$bResult = False
If $i = 1 Then Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
EndIf
SetDebugLog("[" & $i & "] Checking LogOut & Confirm button x:" & $Pixel[0] & " y:" & $Pixel[1] & " : " & _GetPixelColor($Pixel[0], $Pixel[1], True))
Next
If $x = 30 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func SwitchCOCAcc_ClickAccountSCID(ByRef $bResult, $NextAccount, $iStep = 4)
Local $YCoord = Int(336 + 73.5 * $NextAccount)
Local $iRetryCloseSCIDTab = 0
Local $aSearchForAccount, $aCoordinates[0][2], $aTempArray
For $i = 0 To 30
If _ColorCheck(_GetPixelColor($aLoginWithSupercellID[0], $aLoginWithSupercellID[1], True), Hex($aLoginWithSupercellID[2], 6), $aLoginWithSupercellID[3]) And  _ColorCheck(_GetPixelColor($aLoginWithSupercellID2[0], $aLoginWithSupercellID2[1], True), Hex($aLoginWithSupercellID2[2], 6), $aLoginWithSupercellID2[3]) Then
SetLog("   " & $iStep & ". Click Log in with Supercell ID")
Click($aLoginWithSupercellID[0], $aLoginWithSupercellID[1], 1, 0, "Click Log in with SC_ID")
If _Sleep(600) Then Return "Exit"
For $j = 0 To 20
If QuickMIS("BC1", $g_sImgListAccountsSCID, 490, 195, 524, 232, True, $g_bDebugImageSave) Then
Local $bDragDone = False
If $NextAccount >= 4 Then
$YCoord = Int(408 - 73.5 *($g_iTotalAcc - $NextAccount))
ClickDrag(700, 590, 700, 172, 2000)
SetLog("     drag for more accounts")
If _Sleep(250) Then Return "Exit"
For $h = 0 To 5
If QuickMIS("N1", @ScriptDir & "\imgxml\SwitchAccounts", 407, 470, 453, 487, True, $g_bDebugImageSave) = "OR" Then
$bDragDone = True
ExitLoop
EndIf
If _Sleep(250) Then Return "Exit"
Next
If $h = 5 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
EndIf
If $NextAccount < 4 Or $bDragDone Then
Click(270, $YCoord, 3, 1000)
If _Sleep(250) Then Return "Exit"
$bResult = True
EndIf
ElseIf QuickMIS("BC1", $g_sImgListAccountsSCID, 468, 190, 498, 300, True, $g_bDebugImageSave) Then
$aSearchForAccount = decodeMultipleCoords(findImage("AccountLocations", $g_sImgSupercellID, GetDiamondFromRect("530,165,620,605"), 0, True, Default))
If UBound($aSearchForAccount) > 0 Then
SetDebugLog("[SCID Accounts]: " & UBound($aSearchForAccount), $COLOR_DEBUG)
For $k = 0 To UBound($aSearchForAccount) - 1
$aTempArray = $aSearchForAccount[$k]
_ArrayAdd($aCoordinates, $aTempArray[0] & "|" & $aTempArray[1], 0, "|", @CRLF, $ARRAYFILL_FORCE_NUMBER)
Next
_ArraySort($aCoordinates, 0, 0, 0, 1)
For $k = 0 To UBound($aCoordinates) - 1
SetDebugLog("[" & $k & "] Account coordinates: " & $aCoordinates[$k][0] & "," & $aCoordinates[$k][1] & " named: " & $g_asProfileName[$k])
Next
SetLog("SC_ID account number " & $NextAccount + 1 & " named: " & $g_asProfileName[$NextAccount])
If $NextAccount + 1 > UBound($aSearchForAccount) Then
SetLog("You selected a SCID undetected account!", $COLOR_ERROR)
Return "Error"
EndIf
Click($aCoordinates[$NextAccount][0] - 150, $aCoordinates[$NextAccount][1], 1)
If _Sleep(250) Then Return "Exit"
$bResult = True
EndIf
If Not $g_bRunState Then Return
If _Sleep(1000) Then Return "Exit"
Return "Error"
EndIf
If $bResult Then
SetLog("   " &($iStep + 1) & ". Click Account [" & $NextAccount + 1 & "] Supercell ID")
SetLog("Please wait for loading CoC!")
Return "OK"
EndIf
If $j = 20 Then
$iRetryCloseSCIDTab += 1
If $iRetryCloseSCIDTab <= 3 Then
SetLog("   " & $iStep & ".5 Click Close Tab Supercell ID")
Click($aCloseTabSCID[0], $aCloseTabSCID[1], 1, 0, "Click Close Tab SC_ID")
If _Sleep(500) Then Return "Exit"
$i = 0
ExitLoop
Else
$iRetryCloseSCIDTab = 0
$bResult = False
Return "Error"
EndIf
EndIf
If _Sleep(900) Then Return "Exit"
Next
EndIf
SetDebugLog("Checking 'Log in with SuperCell ID' buttonn' x:" & $aLoginWithSupercellID[0] & " y:" & $aLoginWithSupercellID[1] & " : " & _GetPixelColor($aLoginWithSupercellID[0], $aLoginWithSupercellID[1], True))
SetDebugLog("Checking 'Log in with SuperCell ID' White Font' x:" & $aLoginWithSupercellID2[0] & " y:" & $aLoginWithSupercellID2[1] & " : " & _GetPixelColor($aLoginWithSupercellID2[0], $aLoginWithSupercellID2[1], True))
If $i = 30 Then
$bResult = False
Return "Error"
EndIf
If _Sleep(900) Then Return "Exit"
Next
Return ""
EndFunc
Func CheckWaitHero()
Local $iActiveHero
Local $aHeroResult[3]
$g_aiTimeTrain[2] = 0
$aHeroResult = getArmyHeroTime("all")
If UBound($aHeroResult) < 3 Then Return
If _Sleep($DELAYRESPOND) Then Return
If $aHeroResult[0] > 0 Or $aHeroResult[1] > 0 Or $aHeroResult[2] > 0 Then
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $g_iModeCount - 1
$iActiveHero = -1
If IsUnitUsed($pMatchMode, $pTroopType) And BitOR($g_aiAttackUseHeroes[$pMatchMode], $g_aiSearchHeroWaitEnable[$pMatchMode]) = $g_aiAttackUseHeroes[$pMatchMode] Then
$iActiveHero = $pTroopType - $eKing
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $g_aiTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$g_aiTimeTrain[2] = $aHeroResult[$iActiveHero]
EndIf
EndIf
Next
If _Sleep($DELAYRESPOND) Then Return
Next
EndIf
EndFunc
Func CheckTroopTimeAllAccount($bExcludeCurrent = False)
Local $abAccountNo = AccountNoActive()
Local $iMinRemainTrain = 999, $iRemainTrain, $bNextAccountDefined = False
If Not $bExcludeCurrent And Not $g_abPBActive[$g_iCurAccount] Then
$g_asTrainTimeFinish[$g_iCurAccount] = _DateAdd("n", Number(_ArrayMax($g_aiTimeTrain, 1, 0, 2)), _NowCalc())
SetDebugLog("Army times: Troop = " & $g_aiTimeTrain[0] & ", Spell = " & $g_aiTimeTrain[1] & ", Hero = " & $g_aiTimeTrain[2] & ", $g_asTrainTimeFinish = " & $g_asTrainTimeFinish[$g_iCurAccount])
EndIf
SetSwitchAccLog(" - Train times: ")
For $i = 0 To $g_iTotalAcc
If $bExcludeCurrent And $i = $g_iCurAccount Then ContinueLoop
If $abAccountNo[$i] And Not $g_abDonateOnly[$i] Then
If _DateIsValid($g_asTrainTimeFinish[$i]) Then
Local $iRemainTrain = _DateDiff("n", _NowCalc(), $g_asTrainTimeFinish[$i])
SetLog("Account [" & $i + 1 & "]: " & $g_asProfileName[$i] & "'s train time: " & $g_asTrainTimeFinish[$i] & " (" & $iRemainTrain & " minutes)")
If $iMinRemainTrain > $iRemainTrain Then
If Not $bNextAccountDefined Then $g_iNextAccount = $i
$iMinRemainTrain = $iRemainTrain
EndIf
SetSwitchAccLog("    Acc " & $i + 1 & ": " & $iRemainTrain & "m")
Else
SetLog("Account [" & $i + 1 & "]: " & $g_asProfileName[$i] & " has not been read its remain train time")
SetSwitchAccLog("    Acc " & $i + 1 & ": Unknown")
If Not $bNextAccountDefined Then
$g_iNextAccount = $i
$bNextAccountDefined = True
EndIf
EndIf
EndIf
Next
SetDebugLog("- Min Remain Train Time is " & $iMinRemainTrain)
Return $iMinRemainTrain
EndFunc
Func DisableGUI_AfterLoadNewProfile()
$g_bGUIControlDisabled = True
For $i = $g_hFirstControlToHide To $g_hLastControlToHide
If IsAlwaysEnabledControl($i) Then ContinueLoop
If BitAND(GUICtrlGetState($i), $GUI_ENABLE) Then GUICtrlSetState($i, $GUI_DISABLE)
Next
ControlEnable("", "", $g_hCmbGUILanguage)
$g_bGUIControlDisabled = False
EndFunc
Func aquireSwitchAccountMutex($iSwitchAccountGroup = $g_iCmbSwitchAcc, $bReturnOnlyMutex = False, $bShowMsgBox = False)
Local $sMsg = GetTranslatedFileIni("MBR GUI Design Child Bot - Profiles", "Msg_SwitchAccounts_InUse", "My Bot with Switch Accounts Group %s is already in use or active.", $iSwitchAccountGroup)
If $iSwitchAccountGroup Then
Local $hMutex_Profile = 0
If $g_ahMutex_SwitchAccountsGroup[0] = $iSwitchAccountGroup And $g_ahMutex_SwitchAccountsGroup[1] Then
$hMutex_Profile = $g_ahMutex_SwitchAccountsGroup[1]
Else
$hMutex_Profile = CreateMutex(StringReplace($g_sProfilePath & "\SwitchAccount.0" & $iSwitchAccountGroup, "\", "-"))
$g_ahMutex_SwitchAccountsGroup[0] = $iSwitchAccountGroup
$g_ahMutex_SwitchAccountsGroup[1] = $hMutex_Profile
EndIf
If $bReturnOnlyMutex Then
Return $hMutex_Profile
EndIf
If $hMutex_Profile = 0 Then
SetLog($sMsg, $COLOR_ERROR)
If $bShowMsgBox Then
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg)
EndIf
EndIf
Return $hMutex_Profile <> 0
EndIf
Return False
EndFunc
Func releaseSwitchAccountMutex()
If $g_ahMutex_SwitchAccountsGroup[1] Then
ReleaseMutex($g_ahMutex_SwitchAccountsGroup[1])
$g_ahMutex_SwitchAccountsGroup[0] = 0
$g_ahMutex_SwitchAccountsGroup[1] = 0
Return True
EndIf
Return False
EndFunc
Func CheckGoogleSelectAccount($bSelectFirst = True)
Local $bResult = False
Local $pColor = _GetPixelColor($aListAccount[0], $aListAccount[1], False)
If _ColorCheck($pColor, Hex($aListAccount[2], 6), $aListAccount[3]) Then
SetDebugLog("Found open Google Accounts list pixel")
If UBound(decodeSingleCoord(FindImageInPlace("GoogleSelectAccount", $g_sImgGoogleSelectAccount, "220,80(420,380)", False))) > 1 Then
SetLog("Found open Google Accounts list")
If $g_bChkSharedPrefs Then
SetLog("Close Google Accounts list")
Click(90, 400)
Return True
EndIf
Local $a = decodeSingleCoord(FindImageInPlace("GoogleSelectEmail", $g_sImgGoogleSelectEmail, "220,80(400,600)", False))
If UBound($a) > 1 Then
SetLog("   1. Click first Google Account")
ClickP($a)
$bResult = True
Switch SwitchCOCAcc_ConfirmAccount($bResult, 2)
Case "OK"
Case "Error"
Case "Exit"
Return
EndSwitch
Else
SetLog("Cannot find Google Account Email", $COLOR_ERROR)
$bResult = False
EndIf
Else
SetDebugLog("Open Google Accounts list not verified")
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("CheckGoogleSelectAccount pixel color: " & $pColor)
EndIf
Return $bResult
EndFunc
Func CheckLoginWithSupercellID()
Local $bResult = False
If UBound(decodeSingleCoord(FindImageInPlace("LoginWithSupercellID", $g_sImgLoginWithSupercellID, "315,663(125,45)", False))) > 1 Then
SetLog("Verified Log in with Supercell ID boot screen")
If HaveSharedPrefs($g_sProfileCurrentName) Then
SetLog("Close CoC and push shared_prefs for Supercell ID screen...")
PushSharedPrefs()
Return True
Else
If $g_bChkSuperCellID And ProfileSwitchAccountEnabled() Then
Local $NextAccount = 0
$bResult = False
For $i = 0 To $g_iTotalAcc
If $g_abAccountNo[$i] = True And SwitchAccountEnabled($i) And $g_asProfileName[$i] = $g_sProfileCurrentName Then $NextAccount = $i
Next
Switch SwitchCOCAcc_ClickAccountSCID($bResult, $NextAccount, 1)
Case "OK"
Case "Error"
Return
Case "Exit"
Return
EndSwitch
Else
SetLog("Cannot close Supercell ID screen, shared_prefs not pulled.", $COLOR_ERROR)
SetLog("Please resolve Supercell ID screen manually, close CoC", $COLOR_INFO)
SetLog("and then pull shared_prefs in tab Bot/Profiles.", $COLOR_INFO)
EndIf
EndIf
Else
SetDebugLog("Log in with Supercell ID boot screen not verified")
EndIf
Return $bResult
EndFunc
Func CheckLoginWithSupercellIDScreen()
Local $aSearchForAccount, $aCoordinates[0][2], $aTempArray
Local $acount = $g_iWhatSCIDAccount2Use
If $g_bChkSuperCellID And ProfileSwitchAccountEnabled() Then
$acount = $g_iCurAccount
EndIf
If UBound(decodeSingleCoord(FindImageInPlace("LoginWithSupercellID", $g_sImgLoginWithSupercellID, "315,663(125,45)", False))) > 1 Then
SetLog("Verified Log in with Supercell ID boot screen for login")
Click($aLoginWithSupercellID[0], $aLoginWithSupercellID[1], 1, 0, "Click Log in with SC_ID")
If _Sleep(600) Then Return
For $i = 0 To 20
$aSearchForAccount = decodeMultipleCoords(findImage("AccountLocations", $g_sImgSupercellID, GetDiamondFromRect("530,165,690,605"), 0, True, Default))
If UBound($aSearchForAccount) > 0 Then
SetDebugLog("[SCID Accounts]: " & UBound($aSearchForAccount), $COLOR_DEBUG)
For $j = 0 To UBound($aSearchForAccount) - 1
$aTempArray = $aSearchForAccount[$j]
_ArrayAdd($aCoordinates, $aTempArray[0] & "|" & $aTempArray[1], 0, "|", @CRLF, $ARRAYFILL_FORCE_NUMBER)
Next
_ArraySort($aCoordinates, 0, 0, 0, 1)
For $j = 0 To UBound($aCoordinates) - 1
SetDebugLog("[" & $j & "] Account coordinates: " & $aCoordinates[$j][0] & "," & $aCoordinates[$j][1] & " named: " & $g_asProfileName[$j])
Next
SetLog("SC_ID account number " & $acount + 1 & " named: " & $g_asProfileName[$acount])
If $acount + 1 > UBound($aSearchForAccount) Then
SetLog("You selected a SCID undetected account", $COLOR_ERROR)
ExitLoop
EndIf
Click($aCoordinates[$acount][0] - 150, $aCoordinates[$acount][1], 1)
SetLog("Please wait for loading CoC!")
ExitLoop
EndIf
If Not $g_bRunState Then Return
If _Sleep(1000) Then Return
Next
Else
SetDebugLog("Log in with Supercell ID boot screen not verified for login")
EndIf
EndFunc
Func SwitchAccountCheckProfileInUse($sNewProfile)
Local $sInGroups = ""
For $g = 1 To 8
If $g = $g_iCmbSwitchAcc Then ContinueLoop
Local $sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $g & ".ini"
If FileExists($sSwitchAccFile) = 0 Then ContinueLoop
Local $sProfile
Local $bEnabled
For $i = 1 To Int(IniRead($sSwitchAccFile, "SwitchAccount", "TotalCocAccount", 0)) + 1
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "Enable", "") = "1"
If $bEnabled Then
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, "") = "1"
If $bEnabled Then
$sProfile = IniRead($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, "")
If $sProfile = $sNewProfile Then
If $sInGroups <> "" Then $sInGroups &= ", "
$sInGroups &= $g
EndIf
EndIf
EndIf
Next
Next
If $sInGroups Then
If StringLen($sInGroups) > 2 Then
$sInGroups = "used in groups " & $sInGroups
Else
$sInGroups = "used in group " & $sInGroups
EndIf
EndIf
Local $iAquired = aquireProfileMutex($sNewProfile)
If $iAquired Then
If $iAquired = 1 Then
releaseProfileMutex($sNewProfile)
EndIf
If $sInGroups Then
SetLog("Profile " & $sNewProfile & " not active, but " & $sInGroups & "!", $COLOR_ERROR)
SetSwitchAccLog($sNewProfile & " " & $sInGroups & "!", $COLOR_ERROR)
Return False
EndIf
Return True
Else
If $sInGroups Then
SetLog("Profile " & $sNewProfile & " active and " & $sInGroups & "!", $COLOR_ERROR)
SetSwitchAccLog($sNewProfile & " active & " & $sInGroups & "!", $COLOR_ERROR)
Else
SetLog("Profile " & $sNewProfile & " active in another bot instance!", $COLOR_ERROR)
SetSwitchAccLog($sNewProfile & " active!", $COLOR_ERROR)
EndIf
Return False
EndIf
EndFunc
Func CheckFarmSchedule()
If Not ProfileSwitchAccountEnabled() Then Return
Static $aiActionDone[8] = [0, 0, 0, 0, 0, 0, 0, 0]
Static $iStartHour = @HOUR
Static $iDay = @YDay
Local $bNeedSwitchAcc = False, $bNeedRunBot = False
If $g_bFirstStart And $iStartHour = -1 Then $iStartHour = @HOUR
Local $bActionDone = False
If $g_bDebugSetlog Then SetDebugLog("Checking Farm Schedule...", $COLOR_DEBUG)
For $i = 0 To 7
If $i > $g_iTotalAcc Then ExitLoop
If $iDay < @YDay Then
$aiActionDone[$i] = 0
$iStartHour = -1
If $i >= _Min($g_iTotalAcc, 7) Then $iDay = @YDay
If $g_bDebugSetlog Then SetDebugLog("New day is coming $iDay/ @YDay : " & $iDay & "/ " & @YDay, $COLOR_DEBUG)
EndIf
If $g_abChkSetFarm[$i] Then
Local $iAction = -1
Local $iTimer1 = 25, $iTimer2 = 25
If $g_aiCmbAction1[$i] >= 1 And $g_aiCmbCriteria1[$i] = 5 And $g_aiCmbTime1[$i] >= 0 Then $iTimer1 = Number($g_aiCmbTime1[$i])
If $g_aiCmbAction2[$i] >= 1 And $g_aiCmbCriteria2[$i] = 5 And $g_aiCmbTime2[$i] >= 0 Then $iTimer2 = Number($g_aiCmbTime2[$i])
If $g_bDebugSetlog Then SetDebugLog($i + 1 & ". $iTimer1: " & $iTimer1 & ", $iTimer2: " & $iTimer2 & ", Max: " & _Max($iTimer1, $iTimer2) & ", Min: " & _Min($iTimer1, $iTimer2) & ", ActionDone: " & $aiActionDone[$i], $COLOR_DEBUG)
If @HOUR < _Min($iTimer1, $iTimer2) Then
ElseIf @HOUR < _Max($iTimer1, $iTimer2) Then
If $iTimer1 < $iTimer2 Then
If $aiActionDone[$i] <> 1 And $iStartHour < $iTimer1 Then
$iAction = $g_aiCmbAction1[$i] - 1
$aiActionDone[$i] = 1
EndIf
Else
If $aiActionDone[$i] <> 2 And $iStartHour < $iTimer2 Then
$iAction = $g_aiCmbAction2[$i] - 1
$aiActionDone[$i] = 2
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog($i + 1 & ". @HOUR (<): " & @HOUR & ", ActionDone: " & $aiActionDone[$i] & ", StartHour: " &$iStartHour & ", Action: " & $iAction, $COLOR_DEBUG)
Else
If $iTimer1 < $iTimer2 Then
If $aiActionDone[$i] <> 2 And $iStartHour < $iTimer2 Then
$iAction = $g_aiCmbAction2[$i] - 1
$aiActionDone[$i] = 2
EndIf
Else
If $aiActionDone[$i] <> 1 And $iStartHour < $iTimer1 Then
$iAction = $g_aiCmbAction1[$i] - 1
$aiActionDone[$i] = 1
EndIf
EndIf
If $g_bDebugSetlog Then SetDebugLog($i + 1 & ". @HOUR (>): " & @HOUR & ", ActionDone: " & $aiActionDone[$i] & ", StartHour: " &$iStartHour & ", Action: " & $iAction, $COLOR_DEBUG)
EndIf
If $i = $g_iCurAccount Then
Local $asText[4] = ["Gold", "Elixir", "DarkE", "Trophy"]
While 1
If $g_aiCmbAction1[$i] >= 1 And $g_aiCmbCriteria1[$i] >= 1 And $g_aiCmbCriteria1[$i] <= 4 Then
For $r = 1 To 4
If $g_aiCmbCriteria1[$i] = $r And Number($g_aiCurrentLoot[$r - 1]) >= Number($g_aiTxtResource1[$i]) Then
SetLog("Village " & $asText[$r - 1] & " detected above 1st criterium: " & $g_aiTxtResource1[$i])
$iAction = $g_aiCmbAction1[$i] - 1
ExitLoop 2
EndIf
Next
EndIf
If $g_aiCmbAction2[$i] >= 1 And $g_aiCmbCriteria2[$i] >= 1 And $g_aiCmbCriteria2[$i] <= 4 Then
For $r = 1 To 4
If $g_aiCmbCriteria2[$i] = $r And Number($g_aiCurrentLoot[$r - 1]) < Number($g_aiTxtResource2[$i]) And Number($g_aiCurrentLoot[$r - 1]) > 1 Then
SetLog("Village " & $asText[$r - 1] & " detected below 2nd criterium: " & $g_aiTxtResource2[$i])
$iAction = $g_aiCmbAction2[$i] - 1
ExitLoop 2
EndIf
Next
EndIf
ExitLoop
WEnd
EndIf
Switch $iAction
Case 0
If GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED Then
Local $iSleeptime = CheckLastActiveAccount($i)
If $iSleeptime > 1 Then
SetLog("This is the last active/donate account to turn off.")
SetLog("Let's go sleep until another account is scheduled to turn active/donate")
SetSwitchAccLog("   Acc. " & $i + 1 & " go sleep", $COLOR_BLUE)
UniversalCloseWaitOpenCoC($iSleeptime * 60 * 1000, "FarmSchedule", False, True)
EndIf
GUICtrlSetState($g_ahChkAccount[$i], $GUI_UNCHECKED)
chkAccount($i)
$bActionDone = True
If $i = $g_iCurAccount Then $g_bInitiateSwitchAcc = True
SetLog("Acc [" & $i + 1 & "] turned OFF")
SetSwitchAccLog("   Acc. " & $i + 1 & " now Idle", $COLOR_BLUE)
EndIf
Case 1
If GUICtrlRead($g_ahChkDonate[$i]) = $GUI_UNCHECKED Then
_GUI_Value_STATE("CHECKED", $g_ahChkAccount[$i] & "#" & $g_ahChkDonate[$i])
$bActionDone = True
If $i = $g_iCurAccount Then $bNeedRunBot = True
SetLog("Acc [" & $i + 1 & "] turned ON for Donating")
SetSwitchAccLog("   Acc. " & $i + 1 & " now Donate", $COLOR_BLUE)
EndIf
Case 2
If GUICtrlRead($g_ahChkAccount[$i]) = $GUI_UNCHECKED Or GUICtrlRead($g_ahChkDonate[$i]) = $GUI_CHECKED Then
GUICtrlSetState($g_ahChkAccount[$i], $GUI_CHECKED)
GUICtrlSetState($g_ahChkDonate[$i], $GUI_UNCHECKED)
$bActionDone = True
If $i = $g_iCurAccount Then $bNeedRunBot = True
SetLog("Acc [" & $i + 1 & "] turned ON for Farming")
SetSwitchAccLog("   Acc. " & $i + 1 & " now Active", $COLOR_BLUE)
EndIf
EndSwitch
EndIf
Next
If $bActionDone Then
SaveConfig_600_35_2()
ReadConfig_600_35_2()
UpdateMultiStats(False)
EndIf
If _Sleep(500) Then Return
If $g_bInitiateSwitchAcc Then
Local $aActiveAccount = _ArrayFindAll($g_abAccountNo, True)
If UBound($aActiveAccount) >= 1 Then
$g_iNextAccount = $aActiveAccount[0]
If $g_sProfileCurrentName <> $g_asProfileName[$g_iNextAccount] Then
If $g_iGuiMode = 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbProfile, _GUICtrlComboBox_FindStringExact($g_hCmbProfile, $g_asProfileName[$g_iNextAccount]))
cmbProfile()
DisableGUI_AfterLoadNewProfile()
Else
saveConfig()
$g_sProfileCurrentName = $g_asProfileName[$g_iNextAccount]
LoadProfile(False)
EndIf
EndIf
runBot()
EndIf
ElseIf $bNeedRunBot Then
runBot()
EndIf
EndFunc
Func CheckLastActiveAccount($i)
Local $iSleeptime = 0
Local $aActiveAccount = _ArrayFindAll($g_abAccountNo, True)
If $i = $g_iCurAccount And UBound($aActiveAccount) <= 1 Then
SetLog("  This is the last active/donate account to turn off.")
Local $iCurrentTime = @HOUR + @MIN / 60 + @SEC / 3600
Local $iSoonestTimer = -1
For $i = 0 To 7
If $i > $g_iTotalAcc Then ExitLoop
If $g_abChkSetFarm[$i] Then
If $g_aiCmbAction1[$i] >= 1 And $g_aiCmbCriteria1[$i] = 5 And $g_aiCmbTime1[$i] >= 0 Then
Local $ConvertTime1 = $g_aiCmbTime1[$i] + $g_aiCmbTime1[$i] <= @HOUR ? 24 : 0
If $iSoonestTimer = -1 Or $iSoonestTimer > $ConvertTime1 Then $iSoonestTimer = $ConvertTime1
EndIf
If $g_aiCmbAction2[$i] >= 1 And $g_aiCmbCriteria2[$i] = 5 And $g_aiCmbTime2[$i] >= 0 Then
Local $ConvertTime2 = $g_aiCmbTime2[$i] + $g_aiCmbTime2[$i] <= @HOUR ? 24 : 0
If $iSoonestTimer = -1 Or $iSoonestTimer > $ConvertTime2 Then $iSoonestTimer = $ConvertTime2
EndIf
If $g_bDebugSetlog Then SetDebugLog("@Hour: " & @HOUR & "Timers " & $i + 1 & ": " & $g_aiCmbTime1[$i] & " / " & $g_aiCmbTime2[$i] & ". $iSoonestTimer = " & $iSoonestTimer)
EndIf
Next
If $g_bDebugSetlog Then SetDebugLog("$iSoonestTimer = " & $iSoonestTimer)
If $iSoonestTimer >= 0 Then $iSleeptime =($iSoonestTimer - $iCurrentTime) * 60
EndIf
If $g_bDebugSetlog Then SetDebugLog("$iSleeptime: " & Round($iSleeptime, 2) & " m")
Return $iSleeptime
EndFunc
Func ProfileSwitch()
For $i = 0 To 3
If $g_abChkSwitchMax[$i] Or $g_abChkSwitchMin[$i] Or $g_abChkBotTypeMax[$i] Or $g_abChkBotTypeMin[$i] Then
ExitLoop
Else
If $i = 3 Then Return
EndIf
Next
Local $iSwitchToProfile = -1, $iChangeBotType = -1
Local $asText[4] = ["Gold", "Elixir", "Dark Elixir", "Trophy"]
Local $bSwitchDone = False, $bChangBotTypeDone = False
For $i = 0 To 3
If $g_abChkSwitchMax[$i] Or $g_abChkBotTypeMax[$i] Then
If Number($g_aiCurrentLoot[$i]) >= Number($g_aiConditionMax[$i]) Then
SetLog("Village " & $asText[$i] & " detected above " & $asText[$i] & " Switch Condition: " & $g_aiCurrentLoot[$i] & "/" & $g_aiConditionMax[$i])
If $g_abChkSwitchMax[$i] Then $iSwitchToProfile = $g_aiCmbSwitchMax[$i]
If $g_abChkBotTypeMax[$i] Then $iChangeBotType = $g_aiCmbBotTypeMax[$i]
ExitLoop
EndIf
EndIf
If $g_abChkSwitchMin[$i] Or $g_abChkBotTypeMin[$i] Then
If Number($g_aiCurrentLoot[$i]) < Number($g_aiConditionMin[$i]) And Number($g_aiCurrentLoot[$i]) > 1 Then
SetLog("Village " & $asText[$i] & " detected below " & $asText[$i] & " Switch Condition: " & $g_aiCurrentLoot[$i] & "/" & $g_aiConditionMin[$i])
If $g_abChkSwitchMin[$i] Then $iSwitchToProfile = $g_aiCmbSwitchMin[$i]
If $g_abChkBotTypeMin[$i] Then $iChangeBotType = $g_aiCmbBotTypeMin[$i]
ExitLoop
EndIf
EndIf
Next
If $iSwitchToProfile >= 0 Or $iChangeBotType >= 0 Then
TrayTip(" Profile Switch Village Report!", "Gold: " & _NumberFormat($g_aiCurrentLoot[$eLootGold]) & "; Elixir: " & _NumberFormat($g_aiCurrentLoot[$eLootElixir]) & "; Dark Elixir: " & _NumberFormat($g_aiCurrentLoot[$eLootDarkElixir]) & "; Trophy: " & _NumberFormat($g_aiCurrentLoot[$eLootTrophy]), "", 0)
If $iSwitchToProfile >= 0 Then
If ProfileSwitchAccountEnabled() Then
If $iSwitchToProfile <> _GUICtrlComboBox_GetCurSel($g_ahCmbProfile[$g_iCurAccount]) Then
_GUICtrlComboBox_SetCurSel($g_ahCmbProfile[$g_iCurAccount], $iSwitchToProfile)
SetLog("Acc [" & $g_iCurAccount + 1 & "] is now matched with Profile: " & GUICtrlRead($g_ahCmbProfile[$g_iCurAccount]))
EndIf
EndIf
If $iSwitchToProfile <> _GUICtrlComboBox_GetCurSel($g_hCmbProfile) Then
_GUICtrlComboBox_SetCurSel($g_hCmbProfile, $iSwitchToProfile)
SetLog("Switched to Profile: " & GUICtrlRead($g_hCmbProfile))
$bSwitchDone = True
If ProfileSwitchAccountEnabled() Then $g_bReMatchAcc = True
EndIf
EndIf
If ProfileSwitchAccountEnabled() Then
Switch $iChangeBotType
Case 0
If GUICtrlRead($g_ahChkAccount[$g_iCurAccount]) = $GUI_CHECKED Then
GUICtrlSetState($g_ahChkAccount[$g_iCurAccount], $GUI_UNCHECKED)
chkAccount($g_iCurAccount)
SetLog("Acc [" & $g_iCurAccount + 1 & "] is now turned off")
$bChangBotTypeDone = True
EndIf
Case 1
If GUICtrlRead($g_ahChkDonate[$g_iCurAccount]) = $GUI_UNCHECKED Then
_GUI_Value_STATE("CHECKED", $g_ahChkAccount[$g_iCurAccount] & "#" & $g_ahChkDonate[$g_iCurAccount])
SetLog("Acc [" & $g_iCurAccount + 1 & "] is now for Donating only")
$bChangBotTypeDone = True
EndIf
Case 2
If GUICtrlRead($g_ahChkAccount[$g_iCurAccount]) = $GUI_UNCHECKED Or GUICtrlRead($g_ahChkDonate[$g_iCurAccount]) = $GUI_CHECKED Then
GUICtrlSetState($g_ahChkAccount[$g_iCurAccount], $GUI_CHECKED)
GUICtrlSetState($g_ahChkDonate[$g_iCurAccount], $GUI_UNCHECKED)
SetLog("Acc [" & $g_iCurAccount + 1 & "] starts Farming now")
$bChangBotTypeDone = True
EndIf
EndSwitch
If $bChangBotTypeDone Then $g_bInitiateSwitchAcc = True
EndIf
If _Sleep(500) Then Return
If $bSwitchDone Or $bChangBotTypeDone Then
If $bSwitchDone Then
cmbProfile()
DisableGUI_AfterLoadNewProfile()
Else
saveConfig()
readConfig()
UpdateMultiStats()
EndIf
runBot()
EndIf
EndIf
EndFunc
Func SwitchAccountVariablesReload($sType = "Load")
Local $aiZero[8] = [0, 0, 0, 0, 0, 0, 0, 0], $aiTrue[8] = [1, 1, 1, 1, 1, 1, 1, 1]
Local $aiZero83[8][3] = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
Local $aiZero84[8][4] = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
Local $aiZero86[8][6] = [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
Local $asEmpty[8] = ["", "", "", "", "", "", "", ""]
Static $aiFirstRun = $aiTrue
Static $aiSkippedVillageCount = $aiZero
Static $aiAttackedCount = $aiZero
Static $aiStatsTotalGain = $aiZero84, $aiStatsStartedWith = $aiZero84, $aiStatsLastAttack = $aiZero84, $aiStatsBonusLast = $aiZero84
Static $aiNbrOfOoS = $aiZero
Static $aiDroppedTrophyCount = $aiZero
Static $aiSearchCost = $aiZero, $aiTrainCostElixir = $aiZero, $aiTrainCostDElixir = $aiZero, $aiTrainCostGold = $aiZero
Static $aiGoldFromMines = $aiZero, $aiElixirFromCollectors = $aiZero, $aiDElixirFromDrills = $aiZero
Static $aiCostGoldWall = $aiZero, $aiCostElixirWall = $aiZero, $aiCostGoldBuilding = $aiZero, $aiCostElixirBuilding = $aiZero, $aiCostDElixirHero = $aiZero
Static $aiNbrOfWallsUppedGold = $aiZero, $aiNbrOfWallsUppedElixir = $aiZero, $aiNbrOfBuildingsUppedGold = $aiZero, $aiNbrOfBuildingsUppedElixir = $aiZero, $aiNbrOfHeroesUpped = $aiZero
Static $aiNbrOfWallsUpped = $aiZero
Static $aiAttackedVillageCount = $aiZero86
Static $aiTotalGoldGain = $aiZero86, $aiTotalElixirGain = $aiZero86, $aiTotalDarkGain = $aiZero86, $aiTotalTrophyGain = $aiZero86
Static $aiNbrOfDetectedMines = $aiZero86, $aiNbrOfDetectedCollectors = $aiZero86, $aiNbrOfDetectedDrills = $aiZero86
Static $aiSmartZapGain = $aiZero, $aiNumEQSpellsUsed = $aiZero, $aiNumLSpellsUsed = $aiZero
Static $asNextBuilderReadyTime = $asEmpty
Static $aiFreeBuilderCount = $aiZero, $aiTotalBuilderCount = $aiZero
Static $asLabUpgradeTime = $asEmpty, $aiLabStatus = $aiZero, $aiLabElixirCost = $aiZero, $aiLabDElixirCost = $aiZero
Static $asStarLabUpgradeTime = $asEmpty
Static $aiHeroAvailable = $aiZero
Static $aiHeroUpgradingBit = $aiZero
Static $aiHeroUpgrading = $aiZero83
Switch $sType
Case "Reset"
$aiFirstRun = $aiTrue
$g_asTrainTimeFinish = $asEmpty
For $i = 0 To $g_iTotalAcc
GUICtrlSetData($g_ahLblTroopTime[$i], "")
Next
$g_ahTimerSinceSwitched = $aiZero
$g_ahTimerSinceSwitched[$g_iCurAccount] = $g_hTimerSinceStarted
$aiSkippedVillageCount = $aiZero
$aiAttackedCount = $aiZero
$aiStatsTotalGain = $aiZero84
$aiStatsStartedWith = $aiZero84
$aiStatsLastAttack = $aiZero84
$aiStatsBonusLast = $aiZero84
$aiNbrOfOoS = $aiZero
$aiDroppedTrophyCount = $aiZero
$aiSearchCost = $aiZero
$aiTrainCostElixir = $aiZero
$aiTrainCostDElixir = $aiZero
$aiTrainCostGold = $aiZero
$aiGoldFromMines = $aiZero
$aiElixirFromCollectors = $aiZero
$aiDElixirFromDrills = $aiZero
$aiCostGoldWall = $aiZero
$aiCostElixirWall = $aiZero
$aiCostGoldBuilding = $aiZero
$aiCostElixirBuilding = $aiZero
$aiCostDElixirHero = $aiZero
$aiNbrOfWallsUppedGold = $aiZero
$aiNbrOfWallsUppedElixir = $aiZero
$aiNbrOfBuildingsUppedGold = $aiZero
$aiNbrOfBuildingsUppedElixir = $aiZero
$aiNbrOfHeroesUpped = $aiZero
$aiNbrOfWallsUpped = $aiZero
$aiAttackedVillageCount = $aiZero86
$aiTotalGoldGain = $aiZero86
$aiTotalElixirGain = $aiZero86
$aiTotalDarkGain = $aiZero86
$aiTotalTrophyGain = $aiZero86
$aiNbrOfDetectedMines = $aiZero86
$aiNbrOfDetectedCollectors = $aiZero86
$aiNbrOfDetectedDrills = $aiZero86
$aiSmartZapGain = $aiZero
$aiNumEQSpellsUsed = $aiZero
$aiNumLSpellsUsed = $aiZero
$asNextBuilderReadyTime = $asEmpty
$aiFreeBuilderCount = $aiZero
$aiTotalBuilderCount = $aiZero
$asLabUpgradeTime = $asEmpty
$aiLabElixirCost = $aiZero
$aiLabDElixirCost = $aiZero
$aiLabStatus = $aiZero
$asStarLabUpgradeTime = $asEmpty
$aiHeroAvailable = $aiZero
$aiHeroUpgradingBit = $aiZero
$aiHeroUpgrading = $aiZero83
Case "Save"
$aiFirstRun[$g_iCurAccount] = $g_iFirstRun
$aiSkippedVillageCount[$g_iCurAccount] = $g_iSkippedVillageCount
$aiAttackedCount[$g_iCurAccount] = $g_aiAttackedCount
For $i = 0 To 3
$aiStatsTotalGain[$g_iCurAccount][$i] = $g_iStatsTotalGain[$i]
$aiStatsStartedWith[$g_iCurAccount][$i] = $g_iStatsStartedWith[$i]
$aiStatsLastAttack[$g_iCurAccount][$i] = $g_iStatsLastAttack[$i]
$aiStatsBonusLast[$g_iCurAccount][$i] = $g_iStatsBonusLast[$i]
Next
$aiNbrOfOoS[$g_iCurAccount] = $g_iNbrOfOoS
$aiDroppedTrophyCount[$g_iCurAccount] = $g_iDroppedTrophyCount
$aiSearchCost[$g_iCurAccount] = $g_iSearchCost
$aiTrainCostElixir[$g_iCurAccount] = $g_iTrainCostElixir
$aiTrainCostDElixir[$g_iCurAccount] = $g_iTrainCostDElixir
$aiTrainCostGold[$g_iCurAccount] = $g_iTrainCostGold
$aiGoldFromMines[$g_iCurAccount] = $g_iGoldFromMines
$aiElixirFromCollectors[$g_iCurAccount] = $g_iElixirFromCollectors
$aiDElixirFromDrills[$g_iCurAccount] = $g_iDElixirFromDrills
$aiCostGoldWall[$g_iCurAccount] = $g_iCostGoldWall
$aiCostElixirWall[$g_iCurAccount] = $g_iCostElixirWall
$aiCostGoldBuilding[$g_iCurAccount] = $g_iCostGoldBuilding
$aiCostElixirBuilding[$g_iCurAccount] = $g_iCostElixirBuilding
$aiCostDElixirHero[$g_iCurAccount] = $g_iCostDElixirHero
$aiNbrOfWallsUppedGold[$g_iCurAccount] = $g_iNbrOfWallsUppedGold
$aiNbrOfWallsUppedElixir[$g_iCurAccount] = $g_iNbrOfWallsUppedElixir
$aiNbrOfBuildingsUppedGold[$g_iCurAccount] = $g_iNbrOfBuildingsUppedGold
$aiNbrOfBuildingsUppedElixir[$g_iCurAccount] = $g_iNbrOfBuildingsUppedElixir
$aiNbrOfHeroesUpped[$g_iCurAccount] = $g_iNbrOfHeroesUpped
$aiNbrOfWallsUpped[$g_iCurAccount] = $g_iNbrOfWallsUpped
For $i = 0 To 5
$aiAttackedVillageCount[$g_iCurAccount][$i] = $g_aiAttackedVillageCount[$i]
$aiTotalGoldGain[$g_iCurAccount][$i] = $g_aiTotalGoldGain[$i]
$aiTotalElixirGain[$g_iCurAccount][$i] = $g_aiTotalElixirGain[$i]
$aiTotalDarkGain[$g_iCurAccount][$i] = $g_aiTotalDarkGain[$i]
$aiTotalTrophyGain[$g_iCurAccount][$i] = $g_aiTotalTrophyGain[$i]
$aiNbrOfDetectedMines[$g_iCurAccount][$i] = $g_aiNbrOfDetectedMines[$i]
$aiNbrOfDetectedCollectors[$g_iCurAccount][$i] = $g_aiNbrOfDetectedCollectors[$i]
$aiNbrOfDetectedDrills[$g_iCurAccount][$i] = $g_aiNbrOfDetectedDrills[$i]
Next
$aiSmartZapGain[$g_iCurAccount] = $g_iSmartZapGain
$aiNumEQSpellsUsed[$g_iCurAccount] = $g_iNumEQSpellsUsed
$aiNumLSpellsUsed[$g_iCurAccount] = $g_iNumLSpellsUsed
$asNextBuilderReadyTime[$g_iCurAccount] = $g_sNextBuilderReadyTime
$aiFreeBuilderCount[$g_iCurAccount] = $g_iFreeBuilderCount
$aiTotalBuilderCount[$g_iCurAccount] = $g_iTotalBuilderCount
$asLabUpgradeTime[$g_iCurAccount] = $g_sLabUpgradeTime
$aiLabElixirCost[$g_iCurAccount] = $g_iLaboratoryElixirCost
$aiLabDElixirCost[$g_iCurAccount] = $g_iLaboratoryDElixirCost
If GUICtrlGetState($g_hPicLabGreen) = $GUI_ENABLE + $GUI_SHOW Then
$aiLabStatus[$g_iCurAccount] = 1
ElseIf GUICtrlGetState($g_hPicLabRed) = $GUI_ENABLE + $GUI_SHOW Then
$aiLabStatus[$g_iCurAccount] = 2
Else
$aiLabStatus[$g_iCurAccount] = 0
EndIf
$asStarLabUpgradeTime[$g_iCurAccount] = $g_sStarLabUpgradeTime
$aiHeroAvailable[$g_iCurAccount] = $g_iHeroAvailable
$aiHeroUpgradingBit[$g_iCurAccount] = $g_iHeroUpgradingBit
For $i = 0 To 2
$aiHeroUpgrading[$g_iCurAccount][$i] = $g_iHeroUpgrading[$i]
Next
Case "Load"
$g_iFirstRun = $aiFirstRun[$g_iCurAccount]
$g_iSkippedVillageCount = $aiSkippedVillageCount[$g_iCurAccount]
$g_aiAttackedCount = $aiAttackedCount[$g_iCurAccount]
For $i = 0 To 3
$g_iStatsTotalGain[$i] = $aiStatsTotalGain[$g_iCurAccount][$i]
$g_iStatsStartedWith[$i] = $aiStatsStartedWith[$g_iCurAccount][$i]
$g_iStatsLastAttack[$i] = $aiStatsLastAttack[$g_iCurAccount][$i]
$g_iStatsBonusLast[$i] = $aiStatsBonusLast[$g_iCurAccount][$i]
Next
$g_iNbrOfOoS = $aiNbrOfOoS[$g_iCurAccount]
$g_iDroppedTrophyCount = $aiDroppedTrophyCount[$g_iCurAccount]
$g_iSearchCost = $aiSearchCost[$g_iCurAccount]
$g_iTrainCostElixir = $aiTrainCostElixir[$g_iCurAccount]
$g_iTrainCostDElixir = $aiTrainCostDElixir[$g_iCurAccount]
$g_iTrainCostGold = $aiTrainCostGold[$g_iCurAccount]
$g_iGoldFromMines = $aiGoldFromMines[$g_iCurAccount]
$g_iElixirFromCollectors = $aiElixirFromCollectors[$g_iCurAccount]
$g_iDElixirFromDrills = $aiDElixirFromDrills[$g_iCurAccount]
$g_iCostGoldWall = $aiCostGoldWall[$g_iCurAccount]
$g_iCostElixirWall = $aiCostElixirWall[$g_iCurAccount]
$g_iCostGoldBuilding = $aiCostGoldBuilding[$g_iCurAccount]
$g_iCostElixirBuilding = $aiCostElixirBuilding[$g_iCurAccount]
$g_iCostDElixirHero = $aiCostDElixirHero[$g_iCurAccount]
$g_iNbrOfWallsUppedGold = $aiNbrOfWallsUppedGold[$g_iCurAccount]
$g_iNbrOfWallsUppedElixir = $aiNbrOfWallsUppedElixir[$g_iCurAccount]
$g_iNbrOfBuildingsUppedGold = $aiNbrOfBuildingsUppedGold[$g_iCurAccount]
$g_iNbrOfBuildingsUppedElixir = $aiNbrOfBuildingsUppedElixir[$g_iCurAccount]
$g_iNbrOfHeroesUpped = $aiNbrOfHeroesUpped[$g_iCurAccount]
$g_iNbrOfWallsUpped = $aiNbrOfWallsUpped[$g_iCurAccount]
For $i = 0 To 5
$g_aiAttackedVillageCount[$i] = $aiAttackedVillageCount[$g_iCurAccount][$i]
$g_aiTotalGoldGain[$i] = $aiTotalGoldGain[$g_iCurAccount][$i]
$g_aiTotalElixirGain[$i] = $aiTotalElixirGain[$g_iCurAccount][$i]
$g_aiTotalDarkGain[$i] = $aiTotalDarkGain[$g_iCurAccount][$i]
$g_aiTotalTrophyGain[$i] = $aiTotalTrophyGain[$g_iCurAccount][$i]
$g_aiNbrOfDetectedMines[$i] = $aiNbrOfDetectedMines[$g_iCurAccount][$i]
$g_aiNbrOfDetectedCollectors[$i] = $aiNbrOfDetectedCollectors[$g_iCurAccount][$i]
$g_aiNbrOfDetectedDrills[$i] = $aiNbrOfDetectedDrills[$g_iCurAccount][$i]
Next
$g_iSmartZapGain = $aiSmartZapGain[$g_iCurAccount]
$g_iNumEQSpellsUsed = $aiNumEQSpellsUsed[$g_iCurAccount]
$g_iNumLSpellsUsed = $aiNumLSpellsUsed[$g_iCurAccount]
$g_sNextBuilderReadyTime = $asNextBuilderReadyTime[$g_iCurAccount]
$g_iFreeBuilderCount = $aiFreeBuilderCount[$g_iCurAccount]
$g_iTotalBuilderCount = $aiTotalBuilderCount[$g_iCurAccount]
$g_sLabUpgradeTime = $asLabUpgradeTime[$g_iCurAccount]
GUICtrlSetData($g_hLbLLabTime, "00:00:00")
$g_iLaboratoryElixirCost = $aiLabElixirCost[$g_iCurAccount]
$g_iLaboratoryDElixirCost = $aiLabDElixirCost[$g_iCurAccount]
Local $Counter = 0
For $i = $g_hPicLabGray To $g_hPicLabRed
GUICtrlSetState($i, $GUI_HIDE)
If $aiLabStatus[$g_iCurAccount] = $Counter Then GUICtrlSetState($i, $GUI_SHOW)
$Counter += 1
Next
$g_sStarLabUpgradeTime = $asStarLabUpgradeTime[$g_iCurAccount]
$g_iHeroAvailable = $aiHeroAvailable[$g_iCurAccount]
$g_iHeroUpgradingBit = $aiHeroUpgradingBit[$g_iCurAccount]
For $i = 0 To 2
$g_iHeroUpgrading[$i] = $aiHeroUpgrading[$g_iCurAccount][$i]
Next
ResetVariables("donated")
$g_aiAttackedCountSwitch[$g_iCurAccount] = $aiAttackedCount[$g_iCurAccount]
$g_hLogFile = 0
Case "UpdateStats"
For $i = 0 To 3
GUICtrlSetData($g_ahLblStatsStartedWith[$i], _NumberFormat($g_iStatsStartedWith[$i], True))
$aiStatsTotalGain[$g_iCurAccount][$i] = $g_iStatsTotalGain[$i]
Next
For $i = 0 To $g_iTotalAcc
GUICtrlSetData($g_ahLblHourlyStatsGoldAcc[$i], _NumberFormat(Round($aiStatsTotalGain[$i][$eLootGold] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_ahLblHourlyStatsElixirAcc[$i], _NumberFormat(Round($aiStatsTotalGain[$i][$eLootElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_ahLblHourlyStatsDarkAcc[$i], _NumberFormat(Round($aiStatsTotalGain[$i][$eLootDarkElixir] /(Int(__TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
Next
Case "SetTime"
Static $DisplayLoop = 1
Local $day = 0, $hour = 0, $min = 0, $sec = 0
_TicksToTime(Int(__TimerDiff($g_ahTimerSinceSwitched[$g_iCurAccount]) + $g_aiRunTime[$g_iCurAccount]), $hour, $min, $sec)
GUICtrlSetData($g_ahLblResultRuntimeNowAcc[$g_iCurAccount], StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
For $i = 0 To $g_iTotalAcc
If _DateIsValid($g_asTrainTimeFinish[$i]) Then
Local $iTime = _DateDiff("s", _NowCalc(), $g_asTrainTimeFinish[$i]) * 1000
_TicksToTime(Abs($iTime), $hour, $min, $sec)
GUICtrlSetData($g_ahLblTroopTime[$i],($iTime < 0 ? "-" : "") & StringFormat("%02i:%02i", $min, $sec))
Local $SetColor = $COLOR_BLACK
If $i = $g_iCurAccount Then
$SetColor = $COLOR_GREEN
ElseIf $iTime < 0 Then
$SetColor = $COLOR_RED
EndIf
GUICtrlSetColor($g_ahLblTroopTime[$i], $SetColor)
EndIf
If IsInt($DisplayLoop / 5) Then
If _DateIsValid($asNextBuilderReadyTime[$i]) Then
_TicksToDay(Int(_DateDiff("s", _NowCalc(), $asNextBuilderReadyTime[$i]) * 1000), $day, $hour, $min, $sec)
Local $sBuilderTime = $day > 0 ? StringFormat("%2ud %02i:%02i", $day, $hour, $min, $sec) :($hour > 0 ? StringFormat("%02i:%02i:%02i", $hour, $min, $sec) : StringFormat("%02i:%02i", $min, $sec))
If Not IsInt($DisplayLoop / 10) Then
GUICtrlSetData($g_ahLblResultBuilderNowAcc[$i], $aiFreeBuilderCount[$i] & "/" & $aiTotalBuilderCount[$i])
GUICtrlSetColor($g_ahLblResultBuilderNowAcc[$i], $COLOR_BLACK)
Else
GUICtrlSetData($g_ahLblResultBuilderNowAcc[$i], $sBuilderTime)
GUICtrlSetColor($g_ahLblResultBuilderNowAcc[$i], $aiFreeBuilderCount[$i] > 0 ? $COLOR_GREEN : $COLOR_BLACK)
EndIf
EndIf
EndIf
If _DateIsValid($asLabUpgradeTime[$i]) Then
Local $iLabTime = _DateDiff("s", _NowCalc(), $asLabUpgradeTime[$i]) * 1000
If $iLabTime > 0 Then
_TicksToDay($iLabTime, $day, $hour, $min, $sec)
GUICtrlSetData($g_hLblLabTimeStatus[$i], $day > 0 ? StringFormat("%2ud %02i:%02i:%02i", $day, $hour, $min, $sec) :($hour > 0 ? StringFormat("%02i:%02i:%02i", $hour, $min, $sec) : StringFormat("%02i:%02i", $min, $sec)))
Local $SetColor = $COLOR_BLACK
If $i = $g_iCurAccount Then $SetColor = $COLOR_GREEN
GUICtrlSetColor($g_hLblLabTimeStatus[$i], $day > 0 ? $SetColor : $COLOR_ORANGE)
Else
GUICtrlSetData($g_hLblLabTimeStatus[$i], "00:00:00")
$asLabUpgradeTime[$i] = ""
EndIf
Else
GUICtrlSetData($g_hLblLabTimeStatus[$i], "00:00:00")
EndIf
Next
$DisplayLoop += 1
If $DisplayLoop > 10 Then $DisplayLoop = 1
EndSwitch
EndFunc
Func _ClanGames($test = False)
If Not $g_bChkClanGamesEnabled Then Return
Local $sINIPath = StringReplace($g_sProfileConfigPath, "config.ini", "ClanGames_config.ini")
If Not FileExists($sINIPath) Then ClanGamesChallenges("", True, $sINIPath, $g_bChkClanGamesDebug)
ClickP($aAway, 1, 0, "#0000")
SetLog("Entering Clan Games...", $COLOR_INFO)
If _Sleep(500) Then Return
Local $TabChallengesPosition[2] = [820, 130]
Local $sTimeRemain = "", $sEventName = "", $getCapture = True
Local Static $YourAccScore[8][2] = [[-1, True], [-1, True], [-1, True], [-1, True], [-1, True], [-1, True], [-1, True], [-1, True]]
If isProblemAffect(True) Then checkMainScreen(False)
Local $hTimer = TimerInit()
If Not IsClanGamesWindow() Then Return
If $g_bChkClanGamesDebug Then Setlog("_ClanGames IsClanGamesWindow (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
$hTimer = TimerInit()
Local $ScoreLimits = GetTimesAndScores()
If $ScoreLimits = -1 Or UBound($ScoreLimits) <> 2 Then Return
If $g_bChkClanGamesDebug Then Setlog("_ClanGames GetTimesAndScores (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
$hTimer = TimerInit()
If _Sleep(1500) Then Return
SetLog("Your Score is: " & Int($ScoreLimits[0]), $COLOR_INFO)
If Int($ScoreLimits[0]) = Int($ScoreLimits[1]) Then
SetLog("Your Score limit was reached, Congrats...")
ClickP($aAway, 1, 0, "#0000")
Return
ElseIf Int($ScoreLimits[0]) + 200 > Int($ScoreLimits[1]) Then
SetLog("Your Score limit is almost reached...")
If $g_bChkClanGamesStopBeforeReachAndPurge Then
If CooldownTime() Then Return
If IsEventRunning() Then Return
SetLog("Stop before completing your limit and only Purge")
$sEventName = "Builder Base Challenges to Purge"
If PurgeEvent($g_sImgPurge, $sEventName, True) Then $g_iPurgeJobCount[$g_iCurAccount] += 1
ClickP($aAway, 1, 0, "#0000")
Return
EndIf
EndIf
If $YourAccScore[$g_iCurAccount][0] = -1 Then $YourAccScore[$g_iCurAccount][0] = $ScoreLimits[0]
If CooldownTime() Then Return
If $g_bChkClanGamesDebug Then Setlog("_ClanGames CooldownTime (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
$hTimer = TimerInit()
If $g_bRunState = False Then Return
If IsEventRunning() Then Return
If $g_bChkClanGamesDebug Then Setlog("_ClanGames IsEventRunning (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
$hTimer = TimerInit()
If $g_bRunState = False Then Return
If $g_bChkClanGamesDebug Then SetLog("Your TownHall Level is " & $g_iTownHallLevel)
If isProblemAffect(True) Then checkMainScreen(False)
Local $FullArea = "300,155,765,550"
Local $pathImages = @ScriptDir & "\imgxml\Resources\ClanGamesImages\Challenges"
Local $pathTemp = @TempDir & "\" & $g_sProfileCurrentName & "\Challenges\"
If $g_bChkClanGamesLoot Then FileCopy($pathImages & "\L-*.xml", $pathTemp, $FC_OVERWRITE + $FC_CREATEPATH)
If $g_bChkClanGamesAirTroop Then FileCopy($pathImages & "\A-*.xml", $pathTemp, $FC_OVERWRITE + $FC_CREATEPATH)
If $g_bChkClanGamesGroundTroop Then FileCopy($pathImages & "\G-*.xml", $pathTemp, $FC_OVERWRITE + $FC_CREATEPATH)
If $g_bChkClanGamesBattle Then FileCopy($pathImages & "\B-*.xml", $pathTemp, $FC_OVERWRITE + $FC_CREATEPATH)
If $g_bChkClanGamesDestruction Then FileCopy($pathImages & "\D-*.xml", $pathTemp, $FC_OVERWRITE + $FC_CREATEPATH)
If $g_bChkClanGamesMiscellaneous Then FileCopy($pathImages & "\M-*.xml", $pathTemp, $FC_OVERWRITE + $FC_CREATEPATH)
Local $HowManyImages = _FileListToArray($pathTemp, "*", $FLTA_FILES)
If IsArray($HowManyImages) Then
Setlog($HowManyImages[0] & " Events to search...")
Else
Setlog("ClanGames-Error on $HowManyImages: " & @error)
EndIf
Local $aAllDetectionsOnScreen[0][4]
Local $sClanGamesWindow = GetDiamondFromRect($FullArea)
Local $aCurrentDetection = findMultiple($pathTemp, $sClanGamesWindow, $sClanGamesWindow, 0, 1000, 0, "objectname,objectpoints", True)
Local $aEachDetection
If $g_bChkClanGamesDebug Then Setlog("_ClanGames findMultiple (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
$hTimer = TimerInit()
If UBound($aCurrentDetection) > 0 Then
Local $FullImageName, $StringCoordinates, $sString, $tempObbj, $tempObbjs, $aNames
For $i = 0 To UBound($aCurrentDetection) - 1
If _Sleep(50) Then Return
If Not $g_bRunState Then Return
$aEachDetection = $aCurrentDetection[$i]
SetDebugLog(_ArrayToString($aEachDetection))
$FullImageName = String($aEachDetection[0])
$StringCoordinates = $aEachDetection[1]
If $FullImageName = "" Or $StringCoordinates = "" Then ContinueLoop
If StringInStr($StringCoordinates, "|") Then
$StringCoordinates = StringReplace($StringCoordinates, "||", "|")
$sString = StringRight($StringCoordinates, 1)
If $sString = "|" Then $StringCoordinates = StringTrimRight($StringCoordinates, 1)
$tempObbjs = StringSplit($StringCoordinates, "|", $STR_NOCOUNT)
$tempObbj = StringSplit($tempObbjs[0], ",", $STR_NOCOUNT)
If UBound($tempObbj) <> 2 Then ContinueLoop
Else
$tempObbj = StringSplit($StringCoordinates, ",", $STR_NOCOUNT)
If UBound($tempObbj) <> 2 Then ContinueLoop
EndIf
$aNames = StringSplit($FullImageName, "-", $STR_NOCOUNT)
ReDim $aAllDetectionsOnScreen[UBound($aAllDetectionsOnScreen) + 1][4]
$aAllDetectionsOnScreen[UBound($aAllDetectionsOnScreen) - 1][0] = $aNames[0]
$aAllDetectionsOnScreen[UBound($aAllDetectionsOnScreen) - 1][1] = $aNames[1]
$aAllDetectionsOnScreen[UBound($aAllDetectionsOnScreen) - 1][2] = $tempObbj[0]
$aAllDetectionsOnScreen[UBound($aAllDetectionsOnScreen) - 1][3] = $tempObbj[1]
Next
EndIf
Local $aSelectChallenges[0][5]
If UBound($aAllDetectionsOnScreen) > 0 Then
For $i = 0 To UBound($aAllDetectionsOnScreen) - 1
If IsBBChallenge($aAllDetectionsOnScreen[$i][2], $aAllDetectionsOnScreen[$i][3]) Then ContinueLoop
Switch $aAllDetectionsOnScreen[$i][0]
Case "L"
If Not $g_bChkClanGamesLoot Then ContinueLoop
Local $LootChallenges = ClanGamesChallenges("$LootChallenges", False, $sINIPath, $g_bChkClanGamesDebug)
For $j = 0 To UBound($LootChallenges) - 1
If $aAllDetectionsOnScreen[$i][1] = $LootChallenges[$j][0] Then
If $g_iTownHallLevel < $LootChallenges[$j][2] Then ExitLoop
If $LootChallenges[$j][3] = 0 Then ExitLoop
Local $aArray = [$LootChallenges[$j][1], $aAllDetectionsOnScreen[$i][2], $aAllDetectionsOnScreen[$i][3], $LootChallenges[$j][3]]
EndIf
Next
Case "A"
If Not $g_bChkClanGamesAirTroop Then ContinueLoop
Local $AirTroopChallenges = ClanGamesChallenges("$AirTroopChallenges", False, $sINIPath, $g_bChkClanGamesDebug)
For $j = 0 To UBound($AirTroopChallenges) - 1
If $aAllDetectionsOnScreen[$i][1] = $AirTroopChallenges[$j][0] Then
Local $TroopIndex = Int(Eval("eTroop" & $AirTroopChallenges[$j][1]))
If $g_aiCurrentTroops[$TroopIndex] < 1 Then
If $g_bChkClanGamesDebug Then SetLog("[" & $AirTroopChallenges[$j][1] & "] No " & $g_asTroopNames[$TroopIndex] & " on your army composition.")
ExitLoop
ElseIf $g_aiCurrentTroops[$TroopIndex] > 0 And $g_aiCurrentTroops[$TroopIndex] < $AirTroopChallenges[$j][3] Then
If $g_bChkClanGamesDebug Then SetLog("[" & $AirTroopChallenges[$j][1] & "] You need more " & $g_asTroopNames[$TroopIndex] & " [" & $g_aiCurrentTroops[$TroopIndex] & "/" & $AirTroopChallenges[$j][3] & "]")
ExitLoop
EndIf
Local $aArray[4] = [$AirTroopChallenges[$j][1], $aAllDetectionsOnScreen[$i][2], $aAllDetectionsOnScreen[$i][3], 1]
EndIf
Next
Case "G"
If Not $g_bChkClanGamesGroundTroop Then ContinueLoop
Local $GroundTroopChallenges = ClanGamesChallenges("$GroundTroopChallenges", False, $sINIPath, $g_bChkClanGamesDebug)
For $j = 0 To UBound($GroundTroopChallenges) - 1
If $aAllDetectionsOnScreen[$i][1] = $GroundTroopChallenges[$j][0] Then
Local $TroopIndex = Int(Eval("eTroop" & $GroundTroopChallenges[$j][1]))
If $g_aiCurrentTroops[$TroopIndex] < 1 Then
If $g_bChkClanGamesDebug Then SetLog("[" & $GroundTroopChallenges[$j][1] & "] No " & $g_asTroopNames[$TroopIndex] & " on your army composition.")
ExitLoop
ElseIf $g_aiCurrentTroops[$TroopIndex] > 0 And $g_aiCurrentTroops[$TroopIndex] < $GroundTroopChallenges[$j][3] Then
If $g_bChkClanGamesDebug Then SetLog("[" & $GroundTroopChallenges[$j][1] & "] You need more " & $g_asTroopNames[$TroopIndex] & " [" & $g_aiCurrentTroops[$TroopIndex] & "/" & $GroundTroopChallenges[$j][3] & "]")
ExitLoop
EndIf
Local $aArray[4] = [$GroundTroopChallenges[$j][1], $aAllDetectionsOnScreen[$i][2], $aAllDetectionsOnScreen[$i][3], 1]
EndIf
Next
Case "B"
If Not $g_bChkClanGamesBattle Then ContinueLoop
Local $BattleChallenges = ClanGamesChallenges("$BattleChallenges", False, $sINIPath, $g_bChkClanGamesDebug)
For $j = 0 To UBound($BattleChallenges) - 1
If $aAllDetectionsOnScreen[$i][1] = $BattleChallenges[$j][0] Then
If $BattleChallenges[$j][1] = "Scrappy 6s" And($g_iTownHallLevel < 5 Or $g_iTownHallLevel > 7) Then ExitLoop
If $BattleChallenges[$j][1] = "Super 7s" And($g_iTownHallLevel < 6 Or $g_iTownHallLevel > 8) Then ExitLoop
If $BattleChallenges[$j][1] = "Exciting 8s" And($g_iTownHallLevel < 7 Or $g_iTownHallLevel > 9) Then ExitLoop
If $BattleChallenges[$j][1] = "Noble 9s" And($g_iTownHallLevel < 8 Or $g_iTownHallLevel > 10) Then ExitLoop
If $BattleChallenges[$j][1] = "Terrific 10s" And($g_iTownHallLevel < 9 Or $g_iTownHallLevel > 11) Then ExitLoop
If $BattleChallenges[$j][1] = "Exotic 11s" And $g_iTownHallLevel < 10 Then ExitLoop
If $BattleChallenges[$j][1] = "Triumphant 12s" And $g_iTownHallLevel < 11 Then ExitLoop
If $g_iTownHallLevel < $BattleChallenges[$j][2] Then ExitLoop
If $BattleChallenges[$j][3] = 0 Then ExitLoop
If $BattleChallenges[$j][1] = "Attack Up" And $g_iTownHallLevel >= 12 Then ExitLoop
If $BattleChallenges[$j][1] = "Slaying The Titans" And Int($g_aiCurrentLoot[$eLootTrophy]) < 4100 Then ExitLoop
If $BattleChallenges[$j][1] = "No-Magic Zone" And(($g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 1) Or($g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 1)) Then ExitLoop
If $BattleChallenges[$j][1] = "No Heroics Allowed" And((Int($g_aiAttackUseHeroes[$DB]) > $eHeroNone And $g_iMatchMode = $DB) Or(Int($g_aiAttackUseHeroes[$LB]) > $eHeroNone And $g_iMatchMode = $LB)) Then ExitLoop
Local $aArray[4] = [$BattleChallenges[$j][1], $aAllDetectionsOnScreen[$i][2], $aAllDetectionsOnScreen[$i][3], $BattleChallenges[$j][3]]
EndIf
Next
Case "D"
If Not $g_bChkClanGamesDestruction Then ContinueLoop
Local $DestructionChallenges = ClanGamesChallenges("$DestructionChallenges", False, $sINIPath, $g_bChkClanGamesDebug)
For $j = 0 To UBound($DestructionChallenges) - 1
If $aAllDetectionsOnScreen[$i][1] = $DestructionChallenges[$j][0] Then
If $g_iTownHallLevel < $DestructionChallenges[$j][2] Then ExitLoop
If $DestructionChallenges[$j][3] = 0 Then ExitLoop
If $DestructionChallenges[$j][1] = "Hero Level Hunter" Or $DestructionChallenges[$j][1] = "King Level Hunter" Or $DestructionChallenges[$j][1] = "Queen Level Hunter" Or $DestructionChallenges[$j][1] = "Warden Level Hunter" And((Int($g_aiAttackUseHeroes[$DB]) = $eHeroNone And $g_iMatchMode = $DB) Or(Int($g_aiAttackUseHeroes[$LB]) = $eHeroNone And $g_iMatchMode = $LB)) Then ExitLoop
Local $aArray[4] = [$DestructionChallenges[$j][1], $aAllDetectionsOnScreen[$i][2], $aAllDetectionsOnScreen[$i][3], $DestructionChallenges[$j][3]]
EndIf
Next
Case "M"
If Not $g_bChkClanGamesMiscellaneous Then ContinueLoop
Local $MiscChallenges = ClanGamesChallenges("$MiscChallenges", False, $sINIPath, $g_bChkClanGamesDebug)
For $j = 0 To UBound($MiscChallenges) - 1
If $aAllDetectionsOnScreen[$i][1] = $MiscChallenges[$j][0] Then
If $MiscChallenges[$j][3] = 0 Then ExitLoop
If $MiscChallenges[$j][1] = "Gardening Exercise" And($g_iFreeBuilderCount < 1 Or Not $g_bChkCleanYard) Then ExitLoop
If $g_iTownHallLevel < $MiscChallenges[$j][2] Then ExitLoop
If $MiscChallenges[$j][1] = "Helping Hand" And Not $g_iActiveDonate Then ExitLoop
If $MiscChallenges[$j][1] = "Donate Spells" And($g_aiPrepDon[2] = 0 And $g_aiPrepDon[3] = 0) Then ExitLoop
If $MiscChallenges[$j][1] = "Battle Blimp" And($g_aiAttackUseSiege[$DB] = 2 Or $g_aiAttackUseSiege[$LB] = 2) And $g_aiArmyCompSiegeMachine[$eSiegeBattleBlimp] = 0 Then ExitLoop
If $MiscChallenges[$j][1] = "Wall Wrecker" And($g_aiAttackUseSiege[$DB] = 1 Or $g_aiAttackUseSiege[$LB] = 1) And $g_aiArmyCompSiegeMachine[$eSiegeWallWrecker] = 0 Then ExitLoop
Local $aArray[4] = [$MiscChallenges[$j][1], $aAllDetectionsOnScreen[$i][2], $aAllDetectionsOnScreen[$i][3], $MiscChallenges[$j][3]]
EndIf
Next
EndSwitch
If IsDeclared("aArray") And $aArray[0] <> "" Then
ReDim $aSelectChallenges[UBound($aSelectChallenges) + 1][5]
$aSelectChallenges[UBound($aSelectChallenges) - 1][0] = $aArray[0]
$aSelectChallenges[UBound($aSelectChallenges) - 1][1] = $aArray[1]
$aSelectChallenges[UBound($aSelectChallenges) - 1][2] = $aArray[2]
$aSelectChallenges[UBound($aSelectChallenges) - 1][3] = $aArray[3]
$aSelectChallenges[UBound($aSelectChallenges) - 1][4] = 0
$aArray[0] = ""
EndIf
Next
EndIf
DirRemove($pathTemp, $DIR_REMOVE)
If $g_bChkClanGamesDebug Then Setlog("_ClanGames aAllDetectionsOnScreen (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds)", $COLOR_INFO)
$hTimer = TimerInit()
_ArraySort($aSelectChallenges, 0, 0, 0, 2)
If UBound($aSelectChallenges) > 0 Then
For $i = 0 To UBound($aSelectChallenges) - 1
Setlog("Detected " & $aSelectChallenges[$i][0] & " difficulty of " & $aSelectChallenges[$i][3])
Click($aSelectChallenges[$i][1], $aSelectChallenges[$i][2])
If _Sleep(1500) Then Return
Local $EventHours = GetEventInformation()
Setlog("Time: " & $EventHours & " min", $COLOR_INFO)
Click($aSelectChallenges[$i][1], $aSelectChallenges[$i][2])
If _Sleep(250) Then Return
$aSelectChallenges[$i][4] = Number($EventHours)
Next
Local $aTempSelectChallenges[0][5]
For $i = 0 To UBound($aSelectChallenges) - 1
If $aSelectChallenges[$i][4] = 60 And $g_bChkClanGames60 Then
Setlog($aSelectChallenges[$i][0] & " unselected, is a 60min event!", $COLOR_INFO)
ContinueLoop
EndIf
ReDim $aTempSelectChallenges[UBound($aTempSelectChallenges) + 1][5]
$aTempSelectChallenges[UBound($aTempSelectChallenges) - 1][0] = $aSelectChallenges[$i][0]
$aTempSelectChallenges[UBound($aTempSelectChallenges) - 1][1] = $aSelectChallenges[$i][1]
$aTempSelectChallenges[UBound($aTempSelectChallenges) - 1][2] = $aSelectChallenges[$i][2]
$aTempSelectChallenges[UBound($aTempSelectChallenges) - 1][3] = $aSelectChallenges[$i][3]
$aTempSelectChallenges[UBound($aTempSelectChallenges) - 1][4] = $aSelectChallenges[$i][4]
Next
ClickP($TabChallengesPosition, 2, 0, "#Tab")
If _sleep(250) Then Return
ClickDrag(807, 210, 807, 385, 500)
If _Sleep(500) Then Return
EndIf
If IsDeclared("aTempSelectChallenges") Then
If UBound($aTempSelectChallenges) > 0 Then
SetDebugLog("$aTempSelectChallenges: " & _ArrayToString($aTempSelectChallenges))
_ArraySort($aTempSelectChallenges, 0, 0, 0, 3)
Setlog("Next Event will be " & $aTempSelectChallenges[0][0] & " to make in " & $aTempSelectChallenges[0][4] & " min.")
$sEventName = $aTempSelectChallenges[0][0]
Click($aTempSelectChallenges[0][1], $aTempSelectChallenges[0][2])
If _Sleep(1750) Then Return
If $test Then Return
If ClickOnEvent($YourAccScore, $ScoreLimits, $sEventName, $getCapture) Then Return
ClickP($TabChallengesPosition, 2, 0, "#Tab")
EndIf
EndIf
If $g_bChkClanGamesPurge Then
If $g_iPurgeJobCount[$g_iCurAccount] + 1 < $g_iPurgeMax Or $g_iPurgeMax = 0 Then
Local $Txt = $g_iPurgeMax
If $g_iPurgeMax = 0 Then $Txt = "Unlimited"
SetLog("Current Purge Jobs " & $g_iPurgeJobCount[$g_iCurAccount] + 1 & " at max of " & $Txt, $COLOR_INFO)
$sEventName = "Builder Base Challenges to Purge"
If PurgeEvent($g_sImgPurge, $sEventName, True) Then
$g_iPurgeJobCount[$g_iCurAccount] += 1
Else
SetLog("No Builder Base Event found to Purge", $COLOR_WARNING)
EndIf
EndIf
Return
EndIf
SetLog("No Event found, Check your settings", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0000")
If _Sleep(2000) Then Return
EndFunc
Func IsClanGamesWindow($getCapture = True)
If QuickMIS("BC1", $g_sImgCaravan, 200, 55, 300, 135, $getCapture, False) Then
SetLog("Caravan available... Entering Clan Games...", $COLOR_SUCCESS)
Click($g_iQuickMISX + 200, $g_iQuickMISY + 55)
If _Sleep(1500) Then Return
If QuickMIS("BC1", $g_sImgReward, 760, 480, 830, 570, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Your Reward is Ready", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0000")
If _Sleep(100) Then Return
Return False
EndIf
If _ColorCheck(_GetPixelColor(384, 388, True), Hex(0xFFFFFF, 6), 5) Then
Local $sTimeRemain = getOcrTimeGameTime(380, 461)
SetLog("Clan Games will start in " & $sTimeRemain, $COLOR_INFO)
GUICtrlSetData($g_hLblRemainTime, $sTimeRemain)
GUICtrlSetState($g_hLblRemainTime, $GUI_ENABLE)
ClickP($aAway, 1, 0, "#0000")
If _Sleep(100) Then Return
Return False
EndIf
Else
SetLog("Caravan not available...", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0000")
Return False
EndIf
If _Sleep(300) Then Return
Return True
EndFunc
Func GetTimesAndScores()
Local $rest = -1, $YourScore = "", $ScoreLimits, $sTimeRemain
$sTimeRemain = StringReplace(getOcrTimeGameTime(50, 479), " ", "")
If Not _IsValideOCR($sTimeRemain) Then
SetLog("Get Time Remain error!!!", $COLOR_WARNING)
Return -1
EndIf
SetLog("Clan Games Time Remaining: " & $sTimeRemain, $COLOR_INFO)
GUICtrlSetData($g_hLblRemainTime, $sTimeRemain)
GUICtrlSetState($g_hLblRemainTime, $GUI_ENABLE)
For $i = 0 To 10
$YourScore = getOcrYourScore(55, 533)
If $g_bChkClanGamesDebug Then SetLog("Your OCR score: " & $YourScore)
$YourScore = StringReplace($YourScore, "#", "/")
$ScoreLimits = StringSplit($YourScore, "/", $STR_NOCOUNT)
If UBound($ScoreLimits) > 1 Then
If $rest = Int($ScoreLimits[0]) Then ExitLoop
$rest = Int($ScoreLimits[0])
Else
Return -1
EndIf
If _Sleep(800) Then Return
If $i = 10 Then Return -1
Next
GUICtrlSetData($g_hLblYourScore, $YourScore)
GUICtrlSetState($g_hLblYourScore, $GUI_ENABLE)
Return $ScoreLimits
EndFunc
Func CooldownTime($getCapture = True)
If QuickMIS("BC1", $g_sImgCoolPurge, 480, 370, 570, 410, $getCapture, False) Then
SetLog("Cooldown Purge Detected", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0000")
Return True
EndIf
Return False
EndFunc
Func IsEventRunning()
If Not _ColorCheck(_GetPixelColor(304, 257, True), Hex(0x53E050, 6), 5) Then
SetLog("An Event is already in progress !", $COLOR_SUCCESS)
If $g_bChkClanGamesDebug Then SetLog("[0]: " & _GetPixelColor(304, 257, True))
ClickP($aAway, 1, 0, "#0000")
Return True
Else
SetLog("No event under progress... Lets look for one...", $COLOR_INFO)
Return False
EndIf
EndFunc
Func ClickOnEvent(ByRef $YourAccScore, $ScoreLimits, $sEventName, $getCapture)
If $YourAccScore[$g_iCurAccount][1] = False Then
Local $Text = "", $color = $COLOR_SUCCESS
If $YourAccScore[$g_iCurAccount][0] <> $ScoreLimits[0] Then
$Text = "You Won " & $ScoreLimits[0] - $YourAccScore[$g_iCurAccount][0] & "pts in last Event"
Else
$Text = "You could not complete the last event!!"
$color = $COLOR_WARNING
EndIf
SetLog($Text, $color)
_FileWriteLog($g_sProfileLogsPath & "\ClanGames.log", " [" & $g_sProfileCurrentName & "] - " & $Text)
EndIf
$YourAccScore[$g_iCurAccount][1] = False
$YourAccScore[$g_iCurAccount][0] = $ScoreLimits[0]
If $g_bChkClanGamesDebug Then SetLog("ClickOnEvent $YourAccScore[" & $g_iCurAccount & "][1]: " & $YourAccScore[$g_iCurAccount][1])
If $g_bChkClanGamesDebug Then SetLog("ClickOnEvent $YourAccScore[" & $g_iCurAccount & "][0]: " & $YourAccScore[$g_iCurAccount][0])
If Not StartsEvent($sEventName, False, $getCapture, $g_bChkClanGamesDebug) Then Return False
ClickP($aAway, 1, 0, "#0000")
Return True
EndFunc
Func StartsEvent($sEventName, $g_bPurgeJob = False, $getCapture = True, $g_bChkClanGamesDebug = False)
If $g_bRunState = False Then Return
If QuickMIS("BC1", $g_sImgStart, 220, 150, 830, 580, $getCapture, $g_bChkClanGamesDebug) Then
Local $Timer = GetEventTimeInMinutes($g_iQuickMISX + 220, $g_iQuickMISY + 150)
SetLog("Starting  Event" & " [" & $Timer & " min]", $COLOR_SUCCESS)
Click($g_iQuickMISX + 220, $g_iQuickMISY + 150)
GUICtrlSetData($g_hTxtClanGamesLog, @CRLF & _NowDate() & " " & _NowTime() & " [" & $g_sProfileCurrentName & "] - Starting " & $sEventName & " for " & $Timer & " min", 1)
_FileWriteLog($g_sProfileLogsPath & "\ClanGames.log", " [" & $g_sProfileCurrentName & "] - Starting " & $sEventName & " for " & $Timer & " min")
If $g_bPurgeJob Then
If _Sleep(2000) Then Return
If QuickMIS("BC1", $g_sImgTrashPurge, 220, 150, 830, 580, $getCapture, $g_bChkClanGamesDebug) Then
Click($g_iQuickMISX + 220, $g_iQuickMISY + 150)
If _Sleep(1200) Then Return
SetLog("Click Trash", $COLOR_INFO)
If QuickMIS("BC1", $g_sImgOkayPurge, 440, 400, 580, 450, $getCapture, $g_bChkClanGamesDebug) Then
SetLog("Click OK", $COLOR_INFO)
Click($g_iQuickMISX + 440, $g_iQuickMISY + 400)
SetLog("Purging a job on progress !", $COLOR_SUCCESS)
GUICtrlSetData($g_hTxtClanGamesLog, @CRLF & _NowDate() & " " & _NowTime() & " [" & $g_sProfileCurrentName & "] - [" & $g_iPurgeJobCount[$g_iCurAccount] + 1 & "] - Purging Event ", 1)
_FileWriteLog($g_sProfileLogsPath & "\ClanGames.log", " [" & $g_sProfileCurrentName & "] - [" & $g_iPurgeJobCount[$g_iCurAccount] + 1 & "] - Purging Event ")
ClickP($aAway, 1, 0, "#0000")
Else
SetLog("$g_sImgOkayPurge Issue!!!", $COLOR_WARNING)
Return False
EndIf
Else
SetLog("$g_sImgTrashPurge Issue!!!", $COLOR_WARNING)
Return False
EndIf
EndIf
Return True
Else
SetLog("Didn't Get the Green Start Button Event!!", $COLOR_WARNING)
If $g_bChkClanGamesDebug Then SetLog("[X: " & 220 & " Y:" & 150 & " X1: " & 830 & " Y1: " & 580 & "]", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0000")
Return False
EndIf
EndFunc
Func PurgeEvent($directoryImage, $sEventName, $getCapture = True)
SetLog("Checking Builder Base Challenges to Purge", $COLOR_DEBUG)
Local $x = 281, $y = 150, $x1 = 775, $y1 = 545
If QuickMIS("BC1", $directoryImage, $x, $y, $x1, $y1, $getCapture, $g_bChkClanGamesDebug) Then
Click($g_iQuickMISX + $x, $g_iQuickMISY + $y)
SetLog("Starting Impossible Job to purge...", $COLOR_INFO)
If _Sleep(1500) Then Return
If StartsEvent($sEventName, True, $getCapture, $g_bChkClanGamesDebug) Then
ClickP($aAway, 1, 0, "#0000")
Return True
EndIf
EndIf
Return False
EndFunc
Func _IsValideOCR($sString)
If StringInStr($sString, "d") > 0 Or StringInStr($sString, "h") > 0 Or StringInStr($sString, "m") > 0 Or StringInStr($sString, "s") > 0 Then Return True
Return False
EndFunc
Func Ocr2Minutes($StringOCR)
If Not _IsValideOCR($StringOCR) Then Return 0
Local $temp
If StringInStr($StringOCR, "d") > 0 Then
$temp = StringSplit($StringOCR, "d", $STR_NOCOUNT)
Local $d = Int($temp[0])
Local $h = Int(StringReplace($temp[1], "h", ""))
Return($d * 24) * 60 +($h * 60)
ElseIf StringInStr($StringOCR, "h") > 0 Then
$temp = StringSplit($StringOCR, "h", $STR_NOCOUNT)
Local $h = Int($temp[0])
Local $m = Int(StringReplace($temp[1], "m", ""))
Return($h * 60) + $m
ElseIf StringInStr($StringOCR, "m") > 0 Then
$temp = StringSplit($StringOCR, "m", $STR_NOCOUNT)
Return Int($temp[0])
ElseIf StringInStr($StringOCR, "s") > 0 Then
Return 1
EndIf
Return 0
EndFunc
Func GetEventTimeInMinutes($iXStartBtn, $iYStartBtn, $bIsStartBtn = True)
Local $XAxis = $iXStartBtn - 163
Local $YAxis = $iYStartBtn + 8
If Not $bIsStartBtn Then
$XAxis = $iXStartBtn - 163
$YAxis = $iYStartBtn + 8
EndIf
Local $Ocr = getOcrEventTime($XAxis, $YAxis)
Return Ocr2Minutes($Ocr)
EndFunc
Func getOcrTimeGameTime($x_start, $y_start)
Return getOcrAndCapture("coc-clangames", $x_start, $y_start, 116, 31, True)
EndFunc
Func getOcrYourScore($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 120, 18, True)
EndFunc
Func getOcrEventTime($x_start, $y_start)
Return getOcrAndCapture("coc-events", $x_start, $y_start, 80, 20, True)
EndFunc
Func ClanGamesChallenges($sReturnArray, $makeIni = False, $sINIPath = "", $debug = False)
Local $LootChallenges[6][5] = [ ["GoldChallenge", "Gold Challenge", 7, 5, 8], ["ElixirChallenge", "Elixir Challenge", 7, 5, 8], ["DarkEChallenge", "Dark Elixir Challenge", 8, 5, 8], ["GoldGrab", "Gold Grab", 3, 1, 1], ["ElixirEmbezz", "Elixir Embezzlement", 3, 1, 1], ["DarkEHeist", "Dark Elixir Heist", 9, 3, 1]]
Local $AirTroopChallenges[6][5] = [ ["Mini", "Minion", 7, 20, 1], ["Ball", "Balloon", 4, 12, 1], ["Drag", "Dragon", 7, 6, 1], ["BabyD", "BabyDragon", 9, 4, 1], ["Lava", "ElectroDragon", 10, 2, 1], ["Edrag", "Lavahound", 9, 3, 1]]
Local $GroundTroopChallenges[14][5] = [ ["Arch", "Archer", 1, 30, 1], ["Barb", "Barbarian", 1, 30, 1], ["Giant", "Giant", 1, 10, 1], ["Gobl", "Goblin", 2, 20, 1], ["Wall", "WallBreaker", 3, 6, 1], ["Wiza", "Wizard", 5, 12, 1], ["Heal", "Healer", 6, 3, 1], ["Hogs", "HogRider", 7, 10, 1], ["Mine", "Miner", 10, 8, 1], ["Pekk", "Pekka", 8, 2, 1], ["Witc", "Witch", 9, 4, 1], ["Bowl", "Bowler", 10, 8, 1], ["Valk", "Valkyrie", 8, 8, 1], ["Gole", "Golem", 8, 2, 1]]
Local $BattleChallenges[16][5] = [ ["Start", "Star Collector", 3, 1, 8], ["Destruction", "Lord of Destruction", 3, 1, 8], ["PileOfVictores", "Pile Of Victories", 3, 1, 8], ["StarThree", "Hunt for Three Stars", 10, 5, 8], ["WinningStreak", "Winning Streak", 9, 5, 8], ["SlayingTitans", "Slaying The Titans", 11, 2, 5], ["NoHero", "No Heroics Allowed", 3, 5, 8], ["NoMagic", "No-Magic Zone", 3, 5, 8], ["Scrappy6s", "Scrappy 6s", 6, 1, 8], ["Super7s", "Super 7s", 7, 1, 8], ["Exciting8s", "Exciting 8s", 8, 1, 8], ["Noble9s", "Noble 9s", 9, 1, 8], ["Terrific10s", "Terrific 10s", 10, 1, 8], ["Exotic11s", "Exotic 11s", 11, 1, 8], ["Triumphant12s", "Triumphant 12s", 12, 1, 8], ["AttackUp", "Attack Up", 3, 1, 8]]
Local $DestructionChallenges[30][5] = [ ["Cannon", "Cannon Carnage", 3, 1, 1], ["ArcherT", "Archer Tower Assault", 3, 1, 1], ["Mortar", "Mortar Mauling", 3, 1, 1], ["AirD", "Destroy Air Defenses", 7, 2, 1], ["WizardT", "Wizard Tower Warfare", 3, 1, 1], ["AirSweepers", "Destroy Air Sweepers", 8, 4, 1], ["Tesla", "Destroy Tesla Towers", 7, 5, 1], ["BombT", "Destroy Bomb Towers", 8, 2, 1], ["Xbow", "Destroy X-Bows", 9, 5, 1], ["Inferno", "Destroy Inferno Towers", 11, 5, 1], ["EagleA", "Eagle Artillery Elimination", 11, 5, 1], ["ClanC", "Clan Castle Charge", 5, 2, 1], ["GoldSRaid", "Gold Storage Raid", 3, 2, 1], ["ElixirSRaid", "Elixir Storage Raid", 3, 1, 1], ["DarkEStorageRaid", "Dark Elixir Storage Raid", 8, 3, 1], ["GoldM", "Gold Mine Mayhem", 3, 1, 1], ["ElixirPump", "Elixir Pump Elimination", 3, 1, 1], ["DarkEPlumbers", "Dark Elixir Plumbers", 3, 1, 1], ["Laboratory", "Laboratory Strike", 3, 1, 1], ["SFacto", "Spell Factory Sabotage", 3, 1, 1], ["DESpell", "Dark Spell Factory Sabotage", 8, 1, 1], ["WallWhacker", "Wall Whacker", 3, 1, 1], ["BBreakdown", "Building Breakdown", 3, 1, 1], ["BKaltar", "Destroy Barbarian King Altars", 9, 4, 1], ["AQaltar", "Destroy Archer Queen Altars", 10, 5, 1], ["GWaltar", "Destroy Grand Warden Altars", 11, 5, 1], ["HeroLevelHunter", "Hero Level Hunter", 9, 5, 8], ["KingLevelHunter", "King Level Hunter", 9, 5, 8], ["QueenLevelHunt", "Queen Level Hunter", 10, 5, 8], ["WardenLevelHunter", "Warden Level Hunter", 11, 5, 8]]
Local $MiscChallenges[5][5] = [ ["Gard", "Gardening Exercise", 3, 1, 8], ["DonateSpell", "Donate Spells", 9, 3, 8], ["DonateTroop", "Helping Hand", 6, 2, 8], ["BattleBlimpBoogie", "Battle Blimp", 12, 5, 1], ["WallWreckerWallop", "Wall Wrecker", 12, 5, 1]]
Local $LocalINI = $sINIPath
If $LocalINI = "" Then $LocalINI = StringReplace($g_sProfileConfigPath, "config.ini", "ClanGames_config.ini")
If $debug Then Setlog(" - Ini Path: " & $LocalINI)
Local $section[4] = ["Loot Challenges", "Battle Challenges", "Destruction Challenges", "Misc Challenges"]
Local $array[4] = [$LootChallenges, $BattleChallenges, $DestructionChallenges, $MiscChallenges]
Local $ResultIni = "", $TempChallenge, $tempXSector
If $makeIni = False Then
Switch $sReturnArray
Case "$AirTroopChallenges"
Return $AirTroopChallenges
Case "$GroundTroopChallenges"
Return $GroundTroopChallenges
Case "$LootChallenges"
$TempChallenge = $array[0]
$tempXSector = $section[0]
Case "$BattleChallenges"
$TempChallenge = $array[1]
$tempXSector = $section[1]
Case "$DestructionChallenges"
$TempChallenge = $array[2]
$tempXSector = $section[2]
Case "$MiscChallenges"
$TempChallenge = $array[3]
$tempXSector = $section[3]
EndSwitch
If $debug Then Setlog("[" & $tempXSector & "]")
For $j = 0 To UBound($TempChallenge) - 1
$ResultIni = Int(IniRead($LocalINI, $tempXSector, $TempChallenge[$j][1], $TempChallenge[$j][3]))
$TempChallenge[$j][3] = IsNumber($ResultIni) = 1 ? Int($ResultIni) : 0
If $TempChallenge[$j][3] > 5 Then $TempChallenge[$j][3] = 5
If $TempChallenge[$j][3] < 0 Then $TempChallenge[$j][3] = 0
If $debug Then Setlog(" - " & $TempChallenge[$j][1] & ": " & $TempChallenge[$j][3])
$ResultIni = ""
Next
Return $TempChallenge
Else
Local $File = FileOpen($LocalINI, $FO_APPEND)
Local $HelpText = "; - MyBotRun 2018 - " & @CRLF & "; - 'Event name' = 'Priority' [1~5][easiest to the hardest] , '0' to disable the event" & @CRLF & "; - Remember on GUI you can enable/disable an entire Section" & @CRLF & "; - Do not change any event name" & @CRLF & "; - Deleting this file will restore the defaults values." & @CRLF & @CRLF
FileWrite($File, $HelpText)
FileClose($File)
For $i = 0 To UBound($array) - 1
$TempChallenge = $array[$i]
If $debug Then Setlog("[" & $section[$i] & "]")
For $j = 0 To UBound($TempChallenge) - 1
If IniWrite($LocalINI, $section[$i], $TempChallenge[$j][1], $TempChallenge[$j][3]) <> 1 Then SetLog("Error on :" & $section[$i] & "|" & $TempChallenge[$j][1], $COLOR_WARNING)
If $debug Then Setlog(" - " & $TempChallenge[$j][1] & ": " & $TempChallenge[$j][3])
If _sleep(100) Then Return
Next
$TempChallenge = Null
Next
EndIf
EndFunc
Func GetEventInformation()
If QuickMIS("BC1", $g_sImgStart, 220, 150, 830, 580, True, $g_bChkClanGamesDebug) Then
Return GetEventTimeInMinutes($g_iQuickMISX + 220, $g_iQuickMISY + 150)
EndIf
Return 0
EndFunc
Func IsBBChallenge($xDetected, $yDetected)
Local $sColorBB = Hex(0x0D6687, 6)
Local $sColorNonBB = Hex(0x7DA9DD, 6)
Local $xToCheck = 299 + 126 * Int(($xDetected - 299) / 126)
Local $yToCheck = 156 + 160 * Int(($yDetected - 156) / 160)
If $g_bChkClanGamesDebug Then Setlog("IsBBChallenge() x = " & $xToCheck & ", y = " & $yToCheck & ", color = " & _GetPixelColor($xToCheck, $yToCheck, True) , $COLOR_INFO)
If _ColorCheck(_GetPixelColor($xToCheck, $yToCheck, True), $sColorBB, 5) Then
Return True
EndIf
Return False
EndFunc
Func CollectFreeMagicItems($bTest = False)
If Not $g_bChkCollectFreeMagicItems Then Return
If Not $g_bRunState Then Return
Local Static $iLastTimeChecked[8] = [0, 0, 0, 0, 0, 0, 0, 0]
If $iLastTimeChecked[$g_iCurAccount] = @MDAY Then Return
ClickP($aAway, 1, 0, "#0332")
If Not IsMainPage() Then Return
SetLog("Collecting Free Magic Items", $COLOR_INFO)
If _Sleep($DELAYCOLLECT2) Then Return
If QuickMIS("BC1", $g_sImgTrader, 120, 160, 210, 215, True, False) Then
SetLog("Trader available, Entering Daily Discounts", $COLOR_SUCCESS)
Click($g_iQuickMISX + 120, $g_iQuickMISY + 160)
If _Sleep(1500) Then Return
Else
SetLog("Trader unavailable", $COLOR_INFO)
Return
EndIf
If Not QuickMIS("BC1", $g_sImgDailyDiscountWindow, 280, 175, 345, 210, True, False) Then
ClickP($aAway, 1, 0, "#0332")
Return
EndIf
If Not $g_bRunState Then Return
Local $aOcrPositions[3][2] = [[200, 439], [390, 439], [580, 439]]
Local $aResults[3] = ["", "", ""]
$iLastTimeChecked[$g_iCurAccount] = @MDAY
For $i = 0 To 2
$aResults[$i] = getOcrAndCapture("coc-freemagicitems", $aOcrPositions[$i][0], $aOcrPositions[$i][1], 80, 25, True)
If $aResults[$i] <> "" Then
If Not $bTest Then
If $aResults[$i] = "FREE" Then
Click($aOcrPositions[$i][0], $aOcrPositions[$i][1], 2, 500)
SetLog("Free Magic Item detected", $COLOR_INFO)
ClickP($aAway, 2, 0, "#0332")
If _Sleep(1000) Then Return
Return
Else
If _ColorCheck(_GetPixelColor($aOcrPositions[$i][0], $aOcrPositions[$i][1] + 5, True), Hex(0x5D79C5, 6), 5) Then
$aResults[$i] = $aResults[$i] & " Gems"
Else
$aResults[$i] = Int($aResults[$i]) > 0 ? "No Space In Castle" : "Collected"
EndIf
EndIf
EndIf
EndIf
If Not $g_bRunState Then Return
Next
SetLog("Daily Discounts: " & $aResults[0] & " | " & $aResults[1] & " | " & $aResults[2])
SetLog("Nothing free to collect!", $COLOR_INFO)
ClickP($aAway, 2, 0, "#0332")
If _Sleep(1000) Then Return
EndFunc
Func CollectBuilderBase($bSwitchToBB = False, $bSwitchToNV = False)
If Not $g_bChkCollectBuilderBase Then Return
If Not $g_bRunState Then Return
If $bSwitchToBB Then
ClickP($aAway, 1, 0, "#0332")
If Not SwitchBetweenBases() Then Return
EndIf
SetLog("Collecting Resources on Builders Base", $COLOR_INFO)
If _Sleep($DELAYCOLLECT2) Then Return
Local $sFilename = ""
Local $aCollectXY, $t
Local $aResult = multiMatches($g_sImgCollectRessourcesBB, 0, "FV", "FV")
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
$sFilename = $aResult[$i][1]
$aCollectXY = $aResult[$i][5]
If IsArray($aCollectXY) Then
$t = Random(0, UBound($aCollectXY) - 1, 1)
If $g_bDebugSetlog Then SetDebugLog($sFilename & " found, random pick(" & $aCollectXY[$t][0] & "," & $aCollectXY[$t][1] & ")", $COLOR_SUCCESS)
If IsMainPageBuilderBase() Then Click($aCollectXY[$t][0], $aCollectXY[$t][1], 1, 0, "#0430")
If _Sleep($DELAYCOLLECT2) Then Return
EndIf
Next
EndIf
If _Sleep($DELAYCOLLECT3) Then Return
If $bSwitchToNV Then SwitchBetweenBases()
EndFunc
Func StartClockTowerBoost($bSwitchToBB = False, $bSwitchToNV = False)
If Not $g_bChkStartClockTowerBoost Then Return
If Not $g_bRunState Then Return
If $bSwitchToBB Then
ClickP($aAway, 1, 0, "#0332")
If Not SwitchBetweenBases() Then Return
EndIf
Local $bCTBoost = True
If $g_bChkCTBoostBlderBz Then
getBuilderCount(True, True)
If $g_iFreeBuilderCountBB = $g_iTotalBuilderCountBB Then $bCTBoost = False
EndIf
If Not $bCTBoost Then
SetLog("Skip Clock Tower Boost as no Building is currently under Upgrade!", $COLOR_INFO)
Else
SetLog("Boosting Clock Tower", $COLOR_INFO)
If _Sleep($DELAYCOLLECT2) Then Return
Local $sCTCoords, $aCTCoords, $aCTBoost
$sCTCoords = findImage("ClockTowerAvailable", $g_sImgStartCTBoost, "FV", 1, True)
If $sCTCoords <> "" Then
$aCTCoords = StringSplit($sCTCoords, ",", $STR_NOCOUNT)
ClickP($aCTCoords)
If _Sleep($DELAYCLOCKTOWER1) Then Return
$aCTBoost = findButton("BoostCT")
If IsArray($aCTBoost) Then
ClickP($aCTBoost)
If _Sleep($DELAYCLOCKTOWER1) Then Return
$aCTBoost = findButton("BOOSTBtn")
If IsArray($aCTBoost) Then
ClickP($aCTBoost)
If _Sleep($DELAYCLOCKTOWER2) Then Return
SetLog("Boosted Clock Tower successfully!", $COLOR_SUCCESS)
Else
SetLog("Failed to find the BOOST window button", $COLOR_ERROR)
EndIf
Else
SetLog("Cannot find the Boost Button of Clock Tower", $COLOR_ERROR)
EndIf
Else
SetLog("Clock Tower boost is not available!")
EndIf
EndIf
ClickP($aAway, 1, 0, "#0329")
If $bSwitchToNV Then SwitchBetweenBases()
EndFunc
Func BuilderBaseReport($bBypass = False, $bSetLog = True)
PureClickP($aAway, 1, 0, "#0319")
If _Sleep($DELAYVILLAGEREPORT1) Then Return
Switch $bBypass
Case False
If $bSetLog Then SetLog("Builder Base Report", $COLOR_INFO)
Case True
If $bSetLog Then SetLog("Updating Builder Base Resource Values", $COLOR_INFO)
Case Else
If $bSetLog Then SetLog("Village Report Error, You have been a BAD programmer!", $COLOR_ERROR)
EndSwitch
If Not $bSetLog Then SetLog("Village Report", $COLOR_INFO)
getBuilderCount($bSetLog, True)
If _Sleep($DELAYRESPOND) Then Return
$g_aiCurrentLootBB[$eLootTrophyBB] = getTrophyMainScreen(67, 84)
$g_aiCurrentLootBB[$eLootGoldBB] = getResourcesMainScreen(705, 23)
$g_aiCurrentLootBB[$eLootElixirBB] = getResourcesMainScreen(705, 72)
If $bSetLog Then SetLog(" [G]: " & _NumberFormat($g_aiCurrentLootBB[$eLootGoldBB]) & " [E]: " & _NumberFormat($g_aiCurrentLootBB[$eLootElixirBB]) & "[T]: " & _NumberFormat($g_aiCurrentLootBB[$eLootTrophyBB]), $COLOR_SUCCESS)
If Not $bBypass Then
UpdateStats()
EndIf
EndFunc
Func chkActivateBBSuggestedUpgrades()
If GUICtrlRead($g_hChkBBSuggestedUpgrades) = $GUI_CHECKED Then
$g_iChkBBSuggestedUpgrades = 1
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, $GUI_ENABLE)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, $GUI_ENABLE)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, $GUI_ENABLE)
GUICtrlSetState($g_hChkPlacingNewBuildings, $GUI_ENABLE)
Else
$g_iChkBBSuggestedUpgrades = 0
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetState($g_hChkPlacingNewBuildings, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
EndIf
EndFunc
Func chkActivateBBSuggestedUpgradesGold()
If $g_iChkBBSuggestedUpgrades = 0 Then Return
$g_iChkBBSuggestedUpgradesIgnoreGold =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreGold) = $GUI_CHECKED) ? 1 : 0
If $g_iChkBBSuggestedUpgradesIgnoreGold = 0 Then
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, $GUI_ENABLE)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
EndIf
$g_iChkBBSuggestedUpgradesIgnoreHall =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreHall) = $GUI_CHECKED) ? 1 : 0
$g_iChkBBSuggestedUpgradesIgnoreElixir =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreElixir) = $GUI_CHECKED) ? 1 : 0
EndFunc
Func chkActivateBBSuggestedUpgradesElixir()
If $g_iChkBBSuggestedUpgrades = 0 Then Return
$g_iChkBBSuggestedUpgradesIgnoreElixir =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreElixir) = $GUI_CHECKED) ? 1 : 0
If $g_iChkBBSuggestedUpgradesIgnoreElixir = 0 Then
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
EndIf
$g_iChkBBSuggestedUpgradesIgnoreGold =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreGold) = $GUI_CHECKED) ? 1 : 0
EndFunc
Func chkPlacingNewBuildings()
$g_iChkPlacingNewBuildings =(GUICtrlRead($g_hChkPlacingNewBuildings) = $GUI_CHECKED) ? 1 : 0
EndFunc
Func MainSuggestedUpgradeCode()
If $g_iChkBBSuggestedUpgrades = 0 Then Return
Local $bDebug = False
Local $bScreencap = True
If isOnBuilderBase(True) Then
If ClickOnBuilder() Then
SetLog(" - Upg Window Opened successfully", $COLOR_INFO)
Local $y = 102, $y1 = 132, $step = 30, $x = 400, $x1 = 540
For $i = 0 To 2
Local $bSkipGoldCheck = False
If $g_iChkBBSuggestedUpgradesIgnoreElixir = 0 And $g_aiCurrentLootBB[$eLootElixirBB] > 250 Then
Local $aResult = GetIconPosition($x, $y, $x1, $y1, $g_sImgAutoUpgradeElixir, "Elixir", $bScreencap, $bDebug)
Switch $aResult[2]
Case "Elixir"
Click($aResult[0], $aResult[1], 1)
If _Sleep(2000) Then Return
If GetUpgradeButton($aResult[2], $bDebug) Then
ExitLoop
EndIf
$bSkipGoldCheck = True
Case "New"
If $g_iChkPlacingNewBuildings = 1 Then
SetLog("[" & $i + 1 & "]" & " New Building detected, Placing it...", $COLOR_INFO)
If NewBuildings($aResult) Then
ExitLoop
EndIf
$bSkipGoldCheck = True
EndIf
Case "NoResources"
SetLog("[" & $i + 1 & "]" & " Not enough Elixir, continuing...", $COLOR_INFO)
$bSkipGoldCheck = True
Case Else
EndSwitch
EndIf
If $g_iChkBBSuggestedUpgradesIgnoreGold = 0 And $g_aiCurrentLootBB[$eLootGoldBB] > 250 And Not $bSkipGoldCheck Then
Local $aResult = GetIconPosition($x, $y, $x1, $y1, $g_sImgAutoUpgradeGold, "Gold", $bScreencap, $bDebug)
Switch $aResult[2]
Case "Gold"
Click($aResult[0], $aResult[1], 1)
If _Sleep(2000) Then Return
If GetUpgradeButton($aResult[2], $bDebug) Then
ExitLoop
EndIf
Case "New"
If $g_iChkPlacingNewBuildings = 1 Then
SetLog("[" & $i + 1 & "]" & " New Building detected, Placing it...", $COLOR_INFO)
If NewBuildings($aResult) Then
ExitLoop
EndIf
EndIf
Case "NoResources"
SetLog("[" & $i + 1 & "]" & " Not enough Gold, continuing...", $COLOR_INFO)
Case Else
EndSwitch
EndIf
$y += $step
$y1 += $step
Next
EndIf
EndIf
ClickP($aAway, 1, 0, "#0121")
EndFunc
Func ClickOnBuilder()
Local Const $aMasterBuilder[4] = [360, 11, 0x7cbdde, 10]
Local $sDebugText = ""
Local Const $Debug = False
Local Const $Screencap = True
If $g_iFreeBuilderCountBB = 0 Then SetLog("No Master Builder available! [" & $g_iFreeBuilderCountBB & "/" & $g_iTotalBuilderCountBB & "]", $COLOR_INFO)
If $g_iFreeBuilderCountBB > 0 Then
If _CheckPixel($aMasterBuilder, True) Then
Click($aMasterBuilder[0], $aMasterBuilder[1], 1)
If _Sleep(2000) Then Return
If QuickMIS("BC1", $g_sImgAutoUpgradeWindow, 330, 85, 550, 145, $Screencap, $Debug) Then
Return True
Else
$sDebugText = "Window didn't opened"
EndIf
Else
$sDebugText = "BB Pixel problem"
EndIf
EndIf
If $sDebugText <> "" Then SetLog("Problem on Suggested Upg Window: [" & $sDebugText & "]", $COLOR_ERROR)
Return False
EndFunc
Func GetIconPosition($x, $y, $x1, $y1, $directory, $Name = "Elixir", $Screencap = True, $Debug = False)
Local $aResult[3] = [-1, -1, ""]
If QuickMIS("BC1", $directory, $x, $y, $x1, $y1, $Screencap, $Debug) Then
Local $iYoffset = $y + $g_iQuickMISY - 15, $iY1offset = $y + $g_iQuickMISY + 7
Local $iX = 300, $iX1 = $g_iQuickMISX + $x
$aResult[0] = $g_iQuickMISX + $x
$aResult[1] = $g_iQuickMISY + $y
$aResult[2] = $Name
If QuickMIS("BC1", $g_sImgAutoUpgradeNoRes, $aResult[0], $iYoffset, $aResult[0] + 100, $iY1offset, True, $Debug) Then
$aResult[2] = "NoResources"
Return $aResult
EndIf
If QuickMIS("BC1", $g_sImgAutoUpgradeNew, $iX, $iYoffset, $iX1, $iY1offset, True, $Debug) Then
$aResult[0] = $g_iQuickMISX + $iX + 35
$aResult[1] = $g_iQuickMISY + $iYoffset
$aResult[2] = "New"
EndIf
EndIf
Return $aResult
EndFunc
Func GetUpgradeButton($sUpgButtom = "", $Debug = False)
Local $aBtnPos = [360, 460, 380, 120]
If $sUpgButtom = "" Then Return
If $sUpgButtom = "Elixir" Then $sUpgButtom = $g_sImgAutoUpgradeBtnElixir
If $sUpgButtom = "Gold" Then $sUpgButtom = $g_sImgAutoUpgradeBtnGold
If QuickMIS("BC1", $g_sImgAutoUpgradeBtnDir, 300, 590, 600, 670, True, $Debug) Then
Local $sBuildingName = getNameBuilding(242, 550)
If _Sleep(500) Then Return
SetLog("Building: " & $sBuildingName, $COLOR_INFO)
If StringInStr($sBuildingName, "Hall") > 0 And $g_iChkBBSuggestedUpgradesIgnoreHall Then
SetLog("Ups! Builder Hall is not to Upgrade!", $COLOR_ERROR)
Return False
EndIf
Click($g_iQuickMISX + 300, $g_iQuickMISY + 590, 1)
If _Sleep(1500) Then Return
If QuickMIS("BC1", $sUpgButtom, $aBtnPos[0], $aBtnPos[1], $aBtnPos[0] + $aBtnPos[2], $aBtnPos[1] + $aBtnPos[3], True, $Debug) Then
Click($g_iQuickMISX + $aBtnPos[0], $g_iQuickMISY + $aBtnPos[1], 1)
SetLog($sBuildingName & " Upgrading!", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0121")
Return True
Else
ClickP($aAway, 1, 0, "#0121")
SetLog("Not enough Resources to Upgrade " & $sBuildingName & " !", $COLOR_ERROR)
EndIf
EndIf
Return False
EndFunc
Func NewBuildings($aResult)
Local $Screencap = True, $Debug = False
If UBound($aResult) = 3 And $aResult[2] = "New" Then
Click($aResult[0], $aResult[1], 1)
If _Sleep(3000) Then Return
Local $ClocksCoordinates = QuickMIS("CX", $g_sImgAutoUpgradeClock, 20, 250, 775, 530, $Screencap, $Debug)
If UBound($ClocksCoordinates) > 0 Then
SetLog("[Clocks]: " & UBound($ClocksCoordinates), $COLOR_DEBUG)
For $i = 0 To UBound($ClocksCoordinates) - 1
Local $Coordinates = StringSplit($ClocksCoordinates[$i], ",", 2)
If UBound($Coordinates) <> 2 Then
Click(820, 38, 1)
ExitLoop
EndIf
Local $x =($Coordinates[0] + 20), $y =($Coordinates[1] + 250) - 135, $x1 =($Coordinates[0] + 20) + 220, $y1 =($Coordinates[1] + 250) + 52
If $g_bDebugSetlog Then SetDebugLog("[x]: " & $x & " [y]: " & $y & " [x1]: " & $x1 & " [y1]: " & $y1, $COLOR_DEBUG)
If QuickMIS("BC1", $g_sImgAutoUpgradeZero, $x, $y, $x1, $y1, $Screencap, $Debug) Then
If Not QuickMIS("BC1", $g_sImgAutoUpgradeInfo, $x, $y, $x1, $y1, $Screencap, $Debug) Then
Click($x + 100, $y + 50, 1)
If _Sleep(3000) Then Return
If QuickMIS("BC1", $g_sImgAutoUpgradeNewBldgYes, 150, 150, 650, 550, $Screencap, $Debug) Then
Click($g_iQuickMISX + 150, $g_iQuickMISY + 150, 1)
SetLog("Placed a new Building on Builder Island! [" & $g_iQuickMISX + 150 & "," & $g_iQuickMISY + 150 & "]", $COLOR_INFO)
If _Sleep(1000) Then Return
If QuickMIS("BC1", $g_sImgAutoUpgradeNewBldgNo, 150, 150, 650, 550, $Screencap, $Debug) Then
Click($g_iQuickMISX + 150, $g_iQuickMISY + 150, 1)
EndIf
Return True
Else
If QuickMIS("BC1", $g_sImgAutoUpgradeNewBldgNo, 150, 150, 650, 550, $Screencap, $Debug) Then
SetLog("Sorry! Wrong place to deploy a new building on BB! [" & $g_iQuickMISX + 150 & "," & $g_iQuickMISY + 150 & "]", $COLOR_ERROR)
Click($g_iQuickMISX + 150, $g_iQuickMISY + 150, 1)
Else
SetLog("Error on Undo symbol!", $COLOR_ERROR)
EndIf
EndIf
Else
If $i = UBound($ClocksCoordinates) - 1 Then
If $g_bDebugSetlog Then SetDebugLog("Slot without enough resources![1]", $COLOR_DEBUG)
Click(820, 38, 1)
ExitLoop
EndIf
ContinueLoop
EndIf
Else
If $g_bDebugSetlog Then SetDebugLog("Slot without enough resources![2]", $COLOR_DEBUG)
If $i = UBound($ClocksCoordinates) - 1 Then Click(820, 38, 1)
EndIf
Next
Else
SetLog("Slot without enough resources![3]", $COLOR_INFO)
Click(820, 38, 1)
EndIf
EndIf
Return False
EndFunc
Func CleanBBYard()
If Not $g_bChkCleanBBYard And Not TestCapture() Then Return
Local $hObstaclesTimer = __TimerInit()
If Not getBuilderCount(True, True) Then Return
If _Sleep($DELAYRESPOND) Then Return
Local $Filename = ""
Local $Locate = 0
Local $CleanBBYardXY
Local $sCocDiamond = $CocDiamondECD
Local $redLines = $sCocDiamond
Local $bNoBuilders = $g_iFreeBuilderCountBB < 1
If $g_iFreeBuilderCountBB > 0 And Number($g_aiCurrentLootBB[$eLootElixirBB]) > 50000 Then
Local $aResult = findMultiple($g_sImgCleanBBYard, $sCocDiamond, $redLines, 0, 1000, 10, "objectname,objectlevel,objectpoints", True)
If IsArray($aResult) Then
For $matchedValues In $aResult
Local $aPoints = decodeMultipleCoords($matchedValues[2])
$Filename = $matchedValues[0]
For $i = 0 To UBound($aPoints) - 1
$CleanBBYardXY = $aPoints[$i]
If UBound($CleanBBYardXY) > 1 And isInsideDiamondXY($CleanBBYardXY[0], $CleanBBYardXY[1]) Then
If $g_bDebugSetlog Then SetDebugLog($Filename & " found (" & $CleanBBYardXY[0] & "," & $CleanBBYardXY[1] & ")", $COLOR_SUCCESS)
If IsMainPageBuilderBase() Then Click($CleanBBYardXY[0], $CleanBBYardXY[1], 1, 0, "#0430")
$Locate = 1
If _Sleep($DELAYCOLLECT3) Then Return
If IsMainPageBuilderBase() Then GemClick($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($DELAYCHECKTOMBS2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($DELAYCHECKTOMBS1) Then Return
If getBuilderCount(True, True) = False Then Return
If _Sleep($DELAYRESPOND) Then Return
If $g_iFreeBuilderCountBB = 0 Then
SetLog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop(2)
EndIf
EndIf
Next
Next
EndIf
EndIf
If $bNoBuilders Then
SetLog("No Builders available to remove Obstacles!")
Else
If $Locate = 0 And $g_bChkCleanBBYard And Number($g_aiCurrentLootBB[$eLootElixirBB]) > 50000 Then SetLog("No Obstacles found, Yard is clean!", $COLOR_SUCCESS)
If $g_bDebugSetlog Then SetDebugLog("Time: " & Round(__TimerDiff($hObstaclesTimer) / 1000, 2) & "'s", $COLOR_SUCCESS)
EndIf
UpdateStats()
ClickP($aAway, 1, 300, "#0329")
EndFunc
Global Const $sStarColorNA = Hex(0xD3D3CB, 6)
Global Const $sStarColorNoLoot = Hex(0xFF7B72, 6)
Global Const $sStarColorMaxLvl = Hex(0xFFFFFF, 6)
Global Const $sStarColorLabUgReq = Hex(0x757575, 6)
Global Const $sStarColorMaxTroop = Hex(0xFFC360, 6)
Global Const $sStarColorBG = Hex(0xD3D3CB, 6)
Global Const $aiStarCloseDefaultPOS[2] = [706,143]
Func StarLaboratory($bTestRun = False)
If Not $g_bAutoStarLabUpgradeEnable Then Return
Local $aUpgradeValue[11] = [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $iAvailElixir, $sElixirCount, $TimeDiff, $aArray, $Result, $aSearchForTroop
Local $iXMoved = 0, $iYMoved = 0, $iFirstPageOffset = 0, $iLastPageOffset = 0
Local $iSelectedUpgrade = $g_iCmbStarLaboratory
If $g_sStarLabUpgradeTime <> "" Then $TimeDiff = _DateDiff("n", _NowCalc(), $g_sStarLabUpgradeTime)
If @error Then _logErrorDateDiff(@error)
If $g_bDebugSetlog Then SetDebugLog($g_avStarLabTroops[$g_iCmbStarLaboratory][3] & " Lab end time: " & $g_sStarLabUpgradeTime & ", DIFF= " & $TimeDiff, $COLOR_DEBUG)
If Not $g_bRunState Then Return
If $TimeDiff <= 0 Then
SetLog("Checking Troop Upgrade in Star Laboratory", $COLOR_INFO)
Else
SetLog("Star Laboratory Upgrade in progress, waiting for completion", $COLOR_INFO)
Return False
EndIf
$sElixirCount = getResourcesMainScreen(705, 74)
SetLog("Updating village values [E]: " & $sElixirCount, $COLOR_SUCCESS)
$iAvailElixir = Number($sElixirCount)
If Not LocateStarLab() Then Return False
Local $aResearchButton = findButton("Research", Default, 1, True)
If IsArray($aResearchButton) And UBound($aResearchButton, 1) = 2 Then
If $g_bDebugImageSave Then DebugImageSave("StarLabUpgrade")
ClickP($aResearchButton)
If _Sleep($DELAYLABORATORY1) Then Return
Else
SetLog("Cannot find the Star Laboratory Research Button!", $COLOR_ERROR)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
Return False
EndIf
Local $aiCloseBtn = findButton("CloseWindow")
If IsArray($aiCloseBtn) Then
$iXMoved = $aiCloseBtn[0] - $aiStarCloseDefaultPOS[0]
$iYMoved = $aiCloseBtn[1] - $aiStarCloseDefaultPOS[1]
If $g_bDebugSetlog Then Setlog("Lab window off: (" & $iXMoved & ", " & $iYMoved & ")", $COLOR_DEBUG)
Else
SetLog("Trouble finding lab close button, try again...", $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0199")
Return False
EndIf
If $g_bDebugSetlog Then SetLog("_GetPixelColor(" & 720 + $iXMoved & "," & 190 + $iYMoved & "): " & _GetPixelColor(720 + $iXMoved, 190 + $iYMoved, True) & ":A2CB6C", $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(720 + $iXMoved, 190 + $iYMoved, True), Hex(0xA2CB6C, 6), 20) Then
SetLog("Laboratory Upgrade in progress, waiting for completion", $COLOR_INFO)
If _Sleep($DELAYLABORATORY2) Then Return
Local $sLabTimeOCR = getRemainTLaboratory(260 + $iXMoved, 257 + $iYMoved)
Local $iLabFinishTime = ConvertOCRTime("Lab Time", $sLabTimeOCR, False)
SetDebugLog("$sLabTimeOCR: " & $sLabTimeOCR & ", $iLabFinishTime = " & $iLabFinishTime & " m")
If $iLabFinishTime > 0 Then
$g_sStarLabUpgradeTime = _DateAdd('n', Ceiling($iLabFinishTime), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog("Research will finish in " & $sLabTimeOCR & " (" & $g_sStarLabUpgradeTime & ")")
LabStatusGUIUpdate()
ElseIf $g_bDebugSetlog Then
SetLog("Invalid getRemainTLaboratory OCR", $COLOR_DEBUG)
EndIf
ClickP($aAway, 2, $DELAYLABORATORY4, "#0328")
Return False
EndIf
For $i = 1 to UBound($g_avStarLabTroops) - 1
$g_avStarLabTroops[$i][0] = -1
$g_avStarLabTroops[$i][1] = -1
Next
$aSearchForTroop = decodeMultipleCoords(findImage("TroopPositions", $g_sImgStarLabElex, GetDiamondFromRect("100,375,730,575"), 0, True, Default))
If IsArray($aSearchForTroop) And UBound($aSearchForTroop, 1) > 0 Then
For $i = 0 To UBound($aSearchForTroop) - 1
Local $aTempArray = $aSearchForTroop[$i]
If IsArray($aTempArray) And UBound($aTempArray) = 2 Then
Local $iCurrentTroop = 2 * Int(($aTempArray[0] - 160) / 103) + Int(($aTempArray[1] - 375) / 100) + 1
$g_avStarLabTroops[$iCurrentTroop][0] = $aTempArray[0] - 80
$g_avStarLabTroops[$iCurrentTroop][1] = $aTempArray[1] - 82
If $g_bDebugSetlog Then
Setlog("New icon X position of " & $g_avStarLabTroops[$iCurrentTroop][3] & " : " & $g_avStarLabTroops[$iCurrentTroop][0], $COLOR_DEBUG)
Setlog("New icon Y position of " & $g_avStarLabTroops[$iCurrentTroop][3] & " : " & $g_avStarLabTroops[$iCurrentTroop][1], $COLOR_DEBUG)
EndIf
EndIf
Next
Else
SetLog("No upgradable troop found!", $COLOR_ERROR)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0328")
Return False
EndIf
If $g_bDebugSetlog Then StarLabTroopImages(1, 10)
For $i = 1 To 10
If $g_avStarLabTroops[$i][0] = -1 Or $g_avStarLabTroops[$i][1] = -1 Then
$aUpgradeValue[$i] = -1
If $g_bDebugSetlog Then SetLog($g_avStarLabTroops[$i][3] & " is not upgradeable, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
Else
$aUpgradeValue[$i] = getStarLabUpgrdResourceRed($g_avStarLabTroops[$i][0] + 2, $g_avStarLabTroops[$i][1] + 74)
If $g_bDebugSetlog Then SetLog($g_avStarLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or Int($aUpgradeValue[$i]) < 3000 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($g_avStarLabTroops[$i][0] + 2, $g_avStarLabTroops[$i][1] + 74)
If $g_bDebugSetlog Then SetLog($g_avStarLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or Int($aUpgradeValue[$i]) < 3000 Then
$aUpgradeValue[$i] = 0
If $g_bDebugSetlog Then SetLog("Failed to read cost of " & $g_avStarLabTroops[$i][3], $COLOR_DEBUG)
StarLabTroopImages($i, $i)
EndIf
EndIf
If Not $g_bRunState Then Return
$aUpgradeValue[$i] = Number($aUpgradeValue[$i])
Next
If $aUpgradeValue[$g_iCmbStarLaboratory] = -1 Then
Local $iCheapestCost = 0
If $g_iCmbStarLaboratory = 0 Then
SetLog("No dedicated troop for upgrade selected.", $COLOR_INFO)
Else
SetLog("No upgrade for " & $g_avStarLabTroops[$g_iCmbStarLaboratory][3] & " available.", $COLOR_INFO)
EndIf
For $i = 1 To 10
If $aUpgradeValue[$i] > 0 Then
If $g_bDebugSetlog Then SetLog($g_avStarLabTroops[$i][3] & " is upgradeable, Value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $iCheapestCost = 0 Or $aUpgradeValue[$i] < $iCheapestCost Then
$iSelectedUpgrade = $i
$iCheapestCost = $aUpgradeValue[$i]
EndIf
EndIf
Next
If $g_iCmbStarLaboratory = $iSelectedUpgrade Then
SetLog("No alternate troop for upgrade found", $COLOR_WARNING)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0353")
Return False
Else
SetLog($g_avStarLabTroops[$iSelectedUpgrade][3] & " selected for upgrade, upgrade cost = " & $aUpgradeValue[$iSelectedUpgrade], $COLOR_INFO)
EndIf
EndIf
If $iAvailElixir < $aUpgradeValue[$iSelectedUpgrade] Then
SetLog("Insufficent Elixir for " & $g_avStarLabTroops[$iSelectedUpgrade][3] & ", Lab requires: " & $aUpgradeValue[$iSelectedUpgrade] & ", available: " & $iAvailElixir, $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0355")
Return False
ElseIf StarLabUpgrade($iSelectedUpgrade, $iXMoved, $iYMoved, $bTestRun) = True Then
SetLog("Elixir used = " & $aUpgradeValue[$iSelectedUpgrade], $COLOR_INFO)
ClickP($aAway, 2, $DELAYLABORATORY4, "#0356")
Return True
EndIf
ClickP($aAway, 2, $DELAYLABORATORY4, "#0359")
Return False
EndFunc
Func StarLabUpgrade($iSelectedUpgrade, $iXMoved = 0, $iYMoved = 0, $bTestRun = False)
Local $StartTime, $EndTime, $EndPeriod, $Result, $TimeAdd = 0
Select
Case _ColorCheck(_GetPixelColor($g_avStarLabTroops[$iSelectedUpgrade][0] + 47, $g_avStarLabTroops[$iSelectedUpgrade][1] + 1, True), $sStarColorNA, 20) = True
SetLog($g_avStarLabTroops[$iSelectedUpgrade][3] & " not unlocked yet, select another troop", $COLOR_WARNING)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _PixelSearch($g_avStarLabTroops[$iSelectedUpgrade][0] + 66, $g_avStarLabTroops[$iSelectedUpgrade][1] + 79, $g_avStarLabTroops[$iSelectedUpgrade][0] + 68, $g_avStarLabTroops[$iSelectedUpgrade][1] + 82, $sStarColorNoLoot, 20) <> 0
SetLog("Value check error and Not enough Loot to upgrade " & $g_avStarLabTroops[$iSelectedUpgrade][3] & "...", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _ColorCheck(_GetPixelColor($g_avStarLabTroops[$iSelectedUpgrade][0] + 22, $g_avStarLabTroops[$iSelectedUpgrade][1] + 60, True), Hex(0xFFC360, 6), 20) = True
SetLog($g_avStarLabTroops[$iSelectedUpgrade][3] & " already max level, select another troop", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case _ColorCheck(_GetPixelColor($g_avStarLabTroops[$iSelectedUpgrade][0] + 3, $g_avStarLabTroops[$iSelectedUpgrade][1] + 19, True), Hex(0xB7B7B7, 6), 20) = True
SetLog("Laboratory upgrade not available now for " & $g_avStarLabTroops[$iSelectedUpgrade][3] & "...", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
Case Else
Click($g_avStarLabTroops[$iSelectedUpgrade][0] + 40, $g_avStarLabTroops[$iSelectedUpgrade][1] + 40, 1, 0, "#0200")
If _Sleep($DELAYLABUPGRADE1) Then Return
If $g_bDebugImageSave Then DebugImageSave("StarLabUpgrade")
If _ColorCheck(_GetPixelColor(258 + $iXMoved, 192 + $iYMoved, True), Hex(0xFF1919, 6), 20) And _ColorCheck(_GetPixelColor(272 + $iXMoved, 194 + $iYMoved, True), Hex(0xFF1919, 6), 20) Then
SetLog($g_avStarLabTroops[$iSelectedUpgrade][3] & " Previously maxxed, select another troop", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0201")
Return False
EndIf
If _PixelSearch($g_avStarLabTroops[$iSelectedUpgrade][0] + 67, $g_avStarLabTroops[$iSelectedUpgrade][1] + 79, $g_avStarLabTroops[$iSelectedUpgrade][0] + 69, $g_avStarLabTroops[$iSelectedUpgrade][0] + 84, $sStarColorNoLoot, 20) <> 0 Then
SetLog("Missing Loot to upgrade " & $g_avStarLabTroops[$iSelectedUpgrade][3] & " (secondary check after Upgrade Value read failed)", $COLOR_ERROR)
If _Sleep($DELAYLABUPGRADE2) Then Return
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0333")
Return False
EndIf
If _ColorCheck(_GetPixelColor(625 + $iXMoved, 250 + $g_iMidOffsetY + $iYMoved, True), Hex(0x848484, 6), 20) And _ColorCheck(_GetPixelColor(660 + $iXMoved, 250 + $g_iMidOffsetY + $iYMoved, True), Hex(0x848484, 6), 20) Then
SetLog("Upgrade in progress, waiting for completion of other troops", $COLOR_WARNING)
If _Sleep($DELAYLABORATORY2) Then Return
ClickP($aAway, 2, $DELAYLABORATORY4, "#0000")
Return False
Else
$Result = getLabUpgradeTime(554 + $iXMoved, 491 + $iYMoved)
Local $iLabFinishTime = ConvertOCRTime("Lab Time", $Result, False)
SetLog($g_avStarLabTroops[$iSelectedUpgrade][3] & " Upgrade OCR Time = " & $Result & ", $iLabFinishTime = " & $iLabFinishTime & " m", $COLOR_INFO)
$StartTime = _NowCalc()
If $g_bDebugSetlog Then SetDebugLog($g_avStarLabTroops[$iSelectedUpgrade][3] & " Upgrade Started @ " & $StartTime, $COLOR_SUCCESS)
If $iLabFinishTime > 0 Then
$g_sStarLabUpgradeTime = _DateAdd('n', Ceiling($iLabFinishTime), $StartTime)
SetLog($g_avStarLabTroops[$iSelectedUpgrade][3] & " Upgrade Finishes @ " & $Result & " (" & $g_sStarLabUpgradeTime & ")", $COLOR_SUCCESS)
Else
SetLog("Error processing upgrade time required, try again!", $COLOR_WARNING)
Return False
EndIf
If Not $bTestRun Then Click(645 + $iXMoved, 530 + $g_iMidOffsetY + $iYMoved, 1, 0, "#0202")
If _Sleep($DELAYLABUPGRADE1) Then Return
EndIf
If isGemOpen(True) = False Then
If Not(_ColorCheck(_GetPixelColor(625 + $iXMoved, 218 + $g_iMidOffsetY + $iYMoved, True), Hex(0x6fbd1f, 6), 15) Or _ColorCheck(_GetPixelColor(660 + $iXMoved, 218 + $g_iMidOffsetY + $iYMoved, True), Hex(0x6fbd1f, 6), 15)) Then
SetLog("Something went wrong with " & $g_avStarLabTroops[$iSelectedUpgrade][3] & " Upgrade, try again.", $COLOR_ERROR)
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0360")
Return False
EndIf
SetLog("Upgrade " & $g_avStarLabTroops[$iSelectedUpgrade][3] & " in your star laboratory started with success...", $COLOR_SUCCESS)
StarLabStatusGUIUpdate()
PushMsg("StarLabSuccess")
If _Sleep($DELAYLABUPGRADE2) Then Return
ClickP($aAway, 2, 0, "#0204")
Return True
Else
SetLog("Oops, Gems required for " & $g_avStarLabTroops[$iSelectedUpgrade][3] & " Upgrade, try again.", $COLOR_ERROR)
EndIf
EndSelect
ClickP($aAway, 2, $DELAYLABUPGRADE3, "#0205")
Return False
EndFunc
Func StarDebugIconSave($sTxtName = "Unknown", $iLeft = 0, $iTop = 0)
SetLog("Taking debug icon snapshot for later review", $COLOR_SUCCESS)
Local $iIconLength = 94
Local $Date = @MDAY & "_" & @MON & "_" & @YEAR
Local $Time = @HOUR & "_" & @MIN & "_" & @SEC
Local $sName = $g_sProfileTempDebugPath & "StarLabUpgrade\" & $sTxtName & "_" & $Date & "_" & $Time & ".png"
DirCreate($g_sProfileTempDebugPath & "StarLabUpgrade\")
ForceCaptureRegion()
_CaptureRegion($iLeft, $iTop, $iLeft + $iIconLength, $iTop + $iIconLength)
_GDIPlus_ImageSaveToFile($g_hBitmap, $sName)
If @error Then SetLog("DebugIconSave failed to save StarLabUpgrade image: " & $sName, $COLOR_WARNING)
If _Sleep($DELAYLABORATORY2) Then Return
EndFunc
Func StarLabTroopImages($iStart, $iEnd)
If $g_bDebugImageSave Then DebugImageSave("StarLabUpgrade")
For $i = $iStart To $iEnd
If $g_avStarLabTroops[$i][0] <> -1 And $g_avStarLabTroops[$i][1] <> -1 Then
StarDebugIconSave($g_avStarLabTroops[$i][3], $g_avStarLabTroops[$i][0], $g_avStarLabTroops[$i][1])
SetDebugLog($g_avStarLabTroops[$i][3], $COLOR_WARNING)
SetDebugLog("_GetPixelColor(+47, +1): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 47, $g_avStarLabTroops[$i][1] + 1, True) & ":" & $sStarColorNA & " =Not unlocked", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+67, +79): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 67, $g_avStarLabTroops[$i][1] + 79, True) & ":" & $sStarColorNoLoot & " =No Loot1", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+67, +82): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 67, $g_avStarLabTroops[$i][1] + 82, True) & ":" & $sStarColorNoLoot & " =No Loot2", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+81, +82): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 81, $g_avStarLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+76, +76): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 76, $g_avStarLabTroops[$i][1] + 76, True) & ":" & $sStarColorMaxLvl & " =Max L", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+76, +80): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 76, $g_avStarLabTroops[$i][1] + 80, True) & ":" & $sStarColorMaxLvl & " =Max L", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+0, +20): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 0, $g_avStarLabTroops[$i][1] + 20, True) & ":" & $sStarColorLabUgReq & " =Lab Upgrade", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+93, +20): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 93, $g_avStarLabTroops[$i][1] + 20, True) & ":" & $sStarColorLabUgReq & " =Lab Upgrade", $COLOR_DEBUG)
SetDebugLog("_GetPixelColor(+23, +60): " & _GetPixelColor($g_avStarLabTroops[$i][0] + 23, $g_avStarLabTroops[$i][1] + 60, True) & ":" & $sStarColorMaxTroop & " =Max troop", $COLOR_DEBUG)
EndIf
Next
EndFunc
Func LocateStarLab()
ZoomOut()
If $g_aiStarLaboratoryPos[0] > 0 And $g_aiStarLaboratoryPos[1] > 0 Then
BuildingClickP($g_aiStarLaboratoryPos, "#0197")
If _Sleep($DELAYLABORATORY1) Then Return
Local $aResult = BuildingInfo(245, 491 + $g_iBottomOffsetY)
If $aResult[0] = 2 Then
If StringInStr($aResult[1], "Lab") = True Then
SetLog("Star Laboratory located.", $COLOR_INFO)
SetLog("It reads as Level " & $aResult[2] & ".", $COLOR_INFO)
Return True
Else
ClickP($aAway, 1, 0, "#0931")
SetDebugLog("Stored Star Laboratory Position is not valid.", $COLOR_ERROR)
SetDebugLog("Found instead: " & $aResult[1] & ", " & $aResult[2] & " !", $COLOR_DEBUG)
SetDebugLog("Village position: " & $g_aiStarLaboratoryPos[0] & ", " & $g_aiStarLaboratoryPos[1], $COLOR_DEBUG, True)
ConvertToVillagePos($g_aiStarLaboratoryPos[0],$g_aiStarLaboratoryPos[1])
SetDebugLog("Real position: " & $g_aiStarLaboratoryPos[0] & ", " & $g_aiStarLaboratoryPos[1], $COLOR_DEBUG, True)
$g_aiStarLaboratoryPos[0] = -1
$g_aiStarLaboratoryPos[1] = -1
EndIf
Else
ClickP($aAway, 1, 0, "#0932")
SetDebugLog("Stored Star Laboratory Position is not valid.", $COLOR_ERROR)
SetDebugLog("Village position: " & $g_aiStarLaboratoryPos[0] & ", " & $g_aiStarLaboratoryPos[1], $COLOR_DEBUG, True)
ConvertToVillagePos($g_aiStarLaboratoryPos[0],$g_aiStarLaboratoryPos[1])
SetDebugLog("Real position: " & $g_aiStarLaboratoryPos[0] & ", " & $g_aiStarLaboratoryPos[1], $COLOR_DEBUG, True)
$g_aiStarLaboratoryPos[0] = -1
$g_aiStarLaboratoryPos[1] = -1
EndIf
EndIf
SetLog("Looking for Star Laboratory...", $COLOR_ACTION)
Local $sCocDiamond = "FV"
Local $sRedLines = $sCocDiamond
Local $iMinLevel = 0
Local $iMaxLevel = 1000
Local $iMaxReturnPoints = 1
Local $sReturnProps = "objectname,objectpoints"
Local $bForceCapture = True
Local $aResult = findMultiple($g_sImgStarLaboratory, $sCocDiamond, $sRedLines, $iMinLevel, $iMaxLevel, $iMaxReturnPoints, $sReturnProps, $bForceCapture)
If IsArray($aResult) And UBound($aResult) > 0 Then
For $i = 0 To UBound($aResult) - 1
If _Sleep(50) Then Return
If Not $g_bRunState Then Return
SetDebugLog(_ArrayToString($aResult[$i]))
Local $aTEMP = $aResult[$i]
Local $sObjectname = String($aTEMP[0])
SetDebugLog("Image name: " & String($aTEMP[0]), $COLOR_INFO)
Local $aObjectpoints = $aTEMP[1]
SetDebugLog("Object points: " & String($aTEMP[1]), $COLOR_INFO)
If StringInStr($aObjectpoints, "|") Then
$aObjectpoints = StringReplace($aObjectpoints, "||", "|")
Local $sString = StringRight($aObjectpoints, 1)
If $sString = "|" Then $aObjectpoints = StringTrimRight($aObjectpoints, 1)
Local $tempObbjs = StringSplit($aObjectpoints, "|", $STR_NOCOUNT)
For $j = 0 To UBound($tempObbjs) - 1
Local $tempObbj = StringSplit($tempObbjs[$j], ",", $STR_NOCOUNT)
If UBound($tempObbj) = 2 Then
$g_aiStarLaboratoryPos[0] = Number($tempObbj[0]) + 9
$g_aiStarLaboratoryPos[1] = Number($tempObbj[1]) + 15
ConvertFromVillagePos($g_aiStarLaboratoryPos[0],$g_aiStarLaboratoryPos[1])
ExitLoop 2
EndIf
Next
Else
Local $tempObbj = StringSplit($aObjectpoints, ",", $STR_NOCOUNT)
If UBound($tempObbj) = 2 Then
$g_aiStarLaboratoryPos[0] = Number($tempObbj[0]) + 9
$g_aiStarLaboratoryPos[1] = Number($tempObbj[1]) + 15
ConvertFromVillagePos($g_aiStarLaboratoryPos[0],$g_aiStarLaboratoryPos[1])
ExitLoop
EndIf
EndIf
Next
EndIf
If $g_aiStarLaboratoryPos[0] > 0 And $g_aiStarLaboratoryPos[1] > 0 Then
BuildingClickP($g_aiStarLaboratoryPos, "#0197")
If _Sleep($DELAYLABORATORY1) Then Return
Local $aResult = BuildingInfo(245, 491 + $g_iBottomOffsetY)
If $aResult[0] = 2 Then
If StringInStr($aResult[1], "Lab") = True Then
SetLog("Star Laboratory located.", $COLOR_INFO)
SetLog("It reads as Level " & $aResult[2] & ".", $COLOR_INFO)
Return True
Else
ClickP($aAway, 1, 0, "#0931")
SetDebugLog("Found Star Laboratory Position is not valid.", $COLOR_ERROR)
SetDebugLog("Found instead: " & $aResult[1] & ", " & $aResult[2] & " !", $COLOR_DEBUG)
SetDebugLog("Village position: " & $g_aiStarLaboratoryPos[0] & ", " & $g_aiStarLaboratoryPos[1], $COLOR_DEBUG, True)
ConvertToVillagePos($g_aiStarLaboratoryPos[0],$g_aiStarLaboratoryPos[1])
SetDebugLog("Real position: " & $g_aiStarLaboratoryPos[0] & ", " & $g_aiStarLaboratoryPos[1], $COLOR_DEBUG, True)
$g_aiStarLaboratoryPos[0] = -1
$g_aiStarLaboratoryPos[1] = -1
EndIf
Else
ClickP($aAway, 1, 0, "#0932")
SetDebugLog("Found Star Laboratory Position is not valid.", $COLOR_ERROR)
SetDebugLog("Village position: " & $g_aiStarLaboratoryPos[0] & ", " & $g_aiStarLaboratoryPos[1], $COLOR_DEBUG, True)
ConvertToVillagePos($g_aiStarLaboratoryPos[0],$g_aiStarLaboratoryPos[1])
SetDebugLog("Real position: " & $g_aiStarLaboratoryPos[0] & ", " & $g_aiStarLaboratoryPos[1], $COLOR_DEBUG, True)
$g_aiStarLaboratoryPos[0] = -1
$g_aiStarLaboratoryPos[1] = -1
EndIf
EndIf
SetLog("Can not find Star Laboratory.", $COLOR_ERROR)
Return False
EndFunc
Global $tagSTRUCT_BOT_STATE = "struct" & ";hwnd BotHWnd" & ";hwnd AndroidHWnd" & ";boolean RunState" & ";boolean Paused" & ";boolean Launched" & ";uint64 g_hTimerSinceStarted" & ";uint g_iTimePassed" & ";char Profile[64]" & ";char AndroidEmulator[32]" & ";char AndroidInstance[32]" & ";int StructType" & ";ptr StructPtr" & ";boolean RegisterInHost" & ";endstruct"
Global Enum $g_eSTRUCT_NONE = 0, $g_eSTRUCT_STATUS_BAR, $g_eSTRUCT_UPDATE_STATS
Global $tagSTRUCT_STATUS_BAR = "struct;char Text[255];endstruct"
Global $tagSTRUCT_UPDATE_STATS = "struct" & ";long g_aiCurrentLoot[" & UBound($g_aiCurrentLoot) & "]" & ";long g_iFreeBuilderCount" & ";long g_iTotalBuilderCount" & ";long g_iGemAmount" & ";long g_iStatsTotalGain[" & UBound($g_iStatsTotalGain) & "]" & ";long g_iStatsLastAttack[" & UBound($g_iStatsLastAttack) & "]" & ";long g_iStatsBonusLast[" & UBound($g_iStatsBonusLast) & "]" & ";int g_iFirstAttack" & ";int g_aiAttackedCount" & ";int g_iSkippedVillageCount" & ";endstruct"
Global $tBotState = DllStructCreate($tagSTRUCT_BOT_STATE)
Global $tStatusBar = DllStructCreate($tagSTRUCT_STATUS_BAR)
Global $tUpdateStats = DllStructCreate($tagSTRUCT_UPDATE_STATS)
Global $API_VERSION = "1.1"
Global $sWatchdogMutex = "MyBot.run/ManageFarm/" & $API_VERSION
Global $WM_MYBOTRUN_API = _WinAPI_RegisterWindowMessage("MyBot.run/API/" & $API_VERSION)
SetDebugLog("MyBot.run/API/1.1 Message ID = " & $WM_MYBOTRUN_API)
Global $WM_MYBOTRUN_STATE = _WinAPI_RegisterWindowMessage("MyBot.run/STATE/" & $API_VERSION)
SetDebugLog("MyBot.run/STATE/1.1 Message ID = " & $WM_MYBOTRUN_STATE)
Func _DllStructSetData(ByRef $Struct, $Element, $value, $index = Default)
If IsArray($value) Then
Local $Result[UBound($value)]
For $i = 0 To UBound($value) - 1
$Result[$i] = DllStructSetData($Struct, $Element, $value[$i], $i + 1)
Next
Return $Result
Else
Return DllStructSetData($Struct, $Element, $value, $index)
EndIf
EndFunc
Global $g_ahManagedMyBotHosts[0]
GUIRegisterMsg($WM_MYBOTRUN_API, "WM_MYBOTRUN_API_CLIENT")
Func WM_MYBOTRUN_API_CLIENT($hWind, $iMsg, $wParam, $lParam)
If $hWind <> $g_hFrmBot Then Return 0
If $g_iDebugWindowMessages Then SetDebugLog("API-CLIENT: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam)
$hWind = HWnd($lParam)
Local $wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
If IsBotLaunched() Then $wParamHi += 4
Local $wParamLo = BitAND($wParam, 0xFFFF)
Local $bRegisterHost = True
Switch $wParamLo
Case 0x0000 To 0x00FF
$lParam = $g_hFrmBot
Local $iActiveBots = BitAND($wParam, 0xFF)
If $iActiveBots < 255 Then
If $g_BotInstanceCount <> $iActiveBots Then SetDebugLog($iActiveBots & " running bot instances detected")
$g_BotInstanceCount = $iActiveBots
Else
$bRegisterHost = False
EndIf
$wParam = 1
$wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
If IsBotLaunched() Then $wParamHi += 4
$wParam += BitShift($wParamHi, -16)
Case 0x0100 To 0x01FF
Local $iActiveBots = BitAND($wParam, 0xFF)
If $iActiveBots < 255 Then
If $g_BotInstanceCount <> $iActiveBots Then SetDebugLog($iActiveBots & " running bot instances detected")
$g_BotInstanceCount = $iActiveBots
EndIf
$iMsg = $WM_MYBOTRUN_STATE
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
$bRegisterHost = $wParamLo < 0x01FF
PrepareStructBotState($tBotState, Default, Default, $bRegisterHost)
Case 0x0200
If $g_iFirstRun = 0 Then
PrepareUpdateStatsManagedMyBotHost($hWind, $iMsg, $wParam, $lParam)
Else
$iMsg = $WM_MYBOTRUN_STATE
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
PrepareStructBotState($tBotState)
EndIf
Case 0x1000
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
If $g_bRunState = False Then
$wParamHi = 1
If IsBotLaunched() Then $wParamHi += 4
btnStart()
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1010
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
If $g_bRunState = True Then
$wParamHi = 0
If IsBotLaunched() Then $wParamHi += 4
btnStop()
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1020
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
If $g_bBotPaused = True And $g_bRunState = True Then
$wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If IsBotLaunched() Then $wParamHi += 4
TogglePauseImpl("ManageFarm")
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1030
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
If $g_bBotPaused = False And $g_bRunState = True Then
$wParamHi = 2
If $g_bRunState = True Then $wParamHi += 1
If IsBotLaunched() Then $wParamHi += 4
TogglePauseImpl("ManageFarm", True)
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1040
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
$wParamHi = 0
BotCloseRequest()
$wParam += BitShift($wParamHi, -16)
Case 0x1050
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
$wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
If IsBotLaunched() Then $wParamHi += 4
btnMakeScreenshot()
$wParam += BitShift($wParamHi, -16)
Case 0x1060
$lParam = $g_hFrmBot
$wParam = $wParamLo + 1
$wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
If IsBotLaunched() Then $wParamHi += 4
Local $pid = WinGetProcess($hWind)
If $pid <> 0 And $pid <> -1 Then
$g_iGuiPID = $pid
SetBotGuiPID($pid)
EndIf
$wParam += BitShift($wParamHi, -16)
Case Else
$hWind = 0
EndSwitch
If Not IsBotLaunched() Then
$hWind = 0
EndIf
If $hWind <> 0 Then
Local $a = GetManagedMyBotHost($hWind, True, $bRegisterHost)
_WinAPI_PostMessage($hWind, $iMsg, $wParam, $lParam)
EndIf
Return 1
EndFunc
Func GetManagedMyBotHost($hFrmHost = Default, $bUpdateTime = False, $bRegisterHost = True)
If $hFrmHost = Default Then
Return $g_ahManagedMyBotHosts
EndIf
If IsHWnd($hFrmHost) = 0 Then Return -1
For $i = 0 To UBound($g_ahManagedMyBotHosts) - 1
Local $a = $g_ahManagedMyBotHosts[$i]
If $a[0] = $hFrmHost Then
If $bUpdateTime Then
$a[1] = __TimerInit()
$g_ahManagedMyBotHosts[$i] = $a
EndIf
Return $a
EndIf
Next
Local $a[2]
$a[0] = $hFrmHost
If $bUpdateTime Then $a[1] = __TimerInit()
If $bRegisterHost Then
Local $i = UBound($g_ahManagedMyBotHosts)
ReDim $g_ahManagedMyBotHosts[$i + 1]
$g_ahManagedMyBotHosts[$i] = $a
SetDebugLog("New Bot Host Window Handle registered: " & $hFrmHost)
EndIf
Return $a
EndFunc
Func LaunchWatchdog()
Local $hMutex = CreateMutex($sWatchdogMutex)
If $hMutex = 0 Then
SetDebugLog("Watchdog already running")
Return 0
EndIf
ReleaseMutex($hMutex)
Local $cmd = """" & @ScriptDir & "\MyBot.run.Watchdog.exe"""
If @Compiled = 0 Then $cmd = """" & @AutoItExe & """ /AutoIt3ExecuteScript """ & @ScriptDir & "\MyBot.run.Watchdog.au3" & """"
If $g_iBotLaunchOption_Console Then $cmd &= " /console"
Local $pid = Run($cmd, @ScriptDir)
If $pid = 0 Then
SetLog("Cannot launch watchdog", $COLOR_RED)
Return 0
EndIf
If $g_bDebugSetlog Then
SetDebugLog("Watchdog launched, PID = " & $pid)
Else
SetLog("Watchdog launched")
EndIf
Return $pid
EndFunc
Func PrepareStructBotState(ByRef $tBotState, $eStructType = Default, $pStructPtr = Default, $bRegisterInHost = True)
If $eStructType = Default Then $eStructType = $g_eSTRUCT_NONE
If $pStructPtr = Default Then $pStructPtr = 0
DllStructSetData($tBotState, "BotHWnd", $g_hFrmBot)
DllStructSetData($tBotState, "AndroidHWnd", $g_hAndroidWindow)
DllStructSetData($tBotState, "RunState", $g_bRunState)
DllStructSetData($tBotState, "Paused", $g_bBotPaused)
DllStructSetData($tBotState, "Launched", IsBotLaunched())
DllStructSetData($tBotState, "g_hTimerSinceStarted", $g_hTimerSinceStarted)
DllStructSetData($tBotState, "g_iTimePassed", $g_iTimePassed)
DllStructSetData($tBotState, "Profile", $g_sProfileCurrentName)
DllStructSetData($tBotState, "AndroidEmulator", $g_sAndroidEmulator)
DllStructSetData($tBotState, "AndroidInstance", $g_sAndroidInstance)
DllStructSetData($tBotState, "StructType", $eStructType)
DllStructSetData($tBotState, "StructPtr", $pStructPtr)
DllStructSetData($tBotState, "RegisterInHost", $bRegisterInHost)
EndFunc
Func PrepareStatusBarManagedMyBotHost($hFrmHost, ByRef $iMsg, ByRef $wParam, ByRef $lParam, $sStatusBar)
$iMsg = $WM_MYBOTRUN_STATE
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
DllStructSetData($tStatusBar, "Text", $sStatusBar)
PrepareStructBotState($tBotState, $g_eSTRUCT_STATUS_BAR, DllStructGetPtr($tStatusBar))
If $g_iDebugWindowMessages Then SetDebugLog("PrepareStatusBarManagedMyBotHost: $hFrmHost=" & $hFrmHost & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ",$sStatusBar=" & $sStatusBar)
Return True
EndFunc
Func StatusBarManagedMyBotHost($sStatusBar)
Return ManagedMyBotHostsPostMessage("PrepareStatusBarManagedMyBotHost", $sStatusBar)
EndFunc
Func PrepareUpdateStatsManagedMyBotHost($hFrmHost, ByRef $iMsg, ByRef $wParam, ByRef $lParam)
$iMsg = $WM_MYBOTRUN_STATE
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
_DllStructSetData($tUpdateStats, "g_aiCurrentLoot", $g_aiCurrentLoot)
_DllStructSetData($tUpdateStats, "g_iFreeBuilderCount", $g_iFreeBuilderCount)
_DllStructSetData($tUpdateStats, "g_iTotalBuilderCount", $g_iTotalBuilderCount)
_DllStructSetData($tUpdateStats, "g_iGemAmount", $g_iGemAmount)
_DllStructSetData($tUpdateStats, "g_iStatsTotalGain", $g_iStatsTotalGain)
_DllStructSetData($tUpdateStats, "g_iStatsLastAttack", $g_iStatsLastAttack)
_DllStructSetData($tUpdateStats, "g_iStatsBonusLast", $g_iStatsBonusLast)
_DllStructSetData($tUpdateStats, "g_iFirstAttack", $g_iFirstAttack)
_DllStructSetData($tUpdateStats, "g_aiAttackedCount", $g_aiAttackedCount)
_DllStructSetData($tUpdateStats, "g_iSkippedVillageCount", $g_iSkippedVillageCount)
PrepareStructBotState($tBotState, $g_eSTRUCT_UPDATE_STATS, DllStructGetPtr($tUpdateStats))
If $g_iDebugWindowMessages Then SetDebugLog("PrepareUpdateStatsManagedMyBotHost: $hFrmHost=" & $hFrmHost & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam)
Return True
EndFunc
Func UpdateStatsManagedMyBotHost()
Return ManagedMyBotHostsPostMessage("PrepareUpdateStatsManagedMyBotHost")
EndFunc
Func PrepareUnregisterManagedMyBotHost($hFrmHost, ByRef $iMsg, ByRef $wParam, ByRef $lParam)
$wParam = 0x1040 + 2
SetDebugLog("Bot Host Window Handle un-registered: " & $hFrmHost)
Return True
EndFunc
Func UnregisterManagedMyBotHost()
Local $Result = ManagedMyBotHostsPostMessage("PrepareUnregisterManagedMyBotHost")
ReDim $g_ahManagedMyBotHosts[0]
Return $Result
EndFunc
Func ManagedMyBotHostsPostMessage($sExecutePrepare, $Value1 = Default, $Value2 = Default, $Value3 = Default)
Local $sAdditional = ""
If $Value1 <> Default Or $Value2 <> Default Or $Value3 <> Default Then
If $Value3 <> Default Then
$sAdditional = ", $Value3"
EndIf
If $Value2 <> Default Then
$sAdditional = ", $Value2" & $sAdditional
ElseIf $sAdditional <> "" Then
$sAdditional = ", Default" & $sAdditional
EndIf
If $Value1 <> Default Then
$sAdditional = ", $Value1" & $sAdditional
ElseIf $sAdditional <> "" Then
$sAdditional = ", Default" & $sAdditional
EndIf
EndIf
For $i = 0 To UBound($g_ahManagedMyBotHosts) - 1
Local $a = $g_ahManagedMyBotHosts[$i]
Local $hFrmHost = $a[0]
$g_ahManagedMyBotHosts[$i] = $a
If IsHWnd($hFrmHost) Then
Local $iMsg = $WM_MYBOTRUN_API
Local $wParam = 0x0000
Local $lParam = $g_hFrmBot
Local $sExecute = $sExecutePrepare & "($hFrmHost, $iMsg, $wParam, $lParam" & $sAdditional & ")"
Local $bPostMessage
Switch $sExecutePrepare
Case "PrepareStatusBarManagedMyBotHost"
$bPostMessage = PrepareStatusBarManagedMyBotHost($hFrmHost, $iMsg, $wParam, $lParam, $Value1)
Case "PrepareUpdateStatsManagedMyBotHost"
$bPostMessage = PrepareUpdateStatsManagedMyBotHost($hFrmHost, $iMsg, $wParam, $lParam)
Case "PrepareUnregisterManagedMyBotHost"
$bPostMessage = PrepareUnregisterManagedMyBotHost($hFrmHost, $iMsg, $wParam, $lParam)
Case Else
$bPostMessage = Execute($sExecute)
EndSwitch
If @error <> 0 And $bPostMessage = "" Then
SetDebugLog("ManagedMyBotHostsPostMessage: Error executing " & $sExecute)
ElseIf $bPostMessage = False Then
If $g_iDebugWindowMessages Then SetDebugLog("ManagedMyBotHostsPostMessage: Not posting message to " & $hFrmHost)
Else
If $g_iDebugWindowMessages Then SetDebugLog("ManagedMyBotHostsPostMessage: Posting message to " & $hFrmHost)
_WinAPI_PostMessage($hFrmHost, $iMsg, $wParam, $lParam)
EndIf
EndIf
Next
EndFunc
Func _GUICtrlStatusBar_SetTextEx($hWnd, $sText = "", $iPart = 0, $iUFlag = 0)
If $hWnd Then _GUICtrlStatusBar_SetText($hWnd, $sText, $iPart, $iUFlag)
StatusBarManagedMyBotHost($sText)
EndFunc
Global Enum $g_eForumAuthenticationWaiting, $g_eForumAuthenticationLogin, $g_eForumAuthenticationExit
Global $g_hGuiForumAuthentication = 0
Global $g_hForumAuthenticationState = $g_eForumAuthenticationWaiting, $g_hForumAuthenticationLogin, $g_hForumAuthenticationExit, $g_hForumAuthenticationUser, $g_hForumAuthenticationPass
Func ForumAuthentication()
Local $sLogLogPleaseEnter = GetTranslatedFileIni("MBR Authentication", "LogPleaseEnter", "Please enter your Mybot.run Forum username and password")
Local $sLogPasswordIsSave = GetTranslatedFileIni("MBR Authentication", "LogPasswordIsSave", "Password is only used once to authenticate and nowhere saved!")
Local $sTitleUsername = GetTranslatedFileIni("MBR Authentication", "Username", "Username")
Local $sTitlePassword = GetTranslatedFileIni("MBR Authentication", "Password", "Password")
Local $sYouNeedToLogin = GetTranslatedFileIni("MBR Authentication", "YouNeedToLogin", "You need to login to MyBot.run Forum...")
Local $sPleaseEnter = GetTranslatedFileIni("MBR Authentication", "PleaseEnter", "Please enter a username and password.")
Local $sWelcome = GetTranslatedFileIni("MBR Authentication", "Welcome", "Welcome to MyBot.run!")
Local $sLoginFailed = GetTranslatedFileIni("MBR Authentication", "LoginFailed", "Login failed, username or password was incorrect.")
Local $sAuthenticationFailed1 = GetTranslatedFileIni("MBR Authentication", "AuthenticationFailed1", "Not authenticated with MyBot.run Forum, bot will not work!")
Local $sAuthenticationFailed2 = GetTranslatedFileIni("MBR Authentication", "AuthenticationFailed2", "Please launch bot again and login to MyBot.run Forum!")
Local $sLogin = GetTranslatedFileIni("MBR Authentication", "Login", "Login")
Local $sExit = GetTranslatedFileIni("MBR Authentication", "Exit", "Exit")
GetTranslatedFileIni("MBR Authentication", "BotIsAuthenticated", "MyBot.run is authenticated")
GetTranslatedFileIni("MBR Authentication", "BotIsNotAuthenticated", "Error authenticating Mybot.run")
Local $bNotAuthenticated =($g_hGuiForumAuthentication <> 0)
Local $sOldFile = @MyDocumentsDir & "\MyBot.run-Profiles\.mybot.run.authentication"
If FileExists($g_sPrivateAuthenticationFile) = 0 And FileExists($sOldFile) = 1 Then FileMove($sOldFile, $g_sPrivateAuthenticationFile)
If FileExists($g_sPrivateAuthenticationFile) = 0 Or Not CheckForumAuthentication() Then
If $bNotAuthenticated Then
SetLog($sAuthenticationFailed1, $COLOR_ERROR)
SetLog($sAuthenticationFailed2, $COLOR_ERROR)
_Sleep(5000)
Return False
Else
SetLog($sLogLogPleaseEnter, $COLOR_BLUE)
SetLog($sLogPasswordIsSave, $COLOR_BLUE)
Local $xyt = CreateSplashScreen("Form Login")
Local $guiLogin = $g_hSplash
$g_hGuiForumAuthentication = $guiLogin
Local $iW = $xyt[0]
Local $iH = $xyt[1]
Local $iSpace = 20
Local $iButtonTop = $iH - 20 - $iSpace
GUICtrlCreateLabel($sTitleUsername, $iSpace, $iButtonTop - 22, 100, 20)
Local $hUser = GUICtrlCreateInput("", $iSpace, $iButtonTop, 100, 20)
GUICtrlSetLimit($hUser, 128, 1)
GUICtrlCreateLabel($sTitlePassword, $iSpace + 100 + 5, $iButtonTop - 22, 100, 20)
Local $hPass = GUICtrlCreateInput("", $iSpace + 100 + 5, $iButtonTop, 100, 20, BitOR($ES_PASSWORD, $GUI_SS_DEFAULT_INPUT))
GUICtrlSetLimit($hPass, 128, 1)
Local $iTextAddWidth = 30
Local $hText = GUICtrlCreateLabel($sYouNeedToLogin, $iSpace + 100 + 5 + 100 + 5 - $iTextAddWidth, $iButtonTop - 22, $iW - $iSpace -($iSpace + 100 + 5 + 100 + 5) + $iTextAddWidth, 20, $SS_RIGHT)
$g_hForumAuthenticationLogin = GUICtrlCreateButton($sLogin, $iW - 50 - $iSpace, $iButtonTop, 50, 25, $BS_DEFPUSHBUTTON)
GUICtrlSetOnEvent(-1, "ForumAuthenticationLogin")
$g_hForumAuthenticationExit = GUICtrlCreateButton($sExit, $iW -(50 + $iSpace + 50 + 5), $iButtonTop, 50, 25)
GUICtrlSetOnEvent(-1, "ForumAuthenticationExit")
ControlFocus($guiLogin, "", $hUser)
GUISetState(@SW_SHOW, $guiLogin)
Local $bOk = False
Local $hTimer = __TimerInit()
While True
Switch $g_hForumAuthenticationState
Case $g_eForumAuthenticationLogin
Local $sUser = GUICtrlRead($hUser)
Local $sPass = GUICtrlRead($hPass)
If $sUser = "" Or $sPass = "" Then
GUICtrlSetData($hText, $sPleaseEnter)
Else
Local $json = ForumLogin($sUser, $sPass)
If StringInStr($json, '"access_token"') And CheckForumAuthentication() Then
GUICtrlSetData($hText, $sWelcome)
Sleep(1000)
$bOk = True
ExitLoop
Else
GUICtrlSetData($hText, $sLoginFailed)
EndIf
EndIf
Case $g_eForumAuthenticationExit
ExitLoop
EndSwitch
If __TimerDiff($hTimer) / 1000 > 15 * 60 Then
SetLog($sAuthenticationFailed1, $COLOR_ERROR)
SetLog($sAuthenticationFailed2, $COLOR_ERROR)
$bOk = True
ExitLoop
EndIf
$g_hForumAuthenticationState = $g_eForumAuthenticationWaiting
Sleep(100)
WEnd
GUIDelete($guiLogin)
$g_hGuiForumAuthentication = 0
If Not $bOk Then BotClose()
EndIf
EndIf
Return True
EndFunc
Func ForumAuthenticationLogin()
$g_hForumAuthenticationState = $g_eForumAuthenticationLogin
EndFunc
Func ForumAuthenticationExit()
$g_hForumAuthenticationState = $g_eForumAuthenticationExit
EndFunc
Func setupProfileComboBox()
Local $profileString = ""
Local $aProfiles = _FileListToArray($g_sProfilePath, "*", $FLTA_FOLDERS)
Local $aProfileList = ["<No Profiles>"]
If @error Then
$profileString = $aProfileList[0]
Else
Local $a[$aProfiles[0]]
$aProfileList = $a
For $i = 1 To $aProfiles[0]
$aProfileList[$i - 1] = $aProfiles[$i]
Next
$profileString = _ArrayToString($aProfileList, "|")
EndIf
$g_asProfiles = $aProfileList
SetDebugLog("Profiles found: " & $profileString)
GUICtrlSetData($g_hCmbProfile, "", "")
GUICtrlSetData($g_hCmbProfile, $profileString, "<No Profiles>")
For $i = 0 To 7
GUICtrlSetData($g_ahCmbProfile[$i], "")
GUICtrlSetData($g_ahCmbProfile[$i], "|" & $profileString)
_GUICtrlComboBox_SetCurSel($g_ahCmbProfile[$i], 0)
Next
For $i = 0 To 3
GUICtrlSetData($g_ahCmb_SwitchMax[$i], "")
GUICtrlSetData($g_ahCmb_SwitchMax[$i], $profileString, "<No Profiles>")
GUICtrlSetData($g_ahCmb_SwitchMin[$i], "")
GUICtrlSetData($g_ahCmb_SwitchMin[$i], $profileString, "<No Profiles>")
Next
EndFunc
Func renameProfile()
Local $originalPath = $g_sProfilePath & "\" & GUICtrlRead($g_hCmbProfile)
Local $newPath = $g_sProfilePath & "\" & $g_sProfileCurrentName
If FileExists($originalPath) Then
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
DirMove($originalPath, $newPath, $FC_NOOVERWRITE)
$originalPath = $g_sPrivateProfilePath & "\" & GUICtrlRead($g_hCmbProfile)
$newPath = $g_sPrivateProfilePath & "\" & $g_sProfileCurrentName
If FileExists($originalPath) Then
DirMove($originalPath, $newPath, $FC_NOOVERWRITE)
EndIf
EndIf
EndFunc
Func deleteProfile()
Local $sProfile = GUICtrlRead($g_hCmbProfile)
If aquireProfileMutex($sProfile, False, True) = 0 Then
Return False
EndIf
releaseProfileMutex($sProfile)
Local $deletePath = $g_sProfilePath & "\" & $sProfile
If FileExists($deletePath) Then
If $sProfile = $g_sProfileCurrentName Then
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
EndIf
DirRemove($deletePath, $DIR_REMOVE)
$deletePath = $g_sPrivateProfilePath & "\" & $sProfile
If FileExists($deletePath) Then
DirRemove($deletePath, $DIR_REMOVE)
EndIf
Return True
EndIf
Return False
EndFunc
Func createProfile($bCreateNew = False)
FuncEnter(createProfile)
If $bCreateNew = True Then
setupProfileComboBox()
setupProfile()
saveConfig()
setupProfileComboBox()
selectProfile()
Return FuncReturn()
EndIf
DirCreate($g_sProfilePath & "\" & $g_sProfileCurrentName)
DirCreate($g_sPrivateProfilePath & "\" & $g_sProfileCurrentName)
If Not FileExists($g_sProfilePath & "\profile.ini") Then
Local $hFile = FileOpen($g_sProfilePath & "\profile.ini", $FO_APPEND + $FO_CREATEPATH)
FileWriteLine($hFile, "[general]")
FileClose($hFile)
EndIf
SetupProfileFolder()
DirCreate($g_sProfileLogsPath)
DirCreate($g_sProfileLootsPath)
DirCreate($g_sProfileTempPath)
DirCreate($g_sProfileTempDebugPath)
DirCreate($g_sProfileDonateCapturePath)
DirCreate($g_sProfileDonateCaptureWhitelistPath)
DirCreate($g_sProfileDonateCaptureBlacklistPath)
If FileExists($g_sProfileConfigPath) = 0 Then SetLog("New Profile '" & $g_sProfileCurrentName & "' created")
FuncReturn()
EndFunc
Func setupProfile($sProfile = Default)
FuncEnter(setupProfile)
If IsString($sProfile) Then
ElseIf $g_iGuiMode = 1 Then
If GUICtrlRead($g_hCmbProfile) = "<No Profiles>" Then
$sProfile = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
Else
$sProfile = GUICtrlRead($g_hCmbProfile)
EndIf
Else
$sProfile = $g_sProfileCurrentName
EndIf
If aquireProfileMutex($sProfile, False, True) = 0 Then
Return FuncReturn(False)
EndIf
If $g_sProfileCurrentName And $g_sProfileCurrentName <> $sProfile Then
releaseProfileMutex($g_sProfileCurrentName)
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
EndIf
$g_sProfileCurrentName = $sProfile
createProfile()
GUICtrlSetData($g_hGrpVillage, GetTranslatedFileIni("MBR Main GUI", "Tab_02", "Village") & ": " & $g_sProfileCurrentName)
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sProfileCurrentName)
Return FuncReturn(True)
EndFunc
Func selectProfile($sProfile = Default)
FuncEnter(selectProfile)
If IsString($sProfile) Then
ElseIf _GUICtrlComboBox_FindStringExact($g_hCmbProfile, String($g_sProfileCurrentName)) <> -1 Then
_GUICtrlComboBox_SelectString($g_hCmbProfile, String($g_sProfileCurrentName))
Else
Local $comboBoxArray = _GUICtrlComboBox_GetListArray($g_hCmbProfile)
If UBound($comboBoxArray) > 1 Then
$sProfile = $comboBoxArray[1]
Else
$sProfile = $g_sProfileCurrentName
EndIf
EndIf
If IsString($sProfile) Then
If aquireProfileMutex($sProfile, False, True) = 0 Then
Return FuncReturn(False)
EndIf
If $g_sProfileCurrentName <> $sProfile Then
releaseProfileMutex($g_sProfileCurrentName)
EndIf
$g_sProfileCurrentName = $sProfile
createProfile()
readConfig()
applyConfig()
_GUICtrlComboBox_SetCurSel($g_hCmbProfile, 0)
EndIf
GUICtrlSetData($g_hGrpVillage, GetTranslatedFileIni("MBR Main GUI", "Tab_02", "Village") & ": " & $g_sProfileCurrentName)
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sProfileCurrentName)
Return FuncReturn(True)
EndFunc
Func aquireProfileMutex($sProfile = Default, $bReturnOnlyMutex = Default, $bShowMsgBox = False)
If $sProfile = Default Then $sProfile = $g_sProfileCurrentName
If $bReturnOnlyMutex = Default Then $bReturnOnlyMutex = False
Local $iProfile = _ArraySearch($g_ahMutex_Profile, $sProfile, 0, 0, 0, 0, 1, 0)
If $iProfile >= 0 Then
If $bReturnOnlyMutex Then
Return $g_ahMutex_Profile[$iProfile][1]
EndIf
Return 2
EndIf
Local $hMutex_Profile = CreateMutex("MyBot.run-Profile-" & $sProfile)
If $bReturnOnlyMutex Then
Return $hMutex_Profile
EndIf
Local $sMsg = StringRegExpReplace(GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_02", "My Bot with Profile %s is already in use.\r\n\r\n", $sProfile), "[\r\n]", "")
If $hMutex_Profile = 0 Then
SetLog($sMsg, $COLOR_ERROR)
If $bShowMsgBox Then
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg)
EndIf
Return 0
EndIf
SetDebugLog("Aquire Mutex for Profile: " & $sProfile)
$iProfile = UBound($g_ahMutex_Profile)
ReDim $g_ahMutex_Profile[$iProfile + 1][2]
$g_ahMutex_Profile[$iProfile][0] = $sProfile
$g_ahMutex_Profile[$iProfile][1] = $hMutex_Profile
Return 1
EndFunc
Func releaseProfileMutex($sProfile = Default)
If $sProfile = Default Then $sProfile = $g_sProfileCurrentName
Local $iProfile = _ArraySearch($g_ahMutex_Profile, $sProfile, 0, 0, 0, 0, 1, 0)
If $iProfile >= 0 Then
SetDebugLog("Release Mutex for Profile: " & $sProfile)
ReleaseMutex($g_ahMutex_Profile[$iProfile][1])
_ArrayDelete($g_ahMutex_Profile, $iProfile)
Return True
EndIf
Return False
EndFunc
Func releaseProfilesMutex($bCurrentAlso = False)
If UBound($g_ahMutex_Profile) > 0 Then
Local $iReleased = 0
For $i = 0 To UBound($g_ahMutex_Profile) - 1
If $bCurrentAlso Or $g_sProfileCurrentName <> $g_ahMutex_Profile[$i - $iReleased][0] Then
If releaseProfileMutex($g_ahMutex_Profile[$i - $iReleased][0]) Then $iReleased += 1
EndIf
Next
EndIf
EndFunc
Global Const $g_iIniLinesMax = 1000
Global $g_asIniTable[$g_iIniLinesMax][2]
Global $g_iIniLineCount = 0
Func _Ini_Save($filename)
ReDim $g_asIniTable[$g_iIniLineCount][3]
_ArraySort($g_asIniTable)
FileCopy($filename, $filename & ".bak", $FC_OVERWRITE)
Local $hFile = FileOpen($filename, $FO_OVERWRITE + $FO_UTF16_LE)
FileWriteLine($hFile, ";" & TimeDebug() & "MyBot.run configuration saved: " & $filename)
Local $sCurrentSection = ""
For $i = 0 To $g_iIniLineCount - 1
Local $asParts = StringSplit($g_asIniTable[$i][0], "|")
If $asParts[1] <> $sCurrentSection Then
$sCurrentSection = $asParts[1]
FileWriteLine($hFile, "[" & $sCurrentSection & "]")
If $g_sProfileSecondaryOutputFileName <> "" Then
If $sCurrentSection = "search" Or $sCurrentSection = "attack" Or $sCurrentSection = "troop" Or $sCurrentSection = "spells" Or $sCurrentSection = "milkingattack" Or $sCurrentSection = "endbattle" Or $sCurrentSection = "collectors" Or $sCurrentSection = "DropOrder" Or $sCurrentSection = "SmartZap" Or $sCurrentSection = "planned" Then
FileWriteLine($g_sProfileSecondaryOutputFileName, "[" & $sCurrentSection & "]")
EndIf
EndIf
EndIf
FileWriteLine($hFile, $asParts[2] & "=" & $g_asIniTable[$i][1])
If $g_sProfileSecondaryOutputFileName <> "" Then
If $sCurrentSection = "search" Or $sCurrentSection = "attack" Or $sCurrentSection = "troop" Or $sCurrentSection = "spells" Or $sCurrentSection = "milkingattack" Or $sCurrentSection = "endbattle" Or $sCurrentSection = "collectors" Or $sCurrentSection = "DropOrder" Or $sCurrentSection = "SmartZap" Or $sCurrentSection = "planned" Then
FileWriteLine($g_sProfileSecondaryOutputFileName, $asParts[2] & "=" & $g_asIniTable[$i][1])
EndIf
EndIf
Next
FileClose($hFile)
FileDelete($filename & ".bak")
EndFunc
Func _Ini_Clear()
$g_asIniTable = 0
Dim $g_asIniTable[$g_iIniLinesMax][3]
$g_iIniLineCount = 0
EndFunc
Func _Ini_Add($section, $key, $value)
_Ini_AddNewKeyValue($section, $key, $value)
EndFunc
Func _Ini_AddNewKeyValue($section, $key, $value)
If UBound($g_asIniTable) < $g_iIniLineCount + 1 Or UBound($g_asIniTable, 2) < 2 Then
SetDebugLog("_Ini_AddNewKeyValue: Incorrect Array size on section '" & $section & "' for key '" & $key & "' value '" & $value & "'")
Return
EndIf
$g_asIniTable[$g_iIniLineCount][0] = $section & "|" & $key
$g_asIniTable[$g_iIniLineCount][1] = $value
$g_iIniLineCount += 1
EndFunc
Func applyConfig($bRedrawAtExit = True, $TypeReadSave = "Read")
Static $iApplyConfigCount = 0
$iApplyConfigCount += 1
If $g_bApplyConfigIsActive Then
SetDebugLog("applyConfig(), already running, exit")
Return
EndIf
$g_bApplyConfigIsActive = True
SetDebugLog("applyConfig(), call number " & $iApplyConfigCount)
setMaxDegreeOfParallelism($g_iThreads)
setProcessingPoolSize($g_iGlobalThreads)
If $g_bAndroidEmbedded = False Then
If $g_iFrmBotPosX > -30000 And $g_iFrmBotPosY > -30000 And $g_bFrmBotMinimized = False And $g_iFrmBotPosX <> $g_WIN_POS_DEFAULT And $g_iFrmBotPosY <> $g_WIN_POS_DEFAULT Then WinMove($g_hFrmBot, "", $g_iFrmBotPosX, $g_iFrmBotPosY)
If $g_iAndroidPosX > -30000 And $g_iAndroidPosY > -30000 And $g_bIsHidden = False And $g_iAndroidPosX <> $g_WIN_POS_DEFAULT And $g_iAndroidPosY <> $g_WIN_POS_DEFAULT Then HideAndroidWindow(False, False, Default, "applyConfig", 0)
Else
If $g_iFrmBotDockedPosX > -30000 And $g_iFrmBotDockedPosY > -30000 And $g_bFrmBotMinimized = False And $g_iFrmBotDockedPosX <> $g_WIN_POS_DEFAULT And $g_iFrmBotDockedPosY <> $g_WIN_POS_DEFAULT Then WinMove($g_hFrmBot, "", $g_iFrmBotDockedPosX, $g_iFrmBotDockedPosY)
EndIf
If $g_iGuiMode <> 1 Then
If $g_iGuiMode = 2 Then
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkBackgroundMode, $g_bChkBackgroundMode = True ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bChkBackgroundMode =(GUICtrlRead($g_hChkBackgroundMode) = $GUI_CHECKED)
EndSwitch
EndIf
UpdateBotTitle()
$g_bApplyConfigIsActive = False
Return
EndIf
Local $bWasRdraw = SetRedrawBotWindow(False, Default, Default, Default, "applyConfig")
ApplyConfig_Profile($TypeReadSave)
ApplyConfig_Android($TypeReadSave)
ApplyConfig_600_1($TypeReadSave)
ApplyConfig_600_6($TypeReadSave)
ApplyConfig_600_9($TypeReadSave)
ApplyConfig_600_11($TypeReadSave)
ApplyConfig_600_12($TypeReadSave)
ApplyConfig_600_13($TypeReadSave)
ApplyConfig_600_14($TypeReadSave)
ApplyConfig_600_15($TypeReadSave)
ApplyConfig_600_16($TypeReadSave)
ApplyConfig_auto($TypeReadSave)
ApplyConfig_600_17($TypeReadSave)
ApplyConfig_600_18($TypeReadSave)
ApplyConfig_600_19($TypeReadSave)
ApplyConfig_600_22($TypeReadSave)
ApplyConfig_600_26($TypeReadSave)
ApplyConfig_600_28($TypeReadSave)
ApplyConfig_600_28_DB($TypeReadSave)
ApplyConfig_600_28_LB($TypeReadSave)
ApplyConfig_600_28_TS($TypeReadSave)
ApplyConfig_600_29($TypeReadSave)
ApplyConfig_600_29_DB($TypeReadSave)
ApplyConfig_600_29_LB($TypeReadSave)
ApplyConfig_600_29_TS($TypeReadSave)
ApplyConfig_600_30($TypeReadSave)
ApplyConfig_600_30_DB($TypeReadSave)
ApplyConfig_600_30_LB($TypeReadSave)
ApplyConfig_600_30_TS($TypeReadSave)
ApplyConfig_600_31($TypeReadSave)
ApplyConfig_600_32($TypeReadSave)
ApplyConfig_600_33($TypeReadSave)
ApplyConfig_600_35_1($TypeReadSave)
ApplyConfig_600_35_2($TypeReadSave)
ApplyConfig_600_35_3($TypeReadSave)
ApplyConfig_600_52_1($TypeReadSave)
ApplyConfig_600_52_2($TypeReadSave)
ApplyConfig_600_54($TypeReadSave)
ApplyConfig_600_56($TypeReadSave)
ApplyConfig_641_1($TypeReadSave)
ApplyConfig_MOD($TypeReadSave)
PopulatePresetComboBox()
MakeSavePresetMessage()
GUICtrlSetState($g_hLblLoadPresetMessage, $GUI_SHOW)
GUICtrlSetState($g_hTxtPresetMessage, $GUI_HIDE)
GUICtrlSetState($g_hBtnGUIPresetLoadConf, $GUI_HIDE)
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_HIDE + $GUI_DISABLE)
GUICtrlSetState($g_hChkDeleteConf, $GUI_HIDE + $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteConf, $GUI_HIDE)
ApplyConfig_Debug($TypeReadSave)
If $bRedrawAtExit Then SetRedrawBotWindow($bWasRdraw, Default, Default, Default, "applyConfig")
$g_bApplyConfigIsActive = False
EndFunc
Func ApplyConfig_Profile($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetData($g_hTxtGlobalActiveBotsAllowed, $g_iGlobalActiveBotsAllowed)
GUICtrlSetData($g_hTxtGlobalThreads, $g_iGlobalThreads)
Case "Save"
$g_iGlobalActiveBotsAllowed = Int(GUICtrlRead($g_hTxtGlobalActiveBotsAllowed))
If $g_iGlobalActiveBotsAllowed < 1 Then
$g_iGlobalActiveBotsAllowed = 1
EndIf
$g_iGlobalThreads = Int(GUICtrlRead($g_hTxtGlobalThreads))
EndSwitch
EndFunc
Func ApplyConfig_Android($TypeReadSave)
Switch $TypeReadSave
Case "Read"
SetCurSelCmbCOCDistributors()
UpdateBotTitle()
_GUICtrlComboBox_SetCurSel($g_hCmbAndroidBackgroundMode, $g_iAndroidBackgroundMode)
_GUICtrlComboBox_SetCurSel($g_hCmbAndroidZoomoutMode, $g_iAndroidZoomoutMode)
GUICtrlSetState($g_hChkAndroidAdbClickDragScript, $g_bAndroidAdbClickDragScript ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAndroidCloseWithBot, $g_bAndroidCloseWithBot ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkUpdateSharedPrefs, $g_bUpdateSharedPrefs ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAndroidRebootHours, $g_iAndroidRebootHours)
_GUICtrlComboBox_SetCurSel($g_hCmbSuspendAndroid, AndroidSuspendFlagsToIndex($g_iAndroidSuspendModeFlags))
Case "Save"
cmbCOCDistributors()
cmbAndroidBackgroundMode()
$g_iAndroidZoomoutMode = _GUICtrlComboBox_GetCurSel($g_hCmbAndroidZoomoutMode)
$g_bAndroidAdbClickEnabled =(GUICtrlRead($g_hChkAndroidAdbClick) = $GUI_CHECKED ? True : False)
$g_bAndroidAdbClick = $g_bAndroidAdbClickEnabled
$g_bAndroidAdbClickDragScript =(GUICtrlRead($g_hChkAndroidAdbClickDragScript) = $GUI_CHECKED ? True : False)
$g_bAndroidCloseWithBot =(GUICtrlRead($g_hChkAndroidCloseWithBot) = $GUI_CHECKED ? True : False)
$g_bUpdateSharedPrefs =(GUICtrlRead($g_hChkUpdateSharedPrefs) = $GUI_CHECKED ? True : False)
$g_iAndroidRebootHours = Int(GUICtrlRead($g_hTxtAndroidRebootHours))
cmbSuspendAndroid()
EndSwitch
EndFunc
Func ApplyConfig_Debug($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDebugSetlog, $g_bDebugSetlog ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugAndroid, $g_bDebugAndroid ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugClick, $g_bDebugClick ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugFunc,($g_bDebugFuncTime And $g_bDebugFuncCall) ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDisableZoomout, $g_bDebugDisableZoomout ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDisableVillageCentering, $g_bDebugDisableVillageCentering ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDeadbaseImage, $g_bDebugDeadBaseImage ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugOCR, $g_bDebugOcr ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugImageSave, $g_bDebugImageSave ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugBuildingPos, $g_bDebugBuildingPos ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugTrain, $g_bDebugSetlogTrain ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugOCRDonate, $g_bDebugOCRdonate ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugAttackCSV, $g_bDebugAttackCSV ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMakeIMGCSV, $g_bDebugMakeIMGCSV ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugSmartZap, $g_bDebugSmartZap ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_bDevMode Then
GUICtrlSetState($g_hChkDebugFunc, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableZoomout, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableVillageCentering, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDeadbaseImage, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCR, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugImageSave, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugBuildingPos, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugTrain, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCRDonate, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugAttackCSV, $GUI_ENABLE)
GUICtrlSetState($g_hChkMakeIMGCSV, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugSmartZap, $GUI_ENABLE)
EndIf
Case "Save"
$g_bDebugSetlog =(GUICtrlRead($g_hChkDebugSetlog) = $GUI_CHECKED)
$g_bDebugAndroid =(GUICtrlRead($g_hChkDebugAndroid) = $GUI_CHECKED)
$g_bDebugClick =(GUICtrlRead($g_hChkDebugClick) = $GUI_CHECKED)
If $g_bDevMode Then
Local $bDebugFunc =(GUICtrlRead($g_hChkDebugFunc) = $GUI_CHECKED)
$g_bDebugFuncTime = $bDebugFunc
$g_bDebugFuncCall = $bDebugFunc
$g_bDebugDisableZoomout =(GUICtrlRead($g_hChkDebugDisableZoomout) = $GUI_CHECKED)
$g_bDebugDisableVillageCentering =(GUICtrlRead($g_hChkDebugDisableVillageCentering) = $GUI_CHECKED)
$g_bDebugDeadBaseImage =(GUICtrlRead($g_hChkDebugDeadbaseImage) = $GUI_CHECKED)
$g_bDebugOcr =(GUICtrlRead($g_hChkDebugOCR) = $GUI_CHECKED)
$g_bDebugImageSave =(GUICtrlRead($g_hChkDebugImageSave) = $GUI_CHECKED)
$g_bDebugBuildingPos =(GUICtrlRead($g_hChkdebugBuildingPos) = $GUI_CHECKED)
$g_bDebugSetlogTrain =(GUICtrlRead($g_hChkdebugTrain) = $GUI_CHECKED)
$g_bDebugOCRdonate =(GUICtrlRead($g_hChkDebugOCRDonate) = $GUI_CHECKED)
$g_bDebugAttackCSV =(GUICtrlRead($g_hChkdebugAttackCSV) = $GUI_CHECKED)
$g_bDebugMakeIMGCSV =(GUICtrlRead($g_hChkMakeIMGCSV) = $GUI_CHECKED)
$g_bDebugSmartZap =(GUICtrlRead($g_hChkDebugSmartZap) = $GUI_CHECKED)
EndIf
EndSwitch
EndFunc
Func ApplyConfig_600_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbLogDividerOption, $g_iCmbLogDividerOption)
cmbLog()
GUICtrlSetState($g_hChkBackgroundMode, $g_bChkBackgroundMode = True ? $GUI_CHECKED : $GUI_UNCHECKED)
UpdateChkBackground()
Case "Save"
$g_iCmbLogDividerOption = _GUICtrlComboBox_GetCurSel($g_hCmbLogDividerOption)
$g_bChkBackgroundMode =(GUICtrlRead($g_hChkBackgroundMode) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_6($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkBotStop, $g_bChkBotStop ? $GUI_CHECKED : $GUI_UNCHECKED)
chkBotStop()
_GUICtrlComboBox_SetCurSel($g_hCmbBotCommand, $g_iCmbBotCommand)
_GUICtrlComboBox_SetCurSel($g_hCmbBotCond, $g_iCmbBotCond)
_GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, $g_iCmbHoursStop)
cmbBotCond()
GUICtrlSetData($g_hTxtRestartGold, $g_iTxtRestartGold)
GUICtrlSetData($g_hTxtRestartElixir, $g_iTxtRestartElixir)
GUICtrlSetData($g_hTxtRestartDark, $g_iTxtRestartDark)
GUICtrlSetState($g_hChkCollect, $g_bChkCollect ? $GUI_CHECKED : $GUI_UNCHECKED)
ChkCollect()
GUICtrlSetState($g_hChkCollectCartFirst, $g_bChkCollectCartFirst ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtCollectGold, $g_iTxtCollectGold)
GUICtrlSetData($g_hTxtCollectElixir, $g_iTxtCollectElixir)
GUICtrlSetData($g_hTxtCollectDark, $g_iTxtCollectDark)
GUICtrlSetState($g_hChkTombstones, $g_bChkTombstones ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCleanYard, $g_bChkCleanYard ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkGemsBox, $g_bChkGemsBox ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTreasuryCollect, $g_bChkTreasuryCollect ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkFreeMagicItems, $g_bChkCollectFreeMagicItems ? $GUI_CHECKED : $GUI_UNCHECKED)
ChkTreasuryCollect()
GUICtrlSetData($g_hTxtTreasuryGold, $g_iTxtTreasuryGold)
GUICtrlSetData($g_hTxtTreasuryElixir, $g_iTxtTreasuryElixir)
GUICtrlSetData($g_hTxtTreasuryDark, $g_iTxtTreasuryDark)
GUICtrlSetState($g_hChkCollectBuilderBase, $g_bChkCollectBuilderBase ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCleanBBYard, $g_bChkCleanBBYard ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkStartClockTowerBoost, $g_bChkStartClockTowerBoost ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCTBoostBlderBz, $g_bChkCTBoostBlderBz ? $GUI_CHECKED : $GUI_UNCHECKED)
chkStartClockTowerBoost()
GUICtrlSetState($g_hChkBBSuggestedUpgrades, $g_iChkBBSuggestedUpgrades = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreGold, $g_iChkBBSuggestedUpgradesIgnoreGold = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreElixir, $g_iChkBBSuggestedUpgradesIgnoreElixir = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkBBSuggestedUpgradesIgnoreHall, $g_iChkBBSuggestedUpgradesIgnoreHall = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkPlacingNewBuildings, $g_iChkPlacingNewBuildings = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkActivateBBSuggestedUpgrades()
chkActivateBBSuggestedUpgradesGold()
chkActivateBBSuggestedUpgradesElixir()
chkPlacingNewBuildings()
GUICtrlSetState($g_hChkClanGamesAir, $g_bChkClanGamesAir ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesGround, $g_bChkClanGamesGround ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesMisc, $g_bChkClanGamesMisc ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesEnabled, $g_bChkClanGamesEnabled ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGames60, $g_bChkClanGames60 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesPurge, $g_bChkClanGamesPurge ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesStopBeforeReachAndPurge, $g_bChkClanGamesStopBeforeReachAndPurge ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesDebug, $g_bChkClanGamesDebug ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesLoot, $g_bChkClanGamesLoot ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesBattle, $g_bChkClanGamesBattle ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesDestruction, $g_bChkClanGamesDestruction ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesAirTroop, $g_bChkClanGamesAirTroop ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesGroundTroop, $g_bChkClanGamesGroundTroop ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkClanGamesMiscellaneous, $g_bChkClanGamesMiscellaneous ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hcmbPurgeLimit, $g_iPurgeMax)
chkActivateClangames()
chkPurgeLimits()
Case "Save"
$g_bChkBotStop =(GUICtrlRead($g_hChkBotStop) = $GUI_CHECKED)
$g_iCmbBotCommand = _GUICtrlComboBox_GetCurSel($g_hCmbBotCommand)
$g_iCmbBotCond = _GUICtrlComboBox_GetCurSel($g_hCmbBotCond)
$g_iCmbHoursStop = _GUICtrlComboBox_GetCurSel($g_hCmbHoursStop)
$g_iTxtRestartGold = GUICtrlRead($g_hTxtRestartGold)
$g_iTxtRestartElixir = GUICtrlRead($g_hTxtRestartElixir)
$g_iTxtRestartDark = GUICtrlRead($g_hTxtRestartDark)
$g_bChkCollect =(GUICtrlRead($g_hChkCollect) = $GUI_CHECKED)
$g_bChkCollectCartFirst =(GUICtrlRead($g_hChkCollectCartFirst) = $GUI_CHECKED)
$g_iTxtCollectGold = GUICtrlRead($g_hTxtCollectGold)
$g_iTxtCollectElixir = GUICtrlRead($g_hTxtCollectElixir)
$g_iTxtCollectDark = GUICtrlRead($g_hTxtCollectDark)
$g_bChkTombstones =(GUICtrlRead($g_hChkTombstones) = $GUI_CHECKED)
$g_bChkCleanYard =(GUICtrlRead($g_hChkCleanYard) = $GUI_CHECKED)
$g_bChkCollectFreeMagicItems =(GUICtrlRead($g_hChkFreeMagicItems) = $GUI_CHECKED)
$g_bChkGemsBox =(GUICtrlRead($g_hChkGemsBox) = $GUI_CHECKED)
$g_bChkTreasuryCollect =(GUICtrlRead($g_hChkTreasuryCollect) = $GUI_CHECKED)
$g_iTxtTreasuryGold = GUICtrlRead($g_hTxtTreasuryGold)
$g_iTxtTreasuryElixir = GUICtrlRead($g_hTxtTreasuryElixir)
$g_iTxtTreasuryDark = GUICtrlRead($g_hTxtTreasuryDark)
$g_bChkCollectBuilderBase =(GUICtrlRead($g_hChkCollectBuilderBase) = $GUI_CHECKED)
$g_bChkCleanBBYard =(GUICtrlRead($g_hChkCleanBBYard) = $GUI_CHECKED)
$g_bChkStartClockTowerBoost =(GUICtrlRead($g_hChkStartClockTowerBoost) = $GUI_CHECKED)
$g_bChkCTBoostBlderBz =(GUICtrlRead($g_hChkCTBoostBlderBz) = $GUI_CHECKED)
$g_iChkBBSuggestedUpgrades =(GUICtrlRead($g_hChkBBSuggestedUpgrades) = $GUI_CHECKED) ? 1 : 0
$g_iChkBBSuggestedUpgradesIgnoreGold =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreGold) = $GUI_CHECKED) ? 1 : 0
$g_iChkBBSuggestedUpgradesIgnoreElixir =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreElixir) = $GUI_CHECKED) ? 1 : 0
$g_iChkBBSuggestedUpgradesIgnoreHall =(GUICtrlRead($g_hChkBBSuggestedUpgradesIgnoreHall) = $GUI_CHECKED) ? 1 : 0
$g_iChkPlacingNewBuildings =(GUICtrlRead($g_hChkPlacingNewBuildings) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesAir =(GUICtrlRead($g_hChkClanGamesAir) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesGround =(GUICtrlRead($g_hChkClanGamesGround) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesMisc =(GUICtrlRead($g_hChkClanGamesMisc) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesEnabled =(GUICtrlRead($g_hChkClanGamesEnabled) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGames60 =(GUICtrlRead($g_hChkClanGames60) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesPurge =(GUICtrlRead($g_hChkClanGamesPurge) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesStopBeforeReachAndPurge =(GUICtrlRead($g_hChkClanGamesStopBeforeReachAndPurge) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesDebug =(GUICtrlRead($g_hChkClanGamesDebug) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesLoot =(GUICtrlRead($g_hChkClanGamesLoot) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesBattle =(GUICtrlRead($g_hChkClanGamesBattle) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesDestruction =(GUICtrlRead($g_hChkClanGamesDestruction) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesAirTroop =(GUICtrlRead($g_hChkClanGamesAirTroop) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesGroundTroop =(GUICtrlRead($g_hChkClanGamesGroundTroop) = $GUI_CHECKED) ? 1 : 0
$g_bChkClanGamesMiscellaneous =(GUICtrlRead($g_hChkClanGamesMiscellaneous) = $GUI_CHECKED) ? 1 : 0
$g_iPurgeMax = _GUICtrlComboBox_GetCurSel($g_hcmbPurgeLimit)
EndSwitch
EndFunc
Func ApplyConfig_600_9($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUnbreakable, $g_iUnbrkMode = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUnbreakable, $g_iUnbrkWait)
GUICtrlSetData($g_hTxtUnBrkMinGold, $g_iUnbrkMinGold)
GUICtrlSetData($g_hTxtUnBrkMinElixir, $g_iUnbrkMinElixir)
GUICtrlSetData($g_hTxtUnBrkMinDark, $g_iUnbrkMinDark)
GUICtrlSetData($g_hTxtUnBrkMaxGold, $g_iUnbrkMaxGold)
GUICtrlSetData($g_hTxtUnBrkMaxElixir, $g_iUnbrkMaxElixir)
GUICtrlSetData($g_hTxtUnBrkMaxDark, $g_iUnbrkMaxDark)
chkUnbreakable()
Case "Save"
$g_iUnbrkMode = GUICtrlRead($g_hChkUnbreakable) = $GUI_CHECKED ? 1 : 0
$g_iUnbrkWait = GUICtrlRead($g_hTxtUnbreakable)
$g_iUnbrkMinGold = GUICtrlRead($g_hTxtUnBrkMinGold)
$g_iUnbrkMinElixir = GUICtrlRead($g_hTxtUnBrkMinElixir)
$g_iUnbrkMinDark = GUICtrlRead($g_hTxtUnBrkMinDark)
$g_iUnbrkMaxGold = GUICtrlRead($g_hTxtUnBrkMaxGold)
$g_iUnbrkMaxElixir = GUICtrlRead($g_hTxtUnBrkMaxElixir)
$g_iUnbrkMaxDark = GUICtrlRead($g_hTxtUnBrkMaxDark)
EndSwitch
EndFunc
Func ApplyConfig_600_11($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkRequestTroopsEnable, $g_bRequestTroopsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkRequestType_Troops, $g_abRequestType[0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkRequestType_Spells, $g_abRequestType[1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkRequestType_Siege, $g_abRequestType[2] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtRequestCountCCTroop, $g_iRequestCountCCTroop)
GUICtrlSetData($g_hTxtRequestCountCCSpell, $g_iRequestCountCCSpell)
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbClanCastleTroop[$i] , $g_aiClanCastleTroopWaitType[$i])
GUICtrlSetData($g_ahTxtClanCastleTroop[$i], $g_aiClanCastleTroopWaitQty[$i])
_GUICtrlComboBox_SetCurSel($g_ahCmbClanCastleSpell[$i] , $g_aiClanCastleSpellWaitType[$i])
If $i > 1 Then ContinueLoop
_GUICtrlComboBox_SetCurSel($g_ahCmbClanCastleSiege[$i] , $g_aiClanCastleSiegeWaitType[$i])
Next
chkRequestCountCC()
chkRequestCCHours()
GUICtrlSetData($g_hTxtRequestCC, $g_sRequestTroopsText)
For $i = 0 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $g_abRequestCCHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetState($g_hChkRequestCCDefense, $g_bRequestCCDefense ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtRequestCCDefense, $g_sRequestCCDefenseText)
_GUICtrlComboBox_SetCurSel($g_hCmbRequestCCDefenseWhen, $g_bRequestCCDefenseWhenPB ? 0 : 1)
GUICtrlSetData($g_hTxtRequestCCDefenseTime, $g_iRequestDefenseTime)
GUICtrlSetState($g_hChkSaveCCTroopForDefense, $g_bSaveCCTroopForDefense ? $GUI_CHECKED : $GUI_UNCHECKED)
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbCCTroopDefense[$i] , $g_aiCCTroopDefenseType[$i])
GUICtrlSetData($g_ahTxtCCTroopDefense[$i], $g_aiCCTroopDefenseQty[$i])
Next
chkSaveCCTroopForDefense()
chkRequestCCDefense()
Case "Save"
$g_bRequestTroopsEnable =(GUICtrlRead($g_hChkRequestTroopsEnable) = $GUI_CHECKED)
$g_sRequestTroopsText = GUICtrlRead($g_hTxtRequestCC)
$g_abRequestType[0] =(GUICtrlRead($g_hChkRequestType_Troops) = $GUI_CHECKED)
$g_abRequestType[1] =(GUICtrlRead($g_hChkRequestType_Spells) = $GUI_CHECKED)
$g_abRequestType[2] =(GUICtrlRead($g_hChkRequestType_Siege) = $GUI_CHECKED)
$g_iRequestCountCCTroop = GUICtrlRead($g_hTxtRequestCountCCTroop)
$g_iRequestCountCCSpell = GUICtrlRead($g_hTxtRequestCountCCSpell)
For $i = 0 To 2
$g_aiClanCastleTroopWaitType[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbClanCastleTroop[$i])
$g_aiClanCastleTroopWaitQty[$i] = GUICtrlRead($g_ahTxtClanCastleTroop[$i])
$g_aiClanCastleSpellWaitType[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbClanCastleSpell[$i])
If $i > 1 Then ContinueLoop
$g_aiClanCastleSiegeWaitType[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbClanCastleSiege[$i])
Next
For $i = 0 To 23
$g_abRequestCCHours[$i] =(GUICtrlRead($g_ahChkRequestCCHours[$i]) = $GUI_CHECKED)
Next
$g_bRequestCCDefense =(GUICtrlRead($g_hChkRequestCCDefense) = $GUI_CHECKED)
$g_sRequestCCDefenseText = GUICtrlRead($g_hTxtRequestCCDefense)
$g_bRequestCCDefenseWhenPB =(_GUICtrlComboBox_GetCurSel($g_hCmbRequestCCDefenseWhen) = 0)
$g_iRequestDefenseTime = GUICtrlRead($g_hTxtRequestCCDefenseTime)
$g_bSaveCCTroopForDefense =(GUICtrlRead($g_hChkSaveCCTroopForDefense) = $GUI_CHECKED)
For $i = 0 To 2
$g_aiCCTroopDefenseType[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbCCTroopDefense[$i])
$g_aiCCTroopDefenseQty[$i] = GUICtrlRead($g_ahTxtCCTroopDefense[$i])
Next
EndSwitch
EndFunc
Func ApplyConfig_600_12($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDonate, $g_bChkDonate ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDonateQueueTroopOnly, $g_abChkDonateQueueOnly[0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDonateQueueSpellOnly, $g_abChkDonateQueueOnly[1] ? $GUI_CHECKED : $GUI_UNCHECKED)
Doncheck()
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
GUICtrlSetState($g_ahChkDonateTroop[$i], $g_abChkDonateTroop[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_abChkDonateTroop[$i] Then
_DonateControls($i)
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $g_abChkDonateAllTroop[$i] Then
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_CHECKED)
_DonateAllControls($i, True)
Else
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
EndIf
GUICtrlSetData($g_ahTxtDonateTroop[$i], $g_asTxtDonateTroop[$i])
GUICtrlSetData($g_ahTxtBlacklistTroop[$i], $g_asTxtBlacklistTroop[$i])
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
GUICtrlSetState($g_ahChkDonateSpell[$i], $g_abChkDonateSpell[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_abChkDonateSpell[$i] Then
_DonateControlsSpell($i)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $g_abChkDonateAllSpell[$i] Then
GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_CHECKED)
_DonateAllControlsSpell($i, True)
Else
GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
EndIf
EndIf
If $i <> $eSpellClone Then
GUICtrlSetData($g_ahTxtDonateSpell[$i], $g_asTxtDonateSpell[$i])
GUICtrlSetData($g_ahTxtBlacklistSpell[$i], $g_asTxtBlacklistSpell[$i])
EndIf
Next
For $i = $eSiegeWallWrecker to $eSiegeMachineCount - 1
Local $index = $eTroopCount + $g_iCustomDonateConfigs
GUICtrlSetState($g_ahChkDonateTroop[$index + $i], $g_abChkDonateTroop[$index + $i] ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_abChkDonateTroop[$index + $i] Then
_DonateControls($index + $i)
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$index + $i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $g_abChkDonateAllTroop[$index + $i] Then
GUICtrlSetState($g_ahChkDonateAllTroop[$index + $i], $GUI_CHECKED)
_DonateAllControls($index + $i, True)
Else
GUICtrlSetState($g_ahChkDonateAllTroop[$index + $i], $GUI_UNCHECKED)
EndIf
GUICtrlSetData($g_ahTxtDonateTroop[$index + $i], $g_asTxtDonateTroop[$index + $i])
GUICtrlSetData($g_ahTxtBlacklistTroop[$index + $i], $g_asTxtBlacklistTroop[$index + $i])
Next
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomA[$i], $g_aiDonateCustomTrpNumA[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomA[$i], $g_aiDonateCustomTrpNumA[$i][1])
Next
cmbDonateCustomA()
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomB[$i], $g_aiDonateCustomTrpNumB[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomB[$i], $g_aiDonateCustomTrpNumB[$i][1])
Next
cmbDonateCustomB()
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomC[$i], $g_aiDonateCustomTrpNumC[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomC[$i], $g_aiDonateCustomTrpNumC[$i][1])
Next
cmbDonateCustomC()
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomD[$i], $g_aiDonateCustomTrpNumD[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomD[$i], $g_aiDonateCustomTrpNumD[$i][1])
Next
cmbDonateCustomD()
GUICtrlSetState($g_hChkExtraAlphabets, $g_bChkExtraAlphabets ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkExtraChinese, $g_bChkExtraChinese ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkExtraKorean, $g_bChkExtraKorean ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkExtraPersian, $g_bChkExtraPersian ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtGeneralBlacklist, $g_sTxtGeneralBlacklist)
Case "Save"
$g_bChkDonate =(GUICtrlRead($g_hChkDonate) = $GUI_CHECKED)
$g_abChkDonateQueueOnly[0] =(GUICtrlRead($g_hChkDonateQueueTroopOnly) = $GUI_CHECKED)
$g_abChkDonateQueueOnly[1] =(GUICtrlRead($g_hChkDonateQueueSpellOnly) = $GUI_CHECKED)
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
$g_abChkDonateTroop[$i] =(GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_CHECKED)
$g_abChkDonateAllTroop[$i] =(GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED)
$g_asTxtDonateTroop[$i] = GUICtrlRead($g_ahTxtDonateTroop[$i])
$g_asTxtBlacklistTroop[$i] = GUICtrlRead($g_ahTxtBlacklistTroop[$i])
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$g_abChkDonateSpell[$i] =(GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_CHECKED)
$g_abChkDonateAllSpell[$i] =(GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED)
$g_asTxtDonateSpell[$i] = GUICtrlRead($g_ahTxtDonateSpell[$i])
$g_asTxtBlacklistSpell[$i] = GUICtrlRead($g_ahTxtBlacklistSpell[$i])
EndIf
Next
For $i = $eSiegeWallWrecker to $eSiegeMachineCount - 1
Local $index = $eTroopCount + $g_iCustomDonateConfigs
$g_abChkDonateTroop[$index + $i] =(GUICtrlRead($g_ahChkDonateTroop[$index + $i]) = $GUI_CHECKED)
$g_abChkDonateAllTroop[$index + $i] =(GUICtrlRead($g_ahChkDonateAllTroop[$index + $i]) = $GUI_CHECKED)
$g_asTxtDonateTroop[$index + $i] = GUICtrlRead($g_ahTxtDonateTroop[$index + $i])
$g_asTxtBlacklistTroop[$index + $i] = GUICtrlRead($g_ahTxtBlacklistTroop[$index + $i])
Next
For $i = 0 To 2
$g_aiDonateCustomTrpNumA[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[$i])
$g_aiDonateCustomTrpNumA[$i][1] = GUICtrlRead($g_ahTxtDonateCustomA[$i])
$g_aiDonateCustomTrpNumB[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[$i])
$g_aiDonateCustomTrpNumB[$i][1] = GUICtrlRead($g_ahTxtDonateCustomB[$i])
$g_aiDonateCustomTrpNumC[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomC[$i])
$g_aiDonateCustomTrpNumC[$i][1] = GUICtrlRead($g_ahTxtDonateCustomC[$i])
$g_aiDonateCustomTrpNumD[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomD[$i])
$g_aiDonateCustomTrpNumD[$i][1] = GUICtrlRead($g_ahTxtDonateCustomD[$i])
Next
$g_bChkExtraAlphabets =(GUICtrlRead($g_hChkExtraAlphabets) = $GUI_CHECKED)
$g_bChkExtraChinese =(GUICtrlRead($g_hChkExtraChinese) = $GUI_CHECKED)
$g_bChkExtraKorean =(GUICtrlRead($g_hChkExtraKorean) = $GUI_CHECKED)
$g_bChkExtraPersian =(GUICtrlRead($g_hChkExtraPersian) = $GUI_CHECKED)
$g_sTxtGeneralBlacklist = GUICtrlRead($g_hTxtGeneralBlacklist)
EndSwitch
EndFunc
Func ApplyConfig_600_13($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDonateHoursEnable, $g_bDonateHoursEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDonateHours()
For $i = 0 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $g_abDonateHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
_GUICtrlComboBox_SetCurSel($g_hCmbFilterDonationsCC, $g_iCmbDonateFilter)
GUICtrlSetState($g_hChkSkipDonateNearFullTroopsEnable, $g_bDonateSkipNearFullEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSkipDonateNearFullTroopsPercentage, $g_iDonateSkipNearFullPercent)
chkskipDonateNearFulLTroopsEnable()
GUICtrlSetState($g_hChkUseCCBalanced, $g_bUseCCBalanced = True ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbCCDonated, $g_iCCDonated - 1)
_GUICtrlComboBox_SetCurSel($g_hCmbCCReceived, $g_iCCReceived - 1)
chkBalanceDR()
Case "Save"
$g_bDonateHoursEnable =(GUICtrlRead($g_hChkDonateHoursEnable) = $GUI_CHECKED)
For $i = 0 To 23
$g_abDonateHours[$i] =(GUICtrlRead($g_ahChkDonateHours[$i]) = $GUI_CHECKED)
Next
$g_iCmbDonateFilter = _GUICtrlComboBox_GetCurSel($g_hCmbFilterDonationsCC)
$g_bDonateSkipNearFullEnable =(GUICtrlRead($g_hChkSkipDonateNearFullTroopsEnable) = $GUI_CHECKED)
$g_iDonateSkipNearFullPercent = Number(GUICtrlRead($g_hTxtSkipDonateNearFullTroopsPercentage))
$g_bUseCCBalanced =(GUICtrlRead($g_hChkUseCCBalanced) = $GUI_CHECKED)
$g_iCCDonated = _GUICtrlComboBox_GetCurSel($g_hCmbCCDonated) + 1
$g_iCCReceived = _GUICtrlComboBox_GetCurSel($g_hCmbCCReceived) + 1
EndSwitch
EndFunc
Func ApplyConfig_600_14($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkAutoLabUpgrades, $g_bAutoLabUpgradeEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbLaboratory, $g_iCmbLaboratory)
_GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $g_avLabTroops[$g_iCmbLaboratory][4])
chkLab()
GUICtrlSetState($g_hChkAutoStarLabUpgrades, $g_bAutoStarLabUpgradeEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbStarLaboratory, $g_iCmbStarLaboratory)
_GUICtrlSetImage($g_hPicStarLabUpgrade, $g_sLibIconPath, $g_avStarLabTroops[$g_iCmbStarLaboratory][4])
chkStarLab()
Case "Save"
$g_bAutoLabUpgradeEnable =(GUICtrlRead($g_hChkAutoLabUpgrades) = $GUI_CHECKED)
$g_iCmbLaboratory = _GUICtrlComboBox_GetCurSel($g_hCmbLaboratory)
$g_bAutoStarLabUpgradeEnable =(GUICtrlRead($g_hChkAutoStarLabUpgrades) = $GUI_CHECKED)
$g_iCmbStarLaboratory = _GUICtrlComboBox_GetCurSel($g_hCmbStarLaboratory)
EndSwitch
EndFunc
Func ApplyConfig_600_15($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUpgradeKing, $g_bUpgradeKingEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeKing()
chkDBKingWait()
chkABKingWait()
GUICtrlSetState($g_hChkUpgradeQueen, $g_bUpgradeQueenEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeQueen()
chkDBQueenWait()
chkABQueenWait()
GUICtrlSetState($g_hChkUpgradeWarden, $g_bUpgradeWardenEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeWarden()
chkDBWardenWait()
chkABWardenWait()
_GUICtrlComboBox_SetCurSel($g_hCmbHeroReservedBuilder, $g_iHeroReservedBuilder)
cmbHeroReservedBuilder()
Case "Save"
$g_bUpgradeKingEnable =(GUICtrlRead($g_hChkUpgradeKing) = $GUI_CHECKED)
$g_bUpgradeQueenEnable =(GUICtrlRead($g_hChkUpgradeQueen) = $GUI_CHECKED)
$g_bUpgradeWardenEnable =(GUICtrlRead($g_hChkUpgradeWarden) = $GUI_CHECKED)
$g_iHeroReservedBuilder = _GUICtrlComboBox_GetCurSel($g_hCmbHeroReservedBuilder)
EndSwitch
EndFunc
Func ApplyConfig_600_16($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
_GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $g_aiPicUpgradeStatus[$iz])
If $g_avBuildingUpgrades[$iz][2] > 0 Then
GUICtrlSetData($g_hTxtUpgradeValue[$iz], _NumberFormat($g_avBuildingUpgrades[$iz][2]))
Else
GUICtrlSetData($g_hTxtUpgradeValue[$iz], "")
EndIf
GUICtrlSetData($g_hTxtUpgradeName[$iz], $g_avBuildingUpgrades[$iz][4])
GUICtrlSetData($g_hTxtUpgradeLevel[$iz], $g_avBuildingUpgrades[$iz][5])
GUICtrlSetData($g_hTxtUpgradeTime[$iz], StringStripWS($g_avBuildingUpgrades[$iz][6], $STR_STRIPALL))
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnGold)
Case "Elixir"
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnElixir)
Case "Dark"
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnDark)
Case Else
_GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnBlank)
EndSwitch
GUICtrlSetState($g_hChkUpgrade[$iz], $g_abBuildingUpgradeEnable[$iz] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $g_abUpgradeRepeatEnable[$iz] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], $g_avBuildingUpgrades[$iz][7])
Next
GUICtrlSetData($g_hTxtUpgrMinGold, $g_iUpgradeMinGold)
GUICtrlSetData($g_hTxtUpgrMinElixir, $g_iUpgradeMinElixir)
GUICtrlSetData($g_hTxtUpgrMinDark, $g_iUpgradeMinDark)
Case "Save"
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
$g_abBuildingUpgradeEnable[$iz] =(GUICtrlRead($g_hChkUpgrade[$iz]) = $GUI_CHECKED)
$g_abUpgradeRepeatEnable[$iz] =(GUICtrlRead($g_hChkUpgradeRepeat[$iz]) = $GUI_CHECKED)
Next
$g_iUpgradeMinGold = Number(GUICtrlRead($g_hTxtUpgrMinGold))
$g_iUpgradeMinElixir = Number(GUICtrlRead($g_hTxtUpgrMinElixir))
$g_iUpgradeMinDark = Number(GUICtrlRead($g_hTxtUpgrMinDark))
EndSwitch
EndFunc
Func ApplyConfig_auto($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkAutoUpgrade, $g_bAutoUpgradeEnabled ? $GUI_CHECKED : $GUI_UNCHECKED)
For $i = 0 To 13
GUICtrlSetState($g_hChkUpgradesToIgnore[$i], $g_iChkUpgradesToIgnore[$i] = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
For $i = 0 To 2
GUICtrlSetState($g_hChkResourcesToIgnore[$i], $g_iChkResourcesToIgnore[$i] = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetData($g_hTxtSmartMinGold, $g_iTxtSmartMinGold)
GUICtrlSetData($g_hTxtSmartMinElixir, $g_iTxtSmartMinElixir)
GUICtrlSetData($g_hTxtSmartMinDark, $g_iTxtSmartMinDark)
chkAutoUpgrade()
Case "Save"
$g_bAutoUpgradeEnabled =(GUICtrlRead($g_hChkAutoUpgrade) = $GUI_CHECKED)
For $i = 0 To 13
$g_iChkUpgradesToIgnore[$i] = GUICtrlRead($g_hChkUpgradesToIgnore[$i]) = $GUI_CHECKED ? 1 : 0
Next
For $i = 0 To 2
$g_iChkResourcesToIgnore[$i] = GUICtrlRead($g_hChkResourcesToIgnore[$i]) = $GUI_CHECKED ? 1 : 0
Next
$g_iTxtSmartMinGold = GUICtrlRead($g_hTxtSmartMinGold)
$g_iTxtSmartMinElixir = GUICtrlRead($g_hTxtSmartMinElixir)
$g_iTxtSmartMinDark = GUICtrlRead($g_hTxtSmartMinDark)
EndSwitch
EndFunc
Func ApplyConfig_600_17($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkWalls, $g_bAutoUpgradeWallsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtWallMinGold, $g_iUpgradeWallMinGold)
GUICtrlSetData($g_hTxtWallMinElixir, $g_iUpgradeWallMinElixir)
Switch $g_iUpgradeWallLootType
Case 0
GUICtrlSetState($g_hRdoUseGold, $GUI_CHECKED)
Case 1
GUICtrlSetState($g_hRdoUseElixir, $GUI_CHECKED)
Case 2
GUICtrlSetState($g_hRdoUseElixirGold, $GUI_CHECKED)
EndSwitch
GUICtrlSetState($g_hChkSaveWallBldr, $g_bUpgradeWallSaveBuilder ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbWalls, $g_iCmbUpgradeWallsLevel)
For $i = 4 To 13
GUICtrlSetData($g_ahWallsCurrentCount[$i], $g_aiWallsCurrentCount[$i])
Next
cmbWalls()
chkWalls()
Case "Save"
$g_bAutoUpgradeWallsEnable =(GUICtrlRead($g_hChkWalls) = $GUI_CHECKED)
$g_iUpgradeWallMinGold = Number(GUICtrlRead($g_hTxtWallMinGold))
$g_iUpgradeWallMinElixir = Number(GUICtrlRead($g_hTxtWallMinElixir))
If GUICtrlRead($g_hRdoUseGold) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 0
ElseIf GUICtrlRead($g_hRdoUseElixir) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 1
ElseIf GUICtrlRead($g_hRdoUseElixirGold) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 2
EndIf
$g_bUpgradeWallSaveBuilder =(GUICtrlRead($g_hChkSaveWallBldr) = $GUI_CHECKED)
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
For $i = 4 To 13
$g_aiWallsCurrentCount[$i] = Number(GUICtrlRead($g_ahWallsCurrentCount[$i]))
Next
EndSwitch
EndFunc
Func ApplyConfig_600_18($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkNotifyTGEnable, $g_bNotifyTGEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkPBTGenabled()
GUICtrlSetData($g_hTxtNotifyTGToken, $g_sNotifyTGToken)
GUICtrlSetState($g_hChkNotifyRemote, $g_bNotifyRemoteEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sNotifyOrigin)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $g_bNotifyAlertMatchFound ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $g_bNotifyAlerLastRaidIMG ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $g_bNotifyAlertUpgradeWalls ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $g_bNotifyAlertOutOfSync ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $g_bNotifyAlertTakeBreak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $g_bNotifyAlertAnotherDevice ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $g_bNotifyAlerLastRaidTXT ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $g_bNotifyAlertCampFull ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $g_bNotifyAlertVillageReport ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $g_bNotifyAlertLastAttack ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $g_bNotifyAlertBulderIdle ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $g_bNotifyAlertMaintenance ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertBAN, $g_bNotifyAlertBAN ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $g_bNotifyAlertBOTUpdate ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertSmartWaitTime, $g_bNotifyAlertSmartWaitTime ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLaboratoryIdle, $g_bNotifyAlertLaboratoryIdle ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bNotifyTGEnable =(GUICtrlRead($g_hChkNotifyTGEnable) = $GUI_CHECKED)
$g_sNotifyTGToken = GUICtrlRead($g_hTxtNotifyTGToken)
$g_bNotifyRemoteEnable =(GUICtrlRead($g_hChkNotifyRemote) = $GUI_CHECKED)
$g_sNotifyOrigin = GUICtrlRead($g_hTxtNotifyOrigin)
$g_bNotifyAlertMatchFound =(GUICtrlRead($g_hChkNotifyAlertMatchFound) = $GUI_CHECKED)
$g_bNotifyAlerLastRaidIMG =(GUICtrlRead($g_hChkNotifyAlertLastRaidIMG) = $GUI_CHECKED)
$g_bNotifyAlertUpgradeWalls =(GUICtrlRead($g_hChkNotifyAlertUpgradeWall) = $GUI_CHECKED)
$g_bNotifyAlertOutOfSync =(GUICtrlRead($g_hChkNotifyAlertOutOfSync) = $GUI_CHECKED)
$g_bNotifyAlertTakeBreak =(GUICtrlRead($g_hChkNotifyAlertTakeBreak) = $GUI_CHECKED)
$g_bNotifyAlertAnotherDevice =(GUICtrlRead($g_hChkNotifyAlertAnotherDevice) = $GUI_CHECKED)
$g_bNotifyAlerLastRaidTXT =(GUICtrlRead($g_hChkNotifyAlertLastRaidTXT) = $GUI_CHECKED)
$g_bNotifyAlertCampFull =(GUICtrlRead($g_hChkNotifyAlertCampFull) = $GUI_CHECKED)
$g_bNotifyAlertVillageReport =(GUICtrlRead($g_hChkNotifyAlertVillageStats) = $GUI_CHECKED)
$g_bNotifyAlertLastAttack =(GUICtrlRead($g_hChkNotifyAlertLastAttack) = $GUI_CHECKED)
$g_bNotifyAlertBulderIdle =(GUICtrlRead($g_hChkNotifyAlertBuilderIdle) = $GUI_CHECKED)
$g_bNotifyAlertMaintenance =(GUICtrlRead($g_hChkNotifyAlertMaintenance) = $GUI_CHECKED)
$g_bNotifyAlertBAN =(GUICtrlRead($g_hChkNotifyAlertBAN) = $GUI_CHECKED)
$g_bNotifyAlertBOTUpdate =(GUICtrlRead($g_hChkNotifyBOTUpdate) = $GUI_CHECKED)
$g_bNotifyAlertSmartWaitTime =(GUICtrlRead($g_hChkNotifyAlertSmartWaitTime) = $GUI_CHECKED)
$g_bNotifyAlertLaboratoryIdle =(GUICtrlRead($g_hChkNotifyAlertLaboratoryIdle) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_19($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkNotifyOnlyHours, $g_bNotifyScheduleHoursEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkNotifyHours()
For $i = 0 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $g_abNotifyScheduleHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetState($g_hChkNotifyOnlyWeekDays, $g_bNotifyScheduleWeekDaysEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkNotifyWeekDays()
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $g_abNotifyScheduleWeekDays[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$g_bNotifyScheduleHoursEnable =(GUICtrlRead($g_hChkNotifyOnlyHours) = $GUI_CHECKED)
For $i = 0 To 23
$g_abNotifyScheduleHours[$i] =(GUICtrlRead($g_hChkNotifyhours[$i]) = $GUI_CHECKED)
Next
$g_bNotifyScheduleWeekDaysEnable =(GUICtrlRead($g_hChkNotifyOnlyWeekDays) = $GUI_CHECKED)
For $i = 0 To 6
$g_abNotifyScheduleWeekDays[$i] =(GUICtrlRead($g_hChkNotifyWeekdays[$i]) = $GUI_CHECKED)
Next
EndSwitch
EndFunc
Func ApplyConfig_600_22($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbBoostBarracks, $g_iCmbBoostBarracks)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostSpellFactory, $g_iCmbBoostSpellFactory)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostWorkshop, $g_iCmbBoostWorkshop)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostBarbarianKing, $g_iCmbBoostBarbarianKing)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostArcherQueen, $g_iCmbBoostArcherQueen)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostWarden, $g_iCmbBoostWarden)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostTrainingPotion, $g_iCmbBoostTrainingPotion)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostResourcePotion, $g_iCmbBoostResourcePotion)
For $i = 0 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $g_abBoostBarracksHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$g_iCmbBoostBarracks = _GUICtrlComboBox_GetCurSel($g_hCmbBoostBarracks)
$g_iCmbBoostSpellFactory = _GUICtrlComboBox_GetCurSel($g_hCmbBoostSpellFactory)
$g_iCmbBoostWorkshop = _GUICtrlComboBox_GetCurSel($g_hCmbBoostWorkshop)
$g_iCmbBoostBarbarianKing = _GUICtrlComboBox_GetCurSel($g_hCmbBoostBarbarianKing)
$g_iCmbBoostArcherQueen = _GUICtrlComboBox_GetCurSel($g_hCmbBoostArcherQueen)
$g_iCmbBoostWarden = _GUICtrlComboBox_GetCurSel($g_hCmbBoostWarden)
$g_iCmbBoostTrainingPotion = _GUICtrlComboBox_GetCurSel($g_hCmbBoostTrainingPotion)
$g_iCmbBoostResourcePotion = _GUICtrlComboBox_GetCurSel($g_hCmbBoostResourcePotion)
For $i = 0 To 23
$g_abBoostBarracksHours[$i] =(GUICtrlRead($g_hChkBoostBarracksHours[$i]) = $GUI_CHECKED)
Next
EndSwitch
EndFunc
Func ApplyConfig_600_26($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkBully, $g_abAttackTypeEnable[$TB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtATBullyMode, $g_iAtkTBEnableCount)
_GUICtrlComboBox_SetCurSel($g_hCmbBullyMaxTH, $g_iAtkTBMaxTHLevel)
CmbBullyMaxTH()
GUICtrlSetState($g_hRadBullyUseDBAttack, $g_iAtkTBMode = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBullyUseLBAttack, $g_iAtkTBMode = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$TB] =(GUICtrlRead($g_hChkBully) = $GUI_CHECKED)
$g_iAtkTBEnableCount = GUICtrlRead($g_hTxtATBullyMode)
$g_iAtkTBMaxTHLevel = _GUICtrlComboBox_GetCurSel($g_hCmbBullyMaxTH)
$g_iAtkTBMode =(GUICtrlRead($g_hRadBullyUseDBAttack) = $GUI_CHECKED ? 0 : 1)
EndSwitch
EndFunc
Func ApplyConfig_600_28($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkSearchReduction, $g_bSearchReductionEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSearchReduction()
GUICtrlSetData($g_hTxtSearchReduceCount, $g_iSearchReductionCount)
GUICtrlSetData($g_hTxtSearchReduceGold, $g_iSearchReductionGold)
GUICtrlSetData($g_hTxtSearchReduceElixir, $g_iSearchReductionElixir)
GUICtrlSetData($g_hTxtSearchReduceGoldPlusElixir, $g_iSearchReductionGoldPlusElixir)
GUICtrlSetData($g_hTxtSearchReduceDark, $g_iSearchReductionDark)
GUICtrlSetData($g_hTxtSearchReduceTrophy, $g_iSearchReductionTrophy)
If $g_iSearchDelayMin > $g_iSearchDelayMax Then $g_iSearchDelayMax = $g_iSearchDelayMin
GUICtrlSetData($g_hSldVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hSldMaxVSDelay, $g_iSearchDelayMax)
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMax)
GUICtrlSetState($g_hChkAttackNow, $g_bSearchAttackNowEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkAttackNow()
_GUICtrlComboBox_SetCurSel($g_hCmbAttackNowDelay, $g_iSearchAttackNowDelay)
GUICtrlSetState($g_hChkRestartSearchLimit, $g_bSearchRestartEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtRestartSearchlimit, $g_iSearchRestartLimit)
ChkRestartSearchLimit()
GUICtrlSetState($g_hChkRestartSearchPickupHero, $g_bSearchRestartPickupHero ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAlertSearch, $g_bSearchAlertMe ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bSearchReductionEnable =(GUICtrlRead($g_hChkSearchReduction) = $GUI_CHECKED)
$g_iSearchReductionCount = GUICtrlRead($g_hTxtSearchReduceCount)
$g_iSearchReductionGold = GUICtrlRead($g_hTxtSearchReduceGold)
$g_iSearchReductionElixir = GUICtrlRead($g_hTxtSearchReduceElixir)
$g_iSearchReductionGoldPlusElixir = GUICtrlRead($g_hTxtSearchReduceGoldPlusElixir)
$g_iSearchReductionDark = GUICtrlRead($g_hTxtSearchReduceDark)
$g_iSearchReductionTrophy = GUICtrlRead($g_hTxtSearchReduceTrophy)
$g_iSearchDelayMin = GUICtrlRead($g_hSldVSDelay)
$g_iSearchDelayMax = GUICtrlRead($g_hSldMaxVSDelay)
$g_bSearchAttackNowEnable =(GUICtrlRead($g_hChkAttackNow) = $GUI_CHECKED)
$g_iSearchAttackNowDelay = _GUICtrlComboBox_GetCurSel($g_hCmbAttackNowDelay)
$g_bSearchRestartEnable =(GUICtrlRead($g_hChkRestartSearchLimit) = $GUI_CHECKED)
$g_iSearchRestartLimit = GUICtrlRead($g_hTxtRestartSearchlimit)
$g_bSearchRestartPickupHero =(GUICtrlRead($g_hChkRestartSearchPickupHero) = $GUI_CHECKED)
$g_bSearchAlertMe =(GUICtrlRead($g_hChkAlertSearch) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDBActivateSearches, $g_abSearchSearchesEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBSearchesMin, $g_aiSearchSearchesMin[$DB])
GUICtrlSetData($g_hTxtDBSearchesMax, $g_aiSearchSearchesMax[$DB])
GUICtrlSetState($g_hChkDBActivateTropies, $g_abSearchTropiesEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBActivateTropies()
GUICtrlSetData($g_hTxtDBTropiesMin, $g_aiSearchTrophiesMin[$DB])
GUICtrlSetData($g_hTxtDBTropiesMax, $g_aiSearchTrophiesMax[$DB])
GUICtrlSetState($g_hChkDBActivateCamps, $g_abSearchCampsEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBActivateCamps()
GUICtrlSetData($g_hTxtDBArmyCamps, $g_aiSearchCampsPct[$DB])
chkDBActivateSearches()
GUICtrlSetState($g_hChkDeadbase, $g_abAttackTypeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBKingWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBQueenWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBWardenWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBNotWaitHeroes, $g_aiSearchNotWaitHeroesEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
$g_iHeroWaitAttackNoBit[$DB][0] = GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][1] = GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][2] = GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED ? 1 : 0
GUICtrlSetState($g_hChkDBSpellsWait, $g_abSearchSpellsWaitEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBSpellsWait()
GUICtrlSetState($g_hChkDBWaitForCastle, $g_abSearchCastleWaitEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbDBMeetGE, $g_aiFilterMeetGE[$DB])
GUICtrlSetData($g_hTxtDBMinGold, $g_aiFilterMinGold[$DB])
GUICtrlSetData($g_hTxtDBMinElixir, $g_aiFilterMinElixir[$DB])
GUICtrlSetData($g_hTxtDBMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$DB])
cmbDBGoldElixir()
GUICtrlSetState($g_hChkDBMeetDE, $g_abFilterMeetDEEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBMinDarkElixir, $g_aiFilterMeetDEMin[$DB])
chkDBMeetDE()
GUICtrlSetState($g_hChkDBMeetTrophy, $g_abFilterMeetTrophyEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBMinTrophy, $g_aiFilterMeetTrophyMin[$DB])
GUICtrlSetData($g_hTxtDBMaxTrophy, $g_aiFilterMeetTrophyMax[$DB])
chkDBMeetTrophy()
GUICtrlSetState($g_hChkDBMeetTH, $g_abFilterMeetTH[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbDBTH, $g_aiFilterMeetTHMin[$DB])
$g_aiMaxTH[$DB] = $g_asTHText[$g_aiFilterMeetTHMin[$DB]]
chkDBMeetTH()
CmbDBTH()
GUICtrlSetState($g_hChkDBMeetTHO, $g_abFilterMeetTHOutsideEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxMortar[$DB], $g_abFilterMaxMortarEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxWizTower[$DB], $g_abFilterMaxWizTowerEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxAirDefense[$DB], $g_abFilterMaxAirDefenseEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxXBow[$DB], $g_abFilterMaxXBowEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxInferno[$DB], $g_abFilterMaxInfernoEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxEagle[$DB], $g_abFilterMaxEagleEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakMortar[$DB], $g_aiFilterMaxMortarLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakWizTower[$DB], $g_aiFilterMaxWizTowerLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakAirDefense[$DB], $g_aiFilterMaxAirDefenseLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakXBow[$DB], $g_aiFilterMaxXBowLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakInferno[$DB], $g_aiFilterMaxInfernoLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakEagle[$DB], $g_aiFilterMaxEagleLevel[$DB])
chkDBWeakBase()
GUICtrlSetState($g_ahChkMeetOne[$DB], $g_abFilterMeetOneConditionEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$DB] =(GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$DB] =(GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$DB] = GUICtrlRead($g_hTxtDBSearchesMin)
$g_aiSearchSearchesMax[$DB] = GUICtrlRead($g_hTxtDBSearchesMax)
$g_abSearchTropiesEnable[$DB] =(GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$DB] = GUICtrlRead($g_hTxtDBTropiesMin)
$g_aiSearchTrophiesMax[$DB] = GUICtrlRead($g_hTxtDBTropiesMax)
$g_abSearchCampsEnable[$DB] =(GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$DB] = Int(GUICtrlRead($g_hTxtDBArmyCamps))
$g_iHeroWaitAttackNoBit[$DB][0] = GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][1] = GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][2] = GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED ? 1 : 0
$g_aiSearchNotWaitHeroesEnable[$DB] = GUICtrlRead($g_hChkDBNotWaitHeroes) = $GUI_CHECKED ? 1 : 0
chkNotWaitHeroes()
$g_abSearchSpellsWaitEnable[$DB] =(GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED)
$g_abSearchCastleWaitEnable[$DB] =(GUICtrlRead($g_hChkDBWaitForCastle) = $GUI_CHECKED)
$g_aiFilterMeetGE[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBMeetGE)
$g_aiFilterMinGold[$DB] = GUICtrlRead($g_hTxtDBMinGold)
$g_aiFilterMinElixir[$DB] = GUICtrlRead($g_hTxtDBMinElixir)
$g_aiFilterMinGoldPlusElixir[$DB] = GUICtrlRead($g_hTxtDBMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$DB] =(GUICtrlRead($g_hChkDBMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$DB] = GUICtrlRead($g_hTxtDBMinDarkElixir)
$g_abFilterMeetTrophyEnable[$DB] =(GUICtrlRead($g_hChkDBMeetTrophy) = $GUI_CHECKED)
$g_aiFilterMeetTrophyMin[$DB] = GUICtrlRead($g_hTxtDBMinTrophy)
$g_aiFilterMeetTrophyMax[$DB] = GUICtrlRead($g_hTxtDBMaxTrophy)
$g_abFilterMeetTH[$DB] =(GUICtrlRead($g_hChkDBMeetTH) = $GUI_CHECKED)
$g_aiFilterMeetTHMin[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBTH)
$g_aiMaxTH[$DB] = $g_asTHText[$g_aiFilterMeetTHMin[$DB]]
$g_abFilterMeetTHOutsideEnable[$DB] =(GUICtrlRead($g_hChkDBMeetTHO) = $GUI_CHECKED)
$g_abFilterMaxMortarEnable[$DB] =(GUICtrlRead($g_ahChkMaxMortar[$DB]) = $GUI_CHECKED)
$g_abFilterMaxWizTowerEnable[$DB] =(GUICtrlRead($g_ahChkMaxWizTower[$DB]) = $GUI_CHECKED)
$g_abFilterMaxAirDefenseEnable[$DB] =(GUICtrlRead($g_ahChkMaxAirDefense[$DB]) = $GUI_CHECKED)
$g_abFilterMaxXBowEnable[$DB] =(GUICtrlRead($g_ahChkMaxXBow[$DB]) = $GUI_CHECKED)
$g_abFilterMaxInfernoEnable[$DB] =(GUICtrlRead($g_ahChkMaxInferno[$DB]) = $GUI_CHECKED)
$g_abFilterMaxEagleEnable[$DB] =(GUICtrlRead($g_ahChkMaxEagle[$DB]) = $GUI_CHECKED)
$g_aiFilterMaxMortarLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakMortar[$DB])
$g_aiFilterMaxWizTowerLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakWizTower[$DB])
$g_aiFilterMaxAirDefenseLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakAirDefense[$DB])
$g_aiFilterMaxXBowLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakXBow[$DB])
$g_aiFilterMaxInfernoLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakInferno[$DB])
$g_aiFilterMaxEagleLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakEagle[$DB])
$g_abFilterMeetOneConditionEnable[$DB] =(GUICtrlRead($g_ahChkMeetOne[$DB]) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkABActivateSearches, $g_abSearchSearchesEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABSearchesMin, $g_aiSearchSearchesMin[$LB])
GUICtrlSetData($g_hTxtABSearchesMax, $g_aiSearchSearchesMax[$LB])
GUICtrlSetState($g_hChkABActivateTropies, $g_abSearchTropiesEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABActivateTropies()
GUICtrlSetData($g_hTxtABTropiesMin, $g_aiSearchTrophiesMin[$LB])
GUICtrlSetData($g_hTxtABTropiesMax, $g_aiSearchTrophiesMax[$LB])
GUICtrlSetState($g_hChkABActivateCamps, $g_abSearchCampsEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABActivateCamps()
GUICtrlSetData($g_hTxtABArmyCamps, $g_aiSearchCampsPct[$LB])
chkABActivateSearches()
GUICtrlSetState($g_hChkActivebase, $g_abAttackTypeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABKingWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABQueenWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABWardenWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABNotWaitHeroes, $g_aiSearchNotWaitHeroesEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
$g_iHeroWaitAttackNoBit[$LB][0] = GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][1] = GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][2] = GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED ? 1 : 0
GUICtrlSetState($g_hChkABSpellsWait, $g_abSearchSpellsWaitEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABSpellsWait()
GUICtrlSetState($g_hChkABWaitForCastle, $g_abSearchCastleWaitEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbABMeetGE, $g_aiFilterMeetGE[$LB])
GUICtrlSetData($g_hTxtABMinGold, $g_aiFilterMinGold[$LB])
GUICtrlSetData($g_hTxtABMinElixir, $g_aiFilterMinElixir[$LB])
GUICtrlSetData($g_hTxtABMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$LB])
cmbABGoldElixir()
GUICtrlSetState($g_hChkABMeetDE, $g_abFilterMeetDEEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABMinDarkElixir, $g_aiFilterMeetDEMin[$LB])
chkABMeetDE()
GUICtrlSetState($g_hChkABMeetTrophy, $g_abFilterMeetTrophyEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABMinTrophy, $g_aiFilterMeetTrophyMin[$LB])
GUICtrlSetData($g_hTxtABMaxTrophy, $g_aiFilterMeetTrophyMax[$LB])
chkABMeetTrophy()
GUICtrlSetState($g_hChkABMeetTH, $g_abFilterMeetTH[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbABTH, $g_aiFilterMeetTHMin[$LB])
$g_aiMaxTH[$LB] = $g_asTHText[$g_aiFilterMeetTHMin[$LB]]
chkABMeetTH()
CmbABTH()
GUICtrlSetState($g_hChkABMeetTHO, $g_abFilterMeetTHOutsideEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxMortar[$LB], $g_abFilterMaxMortarEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxWizTower[$LB], $g_abFilterMaxWizTowerEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxAirDefense[$LB], $g_abFilterMaxAirDefenseEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxXBow[$LB], $g_abFilterMaxXBowEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxInferno[$LB], $g_abFilterMaxInfernoEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxEagle[$LB], $g_abFilterMaxEagleEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakMortar[$LB], $g_aiFilterMaxMortarLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakWizTower[$LB], $g_aiFilterMaxWizTowerLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakAirDefense[$LB], $g_aiFilterMaxAirDefenseLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakXBow[$LB], $g_aiFilterMaxXBowLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakInferno[$LB], $g_aiFilterMaxInfernoLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakEagle[$LB], $g_aiFilterMaxEagleLevel[$LB])
chkABWeakBase()
GUICtrlSetState($g_ahChkMeetOne[$LB], $g_abFilterMeetOneConditionEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$LB] =(GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$LB] =(GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$LB] = GUICtrlRead($g_hTxtABSearchesMin)
$g_aiSearchSearchesMax[$LB] = GUICtrlRead($g_hTxtABSearchesMax)
$g_abSearchTropiesEnable[$LB] =(GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$LB] = GUICtrlRead($g_hTxtABTropiesMin)
$g_aiSearchTrophiesMax[$LB] = GUICtrlRead($g_hTxtABTropiesMax)
$g_abSearchCampsEnable[$LB] =(GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$LB] = Int(GUICtrlRead($g_hTxtABArmyCamps))
$g_iHeroWaitAttackNoBit[$LB][0] = GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][1] = GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][2] = GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED ? 1 : 0
$g_aiSearchNotWaitHeroesEnable[$LB] = GUICtrlRead($g_hChkABNotWaitHeroes) = $GUI_CHECKED ? 1 : 0
ChkNotWaitHeroes()
$g_abSearchSpellsWaitEnable[$LB] =(GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED)
$g_abSearchCastleWaitEnable[$LB] =(GUICtrlRead($g_hChkABWaitForCastle) = $GUI_CHECKED)
$g_aiFilterMeetGE[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABMeetGE)
$g_aiFilterMinGold[$LB] = GUICtrlRead($g_hTxtABMinGold)
$g_aiFilterMinElixir[$LB] = GUICtrlRead($g_hTxtABMinElixir)
$g_aiFilterMinGoldPlusElixir[$LB] = GUICtrlRead($g_hTxtABMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$LB] =(GUICtrlRead($g_hChkABMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$LB] = GUICtrlRead($g_hTxtABMinDarkElixir)
$g_abFilterMeetTrophyEnable[$LB] =(GUICtrlRead($g_hChkABMeetTrophy) = $GUI_CHECKED)
$g_aiFilterMeetTrophyMin[$LB] = GUICtrlRead($g_hTxtABMinTrophy)
$g_aiFilterMeetTrophyMax[$LB] = GUICtrlRead($g_hTxtABMaxTrophy)
$g_abFilterMeetTH[$LB] =(GUICtrlRead($g_hChkABMeetTH) = $GUI_CHECKED)
$g_aiFilterMeetTHMin[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABTH)
$g_aiMaxTH[$LB] = $g_asTHText[$g_aiFilterMeetTHMin[$LB]]
$g_abFilterMeetTHOutsideEnable[$LB] =(GUICtrlRead($g_hChkABMeetTHO) = $GUI_CHECKED)
$g_abFilterMaxMortarEnable[$LB] =(GUICtrlRead($g_ahChkMaxMortar[$LB]) = $GUI_CHECKED)
$g_abFilterMaxWizTowerEnable[$LB] =(GUICtrlRead($g_ahChkMaxWizTower[$LB]) = $GUI_CHECKED)
$g_abFilterMaxAirDefenseEnable[$LB] =(GUICtrlRead($g_ahChkMaxAirDefense[$LB]) = $GUI_CHECKED)
$g_abFilterMaxXBowEnable[$LB] =(GUICtrlRead($g_ahChkMaxXBow[$LB]) = $GUI_CHECKED)
$g_abFilterMaxInfernoEnable[$LB] =(GUICtrlRead($g_ahChkMaxInferno[$LB]) = $GUI_CHECKED)
$g_abFilterMaxEagleEnable[$LB] =(GUICtrlRead($g_ahChkMaxEagle[$LB]) = $GUI_CHECKED)
$g_aiFilterMaxMortarLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakMortar[$LB])
$g_aiFilterMaxWizTowerLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakWizTower[$LB])
$g_aiFilterMaxAirDefenseLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakAirDefense[$LB])
$g_aiFilterMaxXBowLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakXBow[$LB])
$g_aiFilterMaxInfernoLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakInferno[$LB])
$g_aiFilterMaxEagleLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakEagle[$LB])
$g_abFilterMeetOneConditionEnable[$LB] =(GUICtrlRead($g_ahChkMeetOne[$LB]) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTSActivateSearches, $g_abSearchSearchesEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTSSearchesMin, $g_aiSearchSearchesMin[$TS])
GUICtrlSetData($g_hTxtTSSearchesMax, $g_aiSearchSearchesMax[$TS])
GUICtrlSetState($g_hChkTSActivateTropies, $g_abSearchTropiesEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateTropies()
GUICtrlSetData($g_hTxtTSTropiesMin, $g_aiSearchTrophiesMin[$TS])
GUICtrlSetData($g_hTxtTSTropiesMax, $g_aiSearchTrophiesMax[$TS])
GUICtrlSetState($g_hChkTSActivateCamps, $g_abSearchCampsEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateCamps()
GUICtrlSetData($g_hTxtTSArmyCamps, $g_aiSearchCampsPct[$TS])
chkTSActivateSearches()
GUICtrlSetState($g_hChkTHSnipe, $g_abAttackTypeEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbTSMeetGE, $g_aiFilterMeetGE[$TS])
GUICtrlSetData($g_hTxtTSMinGold, $g_aiFilterMinGold[$TS])
GUICtrlSetData($g_hTxtTSMinElixir, $g_aiFilterMinElixir[$TS])
GUICtrlSetData($g_hTxtTSMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$TS])
cmbTSGoldElixir()
GUICtrlSetState($g_hChkTSMeetDE, $g_abFilterMeetDEEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTSMinDarkElixir, $g_aiFilterMeetDEMin[$TS])
chkTSMeetDE()
GUICtrlSetData($g_hTxtSWTTiles, $g_iAtkTSAddTilesWhileTrain)
GUICtrlSetData($g_hTxtTHaddTiles, $g_iAtkTSAddTilesFullTroops)
Case "Save"
$g_abAttackTypeEnable[$TS] =(GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$TS] =(GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$TS] = GUICtrlRead($g_hTxtTSSearchesMin)
$g_aiSearchSearchesMax[$TS] = GUICtrlRead($g_hTxtTSSearchesMax)
$g_abSearchTropiesEnable[$TS] =(GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$TS] = GUICtrlRead($g_hTxtTSTropiesMin)
$g_aiSearchTrophiesMax[$TS] = GUICtrlRead($g_hTxtTSTropiesMax)
$g_abSearchCampsEnable[$TS] =(GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$TS] = Int(GUICtrlRead($g_hTxtTSArmyCamps))
$g_aiFilterMeetGE[$TS] = _GUICtrlComboBox_GetCurSel($g_hCmbTSMeetGE)
$g_aiFilterMinGold[$TS] = GUICtrlRead($g_hTxtTSMinGold)
$g_aiFilterMinElixir[$TS] = GUICtrlRead($g_hTxtTSMinElixir)
$g_aiFilterMinGoldPlusElixir[$TS] = GUICtrlRead($g_hTxtTSMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$TS] =(GUICtrlRead($g_hChkTSMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$TS] = GUICtrlRead($g_hTxtTSMinDarkElixir)
$g_iAtkTSAddTilesWhileTrain = GUICtrlRead($g_hTxtSWTTiles)
$g_iAtkTSAddTilesFullTroops = GUICtrlRead($g_hTxtTHaddTiles)
EndSwitch
EndFunc
Func ApplyConfig_600_29($TypeReadSave)
Switch $TypeReadSave
Case "Read"
radHerosApply()
GUICtrlSetState($g_hChkAttackPlannerEnable, $g_bAttackPlannerEnable = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $g_bAttackPlannerCloseCoC = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $g_bAttackPlannerCloseAll = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerSuspendComputer, $g_bAttackPlannerSuspendComputer = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerRandom, $g_bAttackPlannerRandomEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbAttackPlannerRandom,($g_iAttackPlannerRandomTime - 1))
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $g_bAttackPlannerDayLimit = True ? $GUI_CHECKED : $GUI_UNCHECKED)
chkAttackPlannerEnable()
GUICtrlSetData($g_hCmbAttackPlannerDayMin, $g_iAttackPlannerDayMin)
GUICtrlSetData($g_hCmbAttackPlannerDayMax, $g_iAttackPlannerDayMax)
_cmbAttackPlannerDayLimit()
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $g_abPlannedAttackWeekDays[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $g_abPlannedattackHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetState($g_hChkDropCCHoursEnable, $g_bPlannedDropCCHoursEnable = True ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDropCCHoursEnable()
For $i = 0 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $g_abPlannedDropCCHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
If GUICtrlRead($g_hRadAutoQueenAbility) = $GUI_CHECKED Then
$g_iActivateQueen = 0
ElseIf GUICtrlRead($g_hRadManQueenAbility) = $GUI_CHECKED Then
$g_iActivateQueen = 1
ElseIf GUICtrlRead($g_hRadBothQueenAbility) = $GUI_CHECKED Then
$g_iActivateQueen = 2
EndIf
$g_iDelayActivateQueen = Int(GUICtrlRead($g_hTxtManQueenAbility) * 1000)
If GUICtrlRead($g_hRadAutoKingAbility) = $GUI_CHECKED Then
$g_iActivateKing = 0
ElseIf GUICtrlRead($g_hRadManKingAbility) = $GUI_CHECKED Then
$g_iActivateKing = 1
ElseIf GUICtrlRead($g_hRadBothKingAbility) = $GUI_CHECKED Then
$g_iActivateKing = 2
EndIf
$g_iDelayActivateKing = Int(GUICtrlRead($g_hTxtManKingAbility) * 1000)
If GUICtrlRead($g_hRadAutoWardenAbility) = $GUI_CHECKED Then
$g_iActivateWarden = 0
ElseIf GUICtrlRead($g_hRadManWardenAbility) = $GUI_CHECKED Then
$g_iActivateWarden = 1
ElseIf GUICtrlRead($g_hRadBothWardenAbility) = $GUI_CHECKED Then
$g_iActivateWarden = 2
EndIf
$g_iDelayActivateWarden = Int(GUICtrlRead($g_hTxtManWardenAbility) * 1000)
$g_bAttackPlannerEnable =(GUICtrlRead($g_hChkAttackPlannerEnable) = $GUI_CHECKED)
$g_bAttackPlannerCloseCoC =(GUICtrlRead($g_hChkAttackPlannerCloseCoC) = $GUI_CHECKED)
$g_bAttackPlannerCloseAll =(GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_CHECKED)
$g_bAttackPlannerSuspendComputer =(GUICtrlRead($g_hChkAttackPlannerSuspendComputer) = $GUI_CHECKED)
$g_bAttackPlannerRandomEnable =(GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED)
$g_iAttackPlannerRandomTime =(_GUICtrlComboBox_GetCurSel($g_hCmbAttackPlannerRandom) + 1)
$g_bAttackPlannerDayLimit =(GUICtrlRead($g_hChkAttackPlannerDayLimit) = $GUI_CHECKED)
$g_iAttackPlannerDayMin = GUICtrlRead($g_hCmbAttackPlannerDayMin)
$g_iAttackPlannerDayMax = GUICtrlRead($g_hCmbAttackPlannerDayMax)
Local $string = ""
For $i = 0 To 6
$g_abPlannedAttackWeekDays[$i] =(GUICtrlRead($g_ahChkAttackWeekdays[$i]) = $GUI_CHECKED)
Next
Local $string = ""
For $i = 0 To 23
$g_abPlannedattackHours[$i] =(GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED)
Next
$g_bPlannedDropCCHoursEnable =(GUICtrlRead($g_hChkDropCCHoursEnable) = $GUI_CHECKED)
Local $string = ""
For $i = 0 To 23
$g_abPlannedDropCCHours[$i] = GUICtrlRead($g_ahChkDropCCHours[$i]) = $GUI_CHECKED ? 1 : 0
Next
EndSwitch
EndFunc
Func ApplyConfig_600_29_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbDBAlgorithm, $g_aiAttackAlgorithm[$DB])
cmbDBAlgorithm()
_GUICtrlComboBox_SetCurSel($g_hCmbDBSelectTroop, $g_aiAttackTroopSelection[$DB])
GUICtrlSetState($g_hChkDBKingAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBQueenAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBWardenAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBWardenAttack()
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkDBKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkDBQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkDBWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkDBDropCC, $g_abAttackDropCC[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBDropCC()
GUICtrlSetState($g_hChkDBLightSpell, $g_abAttackUseLightSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBHealSpell, $g_abAttackUseHealSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBRageSpell, $g_abAttackUseRageSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBJumpSpell, $g_abAttackUseJumpSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBFreezeSpell, $g_abAttackUseFreezeSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBCloneSpell, $g_abAttackUseCloneSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBPoisonSpell, $g_abAttackUsePoisonSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBHasteSpell, $g_abAttackUseHasteSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBSkeletonSpell, $g_abAttackUseSkeletonSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBBatSpell, $g_abAttackUseBatSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTHSnipeBeforeDBEnable, $g_bTHSnipeBeforeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTHSnipeBeforeDBEnable()
GUICtrlSetData($g_hTxtTHSnipeBeforeDBTiles, $g_iTHSnipeBeforeTiles[$DB])
LoadDBSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, $g_iTHSnipeBeforeScript[$DB]))
_GUICtrlComboBox_SetCurSel($g_hCmbDBWardenMode, $g_aiAttackUseWardenMode[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbDBSiege, $g_aiAttackUseSiege[$DB])
Case "Save"
$g_aiAttackAlgorithm[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
$g_aiAttackTroopSelection[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkDBKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkDBQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkDBWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$DB] =(GUICtrlRead($g_hChkDBDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$DB] =(GUICtrlRead($g_hChkDBLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$DB] =(GUICtrlRead($g_hChkDBHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$DB] =(GUICtrlRead($g_hChkDBRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$DB] =(GUICtrlRead($g_hChkDBJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$DB] =(GUICtrlRead($g_hChkDBFreezeSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$DB] =(GUICtrlRead($g_hChkDBPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$DB] =(GUICtrlRead($g_hChkDBEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$DB] =(GUICtrlRead($g_hChkDBHasteSpell) = $GUI_CHECKED)
$g_abAttackUseCloneSpell[$DB] =(GUICtrlRead($g_hChkDBCloneSpell) = $GUI_CHECKED)
$g_abAttackUseSkeletonSpell[$DB] =(GUICtrlRead($g_hChkDBSkeletonSpell) = $GUI_CHECKED)
$g_abAttackUseBatSpell[$DB] =(GUICtrlRead($g_hChkDBBatSpell) = $GUI_CHECKED)
$g_bTHSnipeBeforeEnable[$DB] =(GUICtrlRead($g_hChkTHSnipeBeforeDBEnable) = $GUI_CHECKED)
$g_iTHSnipeBeforeTiles[$DB] = GUICtrlRead($g_hTxtTHSnipeBeforeDBTiles)
$g_iTHSnipeBeforeScript[$DB] = GUICtrlRead($g_hCmbTHSnipeBeforeDBScript)
$g_aiAttackUseWardenMode[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBWardenMode)
$g_aiAttackUseSiege[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBSiege)
EndSwitch
ApplyConfig_600_29_DB_Standard($TypeReadSave)
ApplyConfig_600_29_DB_Scripted($TypeReadSave)
ApplyConfig_600_29_DB_SmartFarm($TypeReadSave)
EndFunc
Func ApplyConfig_600_29_DB_Standard($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropOrderDB, $g_aiAttackStdDropOrder[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropSidesDB, $g_aiAttackStdDropSides[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayDB, $g_aiAttackStdUnitDelay[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayDB, $g_aiAttackStdWaveDelay[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayDB1, $g_aiAttackStdUnitDelay[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayDB1, $g_aiAttackStdWaveDelay[$DB])
GUICtrlSetState($g_hChkRandomSpeedAtkDB, $g_abAttackStdRandomizeDelay[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkRandomSpeedAtkDB1, $g_abAttackStdRandomizeDelay[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkRandomSpeedAtkDB()
GUICtrlSetState($g_hChkSmartAttackRedAreaDB, $g_abAttackStdSmartAttack[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSmartAttackRedAreaDB()
_GUICtrlComboBox_SetCurSel($g_hCmbSmartDeployDB, $g_aiAttackStdSmartDeploy[$DB])
GUICtrlSetState($g_hChkAttackNearGoldMineDB, $g_abAttackStdSmartNearCollectors[$DB][0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearElixirCollectorDB, $g_abAttackStdSmartNearCollectors[$DB][1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearDarkElixirDrillDB, $g_abAttackStdSmartNearCollectors[$DB][2] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_aiAttackStdDropOrder[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropOrderDB)
$g_aiAttackStdDropSides[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesDB)
$g_aiAttackStdUnitDelay[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardUnitDelayDB)
$g_aiAttackStdWaveDelay[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardWaveDelayDB)
$g_abAttackStdRandomizeDelay[$DB] =(GUICtrlRead($g_hChkRandomSpeedAtkDB) = $GUI_CHECKED)
$g_abAttackStdSmartAttack[$DB] =(GUICtrlRead($g_hChkSmartAttackRedAreaDB) = $GUI_CHECKED)
$g_aiAttackStdSmartDeploy[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbSmartDeployDB)
$g_abAttackStdSmartNearCollectors[$DB][0] =(GUICtrlRead($g_hChkAttackNearGoldMineDB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$DB][1] =(GUICtrlRead($g_hChkAttackNearElixirCollectorDB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$DB][2] =(GUICtrlRead($g_hChkAttackNearDarkElixirDrillDB) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_29_DB_Scripted($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplDB, $g_aiAttackScrRedlineRoutine[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineDB, $g_aiAttackScrDroplineEdge[$DB])
PopulateComboScriptsFilesDB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $g_sAttackScrScriptName[$DB])
If $tempindex = -1 Then
$tempindex = 0
SetLog("Previous saved Scripted Attack not found (deleted, renamed?)", $COLOR_ERROR)
SetLog("Automatically setted a default script, please check your config", $COLOR_ERROR)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, $tempindex)
cmbScriptNameDB()
cmbScriptRedlineImplDB()
Case "Save"
$g_aiAttackScrRedlineRoutine[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplDB)
$g_aiAttackScrDroplineEdge[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineDB)
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$DB] = $scriptname
IniWriteS($g_sProfileConfigPath, "attack", "ScriptDB", $g_sAttackScrScriptName[$DB])
EndSwitch
EndFunc
Func ApplyConfig_600_29_DB_SmartFarm($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetData($g_hTxtInsidePercentage, $g_iTxtInsidePercentage)
GUICtrlSetData($g_hTxtOutsidePercentage, $g_iTxtOutsidePercentage)
GUICtrlSetState($g_hChkDebugSmartFarm, $g_bDebugSmartFarm ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_iTxtInsidePercentage = GUICtrlRead($g_hTxtInsidePercentage)
$g_iTxtOutsidePercentage = GUICtrlRead($g_hTxtOutsidePercentage)
$g_bDebugSmartFarm =(GUICtrlRead($g_hChkDebugSmartFarm) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_29_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbABAlgorithm, $g_aiAttackAlgorithm[$LB])
cmbABAlgorithm()
_GUICtrlComboBox_SetCurSel($g_hCmbABSelectTroop, $g_aiAttackTroopSelection[$LB])
GUICtrlSetState($g_hChkABKingAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABQueenAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABWardenAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABWardenAttack()
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkABKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkABQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkABWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkABDropCC, $g_abAttackDropCC[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABDropCC()
GUICtrlSetState($g_hChkABLightSpell, $g_abAttackUseLightSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABHealSpell, $g_abAttackUseHealSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABRageSpell, $g_abAttackUseRageSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABJumpSpell, $g_abAttackUseJumpSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABFreezeSpell, $g_abAttackUseFreezeSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABCloneSpell, $g_abAttackUseCloneSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABPoisonSpell, $g_abAttackUsePoisonSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABHasteSpell, $g_abAttackUseHasteSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABSkeletonSpell, $g_abAttackUseSkeletonSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABBatSpell, $g_abAttackUseBatSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTHSnipeBeforeLBEnable, $g_bTHSnipeBeforeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTHSnipeBeforeLBEnable()
GUICtrlSetData($g_hTxtTHSnipeBeforeLBTiles, $g_iTHSnipeBeforeTiles[$LB])
LoadABSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, $g_iTHSnipeBeforeScript[$LB]))
_GUICtrlComboBox_SetCurSel($g_hCmbABWardenMode, $g_aiAttackUseWardenMode[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbABSiege, $g_aiAttackUseSiege[$LB])
Case "Save"
$g_aiAttackAlgorithm[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABAlgorithm)
$g_aiAttackTroopSelection[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkABKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkABQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkABWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$LB] =(GUICtrlRead($g_hChkABDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$LB] =(GUICtrlRead($g_hChkABLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$LB] =(GUICtrlRead($g_hChkABHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$LB] =(GUICtrlRead($g_hChkABRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$LB] =(GUICtrlRead($g_hChkABJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$LB] =(GUICtrlRead($g_hChkABFreezeSpell) = $GUI_CHECKED)
$g_abAttackUseCloneSpell[$LB] =(GUICtrlRead($g_hChkABCloneSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$LB] =(GUICtrlRead($g_hChkABPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$LB] =(GUICtrlRead($g_hChkABEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$LB] =(GUICtrlRead($g_hChkABHasteSpell) = $GUI_CHECKED)
$g_abAttackUseSkeletonSpell[$LB] =(GUICtrlRead($g_hChkABSkeletonSpell) = $GUI_CHECKED)
$g_abAttackUseBatSpell[$LB] =(GUICtrlRead($g_hChkABBatSpell) = $GUI_CHECKED)
$g_bTHSnipeBeforeEnable[$LB] =(GUICtrlRead($g_hChkTHSnipeBeforeLBEnable) = $GUI_CHECKED)
$g_iTHSnipeBeforeTiles[$LB] = GUICtrlRead($g_hTxtTHSnipeBeforeLBTiles)
$g_iTHSnipeBeforeScript[$LB] = GUICtrlRead($g_hCmbTHSnipeBeforeLBScript)
$g_aiAttackUseWardenMode[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABWardenMode)
$g_aiAttackUseSiege[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABSiege)
EndSwitch
ApplyConfig_600_29_LB_Standard($TypeReadSave)
ApplyConfig_600_29_LB_Scripted($TypeReadSave)
EndFunc
Func ApplyConfig_600_29_LB_Standard($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropOrderAB, $g_aiAttackStdDropOrder[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropSidesAB, $g_aiAttackStdDropSides[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayAB, $g_aiAttackStdUnitDelay[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayAB, $g_aiAttackStdWaveDelay[$LB])
GUICtrlSetState($g_hChkRandomSpeedAtkAB, $g_abAttackStdRandomizeDelay[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkRandomSpeedAtkAB()
GUICtrlSetState($g_hChkSmartAttackRedAreaAB, $g_abAttackStdSmartAttack[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSmartAttackRedAreaAB()
_GUICtrlComboBox_SetCurSel($g_hCmbSmartDeployAB, $g_aiAttackStdSmartDeploy[$LB])
GUICtrlSetState($g_hChkAttackNearGoldMineAB, $g_abAttackStdSmartNearCollectors[$LB][0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearElixirCollectorAB, $g_abAttackStdSmartNearCollectors[$LB][1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearDarkElixirDrillAB, $g_abAttackStdSmartNearCollectors[$LB][2] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_aiAttackStdDropOrder[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropOrderAB)
$g_aiAttackStdDropSides[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesAB)
$g_aiAttackStdUnitDelay[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardUnitDelayAB)
$g_aiAttackStdWaveDelay[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardWaveDelayAB)
$g_abAttackStdRandomizeDelay[$LB] =(GUICtrlRead($g_hChkRandomSpeedAtkAB) = $GUI_CHECKED)
$g_abAttackStdSmartAttack[$LB] =(GUICtrlRead($g_hChkSmartAttackRedAreaAB) = $GUI_CHECKED)
$g_aiAttackStdSmartDeploy[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbSmartDeployAB)
$g_abAttackStdSmartNearCollectors[$LB][0] =(GUICtrlRead($g_hChkAttackNearGoldMineAB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$LB][1] =(GUICtrlRead($g_hChkAttackNearElixirCollectorAB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$LB][2] =(GUICtrlRead($g_hChkAttackNearDarkElixirDrillAB) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_29_LB_Scripted($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplAB, $g_aiAttackScrRedlineRoutine[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineAB, $g_aiAttackScrDroplineEdge[$LB])
PopulateComboScriptsFilesAB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $g_sAttackScrScriptName[$LB])
If $tempindex = -1 Then
$tempindex = 0
SetLog("Previous saved Scripted Attack not found (deleted, renamed?)", $COLOR_ERROR)
SetLog("Automatically setted a default script, please check your config", $COLOR_ERROR)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, $tempindex)
cmbScriptNameAB()
cmbScriptRedlineImplAB()
Case "Save"
$g_aiAttackScrRedlineRoutine[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplAB)
$g_aiAttackScrDroplineEdge[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineAB)
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$LB] = $scriptname
IniWriteS($g_sProfileConfigPath, "attack", "ScriptAB", $g_sAttackScrScriptName[$LB])
EndSwitch
EndFunc
Func ApplyConfig_600_29_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbTSSelectTroop, $g_aiAttackTroopSelection[$TS])
GUICtrlSetState($g_hChkTSKingAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSQueenAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSWardenAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkTSKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkTSQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkTSWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkTSDropCC, $g_abAttackDropCC[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSLightSpell, $g_abAttackUseLightSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSHealSpell, $g_abAttackUseHealSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSRageSpell, $g_abAttackUseRageSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSJumpSpell, $g_abAttackUseJumpSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSFreezeSpell, $g_abAttackUseFreezeSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSPoisonSpell, $g_abAttackUsePoisonSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSHasteSpell, $g_abAttackUseHasteSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
LoadThSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbAttackTHType, _GUICtrlComboBox_FindStringExact($g_hCmbAttackTHType, $g_sAtkTSType))
Case "Save"
$g_aiAttackTroopSelection[$TS] = _GUICtrlComboBox_GetCurSel($g_hCmbTSSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkTSKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkTSQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkTSWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$TS] =(GUICtrlRead($g_hChkTSDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$TS] =(GUICtrlRead($g_hChkTSLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$TS] =(GUICtrlRead($g_hChkTSHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$TS] =(GUICtrlRead($g_hChkTSRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$TS] =(GUICtrlRead($g_hChkTSJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$TS] =(GUICtrlRead($g_hChkTSFreezeSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$TS] =(GUICtrlRead($g_hChkTSPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$TS] =(GUICtrlRead($g_hChkTSEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$TS] =(GUICtrlRead($g_hChkTSHasteSpell) = $GUI_CHECKED)
$g_sAtkTSType = GUICtrlRead($g_hCmbAttackTHType)
EndSwitch
EndFunc
Func ApplyConfig_600_30($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkShareAttack, $g_bShareAttackEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtShareMinGold, $g_iShareMinGold)
GUICtrlSetData($g_hTxtShareMinElixir, $g_iShareMinElixir)
GUICtrlSetData($g_hTxtShareMinDark, $g_iShareMinDark)
GUICtrlSetData($g_hTxtShareMessage, StringReplace($g_sShareMessage, "|", @CRLF))
chkShareAttack()
GUICtrlSetState($g_hChkTakeLootSS, $g_bTakeLootSnapShot ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotLootInfo, $g_bScreenshotLootInfo ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTakeLootSS()
Case "Save"
$g_bShareAttackEnable =(GUICtrlRead($g_hChkShareAttack) = $GUI_CHECKED)
$g_iShareMinGold = GUICtrlRead($g_hTxtShareMinGold)
$g_iShareMinElixir = GUICtrlRead($g_hTxtShareMinElixir)
$g_iShareMinDark = GUICtrlRead($g_hTxtShareMinDark)
$g_sShareMessage = StringReplace(GUICtrlRead($g_hTxtShareMessage), @CRLF, "|")
$g_bTakeLootSnapShot =(GUICtrlRead($g_hChkTakeLootSS) = $GUI_CHECKED)
$g_bScreenshotLootInfo =(GUICtrlRead($g_hChkScreenshotLootInfo) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_30_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkStopAtkDBNoLoot1, $g_abStopAtkNoLoot1Enable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkDBNoLoot1, $g_aiStopAtkNoLoot1Time[$DB])
chkStopAtkDBNoLoot1()
GUICtrlSetState($g_hChkStopAtkDBNoLoot2, $g_abStopAtkNoLoot2Enable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkDBNoLoot2, $g_aiStopAtkNoLoot2Time[$DB])
chkStopAtkDBNoLoot2()
GUICtrlSetData($g_hTxtDBMinGoldStopAtk2, $g_aiStopAtkNoLoot2MinGold[$DB])
GUICtrlSetData($g_hTxtDBMinElixirStopAtk2, $g_aiStopAtkNoLoot2MinElixir[$DB])
GUICtrlSetData($g_hTxtDBMinDarkElixirStopAtk2, $g_aiStopAtkNoLoot2MinDark[$DB])
GUICtrlSetState($g_hChkDBEndNoResources, $g_abStopAtkNoResources[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndOneStar, $g_abStopAtkOneStar[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndTwoStars, $g_abStopAtkTwoStars[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndPercentHigher, $g_abStopAtkPctHigherEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBPercentHigher, $g_aiStopAtkPctHigherAmt[$DB])
chkDBEndPercentHigher()
GUICtrlSetState($g_hChkDBEndPercentChange, $g_abStopAtkPctNoChangeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBPercentChange, $g_aiStopAtkPctNoChangeTime[$DB])
chkDBEndPercentChange()
Case "Save"
$g_abStopAtkNoLoot1Enable[$DB] =(GUICtrlRead($g_hChkStopAtkDBNoLoot1) = $GUI_CHECKED)
$g_aiStopAtkNoLoot1Time[$DB] = Int(GUICtrlRead($g_hTxtStopAtkDBNoLoot1))
$g_abStopAtkNoLoot2Enable[$DB] =(GUICtrlRead($g_hChkStopAtkDBNoLoot2) = $GUI_CHECKED)
$g_aiStopAtkNoLoot2Time[$DB] = Int(GUICtrlRead($g_hTxtStopAtkDBNoLoot2))
$g_aiStopAtkNoLoot2MinGold[$DB] = Int(GUICtrlRead($g_hTxtDBMinGoldStopAtk2))
$g_aiStopAtkNoLoot2MinElixir[$DB] = Int(GUICtrlRead($g_hTxtDBMinElixirStopAtk2))
$g_aiStopAtkNoLoot2MinDark[$DB] = Int(GUICtrlRead($g_hTxtDBMinDarkElixirStopAtk2))
$g_abStopAtkNoResources[$DB] =(GUICtrlRead($g_hChkDBEndNoResources) = $GUI_CHECKED)
$g_abStopAtkOneStar[$DB] =(GUICtrlRead($g_hChkDBEndOneStar) = $GUI_CHECKED)
$g_abStopAtkTwoStars[$DB] =(GUICtrlRead($g_hChkDBEndTwoStars) = $GUI_CHECKED)
$g_abStopAtkPctHigherEnable[$DB] =(GUICtrlRead($g_hChkDBEndPercentHigher) = $GUI_CHECKED)
$g_aiStopAtkPctHigherAmt[$DB] = GUICtrlRead($g_hTxtDBPercentHigher)
$g_abStopAtkPctNoChangeEnable[$DB] =(GUICtrlRead($g_hChkDBEndPercentChange) = $GUI_CHECKED)
$g_aiStopAtkPctNoChangeTime[$DB] = GUICtrlRead($g_hTxtDBPercentChange)
EndSwitch
EndFunc
Func ApplyConfig_600_30_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkStopAtkABNoLoot1, $g_abStopAtkNoLoot1Enable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkABNoLoot1, $g_aiStopAtkNoLoot1Time[$LB])
chkStopAtkABNoLoot1()
GUICtrlSetState($g_hChkStopAtkABNoLoot2, $g_abStopAtkNoLoot2Enable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkABNoLoot2, $g_aiStopAtkNoLoot2Time[$LB])
chkStopAtkABNoLoot2()
GUICtrlSetData($g_hTxtABMinGoldStopAtk2, $g_aiStopAtkNoLoot2MinGold[$LB])
GUICtrlSetData($g_hTxtABMinElixirStopAtk2, $g_aiStopAtkNoLoot2MinElixir[$LB])
GUICtrlSetData($g_hTxtABMinDarkElixirStopAtk2, $g_aiStopAtkNoLoot2MinDark[$LB])
GUICtrlSetState($g_hChkABEndNoResources, $g_abStopAtkNoResources[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndOneStar, $g_abStopAtkOneStar[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndTwoStars, $g_abStopAtkTwoStars[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDESideEB, $g_bDESideEndEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDESideEB()
GUICtrlSetData($g_hTxtDELowEndMin, $g_iDESideEndMin)
GUICtrlSetState($g_hChkDisableOtherEBO, $g_bDESideDisableOther ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndBk, $g_bDESideEndBKWeak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndAq, $g_bDESideEndAQWeak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndOneStar, $g_bDESideEndOneStar ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndPercentHigher, $g_abStopAtkPctHigherEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABPercentHigher, $g_aiStopAtkPctHigherAmt[$LB])
chkABEndPercentHigher()
GUICtrlSetState($g_hChkABEndPercentChange, $g_abStopAtkPctNoChangeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABPercentChange, $g_aiStopAtkPctNoChangeTime[$LB])
chkABEndPercentChange()
Case "Save"
$g_abStopAtkNoLoot1Enable[$LB] =(GUICtrlRead($g_hChkStopAtkABNoLoot1) = $GUI_CHECKED)
$g_aiStopAtkNoLoot1Time[$LB] = Int(GUICtrlRead($g_hTxtStopAtkABNoLoot1))
$g_abStopAtkNoLoot2Enable[$LB] =(GUICtrlRead($g_hChkStopAtkABNoLoot2) = $GUI_CHECKED)
$g_aiStopAtkNoLoot2Time[$LB] =(GUICtrlRead($g_hTxtStopAtkABNoLoot2))
$g_aiStopAtkNoLoot2MinGold[$LB] = Int(GUICtrlRead($g_hTxtABMinGoldStopAtk2))
$g_aiStopAtkNoLoot2MinElixir[$LB] = Int(GUICtrlRead($g_hTxtABMinElixirStopAtk2))
$g_aiStopAtkNoLoot2MinDark[$LB] = Int(GUICtrlRead($g_hTxtABMinDarkElixirStopAtk2))
$g_abStopAtkNoResources[$LB] =(GUICtrlRead($g_hChkABEndNoResources) = $GUI_CHECKED)
$g_abStopAtkOneStar[$LB] =(GUICtrlRead($g_hChkABEndOneStar) = $GUI_CHECKED)
$g_abStopAtkTwoStars[$LB] =(GUICtrlRead($g_hChkABEndTwoStars) = $GUI_CHECKED)
$g_bDESideEndEnable =(GUICtrlRead($g_hChkDESideEB) = $GUI_CHECKED)
$g_iDESideEndMin = GUICtrlRead($g_hTxtDELowEndMin)
$g_bDESideDisableOther =(GUICtrlRead($g_hChkDisableOtherEBO) = $GUI_CHECKED)
$g_bDESideEndAQWeak =(GUICtrlRead($g_hChkDEEndAq) = $GUI_CHECKED)
$g_bDESideEndBKWeak =(GUICtrlRead($g_hChkDEEndBk) = $GUI_CHECKED)
$g_bDESideEndOneStar =(GUICtrlRead($g_hChkDEEndOneStar) = $GUI_CHECKED)
$g_abStopAtkPctHigherEnable[$LB] =(GUICtrlRead($g_hChkABEndPercentHigher) = $GUI_CHECKED)
$g_aiStopAtkPctHigherAmt[$LB] = GUICtrlRead($g_hTxtABPercentHigher)
$g_abStopAtkPctNoChangeEnable[$LB] =(GUICtrlRead($g_hChkABEndPercentChange) = $GUI_CHECKED)
$g_aiStopAtkPctNoChangeTime[$LB] = GUICtrlRead($g_hTxtABPercentChange)
EndSwitch
EndFunc
Func ApplyConfig_600_30_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTSActivateCamps2, $g_bEndTSCampsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateCamps2()
GUICtrlSetData($g_hTxtTSArmyCamps2, $g_iEndTSCampsPct)
Case "Save"
$g_bEndTSCampsEnable =(GUICtrlRead($g_hChkTSActivateCamps2) = $GUI_CHECKED)
$g_iEndTSCampsPct = GUICtrlRead($g_hTxtTSArmyCamps2)
EndSwitch
EndFunc
Func ApplyConfig_600_31($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $i = 6 To 13
GUICtrlSetState($g_ahChkDBCollectorLevel[$i], $g_abCollectorLevelEnabled[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahCmbDBCollectorLevel[$i], $g_abCollectorLevelEnabled[$i] ? $GUI_ENABLE : $GUI_DISABLE)
_GUICtrlComboBox_SetCurSel($g_ahCmbDBCollectorLevel[$i], $g_aiCollectorLevelFill[$i])
Next
GUICtrlSetState($g_hChkDBDisableCollectorsFilter, $g_bCollectorFilterDisable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbMinCollectorMatches, $g_iCollectorMatchesMin - 1)
GUICtrlSetData($g_hSldCollectorTolerance, $g_iCollectorToleranceOffset)
checkCollectors()
Case "Save"
For $i = 6 To 13
$g_abCollectorLevelEnabled[$i] =(GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED)
$g_aiCollectorLevelFill[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbDBCollectorLevel[$i])
Next
$g_bCollectorFilterDisable =(GUICtrlRead($g_hChkDBDisableCollectorsFilter) = $GUI_CHECKED)
$g_iCollectorMatchesMin = _GUICtrlComboBox_GetCurSel($g_hCmbMinCollectorMatches) + 1
$g_iCollectorToleranceOffset = GUICtrlRead($g_hSldCollectorTolerance)
EndSwitch
EndFunc
Func ApplyConfig_600_32($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTrophyRange, $g_bDropTrophyEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtMaxTrophy, $g_iDropTrophyMax)
GUICtrlSetData($g_hTxtDropTrophy, $g_iDropTrophyMin)
GUICtrlSetState($g_hChkTrophyHeroes, $g_bDropTrophyUseHeroes ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTrophyHeroes()
_GUICtrlComboBox_SetCurSel($g_hCmbTrophyHeroesPriority, $g_iDropTrophyHeroesPriority)
GUICtrlSetState($g_hChkTrophyAtkDead, $g_bDropTrophyAtkDead ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDropTrophyArmyMin, $g_iDropTrophyArmyMinPct)
chkTrophyRange()
TxtDropTrophy()
TxtMaxTrophy()
Case "Save"
$g_bDropTrophyEnable =(GUICtrlRead($g_hChkTrophyRange) = $GUI_CHECKED)
$g_iDropTrophyMax = GUICtrlRead($g_hTxtMaxTrophy)
$g_iDropTrophyMin = GUICtrlRead($g_hTxtDropTrophy)
$g_bDropTrophyUseHeroes =(GUICtrlRead($g_hChkTrophyHeroes) = $GUI_CHECKED)
$g_iDropTrophyHeroesPriority = _GUICtrlComboBox_GetCurSel($g_hCmbTrophyHeroesPriority)
$g_bDropTrophyAtkDead =(GUICtrlRead($g_hChkTrophyAtkDead) = $GUI_CHECKED)
$g_iDropTrophyArmyMinPct = GUICtrlRead($g_hTxtDropTrophyArmyMin)
EndSwitch
EndFunc
Func ApplyConfig_600_33($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkCustomDropOrderEnable, $g_bCustomDropOrderEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDropOrder()
For $p = 0 To UBound($g_ahCmbDropOrder) - 1
_GUICtrlComboBox_SetCurSel($g_ahCmbDropOrder[$p], $g_aiCmbCustomDropOrder[$p])
_GUICtrlSetImage($g_ahImgDropOrder[$p], $g_sLibIconPath, $g_aiDropOrderIcon[$g_aiCmbCustomDropOrder[$p] + 1])
Next
If $g_bCustomDropOrderEnable Then
If Not ChangeDropOrder() Then
SetDefaultDropOrderGroup()
GUICtrlSetState($g_hChkCustomDropOrderEnable, $GUI_UNCHECKED)
$g_bCustomDropOrderEnable = False
GUICtrlSetState($g_hBtnDropOrderSet, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRemoveDropOrder, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbDropOrder) - 1
GUICtrlSetState($g_ahCmbDropOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
Case "Save"
$g_bCustomDropOrderEnable =(GUICtrlRead($g_hChkCustomDropOrderEnable) = $GUI_CHECKED)
For $p = 0 To UBound($g_ahCmbDropOrder) - 1
$g_aiCmbCustomDropOrder[$p] = _GUICtrlComboBox_GetCurSel($g_ahCmbDropOrder[$p])
Next
EndSwitch
EndFunc
Func ApplyConfig_600_35_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
LoadLanguagesComboBox()
GUICtrlSetState($g_hChkDisableSplash, $g_bDisableSplash ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkForMBRUpdates, $g_bCheckVersion ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteLogs, $g_bDeleteLogs ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteLogsDays, $g_iDeleteLogsDays)
chkDeleteLogs()
GUICtrlSetState($g_hChkDeleteTemp, $g_bDeleteTemp ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteTempDays, $g_iDeleteTempDays)
chkDeleteTemp()
GUICtrlSetState($g_hChkDeleteLoots, $g_bDeleteLoots ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteLootsDays, $g_iDeleteLootsDays)
chkDeleteLoots()
GUICtrlSetState($g_hChkAutostart, $g_bAutoStart ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAutostartDelay, $g_iAutoStartDelay)
chkAutoStart()
GUICtrlSetState($g_hChkCheckGameLanguage, $g_bCheckGameLanguage ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAutoAlign, $g_bAutoAlignEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDisposeWindows()
_GUICtrlComboBox_SetCurSel($g_hCmbAlignmentOptions, $g_iAutoAlignPosition)
GUICtrlSetData($g_hTxtAlignOffsetX, $g_iAutoAlignOffsetX)
GUICtrlSetData($g_hTxtAlignOffsetY, $g_iAutoAlignOffsetY)
GUICtrlSetState($g_hChkBotCustomTitleBarClick,((BitAND($g_iBotDesignFlags, 1)) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
GUICtrlSetState($g_hChkBotAutoSlideClick,((BitAND($g_iBotDesignFlags, 2)) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
GUICtrlSetState($g_hChkHideWhenMinimized, $g_bHideWhenMinimized ? $GUI_CHECKED : $GUI_UNCHECKED)
TrayItemSetState($g_hTiHide, $g_bHideWhenMinimized ? $TRAY_CHECKED : $TRAY_UNCHECKED)
GUICtrlSetState($g_hChkUseRandomClick, $g_bUseRandomClick ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotType, $g_bScreenshotPNGFormat ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotHideName, $g_bScreenshotHideName ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTimeAnotherDevice, Int(Int($g_iAnotherDeviceWaitTime) / 60))
GUICtrlSetState($g_hChkSinglePBTForced, $g_bForceSinglePBLogoff ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSinglePBTimeForced, $g_iSinglePBForcedLogoffTime)
GUICtrlSetData($g_hTxtPBTimeForcedExit, $g_iSinglePBForcedEarlyExitTime)
chkSinglePBTForced()
GUICtrlSetState($g_hChkAutoResume, $g_bAutoResumeEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAutoResumeTime, $g_iAutoResumeTime)
chkAutoResume()
GUICtrlSetState($g_hChkDisableNotifications, $g_bDisableNotifications ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkFixClanCastle, $g_bForceClanCastleDetection ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSqlite, $g_bUseStatistics ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkOnlySCIDAccounts, $g_bOnlySCIDAccounts ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbWhatSCIDAccount2Use, $g_iWhatSCIDAccount2Use)
OnlySCIDAccounts()
Case "Save"
$g_bDisableSplash =(GUICtrlRead($g_hChkDisableSplash) = $GUI_CHECKED)
$g_bCheckVersion =(GUICtrlRead($g_hChkForMBRUpdates) = $GUI_CHECKED)
$g_bDeleteLogs =(GUICtrlRead($g_hChkDeleteLogs) = $GUI_CHECKED)
$g_iDeleteLogsDays = GUICtrlRead($g_hTxtDeleteLogsDays)
$g_bDeleteTemp =(GUICtrlRead($g_hChkDeleteTemp) = $GUI_CHECKED)
$g_iDeleteTempDays = GUICtrlRead($g_hTxtDeleteTempDays)
$g_bDeleteLoots =(GUICtrlRead($g_hChkDeleteLoots) = $GUI_CHECKED)
$g_iDeleteLootsDays = GUICtrlRead($g_hTxtDeleteLootsDays)
$g_bAutoStart =(GUICtrlRead($g_hChkAutostart) = $GUI_CHECKED)
$g_iAutoStartDelay = GUICtrlRead($g_hTxtAutostartDelay)
$g_bCheckGameLanguage =(GUICtrlRead($g_hChkCheckGameLanguage) = $GUI_CHECKED)
$g_bAutoAlignEnable =(GUICtrlRead($g_hChkAutoAlign) = $GUI_CHECKED)
$g_iAutoAlignPosition = _GUICtrlComboBox_GetCurSel($g_hCmbAlignmentOptions)
$g_iAutoAlignOffsetX = GUICtrlRead($g_hTxtAlignOffsetX)
$g_iAutoAlignOffsetY = GUICtrlRead($g_hTxtAlignOffsetY)
$g_iBotDesignFlags = BitOR(BitAND($g_iBotDesignFlags, BitNOT(1)),((GUICtrlRead($g_hChkBotCustomTitleBarClick) = $GUI_CHECKED) ?(1) :(0)))
$g_iBotDesignFlags = BitOR(BitAND($g_iBotDesignFlags, BitNOT(2)),((GUICtrlRead($g_hChkBotAutoSlideClick) = $GUI_CHECKED) ?(2) :(0)))
$g_bHideWhenMinimized =(GUICtrlRead($g_hChkHideWhenMinimized) = $GUI_CHECKED)
$g_bUseRandomClick =(GUICtrlRead($g_hChkUseRandomClick) = $GUI_CHECKED)
$g_bScreenshotPNGFormat =(GUICtrlRead($g_hChkScreenshotType) = $GUI_CHECKED)
$g_bScreenshotHideName =(GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED)
$g_iAnotherDeviceWaitTime = Int(GUICtrlRead($g_hTxtTimeAnotherDevice)) * 60
$g_bForceSinglePBLogoff =(GUICtrlRead($g_hChkSinglePBTForced) = $GUI_CHECKED)
$g_iSinglePBForcedLogoffTime = GUICtrlRead($g_hTxtSinglePBTimeForced)
$g_iSinglePBForcedEarlyExitTime = GUICtrlRead($g_hTxtPBTimeForcedExit)
$g_bAutoResumeEnable =(GUICtrlRead($g_hChkAutoResume) = $GUI_CHECKED)
$g_iAutoResumeTime = GUICtrlRead($g_hTxtAutoResumeTime)
$g_bDisableNotifications =(GUICtrlRead($g_hChkDisableNotifications) = $GUI_CHECKED)
$g_bForceClanCastleDetection =(GUICtrlRead($g_hChkFixClanCastle) = $GUI_CHECKED)
$g_bUseStatistics =(GUICtrlRead($g_hChkSqlite) = $GUI_CHECKED)
$g_bOnlySCIDAccounts =(GUICtrlRead($g_hChkOnlySCIDAccounts) = $GUI_CHECKED)
$g_iWhatSCIDAccount2Use = _GUICtrlComboBox_GetCurSel($g_hCmbWhatSCIDAccount2Use)
EndSwitch
EndFunc
Func ApplyConfig_600_35_2($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbSwitchAcc, $g_iCmbSwitchAcc)
GUICtrlSetState($g_hChkSwitchAcc, $g_bChkSwitchAcc ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSwitchAcc()
If $g_bChkGooglePlay Then
GUICtrlSetState($g_hRadSwitchGooglePlay, $GUI_CHECKED)
GUICtrlSetState($g_hRadSwitchSuperCellID, $GUI_UNCHECKED)
GUICtrlSetState($g_hRadSwitchSharedPrefs, $GUI_UNCHECKED)
EndIf
If $g_bChkSuperCellID Then
GUICtrlSetState($g_hRadSwitchGooglePlay, $GUI_UNCHECKED)
GUICtrlSetState($g_hRadSwitchSuperCellID, $GUI_CHECKED)
GUICtrlSetState($g_hRadSwitchSharedPrefs, $GUI_UNCHECKED)
EndIf
If $g_bChkSharedPrefs Then
GUICtrlSetState($g_hRadSwitchGooglePlay, $GUI_UNCHECKED)
GUICtrlSetState($g_hRadSwitchSuperCellID, $GUI_UNCHECKED)
GUICtrlSetState($g_hRadSwitchSharedPrefs, $GUI_CHECKED)
EndIf
GUICtrlSetState($g_hChkSmartSwitch, $g_bChkSmartSwitch ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDonateLikeCrazy, $g_bDonateLikeCrazy ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbTotalAccount, $g_iTotalAcc - 1)
For $i = 0 To 7
GUICtrlSetState($g_ahChkAccount[$i], $g_abAccountNo[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbProfile[$i], _GUICtrlComboBox_FindStringExact($g_ahCmbProfile[$i], $g_asProfileName[$i]))
GUICtrlSetState($g_ahChkDonate[$i], $g_abDonateOnly[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkSetFarm[$i], $g_abChkSetFarm[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbAction1[$i], $g_aiCmbAction1[$i])
_GUICtrlComboBox_SetCurSel($g_ahCmbCriteria1[$i], $g_aiCmbCriteria1[$i])
GUICtrlSetData($g_ahTxtResource1[$i], $g_aiTxtResource1[$i])
_GUICtrlComboBox_SetCurSel($g_ahCmbTime1[$i], $g_aiCmbTime1[$i])
_GUICtrlComboBox_SetCurSel($g_ahCmbAction2[$i], $g_aiCmbAction2[$i])
_GUICtrlComboBox_SetCurSel($g_ahCmbCriteria2[$i], $g_aiCmbCriteria2[$i])
GUICtrlSetData($g_ahTxtResource2[$i], $g_aiTxtResource2[$i])
_GUICtrlComboBox_SetCurSel($g_ahCmbTime2[$i], $g_aiCmbTime2[$i])
Next
_GUICtrlComboBox_SetCurSel($g_hCmbTrainTimeToSkip, $g_iTrainTimeToSkip)
_cmbSwitchAcc(False)
Case "Save"
$g_iCmbSwitchAcc = _GUICtrlComboBox_GetCurSel($g_hCmbSwitchAcc)
$g_bChkSwitchAcc =(GUICtrlRead($g_hChkSwitchAcc) = $GUI_CHECKED)
$g_bChkGooglePlay =(GUICtrlRead($g_hRadSwitchGooglePlay) = $GUI_CHECKED)
$g_bChkSuperCellID =(GUICtrlRead($g_hRadSwitchSuperCellID) = $GUI_CHECKED)
$g_bChkSharedPrefs =(GUICtrlRead($g_hRadSwitchSharedPrefs) = $GUI_CHECKED)
$g_bChkSmartSwitch =(GUICtrlRead($g_hChkSmartSwitch) = $GUI_CHECKED)
$g_bDonateLikeCrazy =(GUICtrlRead($g_hChkDonateLikeCrazy) = $GUI_CHECKED)
$g_iTotalAcc = _GUICtrlComboBox_GetCurSel($g_hCmbTotalAccount) + 1
For $i = 0 To 7
$g_abAccountNo[$i] =(GUICtrlRead($g_ahChkAccount[$i]) = $GUI_CHECKED)
$g_asProfileName[$i] = GUICtrlRead($g_ahCmbProfile[$i])
$g_abDonateOnly[$i] =(GUICtrlRead($g_ahChkDonate[$i]) = $GUI_CHECKED)
$g_abChkSetFarm[$i] =(GUICtrlRead($g_ahChkSetFarm[$i]) = $GUI_CHECKED)
$g_aiCmbAction1[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbAction1[$i])
$g_aiCmbCriteria1[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbCriteria1[$i])
$g_aiTxtResource1[$i] = GUICtrlRead($g_ahTxtResource1[$i])
$g_aiCmbTime1[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbTime1[$i])
$g_aiCmbAction2[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbAction2[$i])
$g_aiCmbCriteria2[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbCriteria2[$i])
$g_aiTxtResource2[$i] = GUICtrlRead($g_ahTxtResource2[$i])
$g_aiCmbTime2[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbTime2[$i])
Next
$g_iTrainTimeToSkip = _GUICtrlComboBox_GetCurSel($g_hCmbTrainTimeToSkip)
EndSwitch
EndFunc
Func ApplyConfig_600_35_3($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $i = 0 To 3
GUICtrlSetState($g_ahChk_SwitchMax[$i], $g_abChkSwitchMax[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChk_SwitchMin[$i], $g_abChkSwitchMin[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmb_SwitchMax[$i], $g_aiCmbSwitchMax[$i])
_GUICtrlComboBox_SetCurSel($g_ahCmb_SwitchMin[$i], $g_aiCmbSwitchMin[$i])
GUICtrlSetState($g_ahChk_BotTypeMax[$i], $g_abChkBotTypeMax[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChk_BotTypeMin[$i], $g_abChkBotTypeMin[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmb_BotTypeMax[$i], $g_aiCmbBotTypeMax[$i])
_GUICtrlComboBox_SetCurSel($g_ahCmb_BotTypeMin[$i], $g_aiCmbBotTypeMin[$i])
GUICtrlSetData($g_ahTxt_ConditionMax[$i], $g_aiConditionMax[$i])
GUICtrlSetData($g_ahTxt_ConditionMin[$i], $g_aiConditionMin[$i])
Next
chkSwitchProfile()
chkSwitchBotType()
Case "Save"
For $i = 0 To 3
$g_abChkSwitchMax[$i] =(GUICtrlRead($g_ahChk_SwitchMax[$i]) = $GUI_CHECKED)
$g_abChkSwitchMin[$i] =(GUICtrlRead($g_ahChk_SwitchMin[$i]) = $GUI_CHECKED)
$g_aiCmbSwitchMax[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmb_SwitchMax[$i])
$g_aiCmbSwitchMin[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmb_SwitchMin[$i])
$g_abChkBotTypeMax[$i] =(GUICtrlRead($g_ahChk_BotTypeMax[$i]) = $GUI_CHECKED)
$g_abChkBotTypeMin[$i] =(GUICtrlRead($g_ahChk_BotTypeMin[$i]) = $GUI_CHECKED)
$g_aiCmbBotTypeMax[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmb_BotTypeMax[$i])
$g_aiCmbBotTypeMin[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmb_BotTypeMin[$i])
$g_aiConditionMax[$i] = GUICtrlRead($g_ahTxt_ConditionMax[$i])
$g_aiConditionMin[$i] = GUICtrlRead($g_ahTxt_ConditionMin[$i])
Next
EndSwitch
EndFunc
Func ApplyConfig_600_52_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUseQuickTrain, $g_bQuickTrainEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkArmy[0], $g_bQuickTrainArmy[0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkArmy[1], $g_bQuickTrainArmy[1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkArmy[2], $g_bQuickTrainArmy[2] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMultiClick, $g_bChkMultiClick ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUseQTrain()
Case "Save"
$g_bQuickTrainEnable =(GUICtrlRead($g_hChkUseQuickTrain) = $GUI_CHECKED)
$g_bQuickTrainArmy[0] =(GUICtrlRead($g_ahChkArmy[0]) = $GUI_CHECKED)
$g_bQuickTrainArmy[1] =(GUICtrlRead($g_ahChkArmy[1]) = $GUI_CHECKED)
$g_bQuickTrainArmy[2] =(GUICtrlRead($g_ahChkArmy[2]) = $GUI_CHECKED)
$g_bChkMultiClick =(GUICtrlRead($g_hChkMultiClick) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_52_2($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $T = 0 To $eTroopCount - 1
Local $iCurrLevel = $g_aiTrainArmyTroopLevel[$T]
Local $iCurrCount = $g_aiArmyCompTroops[$T]
Local $iMaxLevel = $g_aiTroopCostPerLevel[$T][0]
Local $iColor =($iCurrLevel = $iMaxLevel ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$T],($iCurrCount <> 0 And $iCurrLevel <> 0) ? $iCurrCount : 0)
GUICtrlSetState($g_ahTxtTrainArmyTroopCount[$T], $iCurrLevel <> 0 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetData($g_ahLblTrainArmyTroopLevel[$T], $iCurrLevel)
If GUICtrlGetBkColor($g_ahLblTrainArmyTroopLevel[$T]) <> $iColor Then GUICtrlSetBkColor($g_ahLblTrainArmyTroopLevel[$T], $iColor)
Next
For $S = 0 To $eSpellCount - 1
Local $iCurrLevel = $g_aiTrainArmySpellLevel[$S]
Local $iCurrCount = $g_aiArmyCompSpells[$S]
Local $iMaxLevel = $g_aiSpellCostPerLevel[$S][0]
Local $iColor =($iCurrLevel = $iMaxLevel ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$S],($iCurrCount <> 0 And $iCurrLevel <> 0) ? $iCurrCount : 0)
GUICtrlSetState($g_ahTxtTrainArmySpellCount[$S], $iCurrLevel <> 0 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$S], $iCurrLevel)
If GUICtrlGetBkColor($g_ahLblTrainArmySpellLevel[$S]) <> $iColor Then GUICtrlSetBkColor($g_ahLblTrainArmySpellLevel[$S], $iColor)
Next
For $S = 0 To $eSiegeMachineCount - 1
Local $iCurrLevel = $g_aiTrainArmySiegeMachineLevel[$S]
Local $iCurrCount = $g_aiArmyCompSiegeMachine[$S]
Local $iMaxLevel = $g_aiSiegeMachineCostPerLevel[$S][0]
Local $iColor =($iCurrLevel = $iMaxLevel ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($g_ahTxtTrainArmySiegeCount[$S],($iCurrCount <> 0 And $iCurrLevel <> 0) ? $iCurrCount : 0)
GUICtrlSetState($g_ahTxtTrainArmySiegeCount[$S], $iCurrLevel <> 0 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetData($g_ahLblTrainArmySiegeLevel[$S], $iCurrLevel)
If GUICtrlGetBkColor($g_ahLblTrainArmySiegeLevel[$S]) <> $iColor Then GUICtrlSetBkColor($g_ahLblTrainArmySiegeLevel[$S], $iColor)
Next
GUICtrlSetData($g_hTxtFullTroop, $g_iTrainArmyFullTroopPct)
GUICtrlSetState($g_hChkTotalCampForced, $g_bTotalCampForced ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTotalCampForced, $g_iTotalCampForcedValue)
GUICtrlSetData($g_hTxtTotalCountSpell, $g_iTotalSpellValue)
GUICtrlSetState($g_hChkForceBrewBeforeAttack, $g_bForceBrewSpells ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDoubleTrain, $g_bDoubleTrain ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkPreciseArmy, $g_bChkPreciseArmy ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
For $T = 0 To $eTroopCount - 1
$g_aiArmyCompTroops[$T] = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$T])
$g_aiTrainArmyTroopLevel[$T] = GUICtrlRead($g_ahLblTrainArmyTroopLevel[$T])
Next
For $S = 0 To $eSpellCount - 1
$g_aiArmyCompSpells[$S] = GUICtrlRead($g_ahTxtTrainArmySpellCount[$S])
$g_aiTrainArmySpellLevel[$S] = GUICtrlRead($g_ahLblTrainArmySpellLevel[$S])
Next
For $S = 0 To $eSiegeMachineCount - 1
$g_aiArmyCompSiegeMachine[$S] = GUICtrlRead($g_ahTxtTrainArmySiegeCount[$S])
$g_aiTrainArmySiegeMachineLevel[$S] = GUICtrlRead($g_ahLblTrainArmySiegeLevel[$S])
Next
$g_iTrainArmyFullTroopPct = Int(GUICtrlRead($g_hTxtFullTroop))
$g_bTotalCampForced =(GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED)
$g_iTotalCampForcedValue = Int(GUICtrlRead($g_hTxtTotalCampForced))
$g_iTotalSpellValue = GUICtrlRead($g_hTxtTotalCountSpell)
$g_bForceBrewSpells =(GUICtrlRead($g_hChkForceBrewBeforeAttack) = $GUI_CHECKED)
$g_bDoubleTrain =(GUICtrlRead($g_hChkDoubleTrain) = $GUI_CHECKED)
$g_bChkPreciseArmy =(GUICtrlRead($g_hChkPreciseArmy) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_54($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkCustomTrainOrderEnable, $g_bCustomTrainOrderEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTroopOrder()
For $z = 0 To UBound($g_ahCmbTroopOrder) - 1
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$z], $g_aiCmbCustomTrainOrder[$z])
_GUICtrlSetImage($g_ahImgTroopOrder[$z], $g_sLibIconPath, $g_aiTroopOrderIcon[$g_aiCmbCustomTrainOrder[$z] + 1])
Next
If $g_bCustomTrainOrderEnable Then
If Not ChangeTroopTrainOrder() Then
SetDefaultTroopGroup()
GUICtrlSetState($g_hChkCustomTrainOrderEnable, $GUI_UNCHECKED)
$g_bCustomTrainOrderEnable = False
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRemoveTroops, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
GUICtrlSetState($g_hChkCustomBrewOrderEnable, $g_bCustomBrewOrderEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSpellsOrder()
For $z = 0 To UBound($g_ahCmbSpellsOrder) - 1
_GUICtrlComboBox_SetCurSel($g_ahCmbSpellsOrder[$z], $g_aiCmbCustomBrewOrder[$z])
_GUICtrlSetImage($g_ahImgSpellsOrder[$z], $g_sLibIconPath, $g_aiSpellsOrderIcon[$g_aiCmbCustomBrewOrder[$z] + 1])
Next
If $g_bCustomBrewOrderEnable Then
If Not ChangeSpellsBrewOrder() Then
SetDefaultSpellsGroup()
GUICtrlSetState($g_hChkCustomBrewOrderEnable, $GUI_UNCHECKED)
$g_bCustomBrewOrderEnable = False
GUICtrlSetState($g_hBtnRemoveSpells, $GUI_DISABLE)
GUICtrlSetState($g_hBtnSpellsOrderSet, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbSpellsOrder) - 1
GUICtrlSetState($g_ahCmbSpellsOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
chkTotalCampForced()
chkUseQTrain()
SetComboTroopComp()
Case "Save"
$g_bCustomTrainOrderEnable =(GUICtrlRead($g_hChkCustomTrainOrderEnable) = $GUI_CHECKED)
For $z = 0 To UBound($g_ahCmbTroopOrder) - 1
$g_aiCmbCustomTrainOrder[$z] = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$z])
Next
$g_bCustomBrewOrderEnable =(GUICtrlRead($g_hChkCustomBrewOrderEnable) = $GUI_CHECKED)
For $z = 0 To UBound($g_ahCmbSpellsOrder) - 1
$g_aiCmbCustomBrewOrder[$z] = _GUICtrlComboBox_GetCurSel($g_ahCmbSpellsOrder[$z])
Next
EndSwitch
EndFunc
Func ApplyConfig_600_56($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkSmartLightSpell, $g_bSmartZapEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartEQSpell, $g_bEarthQuakeZap = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNoobZap, $g_bNoobZap = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartZapDB, $g_bSmartZapDB = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $g_bSmartZapSaveHeroes = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartZapFTW, $g_bSmartZapFTW = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSmartZapMinDE, $g_iSmartZapMinDE)
GUICtrlSetData($g_hTxtSmartExpectedDE, $g_iSmartZapExpectedDE)
chkSmartLightSpell()
Case "Save"
$g_bSmartZapEnable =(GUICtrlRead($g_hChkSmartLightSpell) = $GUI_CHECKED)
$g_bEarthQuakeZap =(GUICtrlRead($g_hChkSmartEQSpell) = $GUI_CHECKED)
$g_bNoobZap =(GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED)
$g_bSmartZapDB =(GUICtrlRead($g_hChkSmartZapDB) = $GUI_CHECKED)
$g_bSmartZapSaveHeroes =(GUICtrlRead($g_hChkSmartZapSaveHeroes) = $GUI_CHECKED)
$g_bSmartZapFTW =(GUICtrlRead($g_hChkSmartZapFTW) = $GUI_CHECKED)
$g_iSmartZapMinDE = Int(GUICtrlRead($g_hTxtSmartZapMinDE))
$g_iSmartZapExpectedDE = Int(GUICtrlRead($g_hTxtSmartExpectedDE))
EndSwitch
EndFunc
Func ApplyConfig_641_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
If $g_bCloseWhileTrainingEnable = True Then
GUICtrlSetState($g_hChkCloseWhileTraining, $GUI_CHECKED)
_GUI_Value_STATE("ENABLE", $groupCloseWhileTraining)
GUICtrlSetState($g_hLblCloseWaitingTroops, $GUI_ENABLE)
GUICtrlSetState($g_hCmbMinimumTimeClose, $GUI_ENABLE)
GUICtrlSetState($g_hLblSymbolWaiting, $GUI_ENABLE)
GUICtrlSetState($g_hLblWaitingInMinutes, $GUI_ENABLE)
GUICtrlSetState($g_hChkTrainLogoutMaxTime, $GUI_ENABLE)
chkTrainLogoutMaxTime()
Else
GUICtrlSetState($g_hChkCloseWhileTraining, $GUI_UNCHECKED)
_GUI_Value_STATE("DISABLE", $groupCloseWhileTraining)
GUICtrlSetState($g_hLblCloseWaitingTroops, $GUI_DISABLE)
GUICtrlSetState($g_hCmbMinimumTimeClose, $GUI_DISABLE)
GUICtrlSetState($g_hLblSymbolWaiting, $GUI_DISABLE)
GUICtrlSetState($g_hLblWaitingInMinutes, $GUI_DISABLE)
GUICtrlSetState($g_hChkTrainLogoutMaxTime, $GUI_DISABLE)
EndIf
GUICtrlSetState($g_hChkCloseWithoutShield, $g_bCloseWithoutShield ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCloseEmulator, $g_bCloseEmulator ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSuspendComputer, $g_bSuspendComputer ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkRandomClose, $g_bCloseRandom ? $GUI_CHECKED : $GUI_UNCHECKED)
btnCloseWaitStopRandom()
If $g_bCloseExactTime Then
GUICtrlSetState($g_hRdoCloseWaitExact, $GUI_CHECKED)
GUICtrlSetState($g_hRdoCloseWaitRandom, $GUI_UNCHECKED)
EndIf
If $g_bCloseRandomTime Then
GUICtrlSetState($g_hRdoCloseWaitRandom, $GUI_CHECKED)
GUICtrlSetState($g_hRdoCloseWaitExact, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbCloseWaitRdmPercent, $g_iCloseRandomTimePercent)
btnCloseWaitRandom()
GUICtrlSetData($g_hCmbMinimumTimeClose, $g_iCloseMinimumTime)
GUICtrlSetData($g_hSldTrainITDelay, $g_iTrainClickDelay)
sldTrainITDelay()
GUICtrlSetData($g_hLblTrainITDelayTime, $g_iTrainClickDelay & " ms")
GUICtrlSetState($g_hChkTrainAddRandomDelayEnable, $g_bTrainAddRandomDelayEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAddRandomDelayMin, $g_iTrainAddRandomDelayMin)
GUICtrlSetData($g_hTxtAddRandomDelayMax, $g_iTrainAddRandomDelayMax)
chkAddDelayIdlePhaseEnable()
Case "Save"
$g_bCloseWhileTrainingEnable =(GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED)
$g_bCloseWithoutShield =(GUICtrlRead($g_hChkCloseWithoutShield) = $GUI_CHECKED)
$g_bCloseEmulator =(GUICtrlRead($g_hChkCloseEmulator) = $GUI_CHECKED)
$g_bSuspendComputer =(GUICtrlRead($g_hChkSuspendComputer) = $GUI_CHECKED)
$g_bCloseRandom =(GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED)
$g_bCloseExactTime =(GUICtrlRead($g_hRdoCloseWaitExact) = $GUI_CHECKED)
$g_bCloseRandomTime =(GUICtrlRead($g_hRdoCloseWaitRandom) = $GUI_CHECKED)
$g_iCloseRandomTimePercent = _GUICtrlComboBox_GetCurSel($g_hCmbCloseWaitRdmPercent)
$g_iCloseMinimumTime = GUICtrlRead($g_hCmbMinimumTimeClose)
$g_iTrainClickDelay = GUICtrlRead($g_hSldTrainITDelay)
$g_bTrainAddRandomDelayEnable =(GUICtrlRead($g_hChkTrainAddRandomDelayEnable) = $GUI_CHECKED)
$g_iTrainAddRandomDelayMin = Int(GUICtrlRead($g_hTxtAddRandomDelayMin))
$g_iTrainAddRandomDelayMax = Int(GUICtrlRead($g_hTxtAddRandomDelayMax))
EndSwitch
EndFunc
Func readConfig($inputfile = $g_sProfileConfigPath)
Static $iReadConfigCount = 0
If $g_bReadConfigIsActive Then
SetDebugLog("readConfig(), already running, exit")
Return
EndIf
$g_bReadConfigIsActive = True
$iReadConfigCount += 1
SetDebugLog("readConfig(), call number " & $iReadConfigCount)
$g_aiWeakBaseStats = readWeakBaseStats()
ReadProfileConfig()
If FileExists($g_sProfileBuildingPath) Then ReadBuildingConfig()
If FileExists($g_sProfileConfigPath) Then ReadRegularConfig()
$g_bReadConfigIsActive = False
EndFunc
Func ReadProfileConfig($sIniFile = $g_sProfilePath & "\profile.ini")
If FileExists($sIniFile) = 0 Then Return False
Local $iValue, $sValue
$iValue = $g_iGlobalActiveBotsAllowed
$g_iGlobalActiveBotsAllowed = Int(IniRead($sIniFile, "general", "globalactivebotsallowed", $g_iGlobalActiveBotsAllowed))
If $g_iGlobalActiveBotsAllowed < 1 Then $g_iGlobalActiveBotsAllowed = 2
If $iValue <> $g_iGlobalActiveBotsAllowed Then
SetDebugLog("Maximum of " & $iValue & " bots running at same time changed to " & $g_iGlobalActiveBotsAllowed)
EndIf
$iValue = $g_iGlobalThreads
$g_iGlobalThreads = Int(IniRead($sIniFile, "general", "globalthreads", $g_iGlobalThreads))
If $iValue <> $g_iGlobalThreads Then
SetDebugLog("Threading: Using " & $g_iGlobalThreads & " threads shared across all bot instances changed to " & $iValue)
EndIf
Return True
EndFunc
Func ReadBuildingConfig()
SetDebugLog("Read Building Config " & $g_sProfileBuildingPath)
Local $locationsInvalid = False
Local $buildingVersion = "0.0.0"
IniReadS($buildingVersion, $g_sProfileBuildingPath, "general", "version", $buildingVersion)
Local $_ver630 = GetVersionNormalized("6.3.0")
Local $_ver63u = GetVersionNormalized("6.3.u")
Local $_ver63u3 = GetVersionNormalized("6.3.u3")
If $buildingVersion < $_ver630 Or($buildingVersion >= $_ver63u And $buildingVersion <= $_ver63u3) Then
SetLog("New MyBot.run version! Re-locate all buildings!", $COLOR_WARNING)
$locationsInvalid = True
EndIf
IniReadS($g_iTownHallLevel, $g_sProfileBuildingPath, "other", "LevelTownHall", 0, "int")
If $locationsInvalid = False Then
IniReadS($g_aiTownHallPos[0], $g_sProfileBuildingPath, "other", "xTownHall", -1, "int")
IniReadS($g_aiTownHallPos[1], $g_sProfileBuildingPath, "other", "yTownHall", -1, "int")
IniReadS($g_aiClanCastlePos[0], $g_sProfileBuildingPath, "other", "xCCPos", -1, "int")
IniReadS($g_aiClanCastlePos[1], $g_sProfileBuildingPath, "other", "yCCPos", -1, "int")
IniReadS($g_aiKingAltarPos[0], $g_sProfileBuildingPath, "other", "xKingAltarPos", -1, "int")
IniReadS($g_aiKingAltarPos[1], $g_sProfileBuildingPath, "other", "yKingAltarPos", -1, "int")
IniReadS($g_aiQueenAltarPos[0], $g_sProfileBuildingPath, "other", "xQueenAltarPos", -1, "int")
IniReadS($g_aiQueenAltarPos[1], $g_sProfileBuildingPath, "other", "yQueenAltarPos", -1, "int")
IniReadS($g_aiWardenAltarPos[0], $g_sProfileBuildingPath, "other", "xWardenAltarPos", -1, "int")
IniReadS($g_aiWardenAltarPos[1], $g_sProfileBuildingPath, "other", "yWardenAltarPos", -1, "int")
IniReadS($g_aiLaboratoryPos[0], $g_sProfileBuildingPath, "upgrade", "LabPosX", -1, "int")
IniReadS($g_aiLaboratoryPos[1], $g_sProfileBuildingPath, "upgrade", "LabPosY", -1, "int")
EndIf
IniReadS($g_aiStarLaboratoryPos[0], $g_sProfileBuildingPath, "upgrade", "StarLabPosX", -1, "int")
IniReadS($g_aiStarLaboratoryPos[1], $g_sProfileBuildingPath, "upgrade", "StarLabPosY", -1, "int")
IniReadS($g_aiLastGoodWallPos[0], $g_sProfileBuildingPath, "upgrade", "xLastGoodWallPos", -1, "int")
IniReadS($g_aiLastGoodWallPos[1], $g_sProfileBuildingPath, "upgrade", "yLastGoodWallPos", -1, "int")
IniReadS($g_aiResourcesPos[0], $g_sProfileBuildingPath, "other", "ResourcesPosX", -1, "int")
IniReadS($g_aiResourcesPos[1], $g_sProfileBuildingPath, "other", "ResourcesPosY", -1, "int")
IniReadS($g_iTotalCampSpace, $g_sProfileBuildingPath, "other", "totalcamp", 0, "int")
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
$g_avBuildingUpgrades[$iz][0] = IniRead($g_sProfileBuildingPath, "upgrade", "xupgrade" & $iz, "-1")
$g_avBuildingUpgrades[$iz][1] = IniRead($g_sProfileBuildingPath, "upgrade", "yupgrade" & $iz, "-1")
$g_avBuildingUpgrades[$iz][2] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradevalue" & $iz, "-1")
$g_avBuildingUpgrades[$iz][3] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradetype" & $iz, "")
$g_avBuildingUpgrades[$iz][4] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradename" & $iz, "")
$g_avBuildingUpgrades[$iz][5] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradelevel" & $iz, "")
$g_avBuildingUpgrades[$iz][6] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradetime" & $iz, "")
$g_avBuildingUpgrades[$iz][7] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradeend" & $iz, "-1")
$g_abBuildingUpgradeEnable[$iz] =(IniRead($g_sProfileBuildingPath, "upgrade", "upgradechk" & $iz, 0) = "1")
$g_abUpgradeRepeatEnable[$iz] =(IniRead($g_sProfileBuildingPath, "upgrade", "upgraderepeat" & $iz, 0) = "1")
$g_aiPicUpgradeStatus[$iz] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradestatusicon" & $iz, $eIcnTroops)
If $locationsInvalid = True Then
$g_avBuildingUpgrades[$iz][0] = -1
$g_avBuildingUpgrades[$iz][1] = -1
$g_abBuildingUpgradeEnable[$iz] = False
$g_abUpgradeRepeatEnable[$iz] = False
EndIf
Next
EndFunc
Func ReadRegularConfig()
SetDebugLog("Read Config " & $g_sProfileConfigPath)
ReadConfig_Debug()
IniReadS($g_iThreads, $g_sProfileConfigPath, "general", "threads", $g_iThreads, "int")
If $g_iThreads < 0 Then $g_iThreads = 0
IniReadS($g_iBotDesignFlags, $g_sProfileConfigPath, "general", "botDesignFlags", 0, "int")
IniReadS($g_iFrmBotPosX, $g_sProfileConfigPath, "general", "frmBotPosX", $g_iFrmBotPosX, "int")
IniReadS($g_iFrmBotPosY, $g_sProfileConfigPath, "general", "frmBotPosY", $g_iFrmBotPosY, "int")
If $g_iFrmBotPosX < -30000 Or $g_iFrmBotPosY < -30000 Then
$g_iFrmBotPosX = $g_WIN_POS_DEFAULT
$g_iFrmBotPosY = $g_WIN_POS_DEFAULT
EndIf
IniReadS($g_iAndroidPosX, $g_sProfileConfigPath, "general", "AndroidPosX", $g_iAndroidPosX, "int")
IniReadS($g_iAndroidPosY, $g_sProfileConfigPath, "general", "AndroidPosY", $g_iAndroidPosY, "int")
If $g_iAndroidPosX < -30000 Or $g_iAndroidPosY < -30000 Then
$g_iAndroidPosX = $g_WIN_POS_DEFAULT
$g_iAndroidPosY = $g_WIN_POS_DEFAULT
EndIf
IniReadS($g_iFrmBotDockedPosX, $g_sProfileConfigPath, "general", "frmBotDockedPosX", $g_iFrmBotDockedPosX, "int")
IniReadS($g_iFrmBotDockedPosY, $g_sProfileConfigPath, "general", "frmBotDockedPosY", $g_iFrmBotDockedPosY, "int")
If $g_iFrmBotDockedPosX < -30000 Or $g_iFrmBotDockedPosY < -30000 Then
$g_iFrmBotDockedPosX = $g_WIN_POS_DEFAULT
$g_iFrmBotDockedPosY = $g_WIN_POS_DEFAULT
EndIf
IniReadS($g_iRedrawBotWindowMode, $g_sProfileConfigPath, "general", "RedrawBotWindowMode", 2, "int")
ReadConfig_Android()
ReadConfig_600_1()
ReadConfig_600_6()
ReadConfig_600_9()
ReadConfig_600_11()
ReadConfig_600_12()
ReadConfig_600_13()
ReadConfig_600_14()
ReadConfig_600_15()
ReadConfig_600_16()
ReadConfig_auto()
ReadConfig_600_17()
ReadConfig_600_18()
ReadConfig_600_19()
ReadConfig_600_22()
ReadConfig_600_26()
ReadConfig_600_28()
ReadConfig_600_28_DB()
ReadConfig_600_28_LB()
ReadConfig_600_28_TS()
ReadConfig_600_29()
ReadConfig_600_29_DB()
ReadConfig_600_29_LB()
ReadConfig_600_29_TS()
ReadConfig_600_30()
ReadConfig_600_30_DB()
ReadConfig_600_30_LB()
ReadConfig_600_30_TS()
ReadConfig_600_31()
ReadConfig_600_32()
ReadConfig_600_33()
ReadConfig_600_35_1()
ReadConfig_600_35_2()
ReadConfig_600_35_3()
ReadConfig_600_52_1()
ReadConfig_600_52_2()
ReadConfig_600_54()
ReadConfig_600_56()
ReadConfig_641_1()
ReadConfig_MOD()
EndFunc
Func ReadConfig_Debug()
$g_bDebugSetlog = IniRead($g_sProfileConfigPath, "debug", "debugsetlog", 0) = 1 ? True : False
$g_bDebugAndroid = IniRead($g_sProfileConfigPath, "debug", "debugAndroid", 0) = 1 ? True : False
$g_bDebugClick = IniRead($g_sProfileConfigPath, "debug", "debugsetclick", 0) = 1 ? True : False
If $g_bDevMode Then
Local $bDebugFunc = IniRead($g_sProfileConfigPath, "debug", "debugFunc", 0) = 1 ? True : False
$g_bDebugFuncTime = $bDebugFunc
$g_bDebugFuncCall = $bDebugFunc
$g_bDebugDisableZoomout = IniRead($g_sProfileConfigPath, "debug", "disablezoomout", 0) = 1 ? True : False
$g_bDebugDisableVillageCentering = IniRead($g_sProfileConfigPath, "debug", "disablevillagecentering", 0) = 1 ? True : False
$g_bDebugDeadBaseImage = IniRead($g_sProfileConfigPath, "debug", "debugdeadbaseimage", 0) = 1 ? True : False
$g_bDebugOcr = IniRead($g_sProfileConfigPath, "debug", "debugocr", 0) = 1 ? True : False
$g_bDebugImageSave = IniRead($g_sProfileConfigPath, "debug", "debugimagesave", 0) = 1 ? True : False
$g_bDebugBuildingPos = IniRead($g_sProfileConfigPath, "debug", "debugbuildingpos", 0) = 1 ? True : False
$g_bDebugSetlogTrain = IniRead($g_sProfileConfigPath, "debug", "debugtrain", 0) = 1 ? True : False
$g_bDebugResourcesOffset = IniRead($g_sProfileConfigPath, "debug", "debugresourcesoffset", 0) = 1 ? True : False
$g_bDebugContinueSearchElixir = IniRead($g_sProfileConfigPath, "debug", "continuesearchelixirdebug", 0) = 1 ? True : False
$g_bDebugMilkingIMGmake = IniRead($g_sProfileConfigPath, "debug", "debugMilkingIMGmake", 0) = 1 ? True : False
$g_bDebugOCRdonate = IniRead($g_sProfileConfigPath, "debug", "debugOCRDonate", 0) = 1 ? True : False
$g_bDebugAttackCSV = IniRead($g_sProfileConfigPath, "debug", "debugAttackCSV", 0) = 1 ? True : False
$g_bDebugMakeIMGCSV = IniRead($g_sProfileConfigPath, "debug", "debugmakeimgcsv", 0) = 1 ? True : False
$g_bDebugSmartZap = BitOR($g_bDebugSmartZap, Int(IniRead($g_sProfileConfigPath, "debug", "DebugSmartZap", 0)))
EndIf
EndFunc
Func ReadConfig_Android()
$g_sAndroidGameDistributor = IniRead($g_sProfileConfigPath, "android", "game.distributor", $g_sAndroidGameDistributor)
$g_sAndroidGamePackage = IniRead($g_sProfileConfigPath, "android", "game.package", $g_sAndroidGamePackage)
$g_sAndroidGameClass = IniRead($g_sProfileConfigPath, "android", "game.class", $g_sAndroidGameClass)
$g_sUserGameDistributor = IniRead($g_sProfileConfigPath, "android", "user.distributor", $g_sUserGameDistributor)
$g_sUserGamePackage = IniRead($g_sProfileConfigPath, "android", "user.package", $g_sUserGamePackage)
$g_sUserGameClass = IniRead($g_sProfileConfigPath, "android", "user.class", $g_sUserGameClass)
$g_iAndroidBackgroundMode = Int(IniRead($g_sProfileConfigPath, "android", "backgroundmode", $g_iAndroidBackgroundMode))
$g_bAndroidCheckTimeLagEnabled = Int(IniRead($g_sProfileConfigPath, "android", "check.time.lag.enabled",($g_bAndroidCheckTimeLagEnabled ? 1 : 0))) = 1
$g_iAndroidAdbScreencapTimeoutMin = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.min", $g_iAndroidAdbScreencapTimeoutMin))
$g_iAndroidAdbScreencapTimeoutMax = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.max", $g_iAndroidAdbScreencapTimeoutMax))
$g_iAndroidAdbScreencapTimeoutDynamic = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.dynamic", $g_iAndroidAdbScreencapTimeoutDynamic))
$g_bAndroidAdbInputEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.input.enabled",($g_bAndroidAdbInputEnabled ? 1 : 0))) = 1
$g_bAndroidAdbClickEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.click.enabled",($g_bAndroidAdbClickEnabled ? 1 : 0))) = 1
$g_bAndroidAdbClickDragScript = Int(IniRead($g_sProfileConfigPath, "android", "adb.click.drag.script",(BitAND($g_iAndroidSupportFeature, 128) ? 0 : 1))) = 1
$g_iAndroidAdbClickGroup = Int(IniRead($g_sProfileConfigPath, "android", "adb.click.group", $g_iAndroidAdbClickGroup))
$g_bAndroidAdbClicksEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.clicks.enabled",($g_bAndroidAdbClicksEnabled ? 1 : 0))) = 1
$g_iAndroidAdbClicksTroopDeploySize = Int(IniRead($g_sProfileConfigPath, "android", "adb.clicks.troop.deploy.size", $g_iAndroidAdbClicksTroopDeploySize))
$g_bNoFocusTampering = Int(IniRead($g_sProfileConfigPath, "android", "no.focus.tampering",($g_bNoFocusTampering ? 1 : 0))) = 1
$g_iAndroidShieldColor = Dec(IniRead($g_sProfileConfigPath, "android", "shield.color", Hex($g_iAndroidShieldColor, 6)))
$g_iAndroidShieldTransparency = Int(IniRead($g_sProfileConfigPath, "android", "shield.transparency", $g_iAndroidShieldTransparency))
$g_iAndroidActiveColor = Dec(IniRead($g_sProfileConfigPath, "android", "active.color", Hex($g_iAndroidActiveColor, 6)))
$g_iAndroidActiveTransparency = Int(IniRead($g_sProfileConfigPath, "android", "active.transparency", $g_iAndroidActiveTransparency))
$g_iAndroidInactiveColor = Dec(IniRead($g_sProfileConfigPath, "android", "inactive.color", Hex($g_iAndroidInactiveColor, 6)))
$g_iAndroidInactiveTransparency = Int(IniRead($g_sProfileConfigPath, "android", "inactive.transparency", $g_iAndroidInactiveTransparency))
$g_iAndroidSuspendModeFlags = Int(IniRead($g_sProfileConfigPath, "android", "suspend.mode", $g_iAndroidSuspendModeFlags))
$g_iAndroidRebootHours = Int(IniRead($g_sProfilePath & "\Profile.ini", "android", "reboot.hours", $g_iAndroidRebootHours))
$g_bAndroidCloseWithBot = Int(IniRead($g_sProfileConfigPath, "android", "close", $g_bAndroidCloseWithBot ? 1 : 0)) = 1
$g_bUpdateSharedPrefs = Int(IniRead($g_sProfileConfigPath, "android", "shared_prefs.update", $g_bUpdateSharedPrefs ? 1 : 0)) = 1
$g_iAndroidProcessAffinityMask = Int(IniRead($g_sProfileConfigPath, "android", "process.affinity.mask", $g_iAndroidProcessAffinityMask))
If $g_bBotLaunchOption_Restart = True Or $g_asCmdLine[0] < 2 Then
Local $sAndroidEmulator = IniRead($g_sProfileConfigPath, "android", "emulator", "")
Local $sAndroidInstance = IniRead($g_sProfileConfigPath, "android", "instance", "")
If $sAndroidEmulator <> "" Then
If $sAndroidEmulator <> $g_sAndroidEmulator Or $sAndroidInstance <> $g_sAndroidInstance Then
UpdateHWnD(0)
UpdateAndroidConfig($sAndroidInstance, $sAndroidEmulator)
EndIf
Else
$g_bBotLaunchOption_Restart = False
EndIf
EndIf
EndFunc
Func ReadConfig_600_1()
IniReadS($g_iCmbLogDividerOption, $g_sProfileConfigPath, "general", "logstyle", 0, "int")
IniReadS($g_iLogDividerY, $g_sProfileConfigPath, "general", "LogDividerY", 243, "int")
IniReadS($g_bChkBackgroundMode, $g_sProfileConfigPath, "general", "Background", True, "Bool")
EndFunc
Func ReadConfig_600_6()
IniReadS($g_bChkBotStop, $g_sProfileConfigPath, "general", "BotStop", False, "Bool")
IniReadS($g_iCmbBotCommand, $g_sProfileConfigPath, "general", "Command", 0, "int")
IniReadS($g_iCmbBotCond, $g_sProfileConfigPath, "general", "Cond", 0, "int")
IniReadS($g_iCmbHoursStop, $g_sProfileConfigPath, "general", "Hour", 0, "int")
IniReadS($g_iTxtRestartGold, $g_sProfileConfigPath, "other", "minrestartgold", 50000, "int")
IniReadS($g_iTxtRestartElixir, $g_sProfileConfigPath, "other", "minrestartelixir", 50000, "int")
IniReadS($g_iTxtRestartDark, $g_sProfileConfigPath, "other", "minrestartdark", 500, "int")
IniReadS($g_bChkCollect, $g_sProfileConfigPath, "other", "chkCollect", True, "Bool")
IniReadS($g_bChkCollectCartFirst, $g_sProfileConfigPath, "other", "chkCollectCartFirst", False, "Bool")
IniReadS($g_iTxtCollectGold, $g_sProfileConfigPath, "other", "minCollectgold", 0, "int")
IniReadS($g_iTxtCollectElixir, $g_sProfileConfigPath, "other", "minCollectelixir", 0, "int")
IniReadS($g_iTxtCollectDark, $g_sProfileConfigPath, "other", "minCollectdark", 0, "int")
IniReadS($g_bChkTombstones, $g_sProfileConfigPath, "other", "chkTombstones", True, "Bool")
IniReadS($g_bChkCleanYard, $g_sProfileConfigPath, "other", "chkCleanYard", False, "Bool")
IniReadS($g_bChkGemsBox, $g_sProfileConfigPath, "other", "chkGemsBox", False, "Bool")
IniReadS($g_bChkCollectFreeMagicItems, $g_sProfileConfigPath, "other", "ChkCollectFreeMagicItems", False, "Bool")
IniReadS($g_bChkTreasuryCollect, $g_sProfileConfigPath, "other", "ChkTreasuryCollect", False, "Bool")
IniReadS($g_iTxtTreasuryGold, $g_sProfileConfigPath, "other", "minTreasurygold", 0, "int")
IniReadS($g_iTxtTreasuryElixir, $g_sProfileConfigPath, "other", "minTreasuryelixir", 0, "int")
IniReadS($g_iTxtTreasuryDark, $g_sProfileConfigPath, "other", "minTreasurydark", 0, "int")
IniReadS($g_bChkCollectBuilderBase, $g_sProfileConfigPath, "other", "ChkCollectBuildersBase", False, "Bool")
IniReadS($g_bChkCleanBBYard, $g_sProfileConfigPath, "other", "ChkCleanBBYard", False, "Bool")
IniReadS($g_bChkStartClockTowerBoost, $g_sProfileConfigPath, "other", "ChkStartClockTowerBoost", False, "Bool")
IniReadS($g_bChkCTBoostBlderBz, $g_sProfileConfigPath, "other", "ChkCTBoostBlderBz", False, "Bool")
IniReadS($g_iChkBBSuggestedUpgrades, $g_sProfileConfigPath, "other", "ChkBBSuggestedUpgrades", $g_iChkBBSuggestedUpgrades, "Int")
IniReadS($g_iChkBBSuggestedUpgradesIgnoreGold, $g_sProfileConfigPath, "other", "ChkBBSuggestedUpgradesIgnoreGold", $g_iChkBBSuggestedUpgradesIgnoreGold, "Int")
IniReadS($g_iChkBBSuggestedUpgradesIgnoreElixir, $g_sProfileConfigPath, "other", "ChkBBSuggestedUpgradesIgnoreElixir", $g_iChkBBSuggestedUpgradesIgnoreElixir, "Int")
IniReadS($g_iChkBBSuggestedUpgradesIgnoreHall, $g_sProfileConfigPath, "other", "ChkBBSuggestedUpgradesIgnoreHall", $g_iChkBBSuggestedUpgradesIgnoreHall, "Int")
IniReadS($g_iChkPlacingNewBuildings, $g_sProfileConfigPath, "other", "ChkPlacingNewBuildings", $g_iChkPlacingNewBuildings, "Int")
IniReadS($g_bChkClanGamesAir, $g_sProfileConfigPath, "other", "ChkClanGamesAir", False, "Bool")
IniReadS($g_bChkClanGamesGround, $g_sProfileConfigPath, "other", "ChkClanGamesGround", False, "Bool")
IniReadS($g_bChkClanGamesMisc, $g_sProfileConfigPath, "other", "ChkClanGamesMisc", False, "Bool")
IniReadS($g_bChkClanGamesEnabled, $g_sProfileConfigPath, "other", "ChkClanGamesEnabled", False, "Bool")
IniReadS($g_bChkClanGames60, $g_sProfileConfigPath, "other", "ChkClanGames60", False, "Bool")
IniReadS($g_bChkClanGamesPurge, $g_sProfileConfigPath, "other", "ChkClanGamesPurge", False, "Bool")
IniReadS($g_bChkClanGamesStopBeforeReachAndPurge, $g_sProfileConfigPath, "other", "ChkClanGamesStopBeforeReachAndPurge", False, "Bool")
IniReadS($g_bChkClanGamesDebug, $g_sProfileConfigPath, "other", "ChkClanGamesDebug", False, "Bool")
IniReadS($g_bChkClanGamesLoot, $g_sProfileConfigPath, "other", "ChkClanGamesLoot", False, "Bool")
IniReadS($g_bChkClanGamesBattle, $g_sProfileConfigPath, "other", "ChkClanGamesBattle", False, "Bool")
IniReadS($g_bChkClanGamesDestruction, $g_sProfileConfigPath, "other", "ChkClanGamesDestruction", False, "Bool")
IniReadS($g_bChkClanGamesAirTroop, $g_sProfileConfigPath, "other", "ChkClanGamesAirTroop", False, "Bool")
IniReadS($g_bChkClanGamesGroundTroop, $g_sProfileConfigPath, "other", "ChkClanGamesGroundTroop", False, "Bool")
IniReadS($g_bChkClanGamesMiscellaneous, $g_sProfileConfigPath, "other", "ChkClanGamesMiscellaneous", False, "Bool")
IniReadS($g_iPurgeMax, $g_sProfileConfigPath, "other", "PurgeMax", 5, "int")
EndFunc
Func ReadConfig_600_9()
IniReadS($g_iUnbrkMode, $g_sProfileConfigPath, "Unbreakable", "chkUnbreakable", 0, "int")
IniReadS($g_iUnbrkWait, $g_sProfileConfigPath, "Unbreakable", "UnbreakableWait", 5, "int")
IniReadS($g_iUnbrkMinGold, $g_sProfileConfigPath, "Unbreakable", "minUnBrkgold", 50000, "int")
IniReadS($g_iUnbrkMaxGold, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkgold", 600000, "int")
IniReadS($g_iUnbrkMinElixir, $g_sProfileConfigPath, "Unbreakable", "minUnBrkelixir", 50000, "int")
IniReadS($g_iUnbrkMaxElixir, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkelixir", 600000, "int")
IniReadS($g_iUnbrkMinDark, $g_sProfileConfigPath, "Unbreakable", "minUnBrkdark", 5000, "int")
IniReadS($g_iUnbrkMaxDark, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkdark", 10000, "int")
EndFunc
Func ReadConfig_600_11()
$g_bRequestTroopsEnable =(IniRead($g_sProfileConfigPath, "planned", "RequestHoursEnable", "0") = "1")
$g_sRequestTroopsText = IniRead($g_sProfileConfigPath, "donate", "txtRequest", "")
$g_abRequestType[0] =(IniRead($g_sProfileConfigPath, "donate", "RequestType_Troop", "0") = "1")
$g_abRequestType[1] =(IniRead($g_sProfileConfigPath, "donate", "RequestType_Spell", "0") = "1")
$g_abRequestType[2] =(IniRead($g_sProfileConfigPath, "donate", "RequestType_Siege", "0") = "1")
$g_iRequestCountCCTroop = Int(IniRead($g_sProfileConfigPath, "donate", "RequestCountCC_Troop", "0"))
$g_iRequestCountCCSpell = Int(IniRead($g_sProfileConfigPath, "donate", "RequestCountCC_Spell", "0"))
For $i = 0 To $eTroopCount - 1
$g_aiCCTroopsExpected[$i] = 0
If $i < $eSpellCount Then $g_aiCCSpellsExpected[$i] = 0
If $i < $eSiegeMachineCount Then $g_aiCCSiegeExpected[$i] = 0
Next
For $i = 0 To 2
$g_aiClanCastleTroopWaitType[$i] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbClanCastleTroop" & $i, $eTroopCount))
$g_aiClanCastleTroopWaitQty[$i] = Int(IniRead($g_sProfileConfigPath, "donate", "txtClanCastleTroop" & $i, "0"))
If $g_aiClanCastleTroopWaitType[$i] < $eTroopCount Then
$g_aiCCTroopsExpected[$g_aiClanCastleTroopWaitType[$i]] += $g_aiClanCastleTroopWaitQty[$i]
EndIf
$g_aiClanCastleSpellWaitType[$i] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbClanCastleSpell" & $i, $eSpellCount))
If $g_aiClanCastleSpellWaitType[$i] < $eSpellCount Then
$g_aiCCSpellsExpected[$g_aiClanCastleSpellWaitType[$i]] += 1
EndIf
If $i > 1 Then ContinueLoop
$g_aiClanCastleSiegeWaitType[$i] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbClanCastleSiege" & $i, $eSiegeMachineCount))
If $g_aiClanCastleSiegeWaitType[$i] < $eSiegeMachineCount Then $g_aiCCSiegeExpected[$g_aiClanCastleSiegeWaitType[$i]] = 1
Next
$g_abRequestCCHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "RequestHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abRequestCCHours[$i] =($g_abRequestCCHours[$i] = "1")
Next
$g_bRequestCCDefense =(IniRead($g_sProfileConfigPath, "donate", "RequestDefenseEnable", "0") = "1")
$g_sRequestCCDefenseText = IniRead($g_sProfileConfigPath, "donate", "RequestDefenseText", "")
$g_bRequestCCDefenseWhenPB =(IniRead($g_sProfileConfigPath, "donate", "RequestDefenseWhenPB", "1") = "1")
$g_iRequestDefenseTime = Int(IniRead($g_sProfileConfigPath, "donate", "RequestDefenseTime", "30"))
$g_bSaveCCTroopForDefense =(IniRead($g_sProfileConfigPath, "donate", "SaveCCTroopForDefense", "0") = "1")
For $i = 0 To $eTroopCount - 1
$g_aiCCTroopsExpectedForDefense[$i] = 0
Next
For $i = 0 To 2
$g_aiCCTroopDefenseType[$i] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbCCTroopDefense" & $i, $eTroopCount))
$g_aiCCTroopDefenseQty[$i] = Int(IniRead($g_sProfileConfigPath, "donate", "txtCCTroopDefense" & $i, "0"))
If $g_aiCCTroopDefenseType[$i] < $eTroopCount Then
$g_aiCCTroopsExpectedForDefense[$g_aiCCTroopDefenseType[$i]] += $g_aiCCTroopDefenseQty[$i]
EndIf
Next
EndFunc
Func ReadConfig_600_12()
IniReadS($g_bChkDonate, $g_sProfileConfigPath, "donate", "Doncheck", True, "Bool")
IniReadS($g_abChkDonateQueueOnly[0], $g_sProfileConfigPath, "donate", "chkDonateQueueOnly[0]", True, "Bool")
IniReadS($g_abChkDonateQueueOnly[1], $g_sProfileConfigPath, "donate", "chkDonateQueueOnly[1]", True, "Bool")
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
Local $sIniName = ""
If $i >= $eTroopBarbarian And $i <= $eTroopIceGolem Then
$sIniName = StringReplace($g_asTroopNamesPlural[$i], " ", "")
ElseIf $i = $eCustomA Then
$sIniName = "CustomA"
ElseIf $i = $eCustomB Then
$sIniName = "CustomB"
ElseIf $i = $eCustomC Then
$sIniName = "CustomC"
ElseIf $i = $eCustomD Then
$sIniName = "CustomD"
EndIf
$g_abChkDonateTroop[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, "0") = "1")
$g_abChkDonateAllTroop[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, "0") = "1")
Next
$g_asTxtDonateTroop[$eTroopBarbarian] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBarbarians", "barbarians|barbarian|barb"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBarbarian] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBarbarians", "no barbarians|no barb|barbarian no|barb no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopArcher] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateArchers", "archers|archer|arch"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopArcher] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistArchers", "no archers|no arch|archer no|arch no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGiant] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGiants", "giants|giant|any"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGiant] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGiants", "no giants|giants no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGoblin] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGoblins", "goblins|goblin"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGoblin] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGoblins", "no goblins|goblins no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWallBreaker] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWallBreakers", "wall breakers|wb"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWallBreaker] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWallBreakers", "no wallbreakers|wb no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBalloon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBalloons", "balloons|balloon"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBalloon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBalloons", "no balloon|balloons no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWizard] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWizards", "wizards|wizard|wiz"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWizard] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWizards", "no wizards|wizards no|no wizard|wizard no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopHealer] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHealers", "healer"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopHealer] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHealers", "no healer|healer no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateDragons", "dragon"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistDragons", "no dragon|dragon no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopPekka] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonatePekkas", "PEKKA|pekka"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopPekka] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistPekkas", "no PEKKA|pekka no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBabyDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBabyDragons", "baby dragon|baby"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBabyDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBabyDragons", "no baby dragon|baby dragon no|no baby|baby no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopMiner] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateMiners", "miner|mine"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopMiner] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistMiners", "no miner|miner no|no mine|mine no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopElectroDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateElectroDragons", "electro dragon|electrodrag|edrag"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopElectroDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistElectroDragons", "no electro dragon|electrodrag no|edrag no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopMinion] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateMinions", "minions|minion"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopMinion] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistMinions", "no minion|minions no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopHogRider] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHogRiders", "hogriders|hogs|hog"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopHogRider] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHogRiders", "no hogriders|hogriders no|no hog|hogs no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopValkyrie] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateValkyries", "valkyries|valkyrie|valk"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopValkyrie] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistValkyries", "no valkyrie|valkyries no|no valk|valk no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGolem] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGolems", "golem"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGolem] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGolems", "no golem|golem no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWitch] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWitches", "witches|witch"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWitch] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWitches", "no witches|witches no|no witch|witch no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopLavaHound] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateLavaHounds", "lavahounds|lava|hound"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopLavaHound] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistLavaHounds", "no lavahound|lavahound no|no lava|lava no|nohound|hound no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBowler] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBowlers", "bowler|bowl"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBowler] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBowlers", "no bowler|bowl no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopIceGolem] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateIceGolems", "ice golem|ice golems"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopIceGolem] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistIceGolems", "no ice golem|ice golem no"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomA] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA", "ground support|ground"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomA] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomA", "no ground|ground no|nonly"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomB] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB", "air support|any air"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomB] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomB", "no air|air no|only|just"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomC] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomC", "ground support|ground"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomC] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomC", "no ground|ground no|nonly"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomD] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomD", "air support|any air"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomD] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomD", "no air|air no|only|just"), "|", @CRLF)
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
Local $sIniName = $g_asSpellNames[$i] & "Spells"
$g_abChkDonateSpell[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, "0") = "1")
$g_abChkDonateAllSpell[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, "0") = "1")
EndIf
Next
$g_asTxtDonateSpell[$eSpellLightning] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateLightningSpells", "lightning"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellLightning] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistLightningSpells", "no lightning|lightning no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellHeal] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHealSpells", "heal"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellHeal] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHealSpells", "no heal|heal no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellRage] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateRageSpells", "rage"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellRage] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistRageSpells", "no rage|rage no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellJump] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateJumpSpells", "jump"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellJump] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistJumpSpells", "no jump|jump no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellFreeze] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateFreezeSpells", "freeze"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellFreeze] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistFreezeSpells", "no freeze|freeze no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellPoison] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonatePoisonSpells", "poison"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellPoison] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistPoisonSpells", "no poison|poison no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellEarthquake] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateEarthQuakeSpells", "earthquake|quake"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellEarthquake] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistEarthQuakeSpells", "no earthquake|quake no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellHaste] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHasteSpells", "haste"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellHaste] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHasteSpells", "no haste|haste no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellSkeleton] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateSkeletonSpells", "skeleton"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellSkeleton] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistSkeletonSpells", "no skeleton|skeleton no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellBat] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBatSpells", "bat"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellBat] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBatSpells", "no bat|bat no"), "|", @CRLF)
For $i = $eSiegeWallWrecker to $eSiegeMachineCount - 1
Local $index = $eTroopCount + $g_iCustomDonateConfigs
Local $sIniName = $g_asSiegeMachineShortNames[$i]
$g_abChkDonateTroop[$index + $i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, "0") = "1")
$g_abChkDonateAllTroop[$index + $i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, "0") = "1")
Next
$g_asTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWallW", "Wrecker|siege"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeWallWrecker] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWallW", "no WallW|no Wrecker|siege no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBattleB", "Blimp|siege"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeBattleBlimp] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBattleB", "no Blimp|siege no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateStoneS", "Slammer|siege"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopCount + $g_iCustomDonateConfigs + $eSiegeStoneSlammer] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistStoneS", "no Slammer|siege no"), "|", @CRLF)
$g_aiDonateCustomTrpNumA[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA1", 6))
$g_aiDonateCustomTrpNumA[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA2", 1))
$g_aiDonateCustomTrpNumA[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA3", 0))
$g_aiDonateCustomTrpNumA[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA1", 2))
$g_aiDonateCustomTrpNumA[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA2", 3))
$g_aiDonateCustomTrpNumA[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA3", 1))
$g_aiDonateCustomTrpNumB[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB1", 11))
$g_aiDonateCustomTrpNumB[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB2", 1))
$g_aiDonateCustomTrpNumB[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB3", 6))
$g_aiDonateCustomTrpNumB[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB1", 3))
$g_aiDonateCustomTrpNumB[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB2", 13))
$g_aiDonateCustomTrpNumB[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB3", 5))
$g_aiDonateCustomTrpNumC[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomC1", 6))
$g_aiDonateCustomTrpNumC[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomC2", 1))
$g_aiDonateCustomTrpNumC[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomC3", 0))
$g_aiDonateCustomTrpNumC[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomC1", 2))
$g_aiDonateCustomTrpNumC[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomC2", 3))
$g_aiDonateCustomTrpNumC[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomC3", 1))
$g_aiDonateCustomTrpNumD[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomD1", 11))
$g_aiDonateCustomTrpNumD[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomD2", 1))
$g_aiDonateCustomTrpNumD[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomD3", 6))
$g_aiDonateCustomTrpNumD[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomD1", 3))
$g_aiDonateCustomTrpNumD[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomD2", 13))
$g_aiDonateCustomTrpNumD[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomD3", 5))
$g_bChkExtraAlphabets =(IniRead($g_sProfileConfigPath, "donate", "chkExtraAlphabets", "0") = "1")
$g_bChkExtraChinese =(IniRead($g_sProfileConfigPath, "donate", "chkExtraChinese", "0") = "1")
$g_bChkExtraKorean =(IniRead($g_sProfileConfigPath, "donate", "chkExtraKorean", "0") = "1")
$g_bChkExtraPersian =(IniRead($g_sProfileConfigPath, "donate", "chkExtraPersian", "0") = "1")
$g_sTxtGeneralBlacklist = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklist", "clan war|war|cw"), "|", @CRLF)
EndFunc
Func ReadConfig_600_13()
$g_bDonateHoursEnable =(IniRead($g_sProfileConfigPath, "planned", "DonateHoursEnable", "0") = "1")
$g_abDonateHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "DonateHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abDonateHours[$i] =($g_abDonateHours[$i] = "1")
Next
$g_iCmbDonateFilter = Int(IniRead($g_sProfileConfigPath, "donate", "cmbFilterDonationsCC", 0))
$g_iDonateSkipNearFullPercent = Int(IniRead($g_sProfileConfigPath, "donate", "SkipDonateNearFulLTroopsPercentual", 90))
$g_bDonateSkipNearFullEnable =(IniRead($g_sProfileConfigPath, "donate", "SkipDonateNearFulLTroopsEnable", "0") = "1")
EndFunc
Func ReadConfig_600_14()
IniReadS($g_bAutoLabUpgradeEnable, $g_sProfileBuildingPath, "upgrade", "upgradetroops", False, "Bool")
IniReadS($g_iCmbLaboratory, $g_sProfileBuildingPath, "upgrade", "upgradetroopname", 0, "int")
IniReadS($g_iLaboratoryElixirCost, $g_sProfileBuildingPath, "upgrade", "upgradelabelexircost", 0, "int")
IniReadS($g_iLaboratoryDElixirCost, $g_sProfileBuildingPath, "upgrade", "upgradelabdelexircost", 0, "int")
IniReadS($g_bAutoStarLabUpgradeEnable, $g_sProfileBuildingPath, "upgrade", "upgradestartroops", False, "Bool")
IniReadS($g_iCmbStarLaboratory, $g_sProfileBuildingPath, "upgrade", "upgradestartroopname", 0, "int")
EndFunc
Func ReadConfig_600_15()
IniReadS($g_bUpgradeKingEnable, $g_sProfileConfigPath, "upgrade", "UpgradeKing", False, "Bool")
IniReadS($g_bUpgradeQueenEnable, $g_sProfileConfigPath, "upgrade", "UpgradeQueen", False, "Bool")
IniReadS($g_bUpgradeWardenEnable, $g_sProfileConfigPath, "upgrade", "UpgradeWarden", False, "Bool")
IniReadS($g_iHeroReservedBuilder, $g_sProfileConfigPath, "upgrade", "HeroReservedBuilder", 0, "int")
EndFunc
Func ReadConfig_600_16()
IniReadS($g_iUpgradeMinGold, $g_sProfileConfigPath, "upgrade", "minupgrgold", 100000, "int")
IniReadS($g_iUpgradeMinElixir, $g_sProfileConfigPath, "upgrade", "minupgrelixir", 100000, "int")
IniReadS($g_iUpgradeMinDark, $g_sProfileConfigPath, "upgrade", "minupgrdark", 2000, "int")
EndFunc
Func ReadConfig_auto()
IniReadS($g_bAutoUpgradeEnabled, $g_sProfileConfigPath, "Auto Upgrade", "AutoUpgradeEnabled", False, "Bool")
For $i = 0 To 13
IniReadS($g_iChkUpgradesToIgnore[$i], $g_sProfileConfigPath, "Auto Upgrade", "ChkUpgradesToIgnore[" & $i & "]", $g_iChkUpgradesToIgnore[$i], "int")
Next
For $i = 0 To 2
IniReadS($g_iChkResourcesToIgnore[$i], $g_sProfileConfigPath, "Auto Upgrade", "ChkResourcesToIgnore[" & $i & "]", $g_iChkResourcesToIgnore[$i], "int")
Next
IniReadS($g_iTxtSmartMinGold, $g_sProfileConfigPath, "Auto Upgrade", "SmartMinGold", 150000, "int")
IniReadS($g_iTxtSmartMinElixir, $g_sProfileConfigPath, "Auto Upgrade", "SmartMinElixir", 150000, "int")
IniReadS($g_iTxtSmartMinDark, $g_sProfileConfigPath, "Auto Upgrade", "SmartMinDark", 1500, "int")
EndFunc
Func ReadConfig_600_17()
IniReadS($g_bAutoUpgradeWallsEnable, $g_sProfileConfigPath, "upgrade", "auto-wall", False, "Bool")
IniReadS($g_iUpgradeWallMinGold, $g_sProfileConfigPath, "upgrade", "minwallgold", 0, "int")
IniReadS($g_iUpgradeWallMinElixir, $g_sProfileConfigPath, "upgrade", "minwallelixir", 0, "int")
IniReadS($g_iUpgradeWallLootType, $g_sProfileConfigPath, "upgrade", "use-storage", 0, "int")
IniReadS($g_bUpgradeWallSaveBuilder, $g_sProfileConfigPath, "upgrade", "savebldr", False, "Bool")
IniReadS($g_iCmbUpgradeWallsLevel, $g_sProfileConfigPath, "upgrade", "walllvl", 6, "int")
For $i = 4 To 13
IniReadS($g_aiWallsCurrentCount[$i], $g_sProfileConfigPath, "Walls", "Wall" & StringFormat("%02d", $i), 0, "int")
Next
IniReadS($g_iWallCost, $g_sProfileConfigPath, "upgrade", "WallCost", 0, "int")
EndFunc
Func ReadConfig_600_18()
IniReadS($g_bNotifyTGEnable, $g_sProfileConfigPath, "notify", "TGEnabled", False, "Bool")
IniReadS($g_sNotifyTGToken, $g_sProfileConfigPath, "notify", "TGToken", "")
IniReadS($g_sTGChatID, $g_sProfileConfigPath, "notify", "TGUserID", "")
IniReadS($g_bNotifyRemoteEnable, $g_sProfileConfigPath, "notify", "PBRemote", False, "Bool")
IniReadS($g_sNotifyOrigin, $g_sProfileConfigPath, "notify", "Origin", $g_sProfileCurrentName)
IniReadS($g_iNotifyDeletePushesOlderThanHours, $g_sProfileConfigPath, "notify", "HoursPushBullet", 4, "int")
IniReadS($g_bNotifyAlertMatchFound, $g_sProfileConfigPath, "notify", "AlertPBVMFound", False, "Bool")
IniReadS($g_bNotifyAlerLastRaidIMG, $g_sProfileConfigPath, "notify", "AlertPBLastRaid", False, "Bool")
IniReadS($g_bNotifyAlerLastRaidTXT, $g_sProfileConfigPath, "notify", "AlertPBLastRaidTxt", False, "Bool")
IniReadS($g_bNotifyAlertCampFull, $g_sProfileConfigPath, "notify", "AlertPBCampFull", False, "Bool")
IniReadS($g_bNotifyAlertUpgradeWalls, $g_sProfileConfigPath, "notify", "AlertPBWallUpgrade", False, "Bool")
IniReadS($g_bNotifyAlertOutOfSync, $g_sProfileConfigPath, "notify", "AlertPBOOS", False, "Bool")
IniReadS($g_bNotifyAlertTakeBreak, $g_sProfileConfigPath, "notify", "AlertPBVBreak", False, "Bool")
IniReadS($g_bNotifyAlertBulderIdle, $g_sProfileConfigPath, "notify", "AlertBuilderIdle", False, "Bool")
IniReadS($g_bNotifyAlertVillageReport, $g_sProfileConfigPath, "notify", "AlertPBVillage", False, "Bool")
IniReadS($g_bNotifyAlertLastAttack, $g_sProfileConfigPath, "notify", "AlertPBLastAttack", False, "Bool")
IniReadS($g_bNotifyAlertAnotherDevice, $g_sProfileConfigPath, "notify", "AlertPBOtherDevice", False, "Bool")
IniReadS($g_bNotifyAlertMaintenance, $g_sProfileConfigPath, "notify", "AlertPBMaintenance", False, "Bool")
IniReadS($g_bNotifyAlertBAN, $g_sProfileConfigPath, "notify", "AlertPBBAN", False, "Bool")
IniReadS($g_bNotifyAlertBOTUpdate, $g_sProfileConfigPath, "notify", "AlertPBUpdate", False, "Bool")
IniReadS($g_bNotifyAlertSmartWaitTime, $g_sProfileConfigPath, "notify", "AlertSmartWaitTime", False, "Bool")
IniReadS($g_bNotifyAlertLaboratoryIdle, $g_sProfileConfigPath, "notify", "AlertLaboratoryIdle", False, "Bool")
EndFunc
Func ReadConfig_600_19()
$g_bNotifyScheduleHoursEnable =(IniRead($g_sProfileConfigPath, "notify", "NotifyHoursEnable", "0") = "1")
$g_abNotifyScheduleHours = StringSplit(IniRead($g_sProfileConfigPath, "notify", "NotifyHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abNotifyScheduleHours[$i] =($g_abNotifyScheduleHours[$i] = "1")
Next
$g_bNotifyScheduleWeekDaysEnable =(IniRead($g_sProfileConfigPath, "notify", "NotifyWeekDaysEnable", "0") = "1")
$g_abNotifyScheduleWeekDays = StringSplit(IniRead($g_sProfileConfigPath, "notify", "NotifyWeekDays", "1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 6
$g_abNotifyScheduleWeekDays[$i] =($g_abNotifyScheduleWeekDays[$i] = "1")
Next
EndFunc
Func ReadConfig_600_22()
$g_abBoostBarracksHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "BoostBarracksHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abBoostBarracksHours[$i] =($g_abBoostBarracksHours[$i] = "1")
Next
EndFunc
Func ReadConfig_600_26()
IniReadS($g_abAttackTypeEnable[$TB], $g_sProfileConfigPath, "search", "BullyMode", False, "Bool")
IniReadS($g_iAtkTBEnableCount, $g_sProfileConfigPath, "search", "ATBullyMode", 0, "int")
IniReadS($g_iAtkTBMaxTHLevel, $g_sProfileConfigPath, "search", "YourTH", 0, "int")
IniReadS($g_iAtkTBMode, $g_sProfileConfigPath, "search", "THBullyAttackMode", 0, "int")
EndFunc
Func ReadConfig_600_28()
IniReadS($g_bSearchReductionEnable, $g_sProfileConfigPath, "search", "reduction", False, "Bool")
IniReadS($g_iSearchReductionCount, $g_sProfileConfigPath, "search", "reduceCount", 20, "int")
IniReadS($g_iSearchReductionGold, $g_sProfileConfigPath, "search", "reduceGold", 2000, "int")
IniReadS($g_iSearchReductionElixir, $g_sProfileConfigPath, "search", "reduceElixir", 2000, "int")
IniReadS($g_iSearchReductionGoldPlusElixir, $g_sProfileConfigPath, "search", "reduceGoldPlusElixir", 4000, "int")
IniReadS($g_iSearchReductionDark, $g_sProfileConfigPath, "search", "reduceDark", 100, "int")
IniReadS($g_iSearchReductionTrophy, $g_sProfileConfigPath, "search", "reduceTrophy", 2, "int")
IniReadS($g_iSearchDelayMin, $g_sProfileConfigPath, "other", "VSDelay", 0, "Int")
IniReadS($g_iSearchDelayMax, $g_sProfileConfigPath, "other", "MaxVSDelay", 4, "Int")
IniReadS($g_bSearchAttackNowEnable, $g_sProfileConfigPath, "general", "AttackNow", False, "Bool")
IniReadS($g_iSearchAttackNowDelay, $g_sProfileConfigPath, "general", "attacknowdelay", 3, "int")
IniReadS($g_bSearchRestartEnable, $g_sProfileConfigPath, "search", "ChkRestartSearchLimit", True, "Bool")
IniReadS($g_iSearchRestartLimit, $g_sProfileConfigPath, "search", "RestartSearchLimit", 50, "int")
IniReadS($g_bSearchRestartPickupHero, $g_sProfileConfigPath, "search", "RestartSearchPickupHero", False, "Bool")
IniReadS($g_bSearchAlertMe, $g_sProfileConfigPath, "general", "AlertSearch", False, "Bool")
EndFunc
Func ReadConfig_600_28_DB()
IniReadS($g_abAttackTypeEnable[$DB], $g_sProfileConfigPath, "search", "DBcheck", True, "Bool")
IniReadS($g_abSearchSearchesEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchSearches", True, "Bool")
IniReadS($g_aiSearchSearchesMin[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$DB], $g_sProfileConfigPath, "search", "DBEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$DB], $g_sProfileConfigPath, "search", "DBEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterArmyCamps", 100, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "DBKingWait", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "DBQueenWait", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "DBWardenWait", $eHeroNone)
$g_aiSearchHeroWaitEnable[$DB] = BitOR(Int($temp1 > $eHeroNone ? $eHeroKing : 0), Int($temp2 > $eHeroNone ? $eHeroQueen : 0), Int($temp3 > $eHeroNone ? $eHeroWarden : 0))
IniReadS($g_aiSearchNotWaitHeroesEnable[$DB], $g_sProfileConfigPath, "attack", "DBNotWaitHeroes", 0, "int")
$g_iHeroWaitAttackNoBit[$DB][0] =($temp1 > $eHeroNone) ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][1] =($temp2 > $eHeroNone) ? 1 : 0
$g_iHeroWaitAttackNoBit[$DB][2] =($temp3 > $eHeroNone) ? 1 : 0
IniReadS($g_abSearchSpellsWaitEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSpellsWait", False, "Bool")
IniReadS($g_abSearchCastleWaitEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBCastleWait", False, "Bool")
IniReadS($g_aiFilterMeetGE[$DB], $g_sProfileConfigPath, "search", "DBMeetGE", 1, "int")
IniReadS($g_aiFilterMinGold[$DB], $g_sProfileConfigPath, "search", "DBsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$DB], $g_sProfileConfigPath, "search", "DBsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$DB], $g_sProfileConfigPath, "search", "DBsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$DB], $g_sProfileConfigPath, "search", "DBsearchDark", 0, "int")
IniReadS($g_abFilterMeetTrophyEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetTrophy", False, "Bool")
IniReadS($g_aiFilterMeetTrophyMin[$DB], $g_sProfileConfigPath, "search", "DBsearchTrophy", 0, "int")
IniReadS($g_aiFilterMeetTrophyMax[$DB], $g_sProfileConfigPath, "search", "DBsearchTrophyMax", 99, "int")
IniReadS($g_abFilterMeetTH[$DB], $g_sProfileConfigPath, "search", "DBMeetTH", False, "Bool")
IniReadS($g_aiFilterMeetTHMin[$DB], $g_sProfileConfigPath, "search", "DBTHLevel", 0, "int")
IniReadS($g_abFilterMeetTHOutsideEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetTHO", False, "Bool")
IniReadS($g_abFilterMaxMortarEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckMortar", False, "Bool")
IniReadS($g_abFilterMaxWizTowerEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckWizTower", False, "Bool")
IniReadS($g_abFilterMaxAirDefenseEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckAirDefense", False, "Bool")
IniReadS($g_abFilterMaxXBowEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckXBow", False, "Bool")
IniReadS($g_abFilterMaxInfernoEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckInferno", False, "Bool")
IniReadS($g_abFilterMaxEagleEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckEagle", False, "Bool")
IniReadS($g_aiFilterMaxMortarLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakMortar", 5, "int")
IniReadS($g_aiFilterMaxWizTowerLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakWizTower", 4, "int")
IniReadS($g_aiFilterMaxAirDefenseLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakAirDefense", 7, "int")
IniReadS($g_aiFilterMaxXBowLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakXBow", 4, "int")
IniReadS($g_aiFilterMaxInfernoLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakInferno", 1, "int")
IniReadS($g_aiFilterMaxEagleLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakEagle", 2, "int")
IniReadS($g_abFilterMeetOneConditionEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetOne", False, "Bool")
EndFunc
Func ReadConfig_600_28_LB()
IniReadS($g_abAttackTypeEnable[$LB], $g_sProfileConfigPath, "search", "ABcheck", False, "Bool")
IniReadS($g_abSearchSearchesEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchSearches", False, "Bool")
IniReadS($g_aiSearchSearchesMin[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$LB], $g_sProfileConfigPath, "search", "ABEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$LB], $g_sProfileConfigPath, "search", "ABEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterArmyCamps", 100, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "ABKingWait", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "ABQueenWait", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "ABWardenWait", $eHeroNone)
$g_aiSearchHeroWaitEnable[$LB] = BitOR(Int($temp1 > $eHeroNone ? $eHeroKing : 0), Int($temp2 > $eHeroNone ? $eHeroQueen : 0), Int($temp3 > $eHeroNone ? $eHeroWarden : 0))
IniReadS($g_aiSearchNotWaitHeroesEnable[$LB], $g_sProfileConfigPath, "attack", "ABNotWaitHeroes", 0, "int")
$g_iHeroWaitAttackNoBit[$LB][0] =($temp1 > $eHeroNone) ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][1] =($temp2 > $eHeroNone) ? 1 : 0
$g_iHeroWaitAttackNoBit[$LB][2] =($temp3 > $eHeroNone) ? 1 : 0
IniReadS($g_abSearchSpellsWaitEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSpellsWait", False, "Bool")
IniReadS($g_abSearchCastleWaitEnable[$LB], $g_sProfileConfigPath, "search", "ChkABCastleWait", False, "Bool")
IniReadS($g_aiFilterMeetGE[$LB], $g_sProfileConfigPath, "search", "ABMeetGE", 2, "int")
IniReadS($g_aiFilterMinGold[$LB], $g_sProfileConfigPath, "search", "ABsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$LB], $g_sProfileConfigPath, "search", "ABsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$LB], $g_sProfileConfigPath, "search", "ABsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$LB], $g_sProfileConfigPath, "search", "ABsearchDark", 0, "int")
IniReadS($g_abFilterMeetTrophyEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetTrophy", False, "Bool")
IniReadS($g_aiFilterMeetTrophyMin[$LB], $g_sProfileConfigPath, "search", "ABsearchTrophy", 0, "int")
IniReadS($g_aiFilterMeetTrophyMax[$LB], $g_sProfileConfigPath, "search", "ABsearchTrophyMax", 99, "int")
IniReadS($g_abFilterMeetTH[$LB], $g_sProfileConfigPath, "search", "ABMeetTH", False, "Bool")
IniReadS($g_aiFilterMeetTHMin[$LB], $g_sProfileConfigPath, "search", "ABTHLevel", 0, "int")
IniReadS($g_abFilterMeetTHOutsideEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetTHO", False, "Bool")
IniReadS($g_abFilterMaxMortarEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckMortar", False, "Bool")
IniReadS($g_abFilterMaxWizTowerEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckWizTower", False, "Bool")
IniReadS($g_abFilterMaxAirDefenseEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckAirDefense", False, "Bool")
IniReadS($g_abFilterMaxXBowEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckXBow", False, "Bool")
IniReadS($g_abFilterMaxInfernoEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckInferno", False, "Bool")
IniReadS($g_abFilterMaxEagleEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckEagle", False, "Bool")
IniReadS($g_aiFilterMaxMortarLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakMortar", 5, "int")
IniReadS($g_aiFilterMaxWizTowerLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakWizTower", 4, "int")
IniReadS($g_aiFilterMaxAirDefenseLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakAirDefense", 7, "int")
IniReadS($g_aiFilterMaxXBowLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakXBow", 4, "int")
IniReadS($g_aiFilterMaxInfernoLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakInferno", 1, "int")
IniReadS($g_aiFilterMaxEagleLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakEagle", 2, "int")
IniReadS($g_abFilterMeetOneConditionEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetOne", False, "Bool")
EndFunc
Func ReadConfig_600_28_TS()
IniReadS($g_abAttackTypeEnable[$TS], $g_sProfileConfigPath, "search", "TScheck", False, "Bool")
IniReadS($g_abSearchSearchesEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchSearches", False, "Bool")
IniReadS($g_aiSearchSearchesMin[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$TS], $g_sProfileConfigPath, "search", "TSEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$TS], $g_sProfileConfigPath, "search", "TSEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterArmyCamps", 100, "int")
IniReadS($g_aiFilterMeetGE[$TS], $g_sProfileConfigPath, "search", "TSMeetGE", 1, "int")
IniReadS($g_aiFilterMinGold[$TS], $g_sProfileConfigPath, "search", "TSsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$TS], $g_sProfileConfigPath, "search", "TSsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$TS], $g_sProfileConfigPath, "search", "TSsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$TS], $g_sProfileConfigPath, "search", "TSMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$TS], $g_sProfileConfigPath, "search", "TSsearchDark", 600, "int")
IniReadS($g_iAtkTSAddTilesWhileTrain, $g_sProfileConfigPath, "search", "SWTtiles", 1, "int")
IniReadS($g_iAtkTSAddTilesFullTroops, $g_sProfileConfigPath, "search", "THaddTiles", 2, "int")
EndFunc
Func ReadConfig_600_29()
IniReadS($g_iActivateQueen, $g_sProfileConfigPath, "attack", "ActivateQueen", 0, "int")
IniReadS($g_iActivateKing, $g_sProfileConfigPath, "attack", "ActivateKing", 0, "int")
IniReadS($g_iActivateWarden, $g_sProfileConfigPath, "attack", "ActivateWarden", 0, "int")
IniReadS($g_iDelayActivateQueen, $g_sProfileConfigPath, "attack", "delayActivateQueen", 9000, "int")
IniReadS($g_iDelayActivateKing, $g_sProfileConfigPath, "attack", "delayActivateKing", 9000, "int")
IniReadS($g_iDelayActivateWarden, $g_sProfileConfigPath, "attack", "delayActivateWarden", 10000, "int")
$g_bAttackPlannerEnable =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerEnable", "0") = "1")
$g_bAttackPlannerCloseCoC =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerCloseCoC", "0") = "1")
$g_bAttackPlannerCloseAll =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerCloseAll", "0") = "1")
$g_bAttackPlannerSuspendComputer =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerSuspendComputer", "0") = "1")
$g_bAttackPlannerRandomEnable =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerRandom", "0") = "1")
$g_iAttackPlannerRandomTime = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerRandom", 4))
$g_bAttackPlannerDayLimit =(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerDayLimit", "0") = "1")
$g_iAttackPlannerDayMin = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerDayMin", 12))
$g_iAttackPlannerDayMax = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerDayMax", 15))
$g_abPlannedAttackWeekDays = StringSplit(IniRead($g_sProfileConfigPath, "planned", "attackDays", "1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 6
$g_abPlannedAttackWeekDays[$i] =($g_abPlannedAttackWeekDays[$i] = "1")
Next
$g_abPlannedattackHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "attackHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abPlannedattackHours[$i] =($g_abPlannedattackHours[$i] = "1")
Next
$g_bPlannedDropCCHoursEnable =(IniRead($g_sProfileConfigPath, "planned", "DropCCEnable", "0") = "1")
$g_abPlannedDropCCHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "DropCCHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abPlannedDropCCHours[$i] =($g_abPlannedDropCCHours[$i] = "1")
Next
IniReadS($g_bUseCCBalanced, $g_sProfileConfigPath, "ClanClastle", "BalanceCC", False, "Bool")
IniReadS($g_iCCDonated, $g_sProfileConfigPath, "ClanClastle", "BalanceCCDonated", 1, "int")
IniReadS($g_iCCReceived, $g_sProfileConfigPath, "ClanClastle", "BalanceCCReceived", 1, "int")
EndFunc
Func ReadConfig_600_29_DB()
IniReadS($g_aiAttackAlgorithm[$DB], $g_sProfileConfigPath, "attack", "DBAtkAlgorithm", 0, "int")
IniReadS($g_aiAttackTroopSelection[$DB], $g_sProfileConfigPath, "attack", "DBSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "DBKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "DBQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "DBWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$DB], $g_sProfileConfigPath, "attack", "DBDropCC", False, "Bool")
IniReadS($g_abAttackUseLightSpell[$DB], $g_sProfileConfigPath, "attack", "DBLightSpell", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$DB], $g_sProfileConfigPath, "attack", "DBHealSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$DB], $g_sProfileConfigPath, "attack", "DBRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$DB], $g_sProfileConfigPath, "attack", "DBJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$DB], $g_sProfileConfigPath, "attack", "DBFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$DB], $g_sProfileConfigPath, "attack", "DBPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$DB], $g_sProfileConfigPath, "attack", "DBEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$DB], $g_sProfileConfigPath, "attack", "DBHasteSpell", False, "Bool")
IniReadS($g_abAttackUseCloneSpell[$DB], $g_sProfileConfigPath, "attack", "DBCloneSpell", False, "Bool")
IniReadS($g_abAttackUseSkeletonSpell[$DB], $g_sProfileConfigPath, "attack", "DBSkeletonSpell", False, "Bool")
IniReadS($g_abAttackUseBatSpell[$DB], $g_sProfileConfigPath, "attack", "DBBatSpell", False, "Bool")
IniReadS($g_bTHSnipeBeforeEnable[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBEnable", False, "Bool")
IniReadS($g_iTHSnipeBeforeTiles[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBTiles", 0, "int")
IniReadS($g_iTHSnipeBeforeScript[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBScript", "bam")
IniReadS($g_aiAttackStdDropOrder[$DB], $g_sProfileConfigPath, "attack", "DBStandardAlgorithm", 0, "int")
IniReadS($g_aiAttackStdDropSides[$DB], $g_sProfileConfigPath, "attack", "DBDeploy", 3, "int")
IniReadS($g_aiAttackStdUnitDelay[$DB], $g_sProfileConfigPath, "attack", "DBUnitD", 4, "int")
IniReadS($g_aiAttackStdWaveDelay[$DB], $g_sProfileConfigPath, "attack", "DBWaveD", 4, "int")
IniReadS($g_abAttackStdRandomizeDelay[$DB], $g_sProfileConfigPath, "attack", "DBRandomSpeedAtk", True, "Bool")
IniReadS($g_abAttackStdSmartAttack[$DB], $g_sProfileConfigPath, "attack", "DBSmartAttackRedArea", True, "Bool")
IniReadS($g_aiAttackStdSmartDeploy[$DB], $g_sProfileConfigPath, "attack", "DBSmartAttackDeploy", 0, "int")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][0], $g_sProfileConfigPath, "attack", "DBSmartAttackGoldMine", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][1], $g_sProfileConfigPath, "attack", "DBSmartAttackElixirCollector", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][2], $g_sProfileConfigPath, "attack", "DBSmartAttackDarkElixirDrill", False, "Bool")
IniReadS($g_aiAttackScrRedlineRoutine[$DB], $g_sProfileConfigPath, "attack", "RedlineRoutineDB", $g_aiAttackScrRedlineRoutine[$DB], "Int")
IniReadS($g_aiAttackScrDroplineEdge[$DB], $g_sProfileConfigPath, "attack", "DroplineEdgeDB", $g_aiAttackScrDroplineEdge[$DB], "Int")
IniReadS($g_sAttackScrScriptName[$DB], $g_sProfileConfigPath, "attack", "ScriptDB", "Barch four fingers")
IniReadS($g_aiAttackUseWardenMode[$DB], $g_sProfileConfigPath, "attack", "DBAtkUseWardenMode", 2, "int")
IniReadS($g_aiAttackUseSiege[$DB], $g_sProfileConfigPath, "attack", "DBAtkUseSiege", 5, "int")
IniReadS($g_iTxtInsidePercentage, $g_sProfileConfigPath, "SmartFarm", "InsidePercentage", 65, "int")
IniReadS($g_iTxtOutsidePercentage, $g_sProfileConfigPath, "SmartFarm", "OutsidePercentage", 80, "int")
IniReadS($g_bDebugSmartFarm, $g_sProfileConfigPath, "SmartFarm", "DebugSmartFarm", False, "Bool")
EndFunc
Func ReadConfig_600_29_LB()
IniReadS($g_aiAttackAlgorithm[$LB], $g_sProfileConfigPath, "attack", "ABAtkAlgorithm", 0, "int")
IniReadS($g_aiAttackTroopSelection[$LB], $g_sProfileConfigPath, "attack", "ABSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "ABKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "ABQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "ABWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$LB], $g_sProfileConfigPath, "attack", "ABDropCC", False, "Bool")
IniReadS($g_abAttackUseLightSpell[$LB], $g_sProfileConfigPath, "attack", "ABLightSpell", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$LB], $g_sProfileConfigPath, "attack", "ABHealSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$LB], $g_sProfileConfigPath, "attack", "ABRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$LB], $g_sProfileConfigPath, "attack", "ABJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$LB], $g_sProfileConfigPath, "attack", "ABFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$LB], $g_sProfileConfigPath, "attack", "ABPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$LB], $g_sProfileConfigPath, "attack", "ABEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$LB], $g_sProfileConfigPath, "attack", "ABHasteSpell", False, "Bool")
IniReadS($g_abAttackUseCloneSpell[$LB], $g_sProfileConfigPath, "attack", "ABCloneSpell", False, "Bool")
IniReadS($g_abAttackUseSkeletonSpell[$LB], $g_sProfileConfigPath, "attack", "ABSkeletonSpell", False, "Bool")
IniReadS($g_abAttackUseBatSpell[$LB], $g_sProfileConfigPath, "attack", "ABBatSpell", False, "Bool")
IniReadS($g_bTHSnipeBeforeEnable[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBEnable", False, "Bool")
IniReadS($g_iTHSnipeBeforeTiles[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBTiles", 0, "int")
IniReadS($g_iTHSnipeBeforeScript[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBScript", "bam")
IniReadS($g_aiAttackStdDropOrder[$LB], $g_sProfileConfigPath, "attack", "LBStandardAlgorithm", 0, "int")
IniReadS($g_aiAttackStdDropSides[$LB], $g_sProfileConfigPath, "attack", "ABDeploy", 0, "int")
IniReadS($g_aiAttackStdUnitDelay[$LB], $g_sProfileConfigPath, "attack", "ABUnitD", 4, "int")
IniReadS($g_aiAttackStdWaveDelay[$LB], $g_sProfileConfigPath, "attack", "ABWaveD", 4, "int")
IniReadS($g_abAttackStdRandomizeDelay[$LB], $g_sProfileConfigPath, "attack", "ABRandomSpeedAtk", True, "Bool")
IniReadS($g_abAttackStdSmartAttack[$LB], $g_sProfileConfigPath, "attack", "ABSmartAttackRedArea", True, "Bool")
IniReadS($g_aiAttackStdSmartDeploy[$LB], $g_sProfileConfigPath, "attack", "ABSmartAttackDeploy", 1, "int")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][0], $g_sProfileConfigPath, "attack", "ABSmartAttackGoldMine", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][1], $g_sProfileConfigPath, "attack", "ABSmartAttackElixirCollector", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][2], $g_sProfileConfigPath, "attack", "ABSmartAttackDarkElixirDrill", False, "Bool")
IniReadS($g_aiAttackScrRedlineRoutine[$LB], $g_sProfileConfigPath, "attack", "RedlineRoutineAB", $g_aiAttackScrRedlineRoutine[$LB], "Int")
IniReadS($g_aiAttackScrDroplineEdge[$LB], $g_sProfileConfigPath, "attack", "DroplineEdgeAB", $g_aiAttackScrDroplineEdge[$LB], "Int")
IniReadS($g_sAttackScrScriptName[$LB], $g_sProfileConfigPath, "attack", "ScriptAB", "Barch four fingers")
IniReadS($g_aiAttackUseWardenMode[$LB], $g_sProfileConfigPath, "attack", "ABAtkUseWardenMode", 2, "int")
IniReadS($g_aiAttackUseSiege[$LB], $g_sProfileConfigPath, "attack", "ABAtkUseSiege", 5, "int")
EndFunc
Func ReadConfig_600_29_TS()
IniReadS($g_aiAttackTroopSelection[$TS], $g_sProfileConfigPath, "attack", "TSSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "TSKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "TSQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "TSWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$TS], $g_sProfileConfigPath, "attack", "TSDropCC", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$TS], $g_sProfileConfigPath, "attack", "TSHealSpell", False, "Bool")
IniReadS($g_abAttackUseLightSpell[$TS], $g_sProfileConfigPath, "attack", "TSLightSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$TS], $g_sProfileConfigPath, "attack", "TSRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$TS], $g_sProfileConfigPath, "attack", "TSJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$TS], $g_sProfileConfigPath, "attack", "TSFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$TS], $g_sProfileConfigPath, "attack", "TSPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$TS], $g_sProfileConfigPath, "attack", "TSEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$TS], $g_sProfileConfigPath, "attack", "TSHasteSpell", False, "Bool")
IniReadS($g_sAtkTSType, $g_sProfileConfigPath, "attack", "AttackTHType", "bam")
EndFunc
Func ReadConfig_600_30()
$g_bShareAttackEnable =(IniRead($g_sProfileConfigPath, "shareattack", "ShareAttack", "0") = "1")
$g_iShareMinGold = Int(IniRead($g_sProfileConfigPath, "shareattack", "minGold", 200000))
$g_iShareMinElixir = Int(IniRead($g_sProfileConfigPath, "shareattack", "minElixir", 200000))
$g_iShareMinDark = Int(IniRead($g_sProfileConfigPath, "shareattack", "minDark", 100))
$g_sShareMessage = IniRead($g_sProfileConfigPath, "shareattack", "Message", "Nice|Good|Thanks|Wowwww")
IniReadS($g_bTakeLootSnapShot, $g_sProfileConfigPath, "attack", "TakeLootSnapShot", False, "Bool")
IniReadS($g_bScreenshotLootInfo, $g_sProfileConfigPath, "attack", "ScreenshotLootInfo", False, "Bool")
EndFunc
Func ReadConfig_600_30_DB()
IniReadS($g_abStopAtkNoLoot1Enable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBTimeStopAtk", True, "Bool")
IniReadS($g_aiStopAtkNoLoot1Time[$DB], $g_sProfileConfigPath, "endbattle", "txtDBTimeStopAtk", 15, "int")
IniReadS($g_abStopAtkNoLoot2Enable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBTimeStopAtk2", False, "Bool")
IniReadS($g_aiStopAtkNoLoot2Time[$DB], $g_sProfileConfigPath, "endbattle", "txtDBTimeStopAtk2", 7, "int")
IniReadS($g_aiStopAtkNoLoot2MinGold[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinGoldStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinElixir[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinElixirStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinDark[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinDarkElixirStopAtk2", 50, "int")
IniReadS($g_abStopAtkNoResources[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndNoResources", False, "Bool")
IniReadS($g_abStopAtkOneStar[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndOneStar", False, "Bool")
IniReadS($g_abStopAtkTwoStars[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndTwoStars", False, "Bool")
IniReadS($g_abStopAtkPctHigherEnable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBPercentageHigher", False, "Bool")
IniReadS($g_aiStopAtkPctHigherAmt[$DB], $g_sProfileConfigPath, "endbattle", "txtDBPercentageHigher", 50, "int")
IniReadS($g_abStopAtkPctNoChangeEnable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBPercentageChange", False, "Bool")
IniReadS($g_aiStopAtkPctNoChangeTime[$DB], $g_sProfileConfigPath, "endbattle", "txtDBPercentageChange", 15, "int")
EndFunc
Func ReadConfig_600_30_LB()
IniReadS($g_abStopAtkNoLoot1Enable[$LB], $g_sProfileConfigPath, "endbattle", "chkABTimeStopAtk", True, "Bool")
IniReadS($g_aiStopAtkNoLoot1Time[$LB], $g_sProfileConfigPath, "endbattle", "txtABTimeStopAtk", 20, "int")
IniReadS($g_abStopAtkNoLoot2Enable[$LB], $g_sProfileConfigPath, "endbattle", "chkABTimeStopAtk2", False, "Bool")
IniReadS($g_aiStopAtkNoLoot2Time[$LB], $g_sProfileConfigPath, "endbattle", "txtABTimeStopAtk2", 7, "int")
IniReadS($g_aiStopAtkNoLoot2MinGold[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinGoldStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinElixir[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinElixirStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinDark[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinDarkElixirStopAtk2", 50, "int")
IniReadS($g_abStopAtkNoResources[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndNoResources", False, "Bool")
IniReadS($g_abStopAtkOneStar[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndOneStar", False, "Bool")
IniReadS($g_abStopAtkTwoStars[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndTwoStars", False, "Bool")
IniReadS($g_bDESideEndEnable, $g_sProfileConfigPath, "endbattle", "chkDESideEB", False, "Bool")
IniReadS($g_iDESideEndMin, $g_sProfileConfigPath, "endbattle", "txtDELowEndMin", 25, "int")
IniReadS($g_bDESideDisableOther, $g_sProfileConfigPath, "endbattle", "chkDisableOtherEBO", False, "Bool")
IniReadS($g_bDESideEndBKWeak, $g_sProfileConfigPath, "endbattle", "chkDEEndBk", False, "Bool")
IniReadS($g_bDESideEndAQWeak, $g_sProfileConfigPath, "endbattle", "chkDEEndAq", False, "Bool")
IniReadS($g_bDESideEndOneStar, $g_sProfileConfigPath, "endbattle", "chkDEEndOneStar", False, "Bool")
IniReadS($g_abStopAtkPctHigherEnable[$LB], $g_sProfileConfigPath, "endbattle", "chkABPercentageHigher", False, "Bool")
IniReadS($g_aiStopAtkPctHigherAmt[$LB], $g_sProfileConfigPath, "endbattle", "txtABPercentageHigher", 50, "int")
IniReadS($g_abStopAtkPctNoChangeEnable[$LB], $g_sProfileConfigPath, "endbattle", "chkABPercentageChange", False, "Bool")
IniReadS($g_aiStopAtkPctNoChangeTime[$LB], $g_sProfileConfigPath, "endbattle", "txtABPercentageChange", 15, "int")
EndFunc
Func ReadConfig_600_30_TS()
IniReadS($g_bEndTSCampsEnable, $g_sProfileConfigPath, "search", "ChkTSSearchCamps2", False, "Bool")
IniReadS($g_iEndTSCampsPct, $g_sProfileConfigPath, "search", "TSEnableAfterArmyCamps2", 100, "int")
EndFunc
Func ReadConfig_600_31()
$g_abCollectorLevelEnabled[6] = 0
For $i = 7 To 13
IniReadS($g_abCollectorLevelEnabled[$i], $g_sProfileConfigPath, "collectors", "lvl" & $i & "Enabled", True, "Bool")
Next
For $i = 6 To 13
IniReadS($g_aiCollectorLevelFill[$i], $g_sProfileConfigPath, "collectors", "lvl" & $i & "fill", 0, "int")
If $g_aiCollectorLevelFill[$i] > 1 Then $g_aiCollectorLevelFill[$i] = 1
Next
IniReadS($g_bCollectorFilterDisable, $g_sProfileConfigPath, "search", "chkDisableCollectorsFilter", False, "Bool")
IniReadS($g_iCollectorMatchesMin, $g_sProfileConfigPath, "collectors", "minmatches", $g_iCollectorMatchesMin)
If $g_iCollectorMatchesMin < 1 Or $g_iCollectorMatchesMin > 6 Then $g_iCollectorMatchesMin = 3
IniReadS($g_iCollectorToleranceOffset, $g_sProfileConfigPath, "collectors", "tolerance", 0, "int")
EndFunc
Func ReadConfig_600_32()
IniReadS($g_bDropTrophyEnable, $g_sProfileConfigPath, "search", "TrophyRange", False, "Bool")
IniReadS($g_iDropTrophyMin, $g_sProfileConfigPath, "search", "MinTrophy", 5000, "int")
IniReadS($g_iDropTrophyMax, $g_sProfileConfigPath, "search", "MaxTrophy", 5000, "int")
IniReadS($g_bDropTrophyUseHeroes, $g_sProfileConfigPath, "search", "chkTrophyHeroes", False, "Bool")
IniReadS($g_iDropTrophyHeroesPriority, $g_sProfileConfigPath, "search", "cmbTrophyHeroesPriority", 0, "int")
IniReadS($g_bDropTrophyAtkDead, $g_sProfileConfigPath, "search", "chkTrophyAtkDead", False, "Bool")
IniReadS($g_iDropTrophyArmyMinPct, $g_sProfileConfigPath, "search", "DTArmyMin", 70, "int")
EndFunc
Func ReadConfig_600_33()
IniReadS($g_bCustomDropOrderEnable, $g_sProfileConfigPath, "DropOrder", "chkDropOrder", False, "Bool")
For $p = 0 To UBound($g_aiCmbCustomDropOrder) - 1
IniReadS($g_aiCmbCustomDropOrder[$p], $g_sProfileConfigPath, "DropOrder", "cmbDropOrder" & $p, -1)
Next
EndFunc
Func ReadConfig_600_35_1()
$g_bDisableSplash =(IniRead($g_sProfileConfigPath, "General", "ChkDisableSplash", "0") = "1")
$g_bCheckVersion =(IniRead($g_sProfileConfigPath, "General", "ChkVersion", "1") = "1")
IniReadS($g_bDeleteLogs, $g_sProfileConfigPath, "deletefiles", "DeleteLogs", True, "Bool")
IniReadS($g_iDeleteLogsDays, $g_sProfileConfigPath, "deletefiles", "DeleteLogsDays", 2, "int")
IniReadS($g_bDeleteTemp, $g_sProfileConfigPath, "deletefiles", "DeleteTemp", True, "Bool")
IniReadS($g_iDeleteTempDays, $g_sProfileConfigPath, "deletefiles", "DeleteTempDays", 5, "int")
IniReadS($g_bDeleteLoots, $g_sProfileConfigPath, "deletefiles", "DeleteLoots", True, "Bool")
IniReadS($g_iDeleteLootsDays, $g_sProfileConfigPath, "deletefiles", "DeleteLootsDays", 2, "int")
IniReadS($g_bAutoStart, $g_sProfileConfigPath, "general", "AutoStart", False, "Bool")
IniReadS($g_iAutoStartDelay, $g_sProfileConfigPath, "general", "AutoStartDelay", 10, "int")
IniReadS($g_bRestarted, $g_sProfileConfigPath, "general", "Restarted", $g_bRestarted, "int")
If $g_bBotLaunchOption_Autostart = True Then $g_bRestarted = True
$g_bCheckGameLanguage =(IniRead($g_sProfileConfigPath, "General", "ChkLanguage", "1") = "1")
IniReadS($g_bAutoAlignEnable, $g_sProfileConfigPath, "general", "DisposeWindows", False, "Bool")
IniReadS($g_iAutoAlignPosition, $g_sProfileConfigPath, "general", "DisposeWindowsPos", "EMBED")
IniReadS($g_iAutoAlignOffsetX, $g_sProfileConfigPath, "other", "WAOffsetX", "")
IniReadS($g_iAutoAlignOffsetY, $g_sProfileConfigPath, "other", "WAOffsetY", "")
IniReadS($g_bHideWhenMinimized, $g_sProfileConfigPath, "general", "HideWhenMinimized", False, "Bool")
$g_bUseRandomClick =(IniRead($g_sProfileConfigPath, "other", "UseRandomClick", "0") = "1")
$g_bScreenshotPNGFormat =(IniRead($g_sProfileConfigPath, "other", "ScreenshotType", "0") = "1")
$g_bScreenshotHideName =(IniRead($g_sProfileConfigPath, "other", "ScreenshotHideName", "1") = "1")
IniReadS($g_iAnotherDeviceWaitTime, $g_sProfileConfigPath, "other", "txtTimeWakeUp", 0, "int")
$g_bForceSinglePBLogoff =(IniRead($g_sProfileConfigPath, "other", "chkSinglePBTForced", "0") = "1")
$g_iSinglePBForcedLogoffTime = Int(IniRead($g_sProfileConfigPath, "other", "ValueSinglePBTimeForced", 18))
$g_iSinglePBForcedEarlyExitTime = Int(IniRead($g_sProfileConfigPath, "other", "ValuePBTimeForcedExit", 15))
$g_bAutoResumeEnable =(IniRead($g_sProfileConfigPath, "other", "ChkAutoResume", "0") = "1")
$g_iAutoResumeTime = Int(IniRead($g_sProfileConfigPath, "other", "AutoResumeTime", 5))
IniReadS($g_bDisableNotifications, $g_sProfileConfigPath, "other", "ChkDisableNotifications", False, "Bool")
$g_bForceClanCastleDetection =(IniRead($g_sProfileConfigPath, "other", "ChkFixClanCastle", "0") = "1")
IniReadS($g_bUseStatistics, $g_sProfileConfigPath, "other", "ChkSqlite", False, "Bool")
IniReadS($g_bOnlySCIDAccounts, $g_sProfileConfigPath, "ProfileSCID", "OnlySCIDAccounts", True, "Bool")
$g_iWhatSCIDAccount2Use = Int(IniRead($g_sProfileConfigPath, "ProfileSCID", "WhatSCIDAccount2Use", 0))
EndFunc
Func ReadConfig_600_35_2()
Local $sSwitchAccFile
$g_iCmbSwitchAcc = 0
$g_bChkSwitchAcc = False
For $g = 1 To 8
$sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $g & ".ini"
If FileExists($sSwitchAccFile) = 0 Then ContinueLoop
Local $sProfile
Local $bEnabled
For $i = 1 To Int(IniRead($sSwitchAccFile, "SwitchAccount", "TotalCocAccount", 0)) + 1
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "Enable", "") = "1"
If $bEnabled Then
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, "") = "1"
If $bEnabled Then
$sProfile = IniRead($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, "")
If $sProfile = $g_sProfileCurrentName Then
$g_iCmbSwitchAcc = $g
ExitLoop
EndIf
EndIf
EndIf
Next
If $g_iCmbSwitchAcc Then
ReadConfig_SwitchAccounts()
ExitLoop
EndIf
Next
EndFunc
Func ReadConfig_SwitchAccounts()
If $g_iCmbSwitchAcc Then
Local $sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $g_iCmbSwitchAcc & ".ini"
$g_bChkSwitchAcc = IniRead($sSwitchAccFile, "SwitchAccount", "Enable", "0") = "1"
$g_bChkGooglePlay = IniRead($sSwitchAccFile, "SwitchAccount", "GooglePlay", "0") = "1"
$g_bChkSuperCellID = IniRead($sSwitchAccFile, "SwitchAccount", "SuperCellID", "0") = "1"
$g_bChkSharedPrefs = IniRead($sSwitchAccFile, "SwitchAccount", "SharedPrefs", "0") = "1"
$g_bChkSmartSwitch = IniRead($sSwitchAccFile, "SwitchAccount", "SmartSwitch", "0") = "1"
$g_bDonateLikeCrazy = IniRead($sSwitchAccFile, "SwitchAccount", "DonateLikeCrazy", "0") = "1"
$g_iTotalAcc = Int(IniRead($sSwitchAccFile, "SwitchAccount", "TotalCocAccount", "-1"))
$g_iTrainTimeToSkip = Int(IniRead($sSwitchAccFile, "SwitchAccount", "TrainTimeToSkip", "1"))
For $i = 1 To 8
$g_abAccountNo[$i - 1] = IniRead($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, "") = "1"
$g_asProfileName[$i - 1] = IniRead($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, "")
$g_abDonateOnly[$i - 1] = $g_abAccountNo[$i - 1] And IniRead($sSwitchAccFile, "SwitchAccount", "DonateOnly." & $i, "0") = "1"
$g_abChkSetFarm[$i - 1] = IniRead($sSwitchAccFile, "FarmStrategy", "ChkSetFarm" & $i, "0") = "1"
$g_aiCmbAction1[$i - 1] = Int(IniRead($sSwitchAccFile, "FarmStrategy", "CmbAction1" & $i, 0))
$g_aiCmbCriteria1[$i - 1] = Int(IniRead($sSwitchAccFile, "FarmStrategy", "CmbCriteria1" & $i, 0))
$g_aiTxtResource1[$i - 1] = Int(IniRead($sSwitchAccFile, "FarmStrategy", "TxtResource1" & $i, 0))
$g_aiCmbTime1[$i - 1] = Int(IniRead($sSwitchAccFile, "FarmStrategy", "CmbTime1" & $i, -1))
$g_aiCmbAction2[$i - 1] = Int(IniRead($sSwitchAccFile, "FarmStrategy", "CmbAction2" & $i, 0))
$g_aiCmbCriteria2[$i - 1] = Int(IniRead($sSwitchAccFile, "FarmStrategy", "CmbCriteria2" & $i, 0))
$g_aiTxtResource2[$i - 1] = Int(IniRead($sSwitchAccFile, "FarmStrategy", "TxtResource2" & $i, 0))
$g_aiCmbTime2[$i - 1] = Int(IniRead($sSwitchAccFile, "FarmStrategy", "CmbTime2" & $i, -1))
Next
EndIf
EndFunc
Func ReadConfig_600_35_3()
For $i = 0 To 3
IniReadS($g_abChkSwitchMax[$i], $g_sProfileConfigPath, "SwitchProfile", "SwitchProfileMax" & $i, $g_abChkSwitchMax[$i], "Bool")
IniReadS($g_abChkSwitchMin[$i], $g_sProfileConfigPath, "SwitchProfile", "SwitchProfileMin" & $i, $g_abChkSwitchMin[$i], "Bool")
IniReadS($g_aiCmbSwitchMax[$i], $g_sProfileConfigPath, "SwitchProfile", "TargetProfileMax" & $i, $g_aiCmbSwitchMax[$i], "Int")
IniReadS($g_aiCmbSwitchMin[$i], $g_sProfileConfigPath, "SwitchProfile", "TargetProfileMin" & $i, $g_aiCmbSwitchMin[$i], "Int")
IniReadS($g_abChkBotTypeMax[$i], $g_sProfileConfigPath, "SwitchProfile", "ChangeBotTypeMax" & $i, $g_abChkBotTypeMax[$i], "Bool")
IniReadS($g_abChkBotTypeMin[$i], $g_sProfileConfigPath, "SwitchProfile", "ChangeBotTypeMin" & $i, $g_abChkBotTypeMin[$i], "Bool")
IniReadS($g_aiCmbBotTypeMax[$i], $g_sProfileConfigPath, "SwitchProfile", "TargetBotTypeMax" & $i, $g_aiCmbBotTypeMax[$i], "Int")
IniReadS($g_aiCmbBotTypeMin[$i], $g_sProfileConfigPath, "SwitchProfile", "TargetBotTypeMin" & $i, $g_aiCmbBotTypeMin[$i], "Int")
IniReadS($g_aiConditionMax[$i], $g_sProfileConfigPath, "SwitchProfile", "ConditionMax" & $i, $g_aiConditionMax[$i], "Int")
IniReadS($g_aiConditionMin[$i], $g_sProfileConfigPath, "SwitchProfile", "ConditionMin" & $i, $g_aiConditionMin[$i], "Int")
Next
EndFunc
Func ReadConfig_600_52_1()
$g_bQuickTrainEnable =(IniRead($g_sProfileConfigPath, "other", "ChkUseQTrain", "0") = "1")
$g_bQuickTrainArmy[0] =(IniRead($g_sProfileConfigPath, "troop", "QuickTrainArmy1", "0") = "1")
$g_bQuickTrainArmy[1] =(IniRead($g_sProfileConfigPath, "troop", "QuickTrainArmy2", "0") = "1")
$g_bQuickTrainArmy[2] =(IniRead($g_sProfileConfigPath, "troop", "QuickTrainArmy3", "0") = "1")
$g_bChkMultiClick =(IniRead($g_sProfileConfigPath, "troop", "ChkMultiClick", "0") = "1")
EndFunc
Func ReadConfig_600_52_2()
For $T = 0 To $eTroopCount - 1
Local $tempTroopCount, $tempTroopLevel
Switch $T
Case $eTroopBarbarian
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 58, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopArcher
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 115, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopGoblin
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 19, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopGiant
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 4, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopWallBreaker
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 4, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case Else
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 0, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 0, "int")
EndSwitch
$g_aiArmyCompTroops[$T] = $tempTroopCount
$g_aiTrainArmyTroopLevel[$T] = $tempTroopLevel
Next
For $S = 0 To $eSpellCount - 1
IniReadS($g_aiArmyCompSpells[$S], $g_sProfileConfigPath, "Spells", $g_asSpellShortNames[$S], 0, "int")
IniReadS($g_aiTrainArmySpellLevel[$S], $g_sProfileConfigPath, "LevelSpell", $g_asSpellShortNames[$S], 0, "int")
Next
For $S = 0 To $eSiegeMachineCount - 1
IniReadS($g_aiArmyCompSiegeMachine[$S], $g_sProfileConfigPath, "Siege", $g_asSiegeMachineShortNames[$S], 0, "int")
IniReadS($g_aiTrainArmySiegeMachineLevel[$S], $g_sProfileConfigPath, "LevelSiege", $g_asSiegeMachineShortNames[$S], 0, "int")
Next
IniReadS($g_iTrainArmyFullTroopPct, $g_sProfileConfigPath, "troop", "fullTroop", 100, "int")
$g_bTotalCampForced =(IniRead($g_sProfileConfigPath, "other", "ChkTotalCampForced", "1") = "1")
$g_iTotalCampForcedValue = Int(IniRead($g_sProfileConfigPath, "other", "ValueTotalCampForced", 220))
$g_bForceBrewSpells =(IniRead($g_sProfileConfigPath, "other", "ChkForceBrewBeforeAttack", "0") = "1")
IniReadS($g_iTotalSpellValue, $g_sProfileConfigPath, "Spells", "SpellFactory", 0, "int")
$g_iTotalSpellValue = Int($g_iTotalSpellValue)
$g_bDoubleTrain =(IniRead($g_sProfileConfigPath, "troop", "DoubleTrain", "0") = "1")
$g_bChkPreciseArmy =(IniRead($g_sProfileConfigPath, "troop", "PreciseArmy", "0") = "1")
EndFunc
Func ReadConfig_600_54()
IniReadS($g_bCustomTrainOrderEnable, $g_sProfileConfigPath, "troop", "chkTroopOrder", False, "Bool")
For $z = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
IniReadS($g_aiCmbCustomTrainOrder[$z], $g_sProfileConfigPath, "troop", "cmbTroopOrder" & $z, -1)
Next
IniReadS($g_bCustomBrewOrderEnable, $g_sProfileConfigPath, "Spells", "chkSpellOrder", False, "Bool")
For $z = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
IniReadS($g_aiCmbCustomBrewOrder[$z], $g_sProfileConfigPath, "Spells", "cmbSpellOrder" & $z, -1)
Next
EndFunc
Func ReadConfig_600_56()
$g_bSmartZapEnable =(IniRead($g_sProfileConfigPath, "SmartZap", "UseSmartZap", "0") = "1")
$g_bEarthQuakeZap =(IniRead($g_sProfileConfigPath, "SmartZap", "UseEarthQuakeZap", "0") = "1")
$g_bNoobZap =(IniRead($g_sProfileConfigPath, "SmartZap", "UseNoobZap", "0") = "1")
$g_bSmartZapDB =(IniRead($g_sProfileConfigPath, "SmartZap", "ZapDBOnly", "1") = "1")
$g_bSmartZapSaveHeroes =(IniRead($g_sProfileConfigPath, "SmartZap", "THSnipeSaveHeroes", "1") = "1")
$g_bSmartZapFTW =(IniRead($g_sProfileConfigPath, "SmartZap", "FTW", "0") = "1")
$g_iSmartZapMinDE = Int(IniRead($g_sProfileConfigPath, "SmartZap", "MinDE", 350))
$g_iSmartZapExpectedDE = Int(IniRead($g_sProfileConfigPath, "SmartZap", "ExpectedDE", 320))
EndFunc
Func ReadConfig_641_1()
IniReadS($g_bCloseWhileTrainingEnable, $g_sProfileConfigPath, "other", "chkCloseWaitEnable", False, "Bool")
IniReadS($g_bCloseWithoutShield, $g_sProfileConfigPath, "other", "chkCloseWaitTrain", True, "Bool")
IniReadS($g_bCloseEmulator, $g_sProfileConfigPath, "other", "btnCloseWaitStop", False, "Bool")
IniReadS($g_bSuspendComputer, $g_sProfileConfigPath, "other", "btnCloseWaitSuspendComputer", False, "Bool")
IniReadS($g_bCloseRandom, $g_sProfileConfigPath, "other", "btnCloseWaitStopRandom", False, "Bool")
IniReadS($g_bCloseExactTime, $g_sProfileConfigPath, "other", "btnCloseWaitExact", True, "Bool")
IniReadS($g_bCloseRandomTime, $g_sProfileConfigPath, "other", "btnCloseWaitRandom", False, "Bool")
IniReadS($g_iCloseRandomTimePercent, $g_sProfileConfigPath, "other", "CloseWaitRdmPercent", 10, "int")
IniReadS($g_iCloseMinimumTime, $g_sProfileConfigPath, "other", "MinimumTimeToClose", 2, "int")
IniReadS($g_iTrainClickDelay, $g_sProfileConfigPath, "other", "TrainITDelay", 40, "int")
IniReadS($g_bTrainAddRandomDelayEnable, $g_sProfileConfigPath, "other", "chkAddIdleTime", $g_bTrainAddRandomDelayEnable, "Bool")
IniReadS($g_iTrainAddRandomDelayMin, $g_sProfileConfigPath, "other", "txtAddDelayIdlePhaseTimeMin", $g_iTrainAddRandomDelayMin, "Int")
IniReadS($g_iTrainAddRandomDelayMax, $g_sProfileConfigPath, "other", "txtAddDelayIdlePhaseTimeMax", $g_iTrainAddRandomDelayMax, "Int")
EndFunc
Func IniReadS(ByRef $variable, $PrimaryInputFile, $section, $key, $defaultvalue, $valueType = Default)
Local $defaultvalueTest = "?"
Local $readValue = IniRead($g_sProfileSecondaryInputFileName, $section, $key, $defaultvalueTest)
If $readValue = $defaultvalueTest Then
$readValue = IniRead($PrimaryInputFile, $section, $key, $defaultvalue)
EndIf
Switch $valueType
Case Default
$variable = $readValue
Case "Int"
$variable = Int($readValue)
Case "Bool"
If $readValue = "True" Or $readValue = "1" Then
$variable = True
Else
$variable = False
EndIf
Case Else
$variable = $readValue
EndSwitch
EndFunc
Func saveConfig()
If $g_iGuiMode = 0 Then Return
If $g_bSaveConfigIsActive Then
SetDebugLog("saveConfig(), already running, exit")
Return
EndIf
$g_bSaveConfigIsActive = True
Local $t = __TimerInit()
Static $iSaveConfigCount = 0
$iSaveConfigCount += 1
SetDebugLog("saveConfig(), call number " & $iSaveConfigCount)
SaveProfileConfig()
SaveWeakBaseStats()
SaveBuildingConfig()
SaveRegularConfig()
SetDebugLog("SaveConfig(), time = " & Round(__TimerDiff($t) / 1000, 2) & " sec")
$g_bSaveConfigIsActive = False
EndFunc
Func SaveProfileConfig($sIniFile = Default, $bForceWrite = False)
If $sIniFile = Default Then $sIniFile = $g_sProfilePath & "\profile.ini"
IniWrite($sIniFile, "general", "defaultprofile", $g_sProfileCurrentName)
If $bForceWrite Or Int(IniRead($sIniFile, "general", "globalactivebotsallowed", 0)) = 0 Then
IniWrite($sIniFile, "general", "globalactivebotsallowed", $g_iGlobalActiveBotsAllowed)
EndIf
If $bForceWrite Or IniRead($sIniFile, "general", "globalthreads", "-") = "-" Then
IniWrite($sIniFile, "general", "globalthreads", $g_iGlobalThreads)
EndIf
EndFunc
Func SaveWeakBaseStats()
_Ini_Clear()
For $j = 0 To UBound($g_aiWeakBaseStats) - 1
_Ini_Add("WeakBase", $g_aiWeakBaseStats[$j][0], $g_aiWeakBaseStats[$j][1])
Next
_Ini_Save($g_sProfileBuildingStatsPath)
EndFunc
Func SaveBuildingConfig()
SetDebugLog("Save Building Config " & $g_sProfileBuildingPath)
_Ini_Clear()
_Ini_Add("general", "version", GetVersionNormalized($g_sBotVersion))
_Ini_Add("upgrade", "LabPosX", $g_aiLaboratoryPos[0])
_Ini_Add("upgrade", "LabPosY", $g_aiLaboratoryPos[1])
_Ini_Add("upgrade", "StarLabPosX", $g_aiStarLaboratoryPos[0])
_Ini_Add("upgrade", "StarLabPosY", $g_aiStarLaboratoryPos[1])
_Ini_Add("other", "xTownHall", $g_aiTownHallPos[0])
_Ini_Add("other", "yTownHall", $g_aiTownHallPos[1])
_Ini_Add("other", "LevelTownHall", $g_iTownHallLevel)
_Ini_Add("other", "xCCPos", $g_aiClanCastlePos[0])
_Ini_Add("other", "yCCPos", $g_aiClanCastlePos[1])
_Ini_Add("other", "totalcamp", $g_iTotalCampSpace)
_Ini_Add("other", "xKingAltarPos", $g_aiKingAltarPos[0])
_Ini_Add("other", "yKingAltarPos", $g_aiKingAltarPos[1])
_Ini_Add("other", "xQueenAltarPos", $g_aiQueenAltarPos[0])
_Ini_Add("other", "yQueenAltarPos", $g_aiQueenAltarPos[1])
_Ini_Add("other", "xWardenAltarPos", $g_aiWardenAltarPos[0])
_Ini_Add("other", "yWardenAltarPos", $g_aiWardenAltarPos[1])
_Ini_Add("upgrade", "xLastGoodWallPos", $g_aiLastGoodWallPos[0])
_Ini_Add("upgrade", "yLastGoodWallPos", $g_aiLastGoodWallPos[1])
_Ini_Add("other", "ResourcesPosX", $g_aiResourcesPos[0])
_Ini_Add("other", "ResourcesPosY", $g_aiResourcesPos[1])
ApplyConfig_600_14(GetApplyConfigSaveAction())
_Ini_Add("upgrade", "upgradetroops", $g_bAutoLabUpgradeEnable ? 1 : 0)
_Ini_Add("upgrade", "upgradetroopname", $g_iCmbLaboratory)
_Ini_Add("upgrade", "upgradelabelexircost", $g_iLaboratoryElixirCost)
_Ini_Add("upgrade", "upgradelabdelexircost", $g_iLaboratoryDElixirCost)
_Ini_Add("upgrade", "upgradestartroops", $g_bAutoStarLabUpgradeEnable ? 1 : 0)
_Ini_Add("upgrade", "upgradestartroopname", $g_iCmbStarLaboratory)
ApplyConfig_600_16(GetApplyConfigSaveAction())
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
_Ini_Add("upgrade", "xupgrade" & $iz, $g_avBuildingUpgrades[$iz][0])
_Ini_Add("upgrade", "yupgrade" & $iz, $g_avBuildingUpgrades[$iz][1])
_Ini_Add("upgrade", "upgradevalue" & $iz, $g_avBuildingUpgrades[$iz][2])
_Ini_Add("upgrade", "upgradetype" & $iz, $g_avBuildingUpgrades[$iz][3])
_Ini_Add("upgrade", "upgradename" & $iz, $g_avBuildingUpgrades[$iz][4])
_Ini_Add("upgrade", "upgradelevel" & $iz, $g_avBuildingUpgrades[$iz][5])
_Ini_Add("upgrade", "upgradetime" & $iz, $g_avBuildingUpgrades[$iz][6])
_Ini_Add("upgrade", "upgradeend" & $iz, $g_avBuildingUpgrades[$iz][7])
_Ini_Add("upgrade", "upgradechk" & $iz, $g_abBuildingUpgradeEnable[$iz] ? 1 : 0)
_Ini_Add("upgrade", "upgraderepeat" & $iz, $g_abUpgradeRepeatEnable[$iz] ? 1 : 0)
_Ini_Add("upgrade", "upgradestatusicon" & $iz, $g_aiPicUpgradeStatus[$iz])
Next
_Ini_Save($g_sProfileBuildingPath)
EndFunc
Func SaveRegularConfig()
SetDebugLog("Save Config " & $g_sProfileConfigPath)
_Ini_Clear()
_Ini_Add("general", "version", GetVersionNormalized($g_sBotVersion))
_Ini_Add("general", "threads", $g_iThreads)
_Ini_add("general", "botDesignFlags", $g_iBotDesignFlags)
_Ini_Add("general", "frmBotPosX", $g_iFrmBotPosX)
_Ini_Add("general", "frmBotPosY", $g_iFrmBotPosY)
If $g_hAndroidWindow <> 0 Then WinGetAndroidHandle()
_Ini_Add("general", "AndroidPosX", $g_iAndroidPosX)
_Ini_Add("general", "AndroidPosY", $g_iAndroidPosY)
_Ini_Add("general", "frmBotDockedPosX", $g_iFrmBotDockedPosX)
_Ini_Add("general", "frmBotDockedPosY", $g_iFrmBotDockedPosY)
_Ini_Add("general", "RedrawBotWindowMode", $g_iRedrawBotWindowMode)
SaveConfig_Android()
SaveConfig_600_1()
SaveConfig_600_6()
SaveConfig_600_9()
SaveConfig_600_11()
SaveConfig_600_12()
SaveConfig_600_13()
SaveConfig_600_15()
SaveConfig_600_16()
SaveConfig_auto()
SaveConfig_600_17()
SaveConfig_600_18()
SaveConfig_600_19()
SaveConfig_600_22()
SaveConfig_600_26()
SaveConfig_600_28()
SaveConfig_600_28_DB()
SaveConfig_600_28_LB()
SaveConfig_600_28_TS()
SaveConfig_600_29()
SaveConfig_600_29_DB()
SaveConfig_600_29_LB()
SaveConfig_600_29_TS()
SaveConfig_600_30()
SaveConfig_600_30_DB()
SaveConfig_600_30_LB()
SaveConfig_600_30_TS()
SaveConfig_600_31()
SaveConfig_600_32()
SaveConfig_600_33()
SaveConfig_600_35_1()
SaveConfig_600_35_2()
SaveConfig_600_35_3()
SaveConfig_600_52_1()
SaveConfig_600_52_2()
SaveConfig_600_54()
SaveConfig_600_56()
SaveConfig_641_1()
SaveConfig_Debug()
SaveConfig_MOD()
_Ini_Save($g_sProfileConfigPath)
EndFunc
Func SaveConfig_Android()
ApplyConfig_Android(GetApplyConfigSaveAction())
_Ini_Add("android", "game.distributor", $g_sAndroidGameDistributor)
_Ini_Add("android", "game.package", $g_sAndroidGamePackage)
_Ini_Add("android", "game.class", $g_sAndroidGameClass)
_Ini_Add("android", "user.distributor", $g_sUserGameDistributor)
_Ini_Add("android", "user.package", $g_sUserGamePackage)
_Ini_Add("android", "user.class", $g_sUserGameClass)
_Ini_Add("android", "backgroundmode", $g_iAndroidBackgroundMode)
_Ini_Add("android", "check.time.lag.enabled",($g_bAndroidCheckTimeLagEnabled ? "1" : "0"))
_Ini_Add("android", "adb.screencap.timeout.min", $g_iAndroidAdbScreencapTimeoutMin)
_Ini_Add("android", "adb.screencap.timeout.max", $g_iAndroidAdbScreencapTimeoutMax)
_Ini_Add("android", "adb.screencap.timeout.dynamic", $g_iAndroidAdbScreencapTimeoutDynamic)
_Ini_Add("android", "adb.input.enabled",($g_bAndroidAdbInputEnabled ? "1" : "0"))
_Ini_Add("android", "adb.click.enabled",($g_bAndroidAdbClickEnabled ? "1" : "0"))
_Ini_Add("android", "adb.click.drag.script",($g_bAndroidAdbClickDragScript ? "1" : "0"))
_Ini_Add("android", "adb.click.group", $g_iAndroidAdbClickGroup)
_Ini_Add("android", "adb.clicks.enabled",($g_bAndroidAdbClicksEnabled ? "1" : "0"))
_Ini_Add("android", "adb.clicks.troop.deploy.size", $g_iAndroidAdbClicksTroopDeploySize)
_Ini_Add("android", "no.focus.tampering",($g_bNoFocusTampering ? "1" : "0"))
_Ini_Add("android", "shield.color", Hex($g_iAndroidShieldColor, 6))
_Ini_Add("android", "shield.transparency", $g_iAndroidShieldTransparency)
_Ini_Add("android", "active.color", Hex($g_iAndroidActiveColor, 6))
_Ini_Add("android", "active.transparency", $g_iAndroidActiveTransparency)
_Ini_Add("android", "inactive.color", Hex($g_iAndroidInactiveColor, 6))
_Ini_Add("android", "inactive.transparency", $g_iAndroidInactiveTransparency)
_Ini_Add("android", "suspend.mode", $g_iAndroidSuspendModeFlags)
_Ini_Add("android", "emulator", $g_sAndroidEmulator)
_Ini_Add("android", "instance", $g_sAndroidInstance)
IniWrite($g_sProfilePath & "\Profile.ini", "android", "reboot.hours", $g_iAndroidRebootHours)
_Ini_Add("android", "close",($g_bAndroidCloseWithBot ? "1" : "0"))
_Ini_Add("android", "shared_prefs.update",($g_bUpdateSharedPrefs ? "1" : "0"))
_Ini_Add("android", "process.affinity.mask", $g_iAndroidProcessAffinityMask)
EndFunc
Func SaveConfig_Debug()
ApplyConfig_Debug(GetApplyConfigSaveAction())
_Ini_Add("debug", "debugsetlog", $g_bDebugSetlog ? 1 : 0)
_Ini_Add("debug", "debugAndroid", $g_bDebugAndroid ? 1 : 0)
_Ini_Add("debug", "debugsetclick", $g_bDebugClick ? 1 : 0)
_Ini_Add("debug", "debugFunc",($g_bDebugFuncTime And $g_bDebugFuncCall)? 1 : 0)
_Ini_Add("debug", "disablezoomout", $g_bDebugDisableZoomout ? 1 : 0)
_Ini_Add("debug", "disablevillagecentering", $g_bDebugDisableVillageCentering ? 1 : 0)
_Ini_Add("debug", "debugdeadbaseimage", $g_bDebugDeadBaseImage ? 1 : 0)
_Ini_Add("debug", "debugocr", $g_bDebugOcr ? 1 : 0)
_Ini_Add("debug", "debugimagesave", $g_bDebugImageSave ? 1 : 0)
_Ini_Add("debug", "debugbuildingpos", $g_bDebugBuildingPos ? 1 : 0)
_Ini_Add("debug", "debugtrain", $g_bDebugSetlogTrain ? 1 : 0)
_Ini_Add("debug", "debugresourcesoffset", $g_bDebugResourcesOffset ? 1 : 0)
_Ini_Add("debug", "continuesearchelixirdebug", $g_bDebugContinueSearchElixir ? 1 : 0)
_Ini_Add("debug", "debugMilkingIMGmake", $g_bDebugMilkingIMGmake ? 1 : 0)
_Ini_Add("debug", "debugOCRDonate", $g_bDebugOCRdonate ? 1 : 0)
_Ini_Add("debug", "debugAttackCSV", $g_bDebugAttackCSV ? 1 : 0)
_Ini_Add("debug", "debugmakeimgcsv", $g_bDebugMakeIMGCSV ? 1 : 0)
_Ini_Add("debug", "DebugSmartZap", $g_bDebugSmartZap)
EndFunc
Func SaveConfig_600_1()
ApplyConfig_600_1(GetApplyConfigSaveAction())
_Ini_Add("general", "logstyle", $g_iCmbLogDividerOption)
_Ini_Add("general", "LogDividerY", $g_iLogDividerY)
_Ini_Add("general", "Background", $g_bChkBackgroundMode ? 1 : 0)
EndFunc
Func SaveConfig_600_6()
ApplyConfig_600_6(GetApplyConfigSaveAction())
_Ini_Add("general", "BotStop", $g_bChkBotStop ? 1 : 0)
_Ini_Add("general", "Command", $g_iCmbBotCommand)
_Ini_Add("general", "Cond", $g_iCmbBotCond)
_Ini_Add("general", "Hour", $g_iCmbHoursStop)
_Ini_Add("other", "minrestartgold", $g_iTxtRestartGold)
_Ini_Add("other", "minrestartelixir", $g_iTxtRestartElixir)
_Ini_Add("other", "minrestartdark", $g_iTxtRestartDark)
_Ini_Add("other", "chkCollect", $g_bChkCollect ? 1 : 0)
_Ini_Add("other", "chkCollectCartFirst", $g_bChkCollectCartFirst ? 1 : 0)
_Ini_Add("other", "minCollectgold", $g_iTxtCollectGold)
_Ini_Add("other", "minCollectelixir", $g_iTxtCollectElixir)
_Ini_Add("other", "minCollectdark", $g_iTxtCollectDark)
_Ini_Add("other", "chkTombstones", $g_bChkTombstones ? 1 : 0)
_Ini_Add("other", "chkCleanYard", $g_bChkCleanYard ? 1 : 0)
_Ini_Add("other", "ChkCollectFreeMagicItems", $g_bChkCollectFreeMagicItems ? 1 : 0)
_Ini_Add("other", "chkGemsBox", $g_bChkGemsBox ? 1 : 0)
_Ini_Add("other", "ChkTreasuryCollect", $g_bChkTreasuryCollect ? 1 : 0)
_Ini_Add("other", "minTreasurygold", $g_iTxtTreasuryGold)
_Ini_Add("other", "minTreasuryelixir", $g_iTxtTreasuryElixir)
_Ini_Add("other", "minTreasurydark", $g_iTxtTreasuryDark)
_Ini_Add("other", "ChkCollectBuildersBase", $g_bChkCollectBuilderBase ? 1 : 0)
_Ini_Add("other", "ChkCleanBBYard", $g_bChkCleanBBYard ? 1 : 0)
_Ini_Add("other", "ChkStartClockTowerBoost", $g_bChkStartClockTowerBoost ? 1 : 0)
_Ini_Add("other", "ChkCTBoostBlderBz", $g_bChkCTBoostBlderBz ? 1 : 0)
_Ini_Add("other", "ChkBBSuggestedUpgrades", $g_iChkBBSuggestedUpgrades)
_Ini_Add("other", "ChkBBSuggestedUpgradesIgnoreGold", $g_iChkBBSuggestedUpgradesIgnoreGold)
_Ini_Add("other", "ChkBBSuggestedUpgradesIgnoreElixir", $g_iChkBBSuggestedUpgradesIgnoreElixir)
_Ini_Add("other", "ChkBBSuggestedUpgradesIgnoreHall", $g_iChkBBSuggestedUpgradesIgnoreHall)
_Ini_Add("other", "ChkPlacingNewBuildings", $g_iChkPlacingNewBuildings)
_Ini_Add("other", "ChkClanGamesAir", $g_bChkClanGamesAir ? 1 : 0)
_Ini_Add("other", "ChkClanGamesGround", $g_bChkClanGamesGround ? 1 : 0)
_Ini_Add("other", "ChkClanGamesMisc", $g_bChkClanGamesMisc ? 1 : 0)
_Ini_Add("other", "ChkClanGamesEnabled", $g_bChkClanGamesEnabled ? 1 : 0)
_Ini_Add("other", "ChkClanGames60", $g_bChkClanGames60 ? 1 : 0)
_Ini_Add("other", "ChkClanGamesPurge", $g_bChkClanGamesPurge ? 1 : 0)
_Ini_Add("other", "ChkClanGamesStopBeforeReachAndPurge", $g_bChkClanGamesStopBeforeReachAndPurge ? 1 : 0)
_Ini_Add("other", "ChkClanGamesDebug", $g_bChkClanGamesDebug ? 1 : 0)
_Ini_Add("other", "ChkClanGamesLoot", $g_bChkClanGamesLoot ? 1 : 0)
_Ini_Add("other", "ChkClanGamesBattle", $g_bChkClanGamesBattle ? 1 : 0)
_Ini_Add("other", "ChkClanGamesDestruction", $g_bChkClanGamesDestruction ? 1 : 0)
_Ini_Add("other", "ChkClanGamesAirTroop", $g_bChkClanGamesAirTroop ? 1 : 0)
_Ini_Add("other", "ChkClanGamesGroundTroop ", $g_bChkClanGamesGroundTroop ? 1 : 0)
_Ini_Add("other", "ChkClanGamesMiscellaneous", $g_bChkClanGamesMiscellaneous ? 1 : 0)
_Ini_Add("other", "PurgeMax", $g_iPurgeMax)
EndFunc
Func SaveConfig_600_9()
ApplyConfig_600_9(GetApplyConfigSaveAction())
_Ini_Add("Unbreakable", "chkUnbreakable", $g_iUnbrkMode)
_Ini_Add("Unbreakable", "UnbreakableWait", $g_iUnbrkWait)
_Ini_Add("Unbreakable", "minUnBrkgold", $g_iUnbrkMinGold)
_Ini_Add("Unbreakable", "minUnBrkelixir", $g_iUnbrkMinElixir)
_Ini_Add("Unbreakable", "minUnBrkdark", $g_iUnbrkMinDark)
_Ini_Add("Unbreakable", "maxUnBrkgold", $g_iUnbrkMaxGold)
_Ini_Add("Unbreakable", "maxUnBrkelixir", $g_iUnbrkMaxElixir)
_Ini_Add("Unbreakable", "maxUnBrkdark", $g_iUnbrkMaxDark)
EndFunc
Func SaveConfig_600_11()
ApplyConfig_600_11(GetApplyConfigSaveAction())
_Ini_Add("planned", "RequestHoursEnable", $g_bRequestTroopsEnable ? 1 : 0)
_Ini_Add("donate", "txtRequest", $g_sRequestTroopsText)
_Ini_Add("donate", "RequestType_Troop", $g_abRequestType[0] ? 1 : 0)
_Ini_Add("donate", "RequestType_Spell", $g_abRequestType[1] ? 1 : 0)
_Ini_Add("donate", "RequestType_Siege", $g_abRequestType[2] ? 1 : 0)
_Ini_Add("donate", "RequestCountCC_Troop", $g_iRequestCountCCTroop)
_Ini_Add("donate", "RequestCountCC_Spell", $g_iRequestCountCCSpell)
For $i = 0 To 2
_Ini_Add("donate", "cmbClanCastleTroop" & $i, $g_aiClanCastleTroopWaitType[$i])
_Ini_Add("donate", "txtClanCastleTroop" & $i, $g_aiClanCastleTroopWaitQty[$i])
_Ini_Add("donate", "cmbClanCastleSpell" & $i, $g_aiClanCastleSpellWaitType[$i])
If $i <= 1 Then _Ini_Add("donate", "cmbClanCastleSiege" & $i, $g_aiClanCastleSiegeWaitType[$i])
Next
Local $string = ""
For $i = 0 To 23
$string &=($g_abRequestCCHours[$i] ? "1" : "0") & "|"
Next
_Ini_Add("planned", "RequestHours", $string)
_Ini_Add("donate", "RequestDefenseEnable", $g_bRequestCCDefense ? 1 : 0)
_Ini_Add("donate", "RequestDefenseText", $g_sRequestCCDefenseText)
_Ini_Add("donate", "RequestDefenseWhenPB", $g_bRequestCCDefenseWhenPB ? 1 : 0)
_Ini_Add("donate", "RequestDefenseTime", $g_iRequestDefenseTime)
_Ini_Add("donate", "SaveCCTroopForDefense", $g_bSaveCCTroopForDefense ? 1 : 0)
For $i = 0 To 2
_Ini_Add("donate", "cmbCCTroopDefense" & $i, $g_aiCCTroopDefenseType[$i])
_Ini_Add("donate", "txtCCTroopDefense" & $i, $g_aiCCTroopDefenseQty[$i])
Next
EndFunc
Func SaveConfig_600_12()
Local $t = __TimerInit()
ApplyConfig_600_12(GetApplyConfigSaveAction())
_Ini_Add("donate", "Doncheck", $g_bChkDonate ? 1 : 0)
_Ini_Add("donate", "chkDonateQueueOnly[0]", $g_abChkDonateQueueOnly[0] ? 1 : 0)
_Ini_Add("donate", "chkDonateQueueOnly[1]", $g_abChkDonateQueueOnly[1] ? 1 : 0)
For $i = 0 To $eTroopCount - 1 + $g_iCustomDonateConfigs
Local $sIniName = ""
If $i >= $eTroopBarbarian And $i <= $eTroopIceGolem Then
$sIniName = StringReplace($g_asTroopNamesPlural[$i], " ", "")
ElseIf $i = $eCustomA Then
$sIniName = "CustomA"
ElseIf $i = $eCustomB Then
$sIniName = "CustomB"
ElseIf $i = $eCustomC Then
$sIniName = "CustomC"
ElseIf $i = $eCustomD Then
$sIniName = "CustomD"
EndIf
_Ini_Add("donate", "chkDonate" & $sIniName, $g_abChkDonateTroop[$i] ? 1 : 0)
_Ini_Add("donate", "chkDonateAll" & $sIniName, $g_abChkDonateAllTroop[$i] ? 1 : 0)
_Ini_Add("donate", "txtDonate" & $sIniName, StringReplace($g_asTxtDonateTroop[$i], @CRLF, "|"))
_Ini_Add("donate", "txtBlacklist" & $sIniName, StringReplace($g_asTxtBlacklistTroop[$i], @CRLF, "|"))
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
Local $sIniName = $g_asSpellNames[$i] & "Spells"
_Ini_Add("donate", "chkDonate" & $sIniName, $g_abChkDonateSpell[$i] ? 1 : 0)
_Ini_Add("donate", "chkDonateAll" & $sIniName, $g_abChkDonateAllSpell[$i] ? 1 : 0)
_Ini_Add("donate", "txtDonate" & $sIniName, StringReplace($g_asTxtDonateSpell[$i], @CRLF, "|"))
_Ini_Add("donate", "txtBlacklist" & $sIniName, StringReplace($g_asTxtBlacklistSpell[$i], @CRLF, "|"))
EndIf
Next
For $i = $eSiegeWallWrecker to $eSiegeMachineCount - 1
Local $index = $eTroopCount + $g_iCustomDonateConfigs
Local $sIniName = $g_asSiegeMachineShortNames[$i]
_Ini_Add("donate", "chkDonate" & $sIniName, $g_abChkDonateTroop[$index + $i] ? 1 : 0)
_Ini_Add("donate", "chkDonateAll" & $sIniName, $g_abChkDonateAllTroop[$index + $i] ? 1 : 0)
_Ini_Add("donate", "txtDonate" & $sIniName, StringReplace($g_asTxtDonateTroop[$index + $i], @CRLF, "|"))
_Ini_Add("donate", "txtBlacklist" & $sIniName, StringReplace($g_asTxtBlacklistTroop[$index + $i], @CRLF, "|"))
Next
For $i = 0 To 2
_Ini_Add("donate", "cmbDonateCustomA" & $i + 1, $g_aiDonateCustomTrpNumA[$i][0])
_Ini_Add("donate", "txtDonateCustomA" & $i + 1, $g_aiDonateCustomTrpNumA[$i][1])
_Ini_Add("donate", "cmbDonateCustomB" & $i + 1, $g_aiDonateCustomTrpNumB[$i][0])
_Ini_Add("donate", "txtDonateCustomB" & $i + 1, $g_aiDonateCustomTrpNumB[$i][1])
_Ini_Add("donate", "cmbDonateCustomC" & $i + 1, $g_aiDonateCustomTrpNumC[$i][0])
_Ini_Add("donate", "txtDonateCustomC" & $i + 1, $g_aiDonateCustomTrpNumC[$i][1])
_Ini_Add("donate", "cmbDonateCustomD" & $i + 1, $g_aiDonateCustomTrpNumD[$i][0])
_Ini_Add("donate", "txtDonateCustomD" & $i + 1, $g_aiDonateCustomTrpNumD[$i][1])
Next
_Ini_Add("donate", "chkExtraAlphabets", $g_bChkExtraAlphabets ? 1 : 0)
_Ini_Add("donate", "chkExtraChinese", $g_bChkExtraChinese ? 1 : 0)
_Ini_Add("donate", "chkExtraKorean", $g_bChkExtraKorean ? 1 : 0)
_Ini_Add("donate", "chkExtraPersian", $g_bChkExtraPersian ? 1 : 0)
_Ini_Add("donate", "txtBlacklist", StringReplace($g_sTxtGeneralBlacklist, @CRLF, "|"))
EndFunc
Func SaveConfig_600_13()
ApplyConfig_600_13(GetApplyConfigSaveAction())
_Ini_Add("planned", "DonateHoursEnable", $g_bDonateHoursEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 23
$string &=($g_abDonateHours[$i] ? "1" : "0") & "|"
Next
_Ini_Add("planned", "DonateHours", $string)
_Ini_Add("donate", "cmbFilterDonationsCC", $g_iCmbDonateFilter)
_Ini_Add("donate", "SkipDonateNearFulLTroopsEnable", $g_bDonateSkipNearFullEnable ? 1 : 0)
_Ini_Add("donate", "SkipDonateNearFulLTroopsPercentual", $g_iDonateSkipNearFullPercent)
EndFunc
Func SaveConfig_600_15()
ApplyConfig_600_15(GetApplyConfigSaveAction())
_Ini_Add("upgrade", "UpgradeKing", $g_bUpgradeKingEnable ? 1 : 0)
_Ini_Add("upgrade", "UpgradeQueen", $g_bUpgradeQueenEnable ? 1 : 0)
_Ini_Add("upgrade", "UpgradeWarden", $g_bUpgradeWardenEnable ? 1 : 0)
_Ini_Add("upgrade", "HeroReservedBuilder", $g_iHeroReservedBuilder)
EndFunc
Func SaveConfig_600_16()
_Ini_Add("upgrade", "minupgrgold", $g_iUpgradeMinGold)
_Ini_Add("upgrade", "minupgrelixir", $g_iUpgradeMinElixir)
_Ini_Add("upgrade", "minupgrdark", $g_iUpgradeMinDark)
EndFunc
Func SaveConfig_auto()
ApplyConfig_auto(GetApplyConfigSaveAction())
_Ini_Add("Auto Upgrade", "AutoUpgradeEnabled", $g_bAutoUpgradeEnabled)
For $i = 0 To 13
_Ini_Add("Auto Upgrade", "ChkUpgradesToIgnore[" & $i & "]", $g_iChkUpgradesToIgnore[$i])
Next
For $i = 0 To 2
_Ini_Add("Auto Upgrade", "ChkResourcesToIgnore[" & $i & "]", $g_iChkResourcesToIgnore[$i])
Next
_Ini_Add("Auto Upgrade", "SmartMinGold", $g_iTxtSmartMinGold)
_Ini_Add("Auto Upgrade", "SmartMinElixir", $g_iTxtSmartMinElixir)
_Ini_Add("Auto Upgrade", "SmartMinDark", $g_iTxtSmartMinDark)
EndFunc
Func SaveConfig_600_17()
ApplyConfig_600_17(GetApplyConfigSaveAction())
_Ini_Add("upgrade", "auto-wall", $g_bAutoUpgradeWallsEnable ? 1 : 0)
_Ini_Add("upgrade", "minwallgold", $g_iUpgradeWallMinGold)
_Ini_Add("upgrade", "minwallelixir", $g_iUpgradeWallMinElixir)
_Ini_Add("upgrade", "use-storage", $g_iUpgradeWallLootType)
_Ini_Add("upgrade", "savebldr", $g_bUpgradeWallSaveBuilder ? 1 : 0)
_Ini_Add("upgrade", "walllvl", $g_iCmbUpgradeWallsLevel)
For $i = 4 To 13
_Ini_Add("Walls", "Wall" & StringFormat("%02d", $i), $g_aiWallsCurrentCount[$i])
Next
_Ini_Add("upgrade", "WallCost", $g_iWallCost)
EndFunc
Func SaveConfig_600_18()
ApplyConfig_600_18(GetApplyConfigSaveAction())
_Ini_Add("notify", "TGEnabled", $g_bNotifyTGEnable ? 1 : 0)
_Ini_Add("notify", "TGToken", $g_sNotifyTGToken)
_Ini_Add("notify", "TGUserID", $g_sTGChatID)
_Ini_Add("notify", "PBRemote", $g_bNotifyRemoteEnable ? 1 : 0)
_Ini_Add("notify", "HoursPushBullet", $g_iNotifyDeletePushesOlderThanHours)
_Ini_Add("notify", "Origin", $g_sNotifyOrigin)
_Ini_Add("notify", "AlertPBVMFound", $g_bNotifyAlertMatchFound ? 1 : 0)
_Ini_Add("notify", "AlertPBLastRaid", $g_bNotifyAlerLastRaidIMG ? 1 : 0)
_Ini_Add("notify", "AlertPBWallUpgrade", $g_bNotifyAlertUpgradeWalls ? 1 : 0)
_Ini_Add("notify", "AlertPBOOS", $g_bNotifyAlertOutOfSync ? 1 : 0)
_Ini_Add("notify", "AlertPBVBreak", $g_bNotifyAlertTakeBreak ? 1 : 0)
_Ini_Add("notify", "AlertPBOtherDevice", $g_bNotifyAlertAnotherDevice ? 1 : 0)
_Ini_Add("notify", "AlertPBLastRaidTxt", $g_bNotifyAlerLastRaidTXT ? 1 : 0)
_Ini_Add("notify", "AlertPBCampFull", $g_bNotifyAlertCampFull ? 1 : 0)
_Ini_Add("notify", "AlertPBVillage", $g_bNotifyAlertVillageReport ? 1 : 0)
_Ini_Add("notify", "AlertPBLastAttack", $g_bNotifyAlertLastAttack ? 1 : 0)
_Ini_Add("notify", "AlertBuilderIdle", $g_bNotifyAlertBulderIdle ? 1 : 0)
_Ini_Add("notify", "AlertPBMaintenance", $g_bNotifyAlertMaintenance ? 1 : 0)
_Ini_Add("notify", "AlertPBBAN", $g_bNotifyAlertBAN ? 1 : 0)
_Ini_Add("notify", "AlertPBUpdate", $g_bNotifyAlertBOTUpdate ? 1 : 0)
_Ini_Add("notify", "AlertSmartWaitTime", $g_bNotifyAlertSmartWaitTime ? 1 : 0)
_Ini_Add("notify", "AlertLaboratoryIdle", $g_bNotifyAlertLaboratoryIdle ? 1 : 0)
EndFunc
Func SaveConfig_600_19()
ApplyConfig_600_19(GetApplyConfigSaveAction())
_Ini_Add("notify", "NotifyHoursEnable", $g_bNotifyScheduleHoursEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 23
$string &=($g_abNotifyScheduleHours[$i] ? "1" : "0") & "|"
Next
_Ini_Add("notify", "NotifyHours", $string)
_Ini_Add("notify", "NotifyWeekDaysEnable", $g_bNotifyScheduleWeekDaysEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 6
$string &=($g_abNotifyScheduleWeekDays[$i] ? "1" : "0") & "|"
Next
_Ini_Add("notify", "NotifyWeekDays", $string)
EndFunc
Func SaveConfig_600_22()
ApplyConfig_600_22(GetApplyConfigSaveAction())
Local $string = ""
For $i = 0 To 23
$string &=($g_abBoostBarracksHours[$i] ? "1" : "0") & "|"
Next
_Ini_Add("planned", "BoostBarracksHours", $string)
EndFunc
Func SaveConfig_600_26()
ApplyConfig_600_26(GetApplyConfigSaveAction())
_Ini_Add("search", "BullyMode", $g_abAttackTypeEnable[$TB] ? 1 : 0)
_Ini_Add("search", "ATBullyMode", $g_iAtkTBEnableCount)
_Ini_Add("search", "YourTH", $g_iAtkTBMaxTHLevel)
_Ini_Add("search", "THBullyAttackMode", $g_iAtkTBMode)
EndFunc
Func SaveConfig_600_28()
ApplyConfig_600_28(GetApplyConfigSaveAction())
_Ini_Add("search", "reduction", $g_bSearchReductionEnable ? 1 : 0)
_Ini_Add("search", "reduceCount", $g_iSearchReductionCount)
_Ini_Add("search", "reduceGold", $g_iSearchReductionGold)
_Ini_Add("search", "reduceElixir", $g_iSearchReductionElixir)
_Ini_Add("search", "reduceGoldPlusElixir", $g_iSearchReductionGoldPlusElixir)
_Ini_Add("search", "reduceDark", $g_iSearchReductionDark)
_Ini_Add("search", "reduceTrophy", $g_iSearchReductionTrophy)
_Ini_Add("other", "VSDelay", $g_iSearchDelayMin)
_Ini_Add("other", "MaxVSDelay", $g_iSearchDelayMax)
_Ini_Add("general", "attacknow", $g_bSearchAttackNowEnable ? 1 : 0)
_Ini_Add("general", "attacknowdelay", $g_iSearchAttackNowDelay)
_Ini_Add("search", "ChkRestartSearchLimit", $g_bSearchRestartEnable ? 1 : 0)
_Ini_Add("search", "RestartSearchLimit", $g_iSearchRestartLimit)
_Ini_Add("search", "RestartSearchPickupHero", $g_bSearchRestartPickupHero ? 1 : 0)
_Ini_Add("general", "AlertSearch", $g_bSearchAlertMe ? 1 : 0)
EndFunc
Func SaveConfig_600_28_DB()
ApplyConfig_600_28_DB(GetApplyConfigSaveAction())
_Ini_Add("search", "DBcheck", $g_abAttackTypeEnable[$DB] ? 1 : 0)
_Ini_Add("search", "ChkDBSearchSearches", $g_abSearchSearchesEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBEnableAfterCount", $g_aiSearchSearchesMin[$DB])
_Ini_Add("search", "DBEnableBeforeCount", $g_aiSearchSearchesMax[$DB])
_Ini_Add("search", "ChkDBSearchTropies", $g_abSearchTropiesEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBEnableAfterTropies", $g_aiSearchTrophiesMin[$DB])
_Ini_Add("search", "DBEnableBeforeTropies", $g_aiSearchTrophiesMax[$DB])
_Ini_Add("search", "ChkDBSearchCamps", $g_abSearchCampsEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBEnableAfterArmyCamps", $g_aiSearchCampsPct[$DB])
_Ini_Add("attack", "DBKingWait", $g_iHeroWaitAttackNoBit[$DB][0])
_Ini_Add("attack", "DBQueenWait", $g_iHeroWaitAttackNoBit[$DB][1])
_Ini_Add("attack", "DBWardenWait", $g_iHeroWaitAttackNoBit[$DB][2])
_Ini_Add("attack", "DBNotWaitHeroes", $g_aiSearchNotWaitHeroesEnable[$DB] ? 1 : 0)
_Ini_Add("search", "ChkDBSpellsWait", $g_abSearchSpellsWaitEnable[$DB] ? 1 : 0)
_Ini_Add("search", "ChkDBCastleWait", $g_abSearchCastleWaitEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBMeetGE", $g_aiFilterMeetGE[$DB])
_Ini_Add("search", "DBsearchGold", $g_aiFilterMinGold[$DB])
_Ini_Add("search", "DBsearchElixir", $g_aiFilterMinElixir[$DB])
_Ini_Add("search", "DBsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$DB])
_Ini_Add("search", "DBMeetDE", $g_abFilterMeetDEEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBsearchDark", $g_aiFilterMeetDEMin[$DB])
_Ini_Add("search", "DBMeetTrophy", $g_abFilterMeetTrophyEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBsearchTrophy", $g_aiFilterMeetTrophyMin[$DB])
_Ini_Add("search", "DBsearchTrophyMax", $g_aiFilterMeetTrophyMax[$DB])
_Ini_Add("search", "DBMeetTH", $g_abFilterMeetTH[$DB] ? 1 : 0)
_Ini_Add("search", "DBTHLevel", $g_aiFilterMeetTHMin[$DB])
_Ini_Add("search", "DBMeetTHO", $g_abFilterMeetTHOutsideEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckMortar", $g_abFilterMaxMortarEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckWizTower", $g_abFilterMaxWizTowerEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckAirDefense", $g_abFilterMaxAirDefenseEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckXBow", $g_abFilterMaxXBowEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckInferno", $g_abFilterMaxInfernoEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBCheckEagle", $g_abFilterMaxEagleEnable[$DB] ? 1 : 0)
_Ini_Add("search", "DBWeakMortar", $g_aiFilterMaxMortarLevel[$DB])
_Ini_Add("search", "DBWeakWizTower", $g_aiFilterMaxWizTowerLevel[$DB])
_Ini_Add("search", "DBWeakAirDefense", $g_aiFilterMaxAirDefenseLevel[$DB])
_Ini_Add("search", "DBWeakXBow", $g_aiFilterMaxXBowLevel[$DB])
_Ini_Add("search", "DBWeakInferno", $g_aiFilterMaxInfernoLevel[$DB])
_Ini_Add("search", "DBWeakEagle", $g_aiFilterMaxEagleLevel[$DB])
_Ini_Add("search", "DBMeetOne", $g_abFilterMeetOneConditionEnable[$DB] ? 1 : 0)
EndFunc
Func SaveConfig_600_28_LB()
ApplyConfig_600_28_LB(GetApplyConfigSaveAction())
_Ini_Add("search", "ABcheck", $g_abAttackTypeEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ChkABSearchSearches", $g_abSearchSearchesEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABEnableAfterCount", $g_aiSearchSearchesMin[$LB])
_Ini_Add("search", "ABEnableBeforeCount", $g_aiSearchSearchesMax[$LB])
_Ini_Add("search", "ChkABSearchTropies", $g_abSearchTropiesEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABEnableAfterTropies", $g_aiSearchTrophiesMin[$LB])
_Ini_Add("search", "ABEnableBeforeTropies", $g_aiSearchTrophiesMax[$LB])
_Ini_Add("search", "ChkABSearchCamps", $g_abSearchCampsEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABEnableAfterArmyCamps", $g_aiSearchCampsPct[$LB])
_Ini_Add("attack", "ABKingWait", $g_iHeroWaitAttackNoBit[$LB][0])
_Ini_Add("attack", "ABQueenWait", $g_iHeroWaitAttackNoBit[$LB][1])
_Ini_Add("attack", "ABWardenWait", $g_iHeroWaitAttackNoBit[$LB][2])
_Ini_Add("attack", "ABNotWaitHeroes", $g_aiSearchNotWaitHeroesEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ChkABSpellsWait", $g_abSearchSpellsWaitEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ChkABCastleWait", $g_abSearchCastleWaitEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABMeetGE", $g_aiFilterMeetGE[$LB])
_Ini_Add("search", "ABsearchGold", $g_aiFilterMinGold[$LB])
_Ini_Add("search", "ABsearchElixir", $g_aiFilterMinElixir[$LB])
_Ini_Add("search", "ABsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$LB])
_Ini_Add("search", "ABMeetDE", $g_abFilterMeetDEEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABsearchDark", $g_aiFilterMeetDEMin[$LB])
_Ini_Add("search", "ABMeetTrophy", $g_abFilterMeetTrophyEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABsearchTrophy", $g_aiFilterMeetTrophyMin[$LB])
_Ini_Add("search", "ABsearchTrophyMax", $g_aiFilterMeetTrophyMax[$LB])
_Ini_Add("search", "ABMeetTH", $g_abFilterMeetTH[$LB] ? 1 : 0)
_Ini_Add("search", "ABTHLevel", $g_aiFilterMeetTHMin[$LB])
_Ini_Add("search", "ABMeetTHO", $g_abFilterMeetTHOutsideEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckMortar", $g_abFilterMaxMortarEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckWizTower", $g_abFilterMaxWizTowerEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckAirDefense", $g_abFilterMaxAirDefenseEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckXBow", $g_abFilterMaxXBowEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckInferno", $g_abFilterMaxInfernoEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABCheckEagle", $g_abFilterMaxEagleEnable[$LB] ? 1 : 0)
_Ini_Add("search", "ABWeakMortar", $g_aiFilterMaxMortarLevel[$LB])
_Ini_Add("search", "ABWeakWizTower", $g_aiFilterMaxWizTowerLevel[$LB])
_Ini_Add("search", "ABWeakAirDefense", $g_aiFilterMaxAirDefenseLevel[$LB])
_Ini_Add("search", "ABWeakXBow", $g_aiFilterMaxXBowLevel[$LB])
_Ini_Add("search", "ABWeakInferno", $g_aiFilterMaxInfernoLevel[$LB])
_Ini_Add("search", "ABWeakEagle", $g_aiFilterMaxEagleLevel[$LB])
_Ini_Add("search", "ABMeetOne", $g_abFilterMeetOneConditionEnable[$LB] ? 1 : 0)
EndFunc
Func SaveConfig_600_28_TS()
ApplyConfig_600_28_TS(GetApplyConfigSaveAction())
_Ini_Add("search", "TScheck", $g_abAttackTypeEnable[$TS] ? 1 : 0)
_Ini_Add("search", "ChkTSSearchSearches", $g_abSearchSearchesEnable[$TS] ? 1 : 0)
_Ini_Add("search", "TSEnableAfterCount", $g_aiSearchSearchesMin[$TS])
_Ini_Add("search", "TSEnableBeforeCount", $g_aiSearchSearchesMax[$TS])
_Ini_Add("search", "ChkTSSearchTropies", $g_abSearchTropiesEnable[$TS] ? 1 : 0)
_Ini_Add("search", "TSEnableAfterTropies", $g_aiSearchTrophiesMin[$TS])
_Ini_Add("search", "TSEnableBeforeTropies", $g_aiSearchTrophiesMax[$TS])
_Ini_Add("search", "ChkTSSearchCamps", $g_abSearchCampsEnable[$TS] ? 1 : 0)
_Ini_Add("search", "TSEnableAfterArmyCamps", $g_aiSearchCampsPct[$TS])
_Ini_Add("search", "TSMeetGE", $g_aiFilterMeetGE[$TS])
_Ini_Add("search", "TSsearchGold", $g_aiFilterMinGold[$TS])
_Ini_Add("search", "TSsearchElixir", $g_aiFilterMinElixir[$TS])
_Ini_Add("search", "TSsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$TS])
_Ini_Add("search", "TSMeetDE", $g_abFilterMeetDEEnable[$TS] ? 1 : 0)
_Ini_Add("search", "TSsearchDark", $g_aiFilterMeetDEMin[$TS])
_Ini_Add("search", "SWTtiles", $g_iAtkTSAddTilesWhileTrain)
_Ini_Add("search", "THaddTiles", $g_iAtkTSAddTilesFullTroops)
EndFunc
Func SaveConfig_600_29()
ApplyConfig_600_29(GetApplyConfigSaveAction())
_Ini_Add("attack", "ActivateQueen", $g_iActivateQueen)
_Ini_Add("attack", "ActivateKing", $g_iActivateKing)
_Ini_Add("attack", "ActivateWarden", $g_iActivateWarden)
_Ini_Add("attack", "delayActivateQueen", $g_iDelayActivateQueen)
_Ini_Add("attack", "delayActivateKing", $g_iDelayActivateKing)
_Ini_Add("attack", "delayActivateWarden", $g_iDelayActivateWarden)
_Ini_Add("planned", "chkAttackPlannerEnable", $g_bAttackPlannerEnable ? 1 : 0)
_Ini_Add("planned", "chkAttackPlannerCloseCoC", $g_bAttackPlannerCloseCoC ? 1 : 0)
_Ini_Add("planned", "chkAttackPlannerCloseAll", $g_bAttackPlannerCloseAll ? 1 : 0)
_Ini_Add("planned", "chkAttackPlannerSuspendComputer", $g_bAttackPlannerSuspendComputer ? 1 : 0)
_Ini_Add("planned", "chkAttackPlannerRandom", $g_bAttackPlannerRandomEnable ? 1 : 0)
_Ini_Add("planned", "cmbAttackPlannerRandom", $g_iAttackPlannerRandomTime)
_Ini_Add("planned", "chkAttackPlannerDayLimit", $g_bAttackPlannerDayLimit ? 1 : 0)
_Ini_Add("planned", "cmbAttackPlannerDayMin", $g_iAttackPlannerDayMin)
_Ini_Add("planned", "cmbAttackPlannerDayMax", $g_iAttackPlannerDayMax)
Local $string = ""
For $i = 0 To 6
$string &=($g_abPlannedAttackWeekDays[$i] ? 1 : 0) & "|"
Next
_Ini_Add("planned", "attackDays", $string)
Local $string = ""
For $i = 0 To 23
$string &=($g_abPlannedattackHours[$i] ? 1 : 0) & "|"
Next
_Ini_Add("planned", "attackHours", $string)
_Ini_Add("planned", "DropCCEnable", $g_bPlannedDropCCHoursEnable ? 1 : 0)
_Ini_Add("ClanClastle", "BalanceCC", $g_bUseCCBalanced ? 1 : 0)
_Ini_Add("ClanClastle", "BalanceCCDonated", $g_iCCDonated)
_Ini_Add("ClanClastle", "BalanceCCReceived", $g_iCCReceived)
Local $string = ""
For $i = 0 To 23
$string &=($g_abPlannedDropCCHours[$i] ? 1 : 0) & "|"
Next
_Ini_Add("planned", "DropCCHours", $string)
EndFunc
Func SaveConfig_600_29_DB()
ApplyConfig_600_29_DB(GetApplyConfigSaveAction())
_Ini_Add("attack", "DBAtkAlgorithm", $g_aiAttackAlgorithm[$DB])
_Ini_Add("attack", "DBSelectTroop", $g_aiAttackTroopSelection[$DB])
_Ini_Add("attack", "DBKingAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing))
_Ini_Add("attack", "DBQueenAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen))
_Ini_Add("attack", "DBWardenAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden))
_Ini_Add("attack", "DBDropCC", $g_abAttackDropCC[$DB] ? 1 : 0)
_Ini_Add("attack", "DBLightSpell", $g_abAttackUseLightSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBHealSpell", $g_abAttackUseHealSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBRageSpell", $g_abAttackUseRageSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBJumpSpell", $g_abAttackUseJumpSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBFreezeSpell", $g_abAttackUseFreezeSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBPoisonSpell", $g_abAttackUsePoisonSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBHasteSpell", $g_abAttackUseHasteSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBCloneSpell", $g_abAttackUseCloneSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBSkeletonSpell", $g_abAttackUseSkeletonSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "DBBatSpell", $g_abAttackUseBatSpell[$DB] ? 1 : 0)
_Ini_Add("attack", "THSnipeBeforeDBEnable", $g_bTHSnipeBeforeEnable[$DB] ? 1 : 0)
_Ini_Add("attack", "THSnipeBeforeDBTiles", $g_iTHSnipeBeforeTiles[$DB])
_Ini_Add("attack", "THSnipeBeforeDBScript", $g_iTHSnipeBeforeScript[$DB])
_Ini_Add("attack", "DBAtkUseWardenMode", $g_aiAttackUseWardenMode[$DB])
_Ini_Add("attack", "DBAtkUseSiege", $g_aiAttackUseSiege[$DB])
SaveConfig_600_29_DB_Standard()
SaveConfig_600_29_DB_Scripted()
SaveConfig_600_29_DB_SmartFarm()
EndFunc
Func SaveConfig_600_29_DB_Standard()
ApplyConfig_600_29_DB_Standard(GetApplyConfigSaveAction())
_Ini_Add("attack", "DBStandardAlgorithm", $g_aiAttackStdDropOrder[$DB])
_Ini_Add("attack", "DBDeploy", $g_aiAttackStdDropSides[$DB])
_Ini_Add("attack", "DBUnitD", $g_aiAttackStdUnitDelay[$DB])
_Ini_Add("attack", "DBWaveD", $g_aiAttackStdWaveDelay[$DB])
_Ini_Add("attack", "DBRandomSpeedAtk", $g_abAttackStdRandomizeDelay[$DB] ? 1 : 0)
_Ini_Add("attack", "DBSmartAttackRedArea", $g_abAttackStdSmartAttack[$DB] ? 1 : 0)
_Ini_Add("attack", "DBSmartAttackDeploy", $g_aiAttackStdSmartDeploy[$DB])
_Ini_Add("attack", "DBSmartAttackGoldMine", $g_abAttackStdSmartNearCollectors[$DB][0] ? 1 : 0)
_Ini_Add("attack", "DBSmartAttackElixirCollector", $g_abAttackStdSmartNearCollectors[$DB][1] ? 1 : 0)
_Ini_Add("attack", "DBSmartAttackDarkElixirDrill", $g_abAttackStdSmartNearCollectors[$DB][2] ? 1 : 0)
EndFunc
Func SaveConfig_600_29_DB_Scripted()
ApplyConfig_600_29_DB_Scripted(GetApplyConfigSaveAction())
_Ini_Add("attack", "RedlineRoutineDB", $g_aiAttackScrRedlineRoutine[$DB])
_Ini_Add("attack", "DroplineEdgeDB", $g_aiAttackScrDroplineEdge[$DB])
_Ini_Add("attack", "ScriptDB", $g_sAttackScrScriptName[$DB])
EndFunc
Func SaveConfig_600_29_DB_SmartFarm()
_Ini_Add("SmartFarm", "InsidePercentage", $g_iTxtInsidePercentage)
_Ini_Add("SmartFarm", "OutsidePercentage", $g_iTxtOutsidePercentage)
_Ini_Add("SmartFarm", "DebugSmartFarm", $g_bDebugSmartFarm)
EndFunc
Func SaveConfig_600_29_LB()
ApplyConfig_600_29_LB(GetApplyConfigSaveAction())
_Ini_Add("attack", "ABAtkAlgorithm", $g_aiAttackAlgorithm[$LB])
_Ini_Add("attack", "ABSelectTroop", $g_aiAttackTroopSelection[$LB])
_Ini_Add("attack", "ABKingAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroKing))
_Ini_Add("attack", "ABQueenAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroQueen))
_Ini_Add("attack", "ABWardenAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroWarden))
_Ini_Add("attack", "ABDropCC", $g_abAttackDropCC[$LB] ? 1 : 0)
_Ini_Add("attack", "ABLightSpell", $g_abAttackUseLightSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABHealSpell", $g_abAttackUseHealSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABRageSpell", $g_abAttackUseRageSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABJumpSpell", $g_abAttackUseJumpSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABFreezeSpell", $g_abAttackUseFreezeSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABCloneSpell", $g_abAttackUseCloneSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABPoisonSpell", $g_abAttackUsePoisonSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABHasteSpell", $g_abAttackUseHasteSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABSkeletonSpell", $g_abAttackUseSkeletonSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "ABBatSpell", $g_abAttackUseBatSpell[$LB] ? 1 : 0)
_Ini_Add("attack", "THSnipeBeforeLBEnable", $g_bTHSnipeBeforeEnable[$LB] ? 1 : 0)
_Ini_Add("attack", "THSnipeBeforeLBTiles", $g_iTHSnipeBeforeTiles[$LB])
_Ini_Add("attack", "THSnipeBeforeLBScript", $g_iTHSnipeBeforeScript[$LB])
_Ini_Add("attack", "ABAtkUseWardenMode", $g_aiAttackUseWardenMode[$LB])
_Ini_Add("attack", "ABAtkUseSiege", $g_aiAttackUseSiege[$LB])
SaveConfig_600_29_LB_Standard()
SaveConfig_600_29_LB_Scripted()
EndFunc
Func SaveConfig_600_29_LB_Standard()
ApplyConfig_600_29_LB_Standard(GetApplyConfigSaveAction())
_Ini_Add("attack", "LBStandardAlgorithm", $g_aiAttackStdDropOrder[$LB])
_Ini_Add("attack", "ABDeploy", $g_aiAttackStdDropSides[$LB])
_Ini_Add("attack", "ABUnitD", $g_aiAttackStdUnitDelay[$LB])
_Ini_Add("attack", "ABWaveD", $g_aiAttackStdWaveDelay[$LB])
_Ini_Add("attack", "ABRandomSpeedAtk", $g_abAttackStdRandomizeDelay[$LB] ? 1 : 0)
_Ini_Add("attack", "ABSmartAttackRedArea", $g_abAttackStdSmartAttack[$LB] ? 1 : 0)
_Ini_Add("attack", "ABSmartAttackDeploy", $g_aiAttackStdSmartDeploy[$LB])
_Ini_Add("attack", "ABSmartAttackGoldMine", $g_abAttackStdSmartNearCollectors[$LB][0] ? 1 : 0)
_Ini_Add("attack", "ABSmartAttackElixirCollector", $g_abAttackStdSmartNearCollectors[$LB][1] ? 1 : 0)
_Ini_Add("attack", "ABSmartAttackDarkElixirDrill", $g_abAttackStdSmartNearCollectors[$LB][2] ? 1 : 0)
EndFunc
Func SaveConfig_600_29_LB_Scripted()
ApplyConfig_600_29_LB_Scripted(GetApplyConfigSaveAction())
_Ini_Add("attack", "RedlineRoutineAB", $g_aiAttackScrRedlineRoutine[$LB])
_Ini_Add("attack", "DroplineEdgeAB", $g_aiAttackScrDroplineEdge[$LB])
_Ini_Add("attack", "ScriptAB", $g_sAttackScrScriptName[$LB])
EndFunc
Func SaveConfig_600_29_TS()
ApplyConfig_600_29_TS(GetApplyConfigSaveAction())
_Ini_Add("attack", "TSSelectTroop", $g_aiAttackTroopSelection[$TS])
_Ini_Add("attack", "TSKingAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing))
_Ini_Add("attack", "TSQueenAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen))
_Ini_Add("attack", "TSWardenAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden))
_Ini_Add("attack", "TSDropCC", $g_abAttackDropCC[$TS] ? 1 : 0)
_Ini_Add("attack", "TSLightSpell", $g_abAttackUseLightSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSHealSpell", $g_abAttackUseHealSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSRageSpell", $g_abAttackUseRageSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSJumpSpell", $g_abAttackUseJumpSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSFreezeSpell", $g_abAttackUseFreezeSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSPoisonSpell", $g_abAttackUsePoisonSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "TSHasteSpell", $g_abAttackUseHasteSpell[$TS] ? 1 : 0)
_Ini_Add("attack", "AttackTHType", $g_sAtkTSType)
EndFunc
Func SaveConfig_600_30()
ApplyConfig_600_30(GetApplyConfigSaveAction())
_Ini_Add("shareattack", "ShareAttack", $g_bShareAttackEnable ? 1 : 0)
_Ini_Add("shareattack", "minGold", $g_iShareMinGold)
_Ini_Add("shareattack", "minElixir", $g_iShareMinElixir)
_Ini_Add("shareattack", "minDark", $g_iShareMinDark)
_Ini_Add("shareattack", "Message", $g_sShareMessage)
_Ini_Add("attack", "TakeLootSnapShot", $g_bTakeLootSnapShot ? 1 : 0)
_Ini_Add("attack", "ScreenshotLootInfo", $g_bScreenshotLootInfo ? 1 : 0)
EndFunc
Func SaveConfig_600_30_DB()
ApplyConfig_600_30_DB(GetApplyConfigSaveAction())
_Ini_Add("endbattle", "chkDBTimeStopAtk", $g_abStopAtkNoLoot1Enable[$DB] ? 1 : 0)
_Ini_Add("endbattle", "txtDBTimeStopAtk", $g_aiStopAtkNoLoot1Time[$DB])
_Ini_Add("endbattle", "chkDBTimeStopAtk2", $g_abStopAtkNoLoot2Enable[$DB] ? 1 : 0)
_Ini_Add("endbattle", "txtDBTimeStopAtk2", $g_aiStopAtkNoLoot2Time[$DB])
_Ini_Add("endbattle", "txtDBMinGoldStopAtk2", $g_aiStopAtkNoLoot2MinGold[$DB])
_Ini_Add("endbattle", "txtDBMinElixirStopAtk2", $g_aiStopAtkNoLoot2MinElixir[$DB])
_Ini_Add("endbattle", "txtDBMinDarkElixirStopAtk2", $g_aiStopAtkNoLoot2MinDark[$DB])
_Ini_Add("endbattle", "chkDBEndNoResources", $g_abStopAtkNoResources[$DB] ? 1 : 0)
_Ini_Add("endbattle", "chkDBEndOneStar", $g_abStopAtkOneStar[$DB] ? 1 : 0)
_Ini_Add("endbattle", "chkDBEndTwoStars", $g_abStopAtkTwoStars[$DB] ? 1 : 0)
_Ini_Add("endbattle", "chkDBPercentageHigher", $g_abStopAtkPctHigherEnable[$DB] ? 1 : 0)
_Ini_Add("endbattle", "txtDBPercentageHigher", $g_aiStopAtkPctHigherAmt[$DB])
_Ini_Add("endbattle", "chkDBPercentageChange", $g_abStopAtkPctNoChangeEnable[$DB] ? 1 : 0)
_Ini_Add("endbattle", "txtDBPercentageChange", $g_aiStopAtkPctNoChangeTime[$DB])
EndFunc
Func SaveConfig_600_30_LB()
ApplyConfig_600_30_LB(GetApplyConfigSaveAction())
_Ini_Add("endbattle", "chkABTimeStopAtk", $g_abStopAtkNoLoot1Enable[$LB] ? 1 : 0)
_Ini_Add("endbattle", "txtABTimeStopAtk", $g_aiStopAtkNoLoot1Time[$LB])
_Ini_Add("endbattle", "chkABTimeStopAtk2", $g_abStopAtkNoLoot2Enable[$LB] ? 1 : 0)
_Ini_Add("endbattle", "txtABTimeStopAtk2", $g_aiStopAtkNoLoot2Time[$LB])
_Ini_Add("endbattle", "txtABMinGoldStopAtk2", $g_aiStopAtkNoLoot2MinGold[$LB])
_Ini_Add("endbattle", "txtABMinElixirStopAtk2", $g_aiStopAtkNoLoot2MinElixir[$LB])
_Ini_Add("endbattle", "txtABMinDarkElixirStopAtk2", $g_aiStopAtkNoLoot2MinDark[$LB])
_Ini_Add("endbattle", "chkABEndNoResources", $g_abStopAtkNoResources[$LB] ? 1 : 0)
_Ini_Add("endbattle", "chkABEndOneStar", $g_abStopAtkOneStar[$LB] ? 1 : 0)
_Ini_Add("endbattle", "chkABEndTwoStars", $g_abStopAtkTwoStars[$LB] ? 1 : 0)
_Ini_Add("endbattle", "chkDESideEB", $g_bDESideEndEnable ? 1 : 0)
_Ini_Add("endbattle", "txtDELowEndMin", $g_iDESideEndMin)
_Ini_Add("endbattle", "chkDisableOtherEBO", $g_bDESideDisableOther ? 1 : 0)
_Ini_Add("endbattle", "chkDEEndAq", $g_bDESideEndAQWeak ? 1 : 0)
_Ini_Add("endbattle", "chkDEEndBk", $g_bDESideEndBKWeak ? 1 : 0)
_Ini_Add("endbattle", "chkDEEndOneStar", $g_bDESideEndOneStar ? 1 : 0)
_Ini_Add("endbattle", "chkABPercentageHigher", $g_abStopAtkPctHigherEnable[$LB] ? 1 : 0)
_Ini_Add("endbattle", "txtABPercentageHigher", $g_aiStopAtkPctHigherAmt[$LB])
_Ini_Add("endbattle", "chkABPercentageChange", $g_abStopAtkPctNoChangeEnable[$LB] ? 1 : 0)
_Ini_Add("endbattle", "txtABPercentageChange", $g_aiStopAtkPctNoChangeTime[$LB])
EndFunc
Func SaveConfig_600_30_TS()
ApplyConfig_600_30_TS(GetApplyConfigSaveAction())
_Ini_Add("search", "ChkTSSearchCamps2", $g_bEndTSCampsEnable ? 1 : 0)
_Ini_Add("search", "TSEnableAfterArmyCamps2", $g_iEndTSCampsPct)
EndFunc
Func SaveConfig_600_31()
ApplyConfig_600_31(GetApplyConfigSaveAction())
For $i = 6 To 13
_Ini_Add("collectors", "lvl" & $i & "Enabled", $g_abCollectorLevelEnabled[$i] ? 1 : 0)
_Ini_Add("collectors", "lvl" & $i & "fill", $g_aiCollectorLevelFill[$i])
Next
_Ini_Add("search", "chkDisableCollectorsFilter", $g_bCollectorFilterDisable ? 1 : 0)
_Ini_Add("collectors", "minmatches", $g_iCollectorMatchesMin)
_Ini_Add("collectors", "tolerance", $g_iCollectorToleranceOffset)
EndFunc
Func SaveConfig_600_32()
ApplyConfig_600_32(GetApplyConfigSaveAction())
_Ini_Add("search", "TrophyRange", $g_bDropTrophyEnable ? 1 : 0)
_Ini_Add("search", "MaxTrophy", $g_iDropTrophyMax)
_Ini_Add("search", "MinTrophy", $g_iDropTrophyMin)
_Ini_Add("search", "chkTrophyHeroes", $g_bDropTrophyUseHeroes ? 1 : 0)
_Ini_Add("search", "cmbTrophyHeroesPriority", $g_iDropTrophyHeroesPriority)
_Ini_Add("search", "chkTrophyAtkDead", $g_bDropTrophyAtkDead ? 1 : 0)
_Ini_Add("search", "DTArmyMin", $g_iDropTrophyArmyMinPct)
EndFunc
Func SaveConfig_600_33()
_Ini_Add("DropOrder", "chkDropOrder", $g_bCustomDropOrderEnable ? 1 : 0)
For $p = 0 To UBound($g_aiCmbCustomDropOrder) - 1
_Ini_Add("DropOrder", "cmbDropOrder" & $p, $g_aiCmbCustomDropOrder[$p])
Next
EndFunc
Func SaveConfig_600_35_1()
ApplyConfig_600_35_1(GetApplyConfigSaveAction())
_Ini_Add("other", "language", $g_sLanguage)
_Ini_Add("General", "ChkDisableSplash", $g_bDisableSplash ? 1 : 0)
_Ini_Add("General", "ChkVersion", $g_bCheckVersion ? 1 : 0)
_Ini_Add("deletefiles", "DeleteLogs", $g_bDeleteLogs ? 1 : 0)
_Ini_Add("deletefiles", "DeleteLogsDays", $g_iDeleteLogsDays)
_Ini_Add("deletefiles", "DeleteTemp", $g_bDeleteTemp ? 1 : 0)
_Ini_Add("deletefiles", "DeleteTempDays", $g_iDeleteTempDays)
_Ini_Add("deletefiles", "DeleteLoots", $g_bDeleteLoots ? 1 : 0)
_Ini_Add("deletefiles", "DeleteLootsDays", $g_iDeleteLootsDays)
_Ini_Add("general", "AutoStart", $g_bAutoStart ? 1 : 0)
_Ini_Add("general", "AutoStartDelay", $g_iAutoStartDelay)
_Ini_Add("General", "ChkLanguage", $g_bCheckGameLanguage ? 1 : 0)
_Ini_Add("general", "DisposeWindows", $g_bAutoAlignEnable ? 1 : 0)
_Ini_Add("general", "DisposeWindowsPos", $g_iAutoAlignPosition)
_Ini_Add("other", "WAOffsetX", $g_iAutoAlignOffsetX)
_Ini_Add("other", "WAOffsetY", $g_iAutoAlignOffsetY)
_Ini_Add("general", "UpdatingWhenMinimized", $g_bUpdatingWhenMinimized ? 1 : 0)
_Ini_Add("general", "HideWhenMinimized", $g_bHideWhenMinimized ? 1 : 0)
_Ini_Add("other", "UseRandomClick", $g_bUseRandomClick ? 1 : 0)
_Ini_Add("other", "ScreenshotType", $g_bScreenshotPNGFormat ? 1 : 0)
_Ini_Add("other", "ScreenshotHideName", $g_bScreenshotHideName ? 1 : 0)
_Ini_Add("other", "txtTimeWakeUp", $g_iAnotherDeviceWaitTime)
_Ini_Add("other", "chkSinglePBTForced", $g_bForceSinglePBLogoff ? 1 : 0)
_Ini_Add("other", "ValueSinglePBTimeForced", $g_iSinglePBForcedLogoffTime)
_Ini_Add("other", "ValuePBTimeForcedExit", $g_iSinglePBForcedEarlyExitTime)
_Ini_Add("other", "ChkAutoResume", $g_bAutoResumeEnable ? 1 : 0)
_Ini_Add("other", "AutoResumeTime", $g_iAutoResumeTime)
_Ini_Add("other", "ChkDisableNotifications", $g_bDisableNotifications)
_Ini_Add("other", "ChkFixClanCastle", $g_bForceClanCastleDetection ? 1 : 0)
_Ini_Add("other", "ChkSqlite", $g_bUseStatistics ? 1 : 0)
_Ini_Add("ProfileSCID", "OnlySCIDAccounts", $g_bOnlySCIDAccounts ? 1 : 0)
_Ini_Add("ProfileSCID", "WhatSCIDAccount2Use", $g_iWhatSCIDAccount2Use)
EndFunc
Func SaveConfig_600_35_2()
ApplyConfig_600_35_2(GetApplyConfigSaveAction())
Local $sSwitchAccFile
Local $iCmbSwitchAcc = $g_iCmbSwitchAcc
If $iCmbSwitchAcc = 0 Then
For $g = 1 To 8
$sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $g & ".ini"
If FileExists($sSwitchAccFile) = 0 Then ContinueLoop
Local $sProfile
Local $bEnabled
For $i = 1 To 8
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "Enable" & $i, "") = "1"
If $bEnabled Then
$bEnabled = IniRead($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, "") = "1"
If $bEnabled Then
$sProfile = IniRead($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, "")
If $sProfile = $g_sProfileCurrentName Then
$iCmbSwitchAcc = $g
ExitLoop 2
EndIf
EndIf
EndIf
Next
Next
EndIf
If $iCmbSwitchAcc Then
$sSwitchAccFile = $g_sProfilePath & "\SwitchAccount.0" & $iCmbSwitchAcc & ".ini"
IniWrite($sSwitchAccFile, "SwitchAccount", "Enable", $g_bChkSwitchAcc ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "GooglePlay", $g_bChkGooglePlay ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "SuperCellID", $g_bChkSuperCellID ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "SharedPrefs", $g_bChkSharedPrefs ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "SmartSwitch", $g_bChkSmartSwitch ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "DonateLikeCrazy", $g_bDonateLikeCrazy ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "TotalCocAccount", $g_iTotalAcc)
IniWrite($sSwitchAccFile, "SwitchAccount", "TrainTimeToSkip", $g_iTrainTimeToSkip)
For $i = 1 To 8
IniWrite($sSwitchAccFile, "SwitchAccount", "AccountNo." & $i, $g_abAccountNo[$i - 1] ? 1 : 0)
IniWrite($sSwitchAccFile, "SwitchAccount", "ProfileName." & $i, $g_asProfileName[$i - 1])
IniWrite($sSwitchAccFile, "SwitchAccount", "DonateOnly." & $i, $g_abDonateOnly[$i - 1] ? 1 : 0)
IniWrite($sSwitchAccFile, "FarmStrategy", "ChkSetFarm" & $i, $g_abChkSetFarm[$i - 1] ? 1 : 0)
IniWrite($sSwitchAccFile, "FarmStrategy", "CmbAction1" & $i, $g_aiCmbAction1[$i - 1])
IniWrite($sSwitchAccFile, "FarmStrategy", "CmbCriteria1" & $i, $g_aiCmbCriteria1[$i - 1])
IniWrite($sSwitchAccFile, "FarmStrategy", "TxtResource1" & $i, $g_aiTxtResource1[$i - 1])
IniWrite($sSwitchAccFile, "FarmStrategy", "CmbTime1" & $i, $g_aiCmbTime1[$i - 1])
IniWrite($sSwitchAccFile, "FarmStrategy", "CmbAction2" & $i, $g_aiCmbAction2[$i - 1])
IniWrite($sSwitchAccFile, "FarmStrategy", "CmbCriteria2" & $i, $g_aiCmbCriteria2[$i - 1])
IniWrite($sSwitchAccFile, "FarmStrategy", "TxtResource2" & $i, $g_aiTxtResource2[$i - 1])
IniWrite($sSwitchAccFile, "FarmStrategy", "CmbTime2" & $i, $g_aiCmbTime2[$i - 1])
Next
EndIf
EndFunc
Func SaveConfig_600_35_3()
ApplyConfig_600_35_3(GetApplyConfigSaveAction())
For $i = 0 To 3
_Ini_Add("SwitchProfile", "SwitchProfileMax" & $i, $g_abChkSwitchMax[$i] ? 1 : 0)
_Ini_Add("SwitchProfile", "SwitchProfileMin" & $i, $g_abChkSwitchMin[$i] ? 1 : 0)
_Ini_Add("SwitchProfile", "TargetProfileMax" & $i, $g_aiCmbSwitchMax[$i])
_Ini_Add("SwitchProfile", "TargetProfileMin" & $i, $g_aiCmbSwitchMin[$i])
_Ini_Add("SwitchProfile", "ChangeBotTypeMax" & $i, $g_abChkBotTypeMax[$i] ? 1 : 0)
_Ini_Add("SwitchProfile", "ChangeBotTypeMin" & $i, $g_abChkBotTypeMin[$i] ? 1 : 0)
_Ini_Add("SwitchProfile", "TargetBotTypeMax" & $i, $g_aiCmbBotTypeMax[$i])
_Ini_Add("SwitchProfile", "TargetBotTypeMin" & $i, $g_aiCmbBotTypeMin[$i])
_Ini_Add("SwitchProfile", "ConditionMax" & $i, $g_aiConditionMax[$i])
_Ini_Add("SwitchProfile", "ConditionMin" & $i, $g_aiConditionMin[$i])
Next
EndFunc
Func SaveConfig_600_52_1()
ApplyConfig_600_52_1(GetApplyConfigSaveAction())
_Ini_Add("other", "ChkUseQTrain", $g_bQuickTrainEnable ? 1 : 0)
_Ini_Add("troop", "QuickTrainArmy1", $g_bQuickTrainArmy[0] ? 1 : 0)
_Ini_Add("troop", "QuickTrainArmy2", $g_bQuickTrainArmy[1] ? 1 : 0)
_Ini_Add("troop", "QuickTrainArmy3", $g_bQuickTrainArmy[2] ? 1 : 0)
_Ini_Add("troop", "ChkMultiClick", $g_bChkMultiClick ? 1 : 0)
EndFunc
Func SaveConfig_600_52_2()
ApplyConfig_600_52_2(GetApplyConfigSaveAction())
For $t = 0 To $eTroopCount - 1
_Ini_Add("troop", $g_asTroopShortNames[$t], $g_aiArmyCompTroops[$t])
_Ini_Add("LevelTroop", $g_asTroopShortNames[$t], $g_aiTrainArmyTroopLevel[$t])
Next
For $s = 0 To $eSpellCount - 1
_Ini_Add("Spells", $g_asSpellShortNames[$s], $g_aiArmyCompSpells[$s])
_Ini_Add("LevelSpell", $g_asSpellShortNames[$s], $g_aiTrainArmySpellLevel[$s])
Next
For $s = 0 To $eSiegeMachineCount - 1
_Ini_Add("Siege", $g_asSiegeMachineShortNames[$s], $g_aiArmyCompSiegeMachine[$s])
_Ini_Add("LevelSiege", $g_asSiegeMachineShortNames[$s], $g_aiTrainArmySiegeMachineLevel[$s])
Next
_Ini_Add("troop", "fulltroop", $g_iTrainArmyFullTroopPct)
_Ini_Add("other", "ChkTotalCampForced", $g_bTotalCampForced ? 1 : 0)
_Ini_Add("other", "ValueTotalCampForced", $g_iTotalCampForcedValue)
_Ini_Add("Spells", "SpellFactory", $g_iTotalSpellValue)
_Ini_Add("other", "ChkForceBrewBeforeAttack", $g_bForceBrewSpells ? 1 : 0)
_Ini_Add("troop", "DoubleTrain", $g_bDoubleTrain ? 1 : 0)
_Ini_Add("troop", "PreciseArmy", $g_bChkPreciseArmy ? 1 : 0)
EndFunc
Func SaveConfig_600_54()
ApplyConfig_600_54(GetApplyConfigSaveAction())
_Ini_Add("troop", "chkTroopOrder", $g_bCustomTrainOrderEnable ? 1 : 0)
For $z = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
_Ini_Add("troop", "cmbTroopOrder" & $z, $g_aiCmbCustomTrainOrder[$z])
Next
_Ini_Add("Spells", "chkSpellOrder", $g_bCustomBrewOrderEnable ? 1 : 0)
For $z = 0 To UBound($g_aiCmbCustomBrewOrder) - 1
_Ini_Add("Spells", "cmbSpellOrder" & $z, $g_aiCmbCustomBrewOrder[$z])
Next
EndFunc
Func SaveConfig_600_56()
ApplyConfig_600_56(GetApplyConfigSaveAction())
_Ini_Add("SmartZap", "UseSmartZap", $g_bSmartZapEnable ? 1 : 0)
_Ini_Add("SmartZap", "UseEarthQuakeZap", $g_bEarthQuakeZap ? 1 : 0)
_Ini_Add("SmartZap", "UseNoobZap", $g_bNoobZap ? 1 : 0)
_Ini_Add("SmartZap", "ZapDBOnly", $g_bSmartZapDB ? 1 : 0)
_Ini_Add("SmartZap", "THSnipeSaveHeroes", $g_bSmartZapSaveHeroes ? 1 : 0)
_Ini_Add("SmartZap", "FTW", $g_bSmartZapFTW ? 1 : 0)
_Ini_Add("SmartZap", "MinDE", $g_iSmartZapMinDE)
_Ini_Add("SmartZap", "ExpectedDE", $g_iSmartZapExpectedDE)
EndFunc
Func SaveConfig_641_1()
ApplyConfig_641_1(GetApplyConfigSaveAction())
_Ini_Add("other", "chkCloseWaitEnable", $g_bCloseWhileTrainingEnable ? 1 : 0)
_Ini_Add("other", "chkCloseWaitTrain", $g_bCloseWithoutShield ? 1 : 0)
_Ini_Add("other", "btnCloseWaitStop", $g_bCloseEmulator ? 1 : 0)
_Ini_Add("other", "btnCloseWaitSuspendComputer", $g_bSuspendComputer ? 1 : 0)
_Ini_Add("other", "btnCloseWaitStopRandom", $g_bCloseRandom ? 1 : 0)
_Ini_Add("other", "btnCloseWaitExact", $g_bCloseExactTime ? 1 : 0)
_Ini_Add("other", "btnCloseWaitRandom", $g_bCloseRandomTime ? 1 : 0)
_Ini_Add("other", "CloseWaitRdmPercent", $g_iCloseRandomTimePercent)
_Ini_Add("other", "MinimumTimeToClose", $g_iCloseMinimumTime)
_Ini_Add("other", "TrainITDelay", $g_iTrainClickDelay)
_Ini_Add("other", "chkAddIdleTime", $g_bTrainAddRandomDelayEnable ? 1 : 0)
_Ini_Add("other", "txtAddDelayIdlePhaseTimeMin", $g_iTrainAddRandomDelayMin)
_Ini_Add("other", "txtAddDelayIdlePhaseTimeMax", $g_iTrainAddRandomDelayMax)
EndFunc
Func IniWriteS($filename, $section, $key, $value)
IniWrite($filename, $section, $key, $value)
EndFunc
Func GetApplyConfigSaveAction()
If $g_iGuiMode <> 1 Then
Return "Save(disabled)"
EndIf
Return "Save"
EndFunc
Func SaveConfig_MOD()
ApplyConfig_MOD(GetApplyConfigSaveAction())
_Ini_Add("attack", "cmbCSVSpeedLB", $icmbCSVSpeed[$LB])
_Ini_Add("attack", "cmbCSVSpeedDB", $icmbCSVSpeed[$DB])
_Ini_Add("general", "EnableAuto", $g_bEnableAuto ? 1 : 0)
_Ini_Add("general", "AutoDock", $g_bChkAutoDock ? 1 : 0)
_Ini_Add("general", "AutoHide", $g_bChkAutoHideEmulator ? 1 : 0)
_Ini_Add("general", "AutoMinimize", $g_bChkAutoMinimizeBot ? 1 : 0)
_Ini_Add("other", "chkTrainLogoutMaxTime", $g_bTrainLogoutMaxTime)
_Ini_Add("other", "txtTrainLogoutMaxTime", $g_iTrainLogoutMaxTime)
_Ini_Add("other", "ChkSearchTimeout", $g_bIsSearchTimeout)
_Ini_Add("other", "SearchTimeout", $g_iSearchTimeout)
_Ini_Add("donate", "chkClanHop", $g_bChkClanHop)
EndFunc
Func ReadConfig_MOD()
IniReadS($icmbCSVSpeed[$LB], $g_sProfileConfigPath, "attack", "cmbCSVSpeedLB", $icmbCSVSpeed[$LB], "int")
IniReadS($icmbCSVSpeed[$DB], $g_sProfileConfigPath, "attack", "cmbCSVSpeedDB", $icmbCSVSpeed[$DB], "int")
For $i = $DB To $LB
If $icmbCSVSpeed[$i] < 5 Then
$g_CSVSpeedDivider[$i] = 0.5 + $icmbCSVSpeed[$i] * 0.25
Else
$g_CSVSpeedDivider[$i] = 2 + $icmbCSVSpeed[$i] - 5
EndIf
Next
IniReadS($g_bEnableAuto, $g_sProfileConfigPath, "general", "EnableAuto", $g_bEnableAuto, "Bool")
IniReadS($g_bChkAutoDock, $g_sProfileConfigPath, "general", "AutoDock", $g_bChkAutoDock, "Bool")
IniReadS($g_bChkAutoHideEmulator, $g_sProfileConfigPath, "general", "AutoHide", $g_bChkAutoHideEmulator, "Bool")
IniReadS($g_bChkAutoMinimizeBot, $g_sProfileConfigPath, "general", "AutoMinimize", $g_bChkAutoMinimizeBot, "Bool")
IniReadS($g_bTrainLogoutMaxTime, $g_sProfileConfigPath, "other", "chkTrainLogoutMaxTime", $g_bTrainLogoutMaxTime, "Bool")
IniReadS($g_iTrainLogoutMaxTime, $g_sProfileConfigPath, "other", "txtTrainLogoutMaxTime", $g_iTrainLogoutMaxTime, "int")
IniReadS($g_bIsSearchTimeout, $g_sProfileConfigPath, "other", "ChkSearchTimeout", $g_bIsSearchTimeout, "Bool")
IniReadS($g_iSearchTimeout, $g_sProfileConfigPath, "other", "SearchTimeout", $g_iSearchTimeout, "int")
IniReadS($g_bChkClanHop, $g_sProfileConfigPath, "donate", "chkClanHop", $g_bChkClanHop, "Bool")
EndFunc
Func ApplyConfig_MOD($TypeReadSave)
Switch $TypeReadSave
Case "Read"
cmbStandardDropSidesAB()
cmbStandardDropSidesDB()
_GUICtrlComboBox_SetCurSel($cmbCSVSpeed[$LB], $icmbCSVSpeed[$LB])
_GUICtrlComboBox_SetCurSel($cmbCSVSpeed[$DB], $icmbCSVSpeed[$DB])
GUICtrlSetState($g_hChkEnableAuto, $g_bEnableAuto = True ? $GUI_CHECKED : $GUI_UNCHECKED)
chkEnableAuto()
If $g_bChkAutoDock Then
GUICtrlSetState($g_hChkAutoDock, $GUI_CHECKED)
GUICtrlSetState($g_hChkAutoHideEmulator, $GUI_UNCHECKED)
ElseIf $g_bChkAutoHideEmulator Then
GUICtrlSetState($g_hChkAutoHideEmulator, $GUI_CHECKED)
GUICtrlSetState($g_hChkAutoDock, $GUI_UNCHECKED)
EndIf
btnEnableAuto()
GUICtrlSetState($g_hChkAutoMinimizeBot, $g_bChkAutoMinimizeBot = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTrainLogoutMaxTime, $g_bTrainLogoutMaxTime = True ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTrainLogoutMaxTime()
GUICtrlSetData($g_hTxtTrainLogoutMaxTime, $g_iTrainLogoutMaxTime)
GUICtrlSetState($g_hChkSearchTimeout, $g_bIsSearchTimeout = True ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSearchTimeout, $g_iSearchTimeout)
chkSearchTimeout()
GUICtrlSetState($g_hChkClanHop, $g_bChkClanHop = True ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$icmbCSVSpeed[$LB] = _GUICtrlComboBox_GetCurSel($cmbCSVSpeed[$LB])
$icmbCSVSpeed[$DB] = _GUICtrlComboBox_GetCurSel($cmbCSVSpeed[$DB])
$g_bEnableAuto =(GUICtrlRead($g_hChkEnableAuto) = $GUI_CHECKED)
$g_bChkAutoDock =(GUICtrlRead($g_hChkAutoDock) = $GUI_CHECKED)
$g_bChkAutoHideEmulator =(GUICtrlRead($g_hChkAutoHideEmulator) = $GUI_CHECKED)
$g_bChkAutoMinimizeBot =(GUICtrlRead($g_hChkAutoMinimizeBot) = $GUI_CHECKED)
$g_bTrainLogoutMaxTime =(GUICtrlRead($g_hChkTrainLogoutMaxTime) = $GUI_CHECKED)
$g_iTrainLogoutMaxTime = GUICtrlRead($g_hTxtTrainLogoutMaxTime)
$g_bIsSearchTimeout =(GUICtrlRead($g_hChkSearchTimeout) = $GUI_CHECKED)
$g_iSearchTimeout = GUICtrlRead($g_hTxtSearchTimeout)
$g_bChkClanHop =(GUICtrlRead($g_hChkClanHop) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ClanHop()
If Not $g_bChkClanHop Then Return
SetLog("Start Clan Hopping", $COLOR_INFO)
Local $sTimeStartedHopping = _NowCalc()
Local $iPosJoinedClans = 0, $iScrolls = 0, $iHopLoops = 0, $iErrors = 0
Local $aJoinClanBtn[4] = [157, 510, 0x6CBB1F, 20]
Local $aClanPage[4] = [725, 410, 0xEF5D5F, 20]
Local $aClanPageJoin[4] = [720, 407, 0xBCE764, 20]
Local $aJoinClanPage[4] = [755, 319, 0xE8C672, 20]
Local $aClanChat[4] = [83, 650, 0x8BD004, 30]
Local $aChatTab[4] = [170, 16, 0x79755B, 20]
Local $aGlobalTab[4] = [170, 16, 0x383828, 10]
Local $aClanBadgeNoClan[4] = [150, 315, 0xEB4C30, 20]
Local $aClanChatRules[4] = [158, 493, 0x6CB531, 20]
Local $aClanNameBtn[2] = [89, 63]
$g_iCommandStop = 0
If Not IsMainPage() Then
SetLog("Couldn't locate Mainscreen!", $COLOR_ERROR)
Return
EndIf
While 1
ClickP($aAway, 1, 0)
If _Sleep($DELAYRESPOND) Then Return
If $iErrors >= 10 Then
Local $y = 0
SetLog("Too Many Errors occured in current ClanHop Loop. Leaving ClanHopping!", $COLOR_ERROR)
While 1
If _Sleep(50) Then Return
If _ColorCheck(_GetPixelColor($aCloseChat[0], $aCloseChat[1], True), Hex($aCloseChat[2], 6), $aCloseChat[3]) Then
Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0173")
ExitLoop
Else
If _Sleep(100) Then Return
$y += 1
If $y > 30 Then
SetLog("Error finding Clan Tab to close.", $COLOR_ERROR)
AndroidPageError("ClanHop")
ExitLoop
EndIf
EndIf
WEnd
Return
EndIf
If $iScrolls >= 8 Then
CloseCoc(True)
$iScrolls = 0
$iPosJoinedClans = 0
EndIf
ForceCaptureRegion()
If Not _CheckPixel($aChatTab, $g_bCapturePixel) Then ClickP($aOpenChat, 1, 0)
If _Sleep($DELAYDONATECC4) Then Return
Local $iCount = 0
While 1
If _CheckPixel($aChatTab, $g_bCapturePixel) Then
ExitLoop
EndIf
If _CheckPixel($aGlobalTab, $g_bCapturePixel) Then
If _Sleep($DELAYDONATECC1) Then Return
ClickP($aClanTab, 1, 0, "#0169")
If _Sleep(500) Then Return
ExitLoop
EndIf
$iCount += 1
If $iCount >= 15 Then
SetLog("Clan Chat Did Not Open - Abandon ClanHop")
AndroidPageError("ClanHop")
Return
EndIf
WEnd
If Not _CheckPixel($aClanBadgeNoClan, $g_bCapturePixel) Then
SetLog("Still in a Clan! Leaving the Clan now")
ClickP($aClanNameBtn)
If _WaitForCheckPixel($aClanPage, $g_bCapturePixel, Default, "Wait for Clan Page:") Then
ClickP($aClanPage)
If Not ClickOkay("ClanHop") Then
SetLog("Okay Button not found! Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
Else
SetLog("Successfully left Clan", $COLOR_SUCCESS)
If _Sleep(400) Then Return
EndIf
Else
SetLog("Clan Page did not open! Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
EndIf
EndIf
If _CheckPixel($aJoinClanBtn, $g_bCapturePixel) Then
SetLog("Opening Join Clan Page", $COLOR_INFO)
ClickP($aJoinClanBtn)
Else
SetLog("Join Clan Button not visible! Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
EndIf
If Not _WaitForCheckPixel($aJoinClanPage, $g_bCapturePixel, Default, "Wait For Join Clan Page:") Then
SetLog("Joinable Clans did not show.. Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
EndIf
If $iPosJoinedClans >= 7 Then
ClickDrag(333, 668, 333, 286, 300)
$iScrolls += 1
$iPosJoinedClans = 0
EndIf
Click(161, 286 +($iPosJoinedClans * 55))
$iPosJoinedClans += 1
If _Sleep(300) Then Return
If Not _WaitForCheckPixel($aClanPageJoin, $g_bCapturePixel, Default, "Wait For Clan Page:") Then
SetLog("Clan Page did not open. Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
EndIf
ClickP($aClanPageJoin)
If Not _WaitForCheckPixel($aClanChatRules, $g_bCapturePixel, Default, "Wait For Chat Rules in Clan Page:") Then
SetLog("Chat Rules did not show.. Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
EndIf
ClickP($aClanChatRules)
If Not _WaitForCheckPixel($aClanChat, $g_bCapturePixel, Default, "Wait For Clan Chat:") Then
SetLog("Could not verify loaded Clan Chat. Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
EndIf
DonateCC()
If _Sleep(300) Then Return
DonateCC()
ForceCaptureRegion()
If Not _CheckPixel($aChatTab, $g_bCapturePixel) Then ClickP($aOpenChat, 1, 0, "#0168")
If _Sleep($DELAYDONATECC4) Then Return
ClickP($aClanNameBtn)
If _WaitForCheckPixel($aClanPage, $g_bCapturePixel, Default, "Wait for Clan Page:") Then
ClickP($aClanPage)
If Not ClickOkay("ClanHop") Then
SetLog("Okay Button not found! Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
Else
SetLog("Successfully left Clan", $COLOR_SUCCESS)
If _Sleep(400) Then Return
EndIf
Else
SetLog("Clan Page did not open! Starting over again", $COLOR_ERROR)
$iErrors += 1
ContinueLoop
EndIf
If $iHopLoops >= 5 Then
Local $i = 0
While 1
If _Sleep(100) Then Return
If _CheckPixel($aCloseChat, $g_bCapturePixel) Then
Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0173")
ExitLoop
Else
If _Sleep(100) Then Return
$i += 1
If $i > 30 Then
SetLog("Error finding Clan Tab to close.", $COLOR_ERROR)
AndroidPageError("ClanHop")
ExitLoop
EndIf
EndIf
WEnd
VillageReport()
ProfileSwitch()
TrainSystem()
$iHopLoops = 0
EndIf
If _DateDiff("h", $sTimeStartedHopping, _NowCalc) > 1 Then ExitLoop
$iHopLoops += 1
WEnd
EndFunc
Func GetTranslatedParsedText($sText, $var1 = Default, $var2 = Default, $var3 = Default)
Local $s = StringReplace(StringReplace($sText, "\r\n", @CRLF), "\n", @CRLF)
If $var1 = Default Then Return $s
If $var2 = Default Then Return StringFormat($sText, $var1)
If $var3 = Default Then Return StringFormat($sText, $var1, $var2)
Return StringFormat($sText, $var1, $var2, $var3)
EndFunc
Func DetectLanguage()
Local $decimalCode = "", $countryCode = "", $langName = ""
$g_sLanguage = IniRead($g_sProfileConfigPath, "other", "language", "")
If Not FileExists(@ScriptDir & "\Languages\" & $g_sLanguage & ".ini") Then $g_sLanguage = ""
If $g_sLanguage = "" Then
Local $OSLang = @OSLang
If $g_bDebugSetlog Then SetDebugLog("Detected language code: " & $OSLang)
Switch $OSLang
Case Hex(0x0004, 4)
$decimalCode = '4'
$countryCode = 'zh-CHS'
$langName = 'Chinese_S'
Case Hex(0x0401, 4)
$decimalCode = '1025'
$countryCode = 'ar-SA'
$langName = 'Arabic'
Case Hex(0x0402, 4)
$decimalCode = '1026'
$countryCode = 'bg-BG'
$langName = 'Bulgarian'
Case Hex(0x0403, 4)
$decimalCode = '1027'
$countryCode = 'ca-ES'
$langName = 'Catalan'
Case Hex(0x0404, 4)
$decimalCode = '1028'
$countryCode = 'zh-TW'
$langName = 'Chinese_T'
Case Hex(0x0405, 4)
$decimalCode = '1029'
$countryCode = 'cs-CZ'
$langName = 'Czech'
Case Hex(0x0406, 4)
$decimalCode = '1030'
$countryCode = 'da-DK'
$langName = 'Danish'
Case Hex(0x0407, 4)
$decimalCode = '1031'
$countryCode = 'de-DE'
$langName = 'German'
Case Hex(0x0408, 4)
$decimalCode = '1032'
$countryCode = 'el-GR'
$langName = 'Greek'
Case Hex(0x0409, 4)
$decimalCode = '1033'
$countryCode = 'en-US'
$langName = 'English'
Case Hex(0x040A, 4)
$decimalCode = '1034'
$countryCode = 'es-ES_tradnl'
$langName = 'Spanish'
Case Hex(0x040B, 4)
$decimalCode = '1035'
$countryCode = 'fi-FI'
$langName = 'Finnish'
Case Hex(0x040C, 4)
$decimalCode = '1036'
$countryCode = 'fr-FR'
$langName = 'French'
Case Hex(0x040D, 4)
$decimalCode = '1037'
$countryCode = 'he-IL'
$langName = 'Hebrew'
Case Hex(0x040E, 4)
$decimalCode = '1038'
$countryCode = 'hu-HU'
$langName = 'Hungarian'
Case Hex(0x040F, 4)
$decimalCode = '1039'
$countryCode = 'is-IS'
$langName = 'Icelandic'
Case Hex(0x0410, 4)
$decimalCode = '1040'
$countryCode = 'it-IT'
$langName = 'Italian'
Case Hex(0x0411, 4)
$decimalCode = '1041'
$countryCode = 'ja-JP'
$langName = 'Japanese'
Case Hex(0x0412, 4)
$decimalCode = '1042'
$countryCode = 'ko-KR'
$langName = 'Korean'
Case Hex(0x0413, 4)
$decimalCode = '1043'
$countryCode = 'nl-NL'
$langName = 'Dutch'
Case Hex(0x0414, 4)
$decimalCode = '1044'
$countryCode = 'nb-NO'
$langName = 'Norwegian'
Case Hex(0x0415, 4)
$decimalCode = '1045'
$countryCode = 'pl-PL'
$langName = 'Polish'
Case Hex(0x0416, 4)
$decimalCode = '1046'
$countryCode = 'pt-BR'
$langName = 'Portuguese'
Case Hex(0x0417, 4)
$decimalCode = '1047'
$countryCode = 'rm-CH'
$langName = 'Romansh'
Case Hex(0x0418, 4)
$decimalCode = '1048'
$countryCode = 'ro-RO'
$langName = 'Romanian'
Case Hex(0x0419, 4)
$decimalCode = '1049'
$countryCode = 'ru-RU'
$langName = 'Russian'
Case Hex(0x041A, 4)
$decimalCode = '1050'
$countryCode = 'hr-HR'
$langName = 'Croatian'
Case Hex(0x041B, 4)
$decimalCode = '1051'
$countryCode = 'sk-SK'
$langName = 'Slovak'
Case Hex(0x041C, 4)
$decimalCode = '1052'
$countryCode = 'sq-AL'
$langName = 'Albanian'
Case Hex(0x041D, 4)
$decimalCode = '1053'
$countryCode = 'sv-SE'
$langName = 'Swedish'
Case Hex(0x041E, 4)
$decimalCode = '1054'
$countryCode = 'th-TH'
$langName = 'Thai'
Case Hex(0x041F, 4)
$decimalCode = '1055'
$countryCode = 'tr-TR'
$langName = 'Turkish'
Case Hex(0x0420, 4)
$decimalCode = '1056'
$countryCode = 'ur-PK'
$langName = 'Urdu'
Case Hex(0x0421, 4)
$decimalCode = '1057'
$countryCode = 'id-ID'
$langName = 'Indonesian'
Case Hex(0x0422, 4)
$decimalCode = '1058'
$countryCode = 'uk-UA'
$langName = 'Ukrainian'
Case Hex(0x0423, 4)
$decimalCode = '1059'
$countryCode = 'be-BY'
$langName = 'Belarusian'
Case Hex(0x0424, 4)
$decimalCode = '1060'
$countryCode = 'sl-SI'
$langName = 'Slovenian'
Case Hex(0x0425, 4)
$decimalCode = '1061'
$countryCode = 'et-EE'
$langName = 'Estonian'
Case Hex(0x0426, 4)
$decimalCode = '1062'
$countryCode = 'lv-LV'
$langName = 'Latvian'
Case Hex(0x0427, 4)
$decimalCode = '1063'
$countryCode = 'lt-LT'
$langName = 'Lithuanian'
Case Hex(0x0428, 4)
$decimalCode = '1064'
$countryCode = 'tg-Cyrl-TJ'
$langName = 'Tajik'
Case Hex(0x0429, 4)
$decimalCode = '1065'
$countryCode = 'fa-IR'
$langName = 'Persian'
Case Hex(0x042A, 4)
$decimalCode = '1066'
$countryCode = 'vi-VN'
$langName = 'Vietnamese'
Case Hex(0x042B, 4)
$decimalCode = '1067'
$countryCode = 'hy-AM'
$langName = 'Armenian'
Case Hex(0x042C, 4)
$decimalCode = '1068'
$countryCode = 'az-Latn-AZ'
$langName = 'Azeri'
Case Hex(0x042D, 4)
$decimalCode = '1069'
$countryCode = 'eu-ES'
$langName = 'Basque'
Case Hex(0x042E, 4)
$decimalCode = '1070'
$countryCode = 'hsb-DE'
$langName = 'Upper'
Case Hex(0x042F, 4)
$decimalCode = '1071'
$countryCode = 'mk-MK'
$langName = 'Macedonian'
Case Hex(0x0432, 4)
$decimalCode = '1074'
$countryCode = 'tn-ZA'
$langName = 'Setswana'
Case Hex(0x0434, 4)
$decimalCode = '1076'
$countryCode = 'xh-ZA'
$langName = 'isiXhosa'
Case Hex(0x0435, 4)
$decimalCode = '1077'
$countryCode = 'zu-ZA'
$langName = 'isiZulu'
Case Hex(0x0436, 4)
$decimalCode = '1078'
$countryCode = 'af-ZA'
$langName = 'Afrikaans'
Case Hex(0x0437, 4)
$decimalCode = '1079'
$countryCode = 'ka-GE'
$langName = 'Georgian'
Case Hex(0x0438, 4)
$decimalCode = '1080'
$countryCode = 'fo-FO'
$langName = 'Faroese'
Case Hex(0x0439, 4)
$decimalCode = '1081'
$countryCode = 'hi-IN'
$langName = 'Hindi'
Case Hex(0x043A, 4)
$decimalCode = '1082'
$countryCode = 'mt-MT'
$langName = 'Maltese'
Case Hex(0x043B, 4)
$decimalCode = '1083'
$countryCode = 'se-NO'
$langName = 'Sami'
Case Hex(0x043e, 4)
$decimalCode = '1086'
$countryCode = 'ms-MY'
$langName = 'Malay'
Case Hex(0x043F, 4)
$decimalCode = '1087'
$countryCode = 'kk-KZ'
$langName = 'Kazakh'
Case Hex(0x0440, 4)
$decimalCode = '1088'
$countryCode = 'ky-KG'
$langName = 'Kyrgyz'
Case Hex(0x0441, 4)
$decimalCode = '1089'
$countryCode = 'sw-KE'
$langName = 'Swahili'
Case Hex(0x0442, 4)
$decimalCode = '1090'
$countryCode = 'tk-TM'
$langName = 'Turkmen'
Case Hex(0x0443, 4)
$decimalCode = '1091'
$countryCode = 'uz-Latn-UZ'
$langName = 'Uzbek'
Case Hex(0x0444, 4)
$decimalCode = '1092'
$countryCode = 'tt-RU'
$langName = 'Tatar'
Case Hex(0x0445, 4)
$decimalCode = '1093'
$countryCode = 'bn-IN'
$langName = 'Bangla'
Case Hex(0x0446, 4)
$decimalCode = '1094'
$countryCode = 'pa-IN'
$langName = 'Punjabi'
Case Hex(0x0447, 4)
$decimalCode = '1095'
$countryCode = 'gu-IN'
$langName = 'Gujarati'
Case Hex(0x0448, 4)
$decimalCode = '1096'
$countryCode = 'or-IN'
$langName = 'Oriya'
Case Hex(0x0449, 4)
$decimalCode = '1097'
$countryCode = 'ta-IN'
$langName = 'Tamil'
Case Hex(0x044A, 4)
$decimalCode = '1098'
$countryCode = 'te-IN'
$langName = 'Telugu'
Case Hex(0x044B, 4)
$decimalCode = '1099'
$countryCode = 'kn-IN'
$langName = 'Kannada'
Case Hex(0x044C, 4)
$decimalCode = '1100'
$countryCode = 'ml-IN'
$langName = 'Malayalam'
Case Hex(0x044D, 4)
$decimalCode = '1101'
$countryCode = 'as-IN'
$langName = 'Assamese'
Case Hex(0x044E, 4)
$decimalCode = '1102'
$countryCode = 'mr-IN'
$langName = 'Marathi'
Case Hex(0x044F, 4)
$decimalCode = '1103'
$countryCode = 'sa-IN'
$langName = 'Sanskrit'
Case Hex(0x0450, 4)
$decimalCode = '1104'
$countryCode = 'mn-MN'
$langName = 'Mongolian'
Case Hex(0x0451, 4)
$decimalCode = '1105'
$countryCode = 'bo-CN'
$langName = 'Tibetan'
Case Hex(0x0452, 4)
$decimalCode = '1106'
$countryCode = 'cy-GB'
$langName = 'Welsh'
Case Hex(0x0453, 4)
$decimalCode = '1107'
$countryCode = 'km-KH'
$langName = 'Khmer'
Case Hex(0x0454, 4)
$decimalCode = '1108'
$countryCode = 'lo-LA'
$langName = 'Lao'
Case Hex(0x0456, 4)
$decimalCode = '1110'
$countryCode = 'gl-ES'
$langName = 'Galician'
Case Hex(0x0457, 4)
$decimalCode = '1111'
$countryCode = 'kok-IN'
$langName = 'Konkani'
Case Hex(0x0459, 4)
$decimalCode = '1113'
$countryCode = 'sd-Deva-IN'
$langName = '(reserved)'
Case Hex(0x045A, 4)
$decimalCode = '1114'
$countryCode = 'syr-SY'
$langName = 'Syriac'
Case Hex(0x045B, 4)
$decimalCode = '1115'
$countryCode = 'si-LK'
$langName = 'Sinhala'
Case Hex(0x045C, 4)
$decimalCode = '1116'
$countryCode = 'chr-Cher-US'
$langName = 'Cherokee'
Case Hex(0x045D, 4)
$decimalCode = '1117'
$countryCode = 'iu-Cans-CA'
$langName = 'Inuktitut'
Case Hex(0x045E, 4)
$decimalCode = '1118'
$countryCode = 'am-ET'
$langName = 'Amharic'
Case Hex(0x0461, 4)
$decimalCode = '1121'
$countryCode = 'ne-NP'
$langName = 'Nepali'
Case Hex(0x0462, 4)
$decimalCode = '1122'
$countryCode = 'fy-NL'
$langName = 'Frisian'
Case Hex(0x0463, 4)
$decimalCode = '1123'
$countryCode = 'ps-AF'
$langName = 'Pashto'
Case Hex(0x0464, 4)
$decimalCode = '1124'
$countryCode = 'fil-PH'
$langName = 'Filipino'
Case Hex(0x0465, 4)
$decimalCode = '1125'
$countryCode = 'dv-MV'
$langName = 'Divehi'
Case Hex(0x0468, 4)
$decimalCode = '1128'
$countryCode = 'ha-Latn-NG'
$langName = 'Hausa'
Case Hex(0x046A, 4)
$decimalCode = '1130'
$countryCode = 'yo-NG'
$langName = 'Yoruba'
Case Hex(0x046B, 4)
$decimalCode = '1131'
$countryCode = 'quz-BO'
$langName = 'Quechua'
Case Hex(0x046C, 4)
$decimalCode = '1132'
$countryCode = 'nso-ZA'
$langName = 'Sesotho'
Case Hex(0x046D, 4)
$decimalCode = '1133'
$countryCode = 'ba-RU'
$langName = 'Bashkir'
Case Hex(0x046E, 4)
$decimalCode = '1134'
$countryCode = 'lb-LU'
$langName = 'Luxembourgish'
Case Hex(0x046F, 4)
$decimalCode = '1135'
$countryCode = 'kl-GL'
$langName = 'Greenlandic'
Case Hex(0x0470, 4)
$decimalCode = '1136'
$countryCode = 'ig-NG'
$langName = 'Igbo'
Case Hex(0x0473, 4)
$decimalCode = '1139'
$countryCode = 'ti-ET'
$langName = 'Tigrinya'
Case Hex(0x0475, 4)
$decimalCode = '1141'
$countryCode = 'haw-US'
$langName = 'Hawiian'
Case Hex(0x0478, 4)
$decimalCode = '1144'
$countryCode = 'ii-CN'
$langName = 'Yi'
Case Hex(0x047A, 4)
$decimalCode = '1146'
$countryCode = 'arn-CL'
$langName = 'Mapudungun'
Case Hex(0x047C, 4)
$decimalCode = '1148'
$countryCode = 'moh-CA'
$langName = 'Mohawk'
Case Hex(0x047E, 4)
$decimalCode = '1150'
$countryCode = 'br-FR'
$langName = 'Breton'
Case Hex(0x0480, 4)
$decimalCode = '1152'
$countryCode = 'ug-CN'
$langName = 'Uyghur'
Case Hex(0x0481, 4)
$decimalCode = '1153'
$countryCode = 'mi-NZ'
$langName = 'Maori'
Case Hex(0x0482, 4)
$decimalCode = '1154'
$countryCode = 'oc-FR'
$langName = 'Occitan'
Case Hex(0x0483, 4)
$decimalCode = '1155'
$countryCode = 'co-FR'
$langName = 'Corsican'
Case Hex(0x0484, 4)
$decimalCode = '1156'
$countryCode = 'gsw-FR'
$langName = 'Alsatian'
Case Hex(0x0485, 4)
$decimalCode = '1157'
$countryCode = 'sah-RU'
$langName = 'Sakha'
Case Hex(0x0486, 4)
$decimalCode = '1158'
$countryCode = 'quc-Latn-GT'
$langName = "K'iche"
Case Hex(0x0487, 4)
$decimalCode = '1159'
$countryCode = 'rw-RW'
$langName = 'Kinyarwanda'
Case Hex(0x0488, 4)
$decimalCode = '1160'
$countryCode = 'wo-SN'
$langName = 'Wolof'
Case Hex(0x048C, 4)
$decimalCode = '1164'
$countryCode = 'prs-AF'
$langName = 'Dari'
Case Hex(0x0491, 4)
$decimalCode = '1169'
$countryCode = 'gd-GB'
$langName = 'Scottish'
Case Hex(0x0492, 4)
$decimalCode = '1170'
$countryCode = 'ku-Arab-IQ'
$langName = 'Central'
Case Hex(0x0801, 4)
$decimalCode = '2049'
$countryCode = 'ar-IQ'
$langName = 'Arabic'
Case Hex(0x0803, 4)
$decimalCode = '2051'
$countryCode = 'ca-ES-valencia'
$langName = 'Valencian'
Case Hex(0x0804, 4)
$decimalCode = '2052'
$countryCode = 'zh-CN'
$langName = 'Chinese_S'
Case Hex(0x0807, 4)
$decimalCode = '2055'
$countryCode = 'de-CH'
$langName = 'German'
Case Hex(0x0809, 4)
$decimalCode = '2057'
$countryCode = 'en-GB'
$langName = 'English'
Case Hex(0x080A, 4)
$decimalCode = '2058'
$countryCode = 'es-MX'
$langName = 'Spanish'
Case Hex(0x080C, 4)
$decimalCode = '2060'
$countryCode = 'fr-BE'
$langName = 'French'
Case Hex(0x0810, 4)
$decimalCode = '2064'
$countryCode = 'it-CH'
$langName = 'Italian'
Case Hex(0x0813, 4)
$decimalCode = '2067'
$countryCode = 'nl-BE'
$langName = 'Dutch'
Case Hex(0x0814, 4)
$decimalCode = '2068'
$countryCode = 'nn-NO'
$langName = 'Norwegian'
Case Hex(0x0816, 4)
$decimalCode = '2070'
$countryCode = 'pt-PT'
$langName = 'Portuguese'
Case Hex(0x081A, 4)
$decimalCode = '2074'
$countryCode = 'sr-Latn-CS'
$langName = 'Serbian'
Case Hex(0x081D, 4)
$decimalCode = '2077'
$countryCode = 'sv-FI'
$langName = 'Swedish'
Case Hex(0x0820, 4)
$decimalCode = '2080'
$countryCode = 'ur-IN'
$langName = 'Urdu'
Case Hex(0x082C, 4)
$decimalCode = '2092'
$countryCode = 'az-Cyrl-AZ'
$langName = 'Azeri'
Case Hex(0x082E, 4)
$decimalCode = '2094'
$countryCode = 'dsb-DE'
$langName = 'Lower'
Case Hex(0x0832, 4)
$decimalCode = '2098'
$countryCode = 'tn-BW'
$langName = 'Setswana'
Case Hex(0x083B, 4)
$decimalCode = '2107'
$countryCode = 'se-SE'
$langName = 'Sami'
Case Hex(0x083C, 4)
$decimalCode = '2108'
$countryCode = 'ga-IE'
$langName = 'Irish'
Case Hex(0x083E, 4)
$decimalCode = '2110'
$countryCode = 'ms-BN'
$langName = 'Malay'
Case Hex(0x0843, 4)
$decimalCode = '2115'
$countryCode = 'uz-Cyrl-UZ'
$langName = 'Uzbek'
Case Hex(0x0845, 4)
$decimalCode = '2117'
$countryCode = 'bn-BD'
$langName = 'Bangla'
Case Hex(0x0846, 4)
$decimalCode = '2118'
$countryCode = 'pa-Arab-PK'
$langName = 'Punjabi'
Case Hex(0x0849, 4)
$decimalCode = '2121'
$countryCode = 'ta-LK'
$langName = 'Tamil'
Case Hex(0x0850, 4)
$decimalCode = '2128'
$countryCode = 'mn-Mong-CN'
$langName = 'Mongolian'
Case Hex(0x0859, 4)
$decimalCode = '2137'
$countryCode = 'sd-Arab-PK'
$langName = 'Sindhi'
Case Hex(0x085D, 4)
$decimalCode = '2141'
$countryCode = 'iu-Latn-CA'
$langName = 'Inuktitut'
Case Hex(0x085F, 4)
$decimalCode = '2143'
$countryCode = 'tzm-Latn-DZ'
$langName = 'Tamazight'
Case Hex(0x0867, 4)
$decimalCode = '2151'
$countryCode = 'ff-Latn-SN'
$langName = 'Pular'
Case Hex(0x086B, 4)
$decimalCode = '2155'
$countryCode = 'quz-EC'
$langName = 'Quechua'
Case Hex(0x0873, 4)
$decimalCode = '2163'
$countryCode = 'ti-ER'
$langName = '(reserved)'
Case Hex(0x0873, 4)
$decimalCode = '2163'
$countryCode = 'ti-ER'
$langName = 'Tigrinya'
Case Hex(0x0C01, 4)
$decimalCode = '3073'
$countryCode = 'ar-EG'
$langName = 'Arabic'
Case Hex(0x0C04, 4)
$decimalCode = '3076'
$countryCode = 'zh-HK'
$langName = 'Chinese_T'
Case Hex(0x0C07, 4)
$decimalCode = '3079'
$countryCode = 'de-AT'
$langName = 'German'
Case Hex(0x0C09, 4)
$decimalCode = '3081'
$countryCode = 'en-AU'
$langName = 'English'
Case Hex(0x0C0A, 4)
$decimalCode = '3082'
$countryCode = 'es-ES'
$langName = 'Spanish'
Case Hex(0x0C0C, 4)
$decimalCode = '3084'
$countryCode = 'fr-CA'
$langName = 'French'
Case Hex(0x0C1A, 4)
$decimalCode = '3098'
$countryCode = 'sr-Cyrl-CS'
$langName = 'Serbian'
Case Hex(0x0C3B, 4)
$decimalCode = '3131'
$countryCode = 'se-FI'
$langName = 'Sami'
Case Hex(0x0C6B, 4)
$decimalCode = '3179'
$countryCode = 'quz-PE'
$langName = 'Quechua'
Case Hex(0x1001, 4)
$decimalCode = '4097'
$countryCode = 'ar-LY'
$langName = 'Arabic'
Case Hex(0x1004, 4)
$decimalCode = '4100'
$countryCode = 'zh-SG'
$langName = 'Chinese_S'
Case Hex(0x1007, 4)
$decimalCode = '4103'
$countryCode = 'de-LU'
$langName = 'German'
Case Hex(0x1009, 4)
$decimalCode = '4105'
$countryCode = 'en-CA'
$langName = 'English'
Case Hex(0x100A, 4)
$decimalCode = '4106'
$countryCode = 'es-GT'
$langName = 'Spanish'
Case Hex(0x100C, 4)
$decimalCode = '4108'
$countryCode = 'fr-CH'
$langName = 'French'
Case Hex(0x101A, 4)
$decimalCode = '4122'
$countryCode = 'hr-BA'
$langName = 'Croatian'
Case Hex(0x103B, 4)
$decimalCode = '4155'
$countryCode = 'smj-NO'
$langName = 'Sami'
Case Hex(0x105F, 4)
$decimalCode = '4191'
$countryCode = 'tzm-Tfng-MA'
$langName = 'Central'
Case Hex(0x1401, 4)
$decimalCode = '5121'
$countryCode = 'ar-DZ'
$langName = 'Arabic'
Case Hex(0x1404, 4)
$decimalCode = '5124'
$countryCode = 'zh-MO'
$langName = 'Chinese_T'
Case Hex(0x1407, 4)
$decimalCode = '5127'
$countryCode = 'de-LI'
$langName = 'German'
Case Hex(0x1409, 4)
$decimalCode = '5129'
$countryCode = 'en-NZ'
$langName = 'English'
Case Hex(0x140A, 4)
$decimalCode = '5130'
$countryCode = 'es-CR'
$langName = 'Spanish'
Case Hex(0x140C, 4)
$decimalCode = '5132'
$countryCode = 'fr-LU'
$langName = 'French'
Case Hex(0x141A, 4)
$decimalCode = '5146'
$countryCode = 'bs-Latn-BA'
$langName = 'Bosnian'
Case Hex(0x143B, 4)
$decimalCode = '5179'
$countryCode = 'smj-SE'
$langName = 'Sami'
Case Hex(0x1801, 4)
$decimalCode = '6145'
$countryCode = 'ar-MA'
$langName = 'Arabic'
Case Hex(0x1809, 4)
$decimalCode = '6153'
$countryCode = 'en-IE'
$langName = 'English'
Case Hex(0x180A, 4)
$decimalCode = '6154'
$countryCode = 'es-PA'
$langName = 'Spanish'
Case Hex(0x180C, 4)
$decimalCode = '6156'
$countryCode = 'fr-MC'
$langName = 'French'
Case Hex(0x181A, 4)
$decimalCode = '6170'
$countryCode = 'sr-Latn-BA'
$langName = 'Serbian'
Case Hex(0x183B, 4)
$decimalCode = '6203'
$countryCode = 'sma-NO'
$langName = 'Sami'
Case Hex(0x1C01, 4)
$decimalCode = '7169'
$countryCode = 'ar-TN'
$langName = 'Arabic'
Case Hex(0x1c09, 4)
$decimalCode = '7177'
$countryCode = 'en-ZA'
$langName = 'English'
Case Hex(0x1C0A, 4)
$decimalCode = '7178'
$countryCode = 'es-DO'
$langName = 'Spanish'
Case Hex(0x1C1A, 4)
$decimalCode = '7194'
$countryCode = 'sr-Cyrl-BA'
$langName = 'Serbian'
Case Hex(0x1C3B, 4)
$decimalCode = '7227'
$countryCode = 'sma-SE'
$langName = 'Sami'
Case Hex(0x2001, 4)
$decimalCode = '8193'
$countryCode = 'ar-OM'
$langName = 'Arabic'
Case Hex(0x2009, 4)
$decimalCode = '8201'
$countryCode = 'en-JM'
$langName = 'English'
Case Hex(0x200A, 4)
$decimalCode = '8202'
$countryCode = 'es-VE'
$langName = 'Spanish'
Case Hex(0x201A, 4)
$decimalCode = '8218'
$countryCode = 'bs-Cyrl-BA'
$langName = 'Bosnian'
Case Hex(0x203B, 4)
$decimalCode = '8251'
$countryCode = 'sms-FI'
$langName = 'Sami'
Case Hex(0x2401, 4)
$decimalCode = '9217'
$countryCode = 'ar-YE'
$langName = 'Arabic'
Case Hex(0x2409, 4)
$decimalCode = '9225'
$countryCode = 'en-029'
$langName = 'English'
Case Hex(0x240A, 4)
$decimalCode = '9226'
$countryCode = 'es-CO'
$langName = 'Spanish'
Case Hex(0x241A, 4)
$decimalCode = '9242'
$countryCode = 'sr-Latn-RS'
$langName = 'Serbian'
Case Hex(0x243B, 4)
$decimalCode = '9275'
$countryCode = 'smn-FI'
$langName = 'Sami'
Case Hex(0x2801, 4)
$decimalCode = '10241'
$countryCode = 'ar-SY'
$langName = 'Arabic'
Case Hex(0x2809, 4)
$decimalCode = '10249'
$countryCode = 'en-BZ'
$langName = 'English'
Case Hex(0x280A, 4)
$decimalCode = '10250'
$countryCode = 'es-PE'
$langName = 'Spanish'
Case Hex(0x281A, 4)
$decimalCode = '10266'
$countryCode = 'sr-Cyrl-RS'
$langName = 'Serbian'
Case Hex(0x2C01, 4)
$decimalCode = '11265'
$countryCode = 'ar-JO'
$langName = 'Arabic'
Case Hex(0x2C09, 4)
$decimalCode = '11273'
$countryCode = 'en-TT'
$langName = 'English'
Case Hex(0x2C0A, 4)
$decimalCode = '11274'
$countryCode = 'es-AR'
$langName = 'Spanish'
Case Hex(0x2C1A, 4)
$decimalCode = '11290'
$countryCode = 'sr-Latn-ME'
$langName = 'Serbian'
Case Hex(0x3001, 4)
$decimalCode = '12289'
$countryCode = 'ar-LB'
$langName = 'Arabic'
Case Hex(0x3009, 4)
$decimalCode = '12297'
$countryCode = 'en-ZW'
$langName = 'English'
Case Hex(0x300A, 4)
$decimalCode = '12298'
$countryCode = 'es-EC'
$langName = 'Spanish'
Case Hex(0x301A, 4)
$decimalCode = '12314'
$countryCode = 'sr-Cyrl-ME'
$langName = 'Serbian'
Case Hex(0x3401, 4)
$decimalCode = '13313'
$countryCode = 'ar-KW'
$langName = 'Arabic'
Case Hex(0x3409, 4)
$decimalCode = '13321'
$countryCode = 'en-PH'
$langName = 'English'
Case Hex(0x340A, 4)
$decimalCode = '13322'
$countryCode = 'es-CL'
$langName = 'Spanish'
Case Hex(0x3801, 4)
$decimalCode = '14337'
$countryCode = 'ar-AE'
$langName = 'Arabic'
Case Hex(0x380A, 4)
$decimalCode = '14346'
$countryCode = 'es-UY'
$langName = 'Spanish'
Case Hex(0x3C01, 4)
$decimalCode = '15361'
$countryCode = 'ar-BH'
$langName = 'Arabic'
Case Hex(0x3C0A, 4)
$decimalCode = '15370'
$countryCode = 'es-PY'
$langName = 'Spanish'
Case Hex(0x4001, 4)
$decimalCode = '16385'
$countryCode = 'ar-QA'
$langName = 'Arabic'
Case Hex(0x4009, 4)
$decimalCode = '16393'
$countryCode = 'en-IN'
$langName = 'English'
Case Hex(0x400A, 4)
$decimalCode = '16394'
$countryCode = 'es-BO'
$langName = 'Spanish'
Case Hex(0x4409, 4)
$decimalCode = '17417'
$countryCode = 'en-MY'
$langName = 'English'
Case Hex(0x440A, 4)
$decimalCode = '17418'
$countryCode = 'es-SV'
$langName = 'Spanish'
Case Hex(0x4809, 4)
$decimalCode = '18441'
$countryCode = 'en-SG'
$langName = 'English'
Case Hex(0x480A, 4)
$decimalCode = '18442'
$countryCode = 'es-HN'
$langName = 'Spanish'
Case Hex(0x4C0A, 4)
$decimalCode = '19466'
$countryCode = 'es-NI'
$langName = 'Spanish'
Case Hex(0x500A, 4)
$decimalCode = '20490'
$countryCode = 'es-PR'
$langName = 'Spanish'
Case Hex(0x540A, 4)
$decimalCode = '21514'
$countryCode = 'es-US'
$langName = 'Spanish'
Case Hex(0x7C04, 4)
$decimalCode = '31748'
$countryCode = 'zh-CHT'
$langName = 'Chinese_T'
Case Else
SetLog("Your computer's language was not recognized.")
$langName = "NONE"
EndSwitch
SetLog("Detected System Locale: " & $langName, $COLOR_INFO)
If FileExists($g_sDirLanguages & "/" & $langName & ".ini") Then
SetLog("Language file " & $langName & ".ini found in " & $g_sDirLanguages)
$g_sLanguage = $langName
If FileExists($g_sProfileConfigPath) Then IniWrite($g_sProfileConfigPath, "other", "language", $g_sLanguage)
Else
SetLog("Language file for " & $langName & " not found! Defaulting to English", $COLOR_ERROR)
$g_sLanguage = $g_sDefaultLanguage
EndIf
Else
$g_sLanguage = IniRead($g_sProfileConfigPath, "other", "language", $g_sDefaultLanguage)
EndIf
EndFunc
Func GetTranslatedFileIni($iSection = -1, $iKey = -1, $sText = "", $var1 = Default, $var2 = Default, $var3 = Default)
Static $aNewLanguage[1][2]
$sText = StringReplace($sText, @CRLF, "\r\n")
Local $sDefaultText, $g_sLanguageText
Local $SearchInLanguage = $iSection & "§" & $iKey
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
Return GetTranslatedParsedText($aNewLanguage[$result][1], $var1, $var2, $var3)
EndIf
If $g_sLanguage = $g_sDefaultLanguage Then
$sDefaultText = IniRead($g_sDirLanguages & $g_sDefaultLanguage & ".ini", $iSection, $iKey, "-3")
If $sText = "-1" Then
If $sDefaultText <> "-3" Then
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sDefaultText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
EndIf
Return $sDefaultText
Else
Return "-3"
EndIf
EndIf
If $sDefaultText <> $sText Then
Local $ini_file = $g_sDirLanguages & $g_sDefaultLanguage & ".ini"
Local $aSection[1][2] = [[$iKey, $sText]]
Local $Count = 1
Local $aKey = IniReadSection($ini_file, $iSection)
If IsArray($aKey) Then
For $i = 1 To $aKey[0][0]
If _ArraySearch($aSection, $aKey[$i][0], 0, 0, 0, 0, 1, 0) = -1 Then
$Count += 1
ReDim $aSection[$Count][2]
$aSection[$Count - 1][0] = $aKey[$i][0]
$aSection[$Count - 1][1] = $aKey[$i][1]
EndIf
Next
EndIf
_ArraySort($aSection, 0, 0, 0, 0)
IniWriteSection($ini_file, $iSection, $aSection, 0)
$sText = GetTranslatedParsedText($sText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $sText
Else
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sDefaultText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $sDefaultText
EndIf
Else
$g_sLanguageText = IniRead($g_sDirLanguages & $g_sLanguage & ".ini", $iSection, $iKey, "-3")
If $sText = "-1" Then
If $g_sLanguageText = "-3" Then
$sDefaultText = IniRead($g_sDirLanguages & $g_sDefaultLanguage & ".ini", $iSection, $iKey, $sText)
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sDefaultText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $sDefaultText
Else
$g_sLanguageText = GetTranslatedParsedText($g_sLanguageText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $g_sLanguageText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $g_sLanguageText
EndIf
EndIf
If $g_sLanguageText = "-3" Then
Local $ini_file = $g_sDirLanguages & $g_sLanguage & ".ini"
Local $aSection[1][2] = [[$iKey, $sText]]
Local $Count = 1
Local $aKey = IniReadSection($ini_file, $iSection)
If IsArray($aKey) Then
For $i = 1 To $aKey[0][0]
If _ArraySearch($aSection, $aKey[$i][0], 0, 0, 0, 0, 1, 0) = -1 Then
$Count += 1
ReDim $aSection[$Count][2]
$aSection[$Count - 1][0] = $aKey[$i][0]
$aSection[$Count - 1][1] = $aKey[$i][1]
EndIf
Next
EndIf
_ArraySort($aSection, 0, 0, 0, 0)
IniWriteSection($ini_file, $iSection, $aSection, 0)
$sText = GetTranslatedParsedText($sText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $sText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $sText
EndIf
$g_sLanguageText = GetTranslatedParsedText($g_sLanguageText, $var1, $var2, $var3)
Local $result = _ArraySearch($aNewLanguage, $SearchInLanguage, 0, 0, 0, 0, 0)
If $result <> -1 Then
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][0] = $SearchInLanguage
$aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) - 1][1] = $g_sLanguageText
ReDim $aNewLanguage[UBound($aNewLanguage, $UBOUND_ROWS) + 1][2]
Else
EndIf
Return $g_sLanguageText
EndIf
EndFunc
Func _ReadFullIni()
Local $ini_file = $g_sDirLanguages & $g_sDefaultLanguage & ".ini"
Static $aNewLanguage[1][2]
Local $Count = 1
Local $aSection = IniReadSectionNames($ini_file)
For $i = 1 To UBound($aSection) - 1
Local $aKey = IniReadSection($ini_file, $aSection[$i])
If IsArray($aKey) Then
ReDim $aNewLanguage[$Count + UBound($aKey) - 1][2]
For $j = 1 To Ubound($aKey) - 1
If _ArraySearch($aNewLanguage, $aSection[$i] & "§" & $aKey[$j][0], 0, 0, 0, 0, 1, 0) = -1 Then
$aNewLanguage[$Count][0] = $aSection[$i] & "§" & $aKey[$j][0]
$aNewLanguage[$Count][1] = $aKey[$j][1]
$Count += 1
EndIf
Next
Else
ReDim $aNewLanguage[$Count + 1][2]
$aNewLanguage[$Count][0] = $aSection[$i]
$Count += 1
EndIf
Next
EndFunc
ReferenceFunctions()
ReferenceGlobals()
Func ReferenceFunctions()
If True Then Return
Local $a1, $a2
BotMoveRequest()
BotMinimizeRequest()
FindPreferredAdbPath()
CloseVboxAndroidSvc()
SetScreenAndroid()
WaitForRunningVMS()
WaitForAndroidBootCompleted()
RebootAndroidSetScreenDefault()
AndroidSetFontSizeNormal()
AndroidCloseSystemBar()
AndroidOpenSystemBar()
AndroidPicturePathAutoConfig()
_ShortcutAppId(0)
_GUICtrlGetControlID()
IsStopped()
GetFont()
btnConfigureCollectors()
btnConfigureReduction()
btnConfigureTHBully()
btnConfigureDBWeakBase()
btnConfigureABWeakBase()
EnableSearchPanels(0)
btnTestTHcsv()
btnConfigureReplayShare()
btnLoots()
btnLogs()
AttackCSVAssignDefaultScriptName()
GUIControl_WM_SYSCOMMAND(0, 0, 0, 0)
RedrawBotWindowNow()
_GUICtrlListView_SetItemHeightByFont(0, 0)
_GUICtrlListView_GetHeightToFitRows(0, 0)
SortRedline(0, 0, 0)
_SortRedline(0)
FindClosestToAxis(0)
GetSlotIndexFromXPos(0)
CheckFullBarrack()
GetCurTotalDarkSpell()
IsElixirTroop(0)
TestTroopsCoords()
TestSpellsCoords()
TestTrainRevamp2()
checkDeadBaseNew()
GetDeployableNextTo(0)
decodeTroopEnum(0)
decodeTroopName(0)
GUISetFont_DPI(0)
SetDPI()
_SysTrayIconTitles()
_SysTrayIconPids()
_SysTrayIconProcesses()
_SysTrayIconIndex(0)
_SysTrayIconTooltip(0)
_SysTrayIconPos(0)
_SysTrayIconVisible(0)
_SysTrayIconHide(0, 0)
_SysTrayIconMove(0, 0)
ZoomOutBlueStacks()
ZoomOutBlueStacks2()
ZoomOutMEmu()
ZoomOutDroid4X()
ZoomOutNox()
DefaultZoomOut()
ZoomOutCtrlWheelScroll()
ZoomOutCtrlClick()
OpenBS()
OpenBlueStacks()
OpenBlueStacks2()
InitBlueStacksX()
InitBlueStacks()
InitBlueStacks2()
RestartBlueStacksXCoC()
RestartBlueStacksCoC()
RestartBlueStacks2CoC()
CheckScreenBlueStacksX()
CheckScreenBlueStacks()
CheckScreenBlueStacks2()
SetScreenBlueStacks()
SetScreenBlueStacks2()
RebootBlueStacksSetScreen()
ConfigBlueStacks2WindowManager()
RebootBlueStacks2SetScreen()
GetBlueStacksRunningInstance()
GetBlueStacks2RunningInstance()
GetBlueStacksProgramParameter()
GetBlueStacks2ProgramParameter()
BlueStacksBotStartEvent()
BlueStacksBotStopEvent()
BlueStacks2BotStartEvent()
BlueStacks2BotStopEvent()
BlueStacksAdjustClickCoordinates($a1, $a2)
BlueStacks2AdjustClickCoordinates($a1, $a2)
GetBlueStacksAdbPath()
GetBlueStacks2AdbPath()
GetDroid4XAdbPath()
DisableBS(0, 0)
EnableBS(0, 0)
GetBlueStacksSvcPid()
CloseBlueStacks()
CloseBlueStacks2()
KillBSProcess()
ServiceStop(0)
CloseUnsupportedBlueStacks2()
OpenDroid4X()
GetDroid4XProgramParameter()
GetDroid4XPath()
GetDroid4XAdbPath()
InitDroid4X()
SetScreenDroid4X()
RebootDroid4XSetScreen()
CheckScreenDroid4X()
UpdateDroid4XConfig()
UpdateDroid4XWindowState()
CloseDroid4X()
OpenMEmu()
GetMEmuProgramParameter()
GetMEmuPath()
GetMEmuAdbPath()
InitMEmu()
SetScreenMEmu()
RebootMEmuSetScreen()
CloseMEmu()
CheckScreenMEmu()
UpdateMEmuConfig()
UpdateMEmuWindowState()
OpenLeapDroid()
IsLeapDroidCommandLine(0)
GetLeapDroidProgramParameter()
GetLeapDroidPath()
GetLeapDroidAdbPath()
InitLeapDroid()
UpdateLeapdroidSettings($a1, 0, 0)
SetScreenLeapDroid()
RebootLeapDroidSetScreen()
CloseLeapDroid()
CheckScreenLeapDroid()
EmbedLeapDroid()
LeapDroidBotStartEvent()
LeapDroidBotStopEvent()
OpenNox()
IsNoxCommandLine(0)
GetNoxProgramParameter()
GetNoxRtPath()
GetNoxPath()
GetNoxAdbPath()
InitNox()
SetScreenNox()
RebootNoxSetScreen()
CloseNox()
CheckScreenNox()
GetNoxRunningInstance()
RedrawNoxWindow()
HideNoxWindow()
EmbedNox()
OpenKOPLAYER()
GetKOPLAYERProgramParameter()
IsKOPLAYERCommandLine(0)
GetKOPLAYERPath()
GetKOPLAYERAdbPath()
InitKOPLAYER()
SetScreenKOPLAYER()
RebootKOPLAYERSetScreen()
CloseKOPLAYER()
CheckScreenKOPLAYER()
EmbedKOPLAYER()
OpeniTools()
IsiToolsCommandLine(0)
GetiToolsProgramParameter()
GetiToolsPath()
GetiToolsAdbPath()
InitiTools()
SetScreeniTools()
RebootiToolsSetScreen()
CloseiTools()
CheckScreeniTools()
HideiToolsWindow()
EmbediTools()
AndroidEmbedded()
_ProcessSuspendResume2(0)
__EnumDefaultProc(0, 0)
__EnumPageFilesProc(0, 0, 0)
GemClickP(0, 0)
SetGuiLog(0)
Tab(0, 0)
isNetFramework4Installed()
WinGetPos2(0)
ControlGetPos2(0, 0, 0)
WindowSystemMenu(0, 0)
IsMainChatOpenPage()
IsClanInfoPage()
IsPixelColorGray(0)
_MultiPixelSearch2(0, 0, 0, 0, 0, 0, 0, 0, 0)
getBarracksTroopQuantity(0, 0)
getOcrOverAllDamage(0, 0)
returnAllMatches(0)
returnLowestLevelSingleMatch(0)
updateGlobalVillageOffset(0, 0)
GemClickR(0, 0, 0)
GetBlueStacksBackgroundMode()
GetBlueStacks2BackgroundMode()
GetDroid4XBackgroundMode()
GetKOPLAYERBackgroundMode()
GetMEmuBackgroundMode()
GetNoxBackgroundMode()
ConfigureSharedFolderBlueStacks()
ConfigureSharedFolderBlueStacks2()
getChatString(0, 0, 0)
getChatStringChinese(0, 0)
getChatStringKorean(0, 0)
getChatStringPersian(0, 0)
EndFunc
Func ReferenceGlobals()
If True Then Return
Local $a1
$a1 = $g_aaiTroopsToBeUsed
$a1 = $g_asMilkFarmOffsetMine
$a1 = $g_asMilkFarmOffsetElixir
$a1 = $g_asMilkFarmOffsetDark
$a1 = $aArmyCCRemainTime
$a1 = $aIsReloadError
$a1 = $g_iAndroidControlClickWindow
$a1 = $ATTACKVECTOR_A
$a1 = $ATTACKVECTOR_B
$a1 = $ATTACKVECTOR_C
$a1 = $ATTACKVECTOR_D
$a1 = $ATTACKVECTOR_E
$a1 = $ATTACKVECTOR_F
$a1 = $ATTACKVECTOR_G
$a1 = $ATTACKVECTOR_H
$a1 = $ATTACKVECTOR_I
$a1 = $ATTACKVECTOR_J
$a1 = $ATTACKVECTOR_K
$a1 = $ATTACKVECTOR_L
$a1 = $ATTACKVECTOR_M
$a1 = $ATTACKVECTOR_N
$a1 = $ATTACKVECTOR_O
$a1 = $ATTACKVECTOR_P
$a1 = $ATTACKVECTOR_Q
$a1 = $ATTACKVECTOR_R
$a1 = $ATTACKVECTOR_S
$a1 = $ATTACKVECTOR_T
$a1 = $ATTACKVECTOR_U
$a1 = $ATTACKVECTOR_V
$a1 = $ATTACKVECTOR_W
$a1 = $ATTACKVECTOR_X
$a1 = $ATTACKVECTOR_Y
$a1 = $ATTACKVECTOR_Z
$a1 = $eIcnArcher
$a1 = $eIcnDonArcher
$a1 = $eIcnBalloon
$a1 = $eIcnDonBalloon
$a1 = $eIcnBarbarian
$a1 = $eIcnDonBarbarian
$a1 = $eBtnTest
$a1 = $eIcnBuilder
$a1 = $eIcnCC
$a1 = $eIcnGUI
$a1 = $eIcnDark
$a1 = $eIcnDragon
$a1 = $eIcnDonDragon
$a1 = $eIcnDrill
$a1 = $eIcnElixir
$a1 = $eIcnCollector
$a1 = $eIcnFreezeSpell
$a1 = $eIcnGem
$a1 = $eIcnGiant
$a1 = $eIcnDonGiant
$a1 = $eIcnTrap
$a1 = $eIcnGoblin
$a1 = $eIcnDonGoblin
$a1 = $eIcnGold
$a1 = $eIcnGolem
$a1 = $eIcnDonGolem
$a1 = $eIcnHealer
$a1 = $eIcnDonHealer
$a1 = $eIcnHogRider
$a1 = $eIcnDonHogRider
$a1 = $eIcnHealSpell
$a1 = $eIcnInferno
$a1 = $eIcnJumpSpell
$a1 = $eIcnLavaHound
$a1 = $eIcnDonLavaHound
$a1 = $eIcnLightSpell
$a1 = $eIcnMinion
$a1 = $eIcnDonMinion
$a1 = $eIcnPekka
$a1 = $eIcnDonPekka
$a1 = $eIcnTreasury
$a1 = $eIcnRageSpell
$a1 = $eIcnTroops
$a1 = $eIcnHourGlass
$a1 = $eIcnTH1
$a1 = $eIcnTH10
$a1 = $eIcnTrophy
$a1 = $eIcnValkyrie
$a1 = $eIcnDonValkyrie
$a1 = $eIcnWall
$a1 = $eIcnWallBreaker
$a1 = $eIcnDonWallBreaker
$a1 = $eIcnWitch
$a1 = $eIcnDonWitch
$a1 = $eIcnWizard
$a1 = $eIcnDonWizard
$a1 = $eIcnXbow
$a1 = $eIcnBarrackBoost
$a1 = $eIcnMine
$a1 = $eIcnCamp
$a1 = $eIcnBarrack
$a1 = $eIcnSpellFactory
$a1 = $eIcnDonBlacklist
$a1 = $eIcnSpellFactoryBoost
$a1 = $eIcnMortar
$a1 = $eIcnWizTower
$a1 = $eIcnPayPal
$a1 = $eIcnNotify
$a1 = $eIcnGreenLight
$a1 = $eIcnLaboratory
$a1 = $eIcnRedLight
$a1 = $eIcnBlank
$a1 = $eIcnYellowLight
$a1 = $eIcnDonCustom
$a1 = $eIcnTombstone
$a1 = $eIcnSilverStar
$a1 = $eIcnGoldStar
$a1 = $eIcnDarkBarrack
$a1 = $eIcnCollectorLocate
$a1 = $eIcnDrillLocate
$a1 = $eIcnMineLocate
$a1 = $eIcnBarrackLocate
$a1 = $eIcnDarkBarrackLocate
$a1 = $eIcnDarkSpellFactoryLocate
$a1 = $eIcnDarkSpellFactory
$a1 = $eIcnEarthQuakeSpell
$a1 = $eIcnHasteSpell
$a1 = $eIcnPoisonSpell
$a1 = $eIcnBldgTarget
$a1 = $eIcnBldgX
$a1 = $eIcnRecycle
$a1 = $eIcnHeroes
$a1 = $eIcnBldgElixir
$a1 = $eIcnBldgGold
$a1 = $eIcnMagnifier
$a1 = $eIcnWallElixir
$a1 = $eIcnWallGold
$a1 = $eIcnKing
$a1 = $eIcnQueen
$a1 = $eIcnDarkSpellBoost
$a1 = $eIcnQueenBoostLocate
$a1 = $eIcnKingBoostLocate
$a1 = $eIcnKingUpgr
$a1 = $eIcnQueenUpgr
$a1 = $eIcnWardenUpgr
$a1 = $eIcnWarden
$a1 = $eIcnWardenBoostLocate
$a1 = $eIcnKingBoost
$a1 = $eIcnQueenBoost
$a1 = $eIcnWardenBoost
$a1 = $eEmpty3
$a1 = $eIcnReload
$a1 = $eIcnCopy
$a1 = $eIcnAddcvs
$a1 = $eIcnEdit
$a1 = $eIcnTreeSnow
$a1 = $eIcnSleepingQueen
$a1 = $eIcnSleepingKing
$a1 = $eIcnGoldElixir
$a1 = $eIcnBowler
$a1 = $eIcnDonBowler
$a1 = $eIcnCCDonate
$a1 = $eIcnEagleArt
$a1 = $eIcnGembox
$a1 = $eIcnInferno4
$a1 = $eIcnInfo
$a1 = $eIcnMain
$a1 = $eIcnTree
$a1 = $eIcnProfile
$a1 = $eIcnCCRequest
$a1 = $eIcnTelegram
$a1 = $eIcnTiles
$a1 = $eIcnXbow3
$a1 = $eIcnBark
$a1 = $eIcnDailyProgram
$a1 = $eIcnLootCart
$a1 = $eIcnSleepMode
$a1 = $eIcnTH11
$a1 = $eIcnTH12
$a1 = $eIcnTrainMode
$a1 = $eIcnSleepingWarden
$a1 = $eIcnCloneSpell
$a1 = $eIcnSkeletonSpell
$a1 = $eIcnBabyDragon
$a1 = $eIcnDonBabyDragon
$a1 = $eIcnMiner
$a1 = $eIcnDonMiner
$a1 = $eIcnNoShield
$a1 = $eIcnDonCustomB
$a1 = $eIcnAirdefense
$a1 = $eIcnDarkBarrackBoost
$a1 = $eIcnDarkElixirStorage
$a1 = $eIcnSpellsCost
$a1 = $eIcnTroopsCost
$a1 = $eIcnResetButton
$a1 = $eIcnNewSmartZap
$a1 = $eIcnTrain
$a1 = $eIcnAttack
$a1 = $eIcnDelay
$a1 = $eIcnReOrder
$a1 = $eIcn2Arrow
$a1 = $eIcnArrowLeft
$a1 = $eIcnArrowRight
$a1 = $eIcnAndroid
$a1 = $eHdV04
$a1 = $eHdV05
$a1 = $eHdV06
$a1 = $eHdV07
$a1 = $eHdV08
$a1 = $eHdV09
$a1 = $eHdV10
$a1 = $eHdV11
$a1 = $eHdV12
$a1 = $eUnranked
$a1 = $eBronze
$a1 = $eSilver
$a1 = $eGold
$a1 = $eCrystal
$a1 = $eMaster
$a1 = $eChampion
$a1 = $eTitan
$a1 = $eLegend
$a1 = $eWall04
$a1 = $eWall05
$a1 = $eWall06
$a1 = $eWall07
$a1 = $eWall08
$a1 = $eWall09
$a1 = $eWall10
$a1 = $eWall11
$a1 = $eIcnPBNotify
$a1 = $eIcnCCTroops
$a1 = $eIcnCCSpells
$a1 = $eIcnSpellsGroup
$a1 = $eBahasaIND
$a1 = $eChinese_S
$a1 = $eChinese_T
$a1 = $eEnglish
$a1 = $eFrench
$a1 = $eGerman
$a1 = $eItalian
$a1 = $ePersian
$a1 = $eRussian
$a1 = $eSpanish
$a1 = $eTurkish
$a1 = $eMissingLangIcon
$a1 = $eWall12
$a1 = $ePortuguese
$a1 = $eIcnDonPoisonSpell
$a1 = $eIcnDonEarthQuakeSpell
$a1 = $eIcnDonHasteSpell
$a1 = $eIcnDonSkeletonSpell
$a1 = $eVietnamese
$a1 = $eKorean
$a1 = $eTroopBarbarian
$a1 = $eTroopArcher
$a1 = $eTroopGiant
$a1 = $eTroopGoblin
$a1 = $eTroopWallBreaker
$a1 = $eTroopBalloon
$a1 = $eTroopWizard
$a1 = $eTroopHealer
$a1 = $eTroopDragon
$a1 = $eTroopPekka
$a1 = $eTroopBabyDragon
$a1 = $eTroopMiner
$a1 = $eTroopElectroDragon
$a1 = $eTroopMinion
$a1 = $eTroopHogRider
$a1 = $eTroopValkyrie
$a1 = $eTroopGolem
$a1 = $eTroopWitch
$a1 = $eTroopLavaHound
$a1 = $eTroopBowler
$a1 = $eTroopIceGolem
$a1 = $eTroopCount
$a1 = $eSpellLightning
$a1 = $eSpellHeal
$a1 = $eSpellRage
$a1 = $eSpellJump
$a1 = $eSpellFreeze
$a1 = $eSpellClone
$a1 = $eSpellPoison
$a1 = $eSpellEarthquake
$a1 = $eSpellHaste
$a1 = $eSpellSkeleton
$a1 = $eSpellBat
$a1 = $eSpellCount
$a1 = $eBarb
$a1 = $eArch
$a1 = $eGiant
$a1 = $eGobl
$a1 = $eWall
$a1 = $eBall
$a1 = $eWiza
$a1 = $eHeal
$a1 = $eDrag
$a1 = $ePekk
$a1 = $eBabyD
$a1 = $eMine
$a1 = $eEDrag
$a1 = $eMini
$a1 = $eHogs
$a1 = $eValk
$a1 = $eGole
$a1 = $eWitc
$a1 = $eLava
$a1 = $eBowl
$a1 = $eIceG
$a1 = $eKing
$a1 = $eQueen
$a1 = $eWarden
$a1 = $eCastle
$a1 = $eLSpell
$a1 = $eHSpell
$a1 = $eRSpell
$a1 = $eJSpell
$a1 = $eFSpell
$a1 = $eCSpell
$a1 = $ePSpell
$a1 = $eESpell
$a1 = $eHaSpell
$a1 = $eSkSpell
$a1 = $eBtSpell
$a1 = $aTrainBarb
$a1 = $aTrainArch
$a1 = $aTrainGiant
$a1 = $aTrainGobl
$a1 = $aTrainWall
$a1 = $aTrainBall
$a1 = $aTrainWiza
$a1 = $aTrainHeal
$a1 = $aTrainDrag
$a1 = $aTrainPekk
$a1 = $aTrainBabyD
$a1 = $aTrainMine
$a1 = $aTrainMini
$a1 = $aTrainHogs
$a1 = $aTrainValk
$a1 = $aTrainGole
$a1 = $aTrainWitc
$a1 = $aTrainLava
$a1 = $aTrainBowl
$a1 = $aTrainIceG
$a1 = $aTrainLSpell
$a1 = $aTrainHSpell
$a1 = $aTrainRSpell
$a1 = $aTrainJSpell
$a1 = $aTrainFSpell
$a1 = $aTrainCSpell
$a1 = $aTrainPSpell
$a1 = $aTrainESpell
$a1 = $aTrainHaSpell
$a1 = $aTrainSkSpell
$a1 = $aTrainBtSpell
$a1 = $aTrainArmy
$a1 = $aLoginWithSupercellID
$a1 = $aButtonLogOutSCID
$a1 = $aButtonConfirmSCID
$a1 = $aiCloseDefaultPOS
$a1 = $TELEGRAM_URL
$a1 = $HTTP_STATUS_OK
EndFunc
Opt("GUIResizeMode", $GUI_DOCKALL)
Opt("GUIEventOptions", 1)
Opt("GUICloseOnESC", 0)
Opt("WinTitleMatchMode", 3)
Opt("GUIOnEventMode", 1)
Opt("MouseClickDelay", $g_iAndroidControlClickDelay)
Opt("MouseClickDownDelay", $g_iAndroidControlClickDownDelay)
Opt("TrayMenuMode", 3)
Opt("TrayOnEventMode", 1)
InitializeBot()
MainLoop(CheckPrerequisites())
Func UpdateBotTitle()
Local $sTitle = "My Bot " & $g_sBotVersion & " - " & " AiO++ MOD " & $g_sModVersion & " -"
Local $sConsoleTitle
If $g_sBotTitle = "" Then
$g_sBotTitle = $sTitle
$sConsoleTitle = $sTitle
Else
$g_sBotTitle = $sTitle & " (" &($g_sAndroidInstance <> "" ? $g_sAndroidInstance : $g_sAndroidEmulator) & ")"
$sConsoleTitle = $sTitle & " " & $g_sAndroidEmulator & " (" &($g_sAndroidInstance <> "" ? $g_sAndroidInstance : $g_sAndroidEmulator) & ")"
EndIf
If $g_hFrmBot <> 0 Then
WinSetTitle($g_hFrmBot, "", $g_sBotTitle)
GUICtrlSetData($g_hLblBotTitle, $g_sBotTitle)
EndIf
DllCall("kernel32.dll", "bool", "SetConsoleTitle", "str", "Console " & $sConsoleTitle)
TraySetToolTip($g_sBotTitle)
SetDebugLog("Bot title updated to: " & $g_sBotTitle)
EndFunc
Func InitializeBot()
ProcessCommandLine()
If FileExists(@ScriptDir & "\EnableMBRDebug.txt") Then
$g_bDevMode = True
Local $aText = FileReadToArray(@ScriptDir & "\EnableMBRDebug.txt")
If Not @error Then
For $l = 0 To UBound($aText) - 1
If StringInStr($aText[$l], "DISABLEWATCHDOG", $STR_NOCASESENSEBASIC) <> 0 Then
$g_bBotLaunchOption_NoWatchdog = True
SetDebugLog("Watch Dog disabled by Developer Mode File Command", $COLOR_INFO)
EndIf
Next
EndIf
EndIf
SetupProfileFolder()
SetLogCentered(" BOT LOG ")
SetSwitchAccLog(_PadStringCenter(" SwitchAcc LOG ", 25, "="), $COLOR_BLACK, "Lucida Console", 8, False)
DetectLanguage()
If $g_iBotLaunchOption_Help Then
ShowCommandLineHelp()
Exit
EndIf
InitAndroidConfig()
Local $bConfigRead = FileExists($g_sProfileConfigPath)
If $bConfigRead Or FileExists($g_sProfileBuildingPath) Then
readConfig()
EndIf
Local $sAndroidInfo = ""
_Crypt_Startup()
__GDIPlus_Startup()
TCPStartup()
CreateMainGUI()
CreateSplashScreen()
If Not $g_bBotLaunchOption_NoWatchdog Then LaunchWatchdog()
InitializeMBR($sAndroidInfo, $bConfigRead)
CreateMainGUIControls()
InitializeMainGUI()
SetupFilesAndFolders()
ShowMainGUI()
If $g_iBotLaunchOption_Dock Then
If AndroidEmbed(True) And $g_iBotLaunchOption_Dock = 2 And $g_bCustomTitleBarActive Then
BotShrinkExpandToggle()
EndIf
EndIf
FinalInitialization($sAndroidInfo)
EndFunc
Func ProcessCommandLine()
If $CmdLine[0] > 0 Then
For $i = 1 To $CmdLine[0]
Local $bOptionDetected = True
Switch $CmdLine[$i]
Case "/restart", "/r", "-restart", "-r"
$g_bBotLaunchOption_Restart = True
Case "/autostart", "/a", "-autostart", "-a"
$g_bBotLaunchOption_Autostart = True
Case "/nowatchdog", "/nwd", "-nowatchdog", "-nwd"
$g_bBotLaunchOption_NoWatchdog = True
Case "/dpiaware", "/da", "-dpiaware", "-da"
$g_bBotLaunchOption_ForceDpiAware = True
Case "/dock1", "/d1", "-dock1", "-d1", "/dock", "/d", "-dock", "-d"
$g_iBotLaunchOption_Dock = 1
Case "/dock2", "/d2", "-dock2", "-d2"
$g_iBotLaunchOption_Dock = 2
Case "/nobotslot", "/nbs", "-nobotslot", "-nbs"
$g_bBotLaunchOption_NoBotSlot = True
Case "/debug", "/debugmode", "/dev", "/dm", "-debug", "-debugmode", "-dev", "-dm"
$g_bDevMode = True
Case "/minigui", "/mg", "-minigui", "-mg"
$g_iGuiMode = 2
Case "/nogui", "/ng", "-nogui", "-ng"
$g_iGuiMode = 0
Case "/hideandroid", "/ha", "-hideandroid", "-ha"
$g_bBotLaunchOption_HideAndroid = True
Case "/minimizebot", "/minbot", "/mb", "-minimizebot", "-minbot", "-mb"
$g_bBotLaunchOption_MinimizeBot = True
Case "/console", "/c", "-console", "-c"
$g_iBotLaunchOption_Console = True
ConsoleWindow()
Case "/?", "/h", "/help", "-?", "-h", "-help"
$g_iBotLaunchOption_Help = True
Case Else
If StringInStr($CmdLine[$i], "/guipid=") Then
Local $guidpid = Int(StringMid($CmdLine[$i], 9))
If ProcessExists($guidpid) Then
$g_iGuiPID = $guidpid
Else
SetDebugLog("GUI Process doesn't exist: " & $guidpid)
EndIf
ElseIf StringInStr($CmdLine[$i], "/profiles=") = 1 Then
Local $sProfilePath = StringMid($CmdLine[$i], 11)
If StringInStr(FileGetAttrib($sProfilePath), "D") Then
$g_sProfilePath = $sProfilePath
Else
SetLog("Profiles Path doesn't exist: " & $sProfilePath, $COLOR_ERROR)
EndIf
Else
$bOptionDetected = False
$g_asCmdLine[0] += 1
ReDim $g_asCmdLine[$g_asCmdLine[0] + 1]
$g_asCmdLine[$g_asCmdLine[0]] = $CmdLine[$i]
EndIf
EndSwitch
If $bOptionDetected Then SetDebugLog("Command Line Option detected: " & $CmdLine[$i])
Next
EndIf
If $g_asCmdLine[0] > 0 Then
$g_sProfileCurrentName = StringRegExpReplace($g_asCmdLine[1], '[/:*?"<>|]', '_')
If $g_asCmdLine[0] >= 2 Then
If StringInStr($g_asCmdLine[2], "BlueStacks3") Then $g_asCmdLine[2] = "BlueStacks2"
If StringInStr($g_asCmdLine[2], "BlueStacks4") Then $g_asCmdLine[2] = "BlueStacks2"
EndIf
ElseIf FileExists($g_sProfilePath & "\profile.ini") Then
$g_sProfileCurrentName = StringRegExpReplace(IniRead($g_sProfilePath & "\profile.ini", "general", "defaultprofile", ""), '[/:*?"<>|]', '_')
If $g_sProfileCurrentName = "" Or Not FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName) Then $g_sProfileCurrentName = "<No Profiles>"
Else
$g_sProfileCurrentName = "<No Profiles>"
EndIf
EndFunc
Func InitializeAndroid($bConfigRead)
Local $s = GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_06", "Initializing Android...")
SplashStep($s)
If $g_bBotLaunchOption_Restart = False Then
If $g_asCmdLine[0] > 1 Then
InitAndroidConfig(True)
Local $i
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
If StringCompare($g_avAndroidAppConfig[$i][0], $g_asCmdLine[2]) = 0 Then
$g_iAndroidConfig = $i
SplashStep($s & "(" & $g_avAndroidAppConfig[$i][0] & ")...", False)
If $g_avAndroidAppConfig[$i][1] <> "" And $g_asCmdLine[0] > 2 Then
UpdateAndroidConfig($g_asCmdLine[3])
Else
UpdateAndroidConfig()
EndIf
SplashStep($s & "(" & $g_avAndroidAppConfig[$i][0] & ")", False)
ExitLoop
EndIf
Next
EndIf
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "StatusBar_Item_07", "Detecting Android..."))
If $g_asCmdLine[0] < 2 And Not $bConfigRead Then
DetectRunningAndroid()
If Not $g_bFoundRunningAndroid Then DetectInstalledAndroid()
EndIf
Else
SplashStep($s)
EndIf
CleanSecureFiles()
GetCOCDistributors()
EndFunc
Func SetupProfileFolder()
SetDebugLog("SetupProfileFolder: " & $g_sProfilePath & "\" & $g_sProfileCurrentName)
$g_sProfileConfigPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\config.ini"
$g_sProfileBuildingStatsPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\stats_buildings.ini"
$g_sProfileBuildingPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\building.ini"
$g_sProfileLogsPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs\"
$g_sProfileLootsPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots\"
$g_sProfileTempPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp\"
$g_sProfileTempDebugPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp\Debug\"
$g_sProfileDonateCapturePath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\'
$g_sProfileDonateCaptureWhitelistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\White List\'
$g_sProfileDonateCaptureBlacklistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\Black List\'
EndFunc
Func InitializeMBR(ByRef $sAI, $bConfigRead)
If Not FileExists(@ScriptDir & "\License.txt") Then
Local $hDownload = InetGet("http://www.gnu.org/licenses/gpl-3.0.txt", @ScriptDir & "\License.txt")
Local $i = 0
Do
Sleep($DELAYDOWNLOADLICENSE)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
If Not FileExists(@ScriptDir & "\Languages") Then DirCreate(@ScriptDir & "\Languages")
_ReadFullIni()
TranslateTroopNames()
InitializeCOCDistributors()
Local $sMsg = GetTranslatedFileIni("MBR GUI Design - Loading", "Compile_Script", "Don't Run/Compile the Script as (x64)! Try to Run/Compile the Script as (x86) to get the bot to work.\r\n" & "If this message still appears, try to re-install AutoIt.")
If @AutoItX64 = 1 Then
DestroySplashScreen()
MsgBox(0, "", $sMsg)
__GDIPlus_Shutdown()
Exit
EndIf
InitializeAndroid($bConfigRead)
UpdateBotTitle()
UpdateSplashTitle($g_sBotTitle & GetTranslatedFileIni("MBR GUI Design - Loading", "Loading_Profile", ", Profile: %s", $g_sProfileCurrentName))
If $g_bBotLaunchOption_Restart = True Then
If CloseRunningBot($g_sBotTitle, True) Then
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "Closing_previous", "Closing previous bot..."), False)
If CloseRunningBot($g_sBotTitle) = True Then
Sleep(3000)
WinGetAndroidHandle()
EndIf
EndIf
EndIf
Local $cmdLineHelp = GetTranslatedFileIni("MBR GUI Design - Loading", "Commandline_multiple_Bots", "By using the commandline (or a shortcut) you can start multiple Bots:\r\n" & "     MyBot.run.exe [ProfileName] [EmulatorName] [InstanceName]\r\n\r\n" & "With the first command line parameter, specify the Profilename (you can create profiles on the Bot/Profiles tab, if a " & "profilename contains a {space}, then enclose the profilename in double quotes). " & "With the second, specify the name of the Emulator and with the third, an Android Instance (not for BlueStacks). \r\n" & "Supported Emulators are MEmu, Droid4X, Nox, BlueStacks2, BlueStacks, KOPlayer and LeapDroid.\r\n\r\n" & "Examples:\r\n" & "     MyBot.run.exe MyVillage BlueStacks2\r\n" & "     MyBot.run.exe ""My Second Village"" MEmu MEmu_1")
$g_hMutex_BotTitle = CreateMutex($g_sBotTitle)
$sAI = GetTranslatedFileIni("MBR GUI Design - Loading", "Android_instance_01", "%s", $g_sAndroidEmulator)
Local $sAndroidInfo2 = GetTranslatedFileIni("MBR GUI Design - Loading", "Android_instance_02", "%s (instance %s)", $g_sAndroidEmulator, $g_sAndroidInstance)
If $g_sAndroidInstance <> "" Then
$sAI = $sAndroidInfo2
EndIf
$sMsg = GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_01", "My Bot for %s is already running.\r\n\r\n", $sAI)
If $g_hMutex_BotTitle = 0 Then
SetDebugLog($g_sBotTitle & " is already running, exit now")
DestroySplashScreen()
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg & $cmdLineHelp)
__GDIPlus_Shutdown()
Exit
EndIf
$sMsg = GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_02", "My Bot with Profile %s is already in use.\r\n\r\n", $g_sProfileCurrentName)
If aquireProfileMutex() = 0 Then
ReleaseMutex($g_hMutex_BotTitle)
releaseProfilesMutex(True)
DestroySplashScreen()
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg & $cmdLineHelp)
__GDIPlus_Shutdown()
Exit
EndIf
$g_hMutex_MyBot = CreateMutex("MyBot.run")
$g_bOnlyInstance = $g_hMutex_MyBot <> 0
SetDebugLog("My Bot is " &($g_bOnlyInstance ? "" : "not ") & "the only running instance")
EndFunc
Func SetupFilesAndFolders()
Local $sOldProfiles = @MyDocumentsDir & "\MyBot.run-Profiles"
If FileExists($sOldProfiles) = 1 And FileExists($g_sPrivateProfilePath) = 0 Then
SetLog("Moving shared_prefs profiles folder...")
If DirMove($sOldProfiles, $g_sPrivateProfilePath) = 0 Then
SetLog("Error moving folder " & $sOldProfiles, $COLOR_ERROR)
SetLog("to new location " & $g_sPrivateProfilePath, $COLOR_ERROR)
SetLog("Please resolve manually!", $COLOR_ERROR)
Else
SetLog("Moved shared_prefs profiles to " & $g_sPrivateProfilePath, $COLOR_SUCCESS)
EndIf
EndIf
DirCreate($g_sProfilePresetPath)
DirCreate($g_sPrivateProfilePath & "\" & $g_sProfileCurrentName)
DirCreate($g_sProfilePath & "\" & $g_sProfileCurrentName)
DirCreate($g_sProfileLogsPath)
DirCreate($g_sProfileLootsPath)
DirCreate($g_sProfileTempPath)
DirCreate($g_sProfileTempDebugPath)
$g_sProfileDonateCapturePath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\'
$g_sProfileDonateCaptureWhitelistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\White List\'
$g_sProfileDonateCaptureBlacklistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\Black List\'
DirCreate($g_sProfileDonateCapturePath)
DirCreate($g_sProfileDonateCaptureWhitelistPath)
DirCreate($g_sProfileDonateCaptureBlacklistPath)
FileMove(@ScriptDir & "\*.ini", $g_sProfilePath & "\" & $g_sProfileCurrentName, $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Logs", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs", $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Loots", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots", $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Temp", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp", $FC_OVERWRITE + $FC_CREATEPATH)
DirRemove(@ScriptDir & "\Logs", 1)
DirRemove(@ScriptDir & "\Loots", 1)
DirRemove(@ScriptDir & "\Temp", 1)
If FileExists($g_sProfileConfigPath) = 0 Then
createProfile(True)
applyConfig()
EndIf
If $g_bDeleteLogs Then DeleteFiles($g_sProfileLogsPath, "*.*", $g_iDeleteLogsDays, 0)
If $g_bDeleteLoots Then DeleteFiles($g_sProfileLootsPath, "*.*", $g_iDeleteLootsDays, 0)
If $g_bDeleteTemp Then
DeleteFiles($g_sProfileTempPath, "*.*", $g_iDeleteTempDays, 0)
DeleteFiles($g_sProfileTempDebugPath, "*.*", $g_iDeleteTempDays, 0, $FLTAR_RECUR)
EndIf
SetDebugLog("$g_sProfilePath = " & $g_sProfilePath)
SetDebugLog("$g_sProfileCurrentName = " & $g_sProfileCurrentName)
SetDebugLog("$g_sProfileLogsPath = " & $g_sProfileLogsPath)
EndFunc
Func FinalInitialization(Const $sAI)
Local $bCheckPrerequisitesOK = CheckPrerequisites(True)
If $bCheckPrerequisitesOK Then
MBRFunc(True)
setAndroidPID()
SetBotGuiPID()
EndIf
If $g_bFoundRunningAndroid Then
SetLog(GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_03", "Found running %s %s", $g_sAndroidEmulator, $g_sAndroidVersion), $COLOR_SUCCESS)
EndIf
If $g_bFoundInstalledAndroid Then
SetLog("Found installed " & $g_sAndroidEmulator & " " & $g_sAndroidVersion, $COLOR_SUCCESS)
EndIf
SetLog(GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_04", "Android Emulator Configuration: %s", $sAI), $COLOR_SUCCESS)
$g_iGuiPID = @AutoItPID
$g_iBotLaunchTime = __TimerDiff($g_hBotLaunchTime)
If $g_iGuiMode = 0 Then
SplashStep(GetTranslatedFileIni("MBR GUI Design - Loading", "Waiting_for_Remote_GUI", "Waiting for remote GUI..."))
SetDebugLog("Wait for GUI Process...")
Local $timer = __TimerInit()
While $g_iGuiPID = @AutoItPID And __TimerDiff($timer) < 60000
Sleep(50)
WEnd
If $g_iGuiPID = @AutoItPID Then
SetDebugLog("GUI Process not received, close bot")
BotClose()
$bCheckPrerequisitesOK = False
Else
SetDebugLog("Linked to GUI Process " & $g_iGuiPID)
EndIf
EndIf
DestroySplashScreen(False)
If $bCheckPrerequisitesOK Then
ForumAuthentication()
EndIf
DestroySplashScreen()
CheckVersion()
UpdateMultiStats()
SetDebugLog("Maximum of " & $g_iGlobalActiveBotsAllowed & " bots running at same time configured")
SetDebugLog("MyBot.run launch time " & Round($g_iBotLaunchTime) & " ms.")
If $g_bAndroidShieldEnabled = False Then
SetLog(GetTranslatedFileIni("MBR GUI Design - Loading", "Msg_Android_instance_05", "Android Shield not available for %s", @OSVersion), $COLOR_ACTION)
EndIf
DisableProcessWindowsGhosting()
UpdateMainGUI()
EndFunc
Func MainLoop($bCheckPrerequisitesOK = True)
Local $iStartDelay = 0
If $bCheckPrerequisitesOK And($g_bAutoStart Or $g_bRestarted = True) Then
Local $iDelay = $g_iAutoStartDelay
If $g_bRestarted = True Then $iDelay = 0
$iStartDelay = $iDelay * 1000
$g_iBotAction = $eBotStart
If $g_bBotLaunchOption_HideAndroid Then $g_bIsHidden = True
If $g_bBotLaunchOption_MinimizeBot Then BotMinimizeRequest()
EndIf
Local $hStarttime = _Timer_Init()
CheckEmuNewVersions()
NotifyGetLastMessageFromTelegram()
$g_iTGLastRemote = $g_sTGLast_UID
While 1
_Sleep($DELAYSLEEP, True, False)
Local $diffhStarttime = _Timer_Diff($hStarttime)
If Not $g_bRunState And $g_bNotifyTGEnable And $g_bNotifyRemoteEnable And $diffhStarttime > 1000 * 15 Then
$hStarttime = _Timer_Init()
NotifyRemoteControlProcBtnStart()
EndIf
Switch $g_iBotAction
Case $eBotStart
BotStart($iStartDelay)
$iStartDelay = 0
If $g_iBotAction = $eBotStart Then $g_iBotAction = $eBotNoAction
Case $eBotStop
BotStop()
If $g_iBotAction = $eBotStop Then $g_iBotAction = $eBotNoAction
$g_iTGLastRemote = $g_sTGLast_UID
Case $eBotSearchMode
BotSearchMode()
If $g_iBotAction = $eBotSearchMode Then $g_iBotAction = $eBotNoAction
Case $eBotClose
BotClose()
EndSwitch
WEnd
EndFunc
Func runBot()
Local $iWaitTime
InitiateSwitchAcc()
If ProfileSwitchAccountEnabled() And $g_bReMatchAcc Then
SetLog("Rematching Account [" & $g_iNextAccount + 1 & "] with Profile [" & GUICtrlRead($g_ahCmbProfile[$g_iNextAccount]) & "]")
SwitchCoCAcc($g_iNextAccount)
EndIf
FirstCheck()
While 1
If FileExists(@ScriptDir & "\EnableMBRDebug.txt") Then
While(FileReadLine(@ScriptDir & "\EnableMBRDebug.txt") = "wait")
If _SleepStatus(15000) = True Then Return
WEnd
EndIf
If $b_iAutoRestartDelay > 0 And __TimerDiff($g_hBotLaunchTime) > $b_iAutoRestartDelay * 1000 Then
If RestartBot(False) = True Then Return
EndIf
PrepareDonateCC()
If Not $g_bRunState Then Return
$g_bRestart = False
$g_bFullArmy = False
$g_iCommandStop = -1
If _Sleep($DELAYRUNBOT1) Then Return
checkMainScreen()
If $g_bRestart = True Then ContinueLoop
chkShieldStatus()
If Not $g_bRunState Then Return
If $g_bRestart = True Then ContinueLoop
checkObstacles()
If $g_bRestart = True Then ContinueLoop
If $g_bUpdateSharedPrefs Then PullSharedPrefs()
If $g_bQuicklyFirstStart = True Then
$g_bQuicklyFirstStart = False
Else
$g_bQuickAttack = QuickAttack()
EndIf
If CheckAndroidReboot() = True Then ContinueLoop
If $g_bIsClientSyncError = False And $g_bIsSearchLimit = False And($g_bQuickAttack = False) Then
If BotCommand() Then btnStop()
If _Sleep($DELAYRUNBOT2) Then Return
checkMainScreen(False)
If $g_bRestart = True Then ContinueLoop
If _Sleep($DELAYRUNBOT3) Then Return
VillageReport()
ProfileSwitch()
CheckFarmSchedule()
If Not $g_bRunState Then Return
If $g_bOutOfGold = True And(Number($g_aiCurrentLoot[$eLootGold]) >= Number($g_iTxtRestartGold)) Then
$g_bOutOfGold = False
SetLog("Switching back to normal after no gold to search ...", $COLOR_SUCCESS)
ContinueLoop
EndIf
If $g_bOutOfElixir = True And(Number($g_aiCurrentLoot[$eLootElixir]) >= Number($g_iTxtRestartElixir)) And(Number($g_aiCurrentLoot[$eLootDarkElixir]) >= Number($g_iTxtRestartDark)) Then
$g_bOutOfElixir = False
SetLog("Switching back to normal setting after no elixir to train ...", $COLOR_SUCCESS)
ContinueLoop
EndIf
If _Sleep($DELAYRUNBOT5) Then Return
checkMainScreen(False)
If $g_bRestart = True Then ContinueLoop
$g_bcanRequestCC = True
RequestCC()
If _Sleep($DELAYRUNBOT1) = False Then checkMainScreen(False)
Local $aRndFuncList = ['LabCheck', 'Collect', 'CheckTombs', 'CleanYard']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList) - 1, 1)
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If $g_bRestart = True Then ContinueLoop 2
WEnd
If($g_iCommandStop = 0 Or $g_iCommandStop = 3) And ProfileSwitchAccountEnabled() And Not $g_abDonateOnly[$g_iCurAccount] Then checkSwitchAcc()
AddIdleTime()
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If IsSearchAttackEnabled() Then
Local $aRndFuncList = ['ReplayShare', 'NotifyReport', 'DonateCC,Train', 'CollectFreeMagicItems']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList) - 1, 1)
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If CheckAndroidReboot() = True Then ContinueLoop 2
WEnd
BoostTrainingPotion()
Local $aRndFuncList = ['BoostBarracks', 'BoostSpellFactory', 'BoostWorkshop', 'BoostKing', 'BoostQueen', 'BoostWarden']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList) - 1, 1)
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If CheckAndroidReboot() = True Then ContinueLoop 2
WEnd
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If $g_iUnbrkMode >= 1 Then
If Unbreakable() = True Then ContinueLoop
EndIf
EndIf
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) Then
If BalanceDonRec(True) Then DonateCC()
EndIf
Local $aRndFuncList = ['Laboratory', 'UpgradeHeroes', 'UpgradeBuilding', 'BuilderBase']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
$Index = Random(0, UBound($aRndFuncList) - 1, 1)
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If CheckAndroidReboot() = True Then ContinueLoop 2
WEnd
ClanHop()
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If IsSearchAttackEnabled() Then
$g_iNbrOfWallsUpped = 0
If Not $g_bChkClanHop Then UpgradeWall()
If _Sleep($DELAYRUNBOT3) Then Return
If $g_bRestart = True Then ContinueLoop
If ProfileSwitchAccountEnabled() And $g_abDonateOnly[$g_iCurAccount] Then checkSwitchAcc()
Idle()
If _Sleep($DELAYRUNBOT3) Then Return
If $g_bRestart = True Then ContinueLoop
If $g_iCommandStop <> 0 And $g_iCommandStop <> 3 Then
AttackMain()
$g_bSkipFirstZoomout = False
If $g_bOutOfGold = True Then
SetLog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_ERROR)
$g_bFirstStart = True
ContinueLoop
EndIf
If _Sleep($DELAYRUNBOT1) Then Return
If $g_bRestart = True Then ContinueLoop
EndIf
Else
$iWaitTime = Random($DELAYWAITATTACK1, $DELAYWAITATTACK2)
SetLog("Attacking Not Planned and Skipped, Waiting random " & StringFormat("%0.1f", $iWaitTime / 1000) & " Seconds", $COLOR_WARNING)
If _SleepStatus($iWaitTime) Then Return False
EndIf
Else
If $g_bQuickAttack Then
SetLog("Quick Restart... ", $COLOR_INFO)
Else
If $g_bIsSearchLimit = True Then
SetLog("Restarted due search limit", $COLOR_INFO)
ElseIf $g_bIsSearchTimeout = True Then
SetLog("[Legend League] Restarted due search timeout", $COLOR_INFO)
Else
SetLog("Restarted after Out of Sync Error: Attack Now", $COLOR_INFO)
EndIf
EndIf
If _Sleep($DELAYRUNBOT3) Then Return
$g_aiCurrentLoot[$eLootTrophy] = Number(getTrophyMainScreen($aTrophies[0], $aTrophies[1]))
If $g_bDebugSetlog Then SetDebugLog("Runbot Trophy Count: " & $g_aiCurrentLoot[$eLootTrophy], $COLOR_DEBUG)
AttackMain()
If Not $g_bRunState Then Return
$g_bSkipFirstZoomout = False
If $g_bOutOfGold = True Then
SetLog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_ERROR)
$g_bFirstStart = True
$g_bIsClientSyncError = False
ContinueLoop
EndIf
If _Sleep($DELAYRUNBOT5) Then Return
If $g_bRestart = True Then ContinueLoop
EndIf
WEnd
EndFunc
Func Idle()
$g_bIdleState = True
Local $Result = _Idle()
$g_bIdleState = False
Return $Result
EndFunc
Func _Idle()
Static $iCollectCounter = 0
Local $TimeIdle = 0
If $g_bDebugSetlog Then SetDebugLog("Func Idle ", $COLOR_DEBUG)
If $g_bChkClanHop Then Return
While $g_bIsFullArmywithHeroesAndSpells = False
CheckAndroidReboot()
NotifyPendingActions()
If _Sleep($DELAYIDLE1) Then Return
If $g_iCommandStop = -1 Then SetLog("====== Waiting for full army ======", $COLOR_SUCCESS)
Local $hTimer = __TimerInit()
If _Sleep($DELAYIDLE1) Then ExitLoop
checkObstacles()
checkMainScreen(False)
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $g_bTrainEnabled = True Then
CheckArmyCamp(True, True)
If _Sleep($DELAYIDLE1) Then Return
If($g_bIsFullArmywithHeroesAndSpells = False) Then
SetLog("Army Camp is not full, Training Continues...", $COLOR_ACTION)
$g_iCommandStop = 0
EndIf
EndIf
ReplayShare($g_bShareAttackEnableNow)
If _Sleep($DELAYIDLE1) Then Return
If $g_bRestart = True Then ExitLoop
If $iCollectCounter > $g_iCollectAtCount Then
Local $aRndFuncList = ['Collect', 'CheckTombs', 'DonateCC', 'CleanYard']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ExitLoop
If CheckAndroidReboot() Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList) - 1, 1)
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
WEnd
If $g_bRunState = False Then Return
If $g_bRestart = True Then ExitLoop
If _Sleep($DELAYIDLE1) Or $g_bRunState = False Then ExitLoop
$iCollectCounter = 0
EndIf
$iCollectCounter = $iCollectCounter + 1
AddIdleTime()
checkMainScreen(False)
If $g_iCommandStop = -1 Then
If $g_iActualTrainSkip < $g_iMaxTrainSkip Then
If CheckNeedOpenTrain($g_sTimeBeforeTrain) Then TrainSystem()
If $g_bRestart = True Then ExitLoop
If _Sleep($DELAYIDLE1) Then ExitLoop
checkMainScreen(False)
$g_iActualTrainSkip = $g_iActualTrainSkip + 1
Else
SetLog("Humanize bot, prevent to delete and recreate troops " & $g_iActualTrainSkip + 1 & "/" & $g_iMaxTrainSkip, $color_blue)
If $g_iActualTrainSkip >= $g_iMaxTrainSkip Then
$g_iActualTrainSkip = 0
EndIf
CheckArmyCamp(True, True)
EndIf
EndIf
If _Sleep($DELAYIDLE1) Then Return
If $g_iCommandStop = 0 And $g_bTrainEnabled = True Then
If Not($g_bIsFullArmywithHeroesAndSpells) Then
If $g_iActualTrainSkip < $g_iMaxTrainSkip Then
If CheckNeedOpenTrain($g_sTimeBeforeTrain) Or(ProfileSwitchAccountEnabled() And $g_iActiveDonate And $g_bChkDonate) Then TrainSystem()
If $g_bRestart = True Then ExitLoop
If _Sleep($DELAYIDLE1) Then ExitLoop
checkMainScreen(False)
If Not $g_bRunState Then Return
$g_iActualTrainSkip = $g_iActualTrainSkip + 1
Else
If $g_iActualTrainSkip >= $g_iMaxTrainSkip Then
$g_iActualTrainSkip = 0
EndIf
CheckArmyCamp(True, True)
If Not $g_bRunState Then Return
EndIf
EndIf
If $g_bIsFullArmywithHeroesAndSpells And $g_bTrainEnabled = True Then
SetLog("Army Camp is full, stop Training...", $COLOR_ACTION)
$g_iCommandStop = 3
EndIf
EndIf
If _Sleep($DELAYIDLE1) Then Return
If $g_iCommandStop = -1 Then
DropTrophy()
If Not $g_bRunState Then Return
If $g_bRestart = True Then ExitLoop
If _Sleep($DELAYIDLE1) Then ExitLoop
checkMainScreen(False)
EndIf
If _Sleep($DELAYIDLE1) Then Return
If $g_bRestart = True Then ExitLoop
$TimeIdle += Round(__TimerDiff($hTimer) / 1000, 2)
If $g_bCanRequestCC = True Then RequestCC()
SetLog("Time Idle: " & StringFormat("%02i", Floor(Floor($TimeIdle / 60) / 60)) & ":" & StringFormat("%02i", Floor(Mod(Floor($TimeIdle / 60), 60))) & ":" & StringFormat("%02i", Floor(Mod($TimeIdle, 60))))
If $g_bOutOfGold = True Or $g_bOutOfElixir = True Then Return
If ProfileSwitchAccountEnabled() Then checkSwitchAcc()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $g_bTrainEnabled = False Then ExitLoop
If $g_iCommandStop = -1 Then
SmartWait4Train()
If Not $g_bRunState Then Return
If $g_bRestart = True Then ExitLoop
EndIf
WEnd
EndFunc
Func AttackMain()
If ProfileSwitchAccountEnabled() And $g_abDonateOnly[$g_iCurAccount] Then Return
ClickP($aAway, 1, 0, "#0000")
If IsSearchAttackEnabled() Then
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If ProfileSwitchAccountEnabled() And($g_aiAttackedCountSwitch[$g_iCurAccount] <= $g_aiAttackedCount - 2) Then checkSwitchAcc()
If $g_bUseCCBalanced = True Then
ProfileReport()
If Not $g_bRunState Then Return
If _Sleep($DELAYATTACKMAIN1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then Return
EndIf
If $g_bDropTrophyEnable And Number($g_aiCurrentLoot[$eLootTrophy]) > Number($g_iDropTrophyMax) Then
DropTrophy()
If Not $g_bRunState Then Return
$g_bIsClientSyncError = False
If _Sleep($DELAYATTACKMAIN1) Then Return
Return
EndIf
If $g_bDebugSetlog Then
SetDebugLog(_PadStringCenter(" Hero status check" & BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $g_iHeroAvailable) & "|" & $g_aiSearchHeroWaitEnable[$DB] & "|" & $g_iHeroAvailable, 54, "="), $COLOR_DEBUG)
SetDebugLog(_PadStringCenter(" Hero status check" & BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $g_iHeroAvailable) & "|" & $g_aiSearchHeroWaitEnable[$LB] & "|" & $g_iHeroAvailable, 54, "="), $COLOR_DEBUG)
EndIf
_ClanGames()
ClickP($aAway, 1, 0, "#0000")
PrepareSearch()
If Not $g_bRunState Then Return
If $g_bOutOfGold = True Then Return
If $g_bRestart = True Then Return
VillageSearch()
If $g_bOutOfGold = True Then Return
If Not $g_bRunState Then Return
If $g_bRestart = True Then Return
PrepareAttack($g_iMatchMode)
If Not $g_bRunState Then Return
If $g_bRestart = True Then Return
Attack()
If Not $g_bRunState Then Return
If $g_bRestart = True Then Return
ReturnHome($g_bTakeLootSnapShot)
If Not $g_bRunState Then Return
If _Sleep($DELAYATTACKMAIN2) Then Return
Return True
Else
If Not $g_bChkClanHop Then
SetLog("None of search condition match:", $COLOR_WARNING)
SetLog("Search, Trophy or Army Camp % are out of range in search setting", $COLOR_WARNING)
$g_bIsSearchLimit = False
$g_bIsClientSyncError = False
$g_bQuickAttack = False
If ProfileSwitchAccountEnabled() Then checkSwitchAcc()
SmartWait4Train()
Else
SetLog("Skipping Attack because Clan Hop is enabled!", $COLOR_INFO)
EndIf
EndIf
Else
SetLog("Attacking Not Planned, Skipped..", $COLOR_WARNING)
EndIf
EndFunc
Func Attack()
$g_bAttackActive = True
SetLog(" ====== Start Attack ====== ", $COLOR_SUCCESS)
If($g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 1) Or($g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 1) Then
If $g_bDebugSetlog Then SetDebugLog("start scripted attack", $COLOR_ERROR)
Algorithm_AttackCSV()
ElseIf $g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 2 Then
If $g_bDebugSetlog Then SetDebugLog("start smart farm attack", $COLOR_ERROR)
Local $Nside = ChkSmartFarm()
If Not $g_bRunState Then Return
AttackSmartFarm($Nside[1], $Nside[2])
Else
If $g_bDebugSetlog Then SetDebugLog("start standard attack", $COLOR_ERROR)
algorithm_AllTroops()
EndIf
$g_bAttackActive = False
EndFunc
Func QuickAttack()
getArmyTroopCapacity(True, True)
If IsSearchModeActive($TS) Then
VillageReport()
EndIf
$g_aiCurrentLoot[$eLootTrophy] = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If($g_bDropTrophyEnable And Number($g_aiCurrentLoot[$eLootTrophy]) > Number($g_iDropTrophyMax)) Then
If $g_bDebugSetlog Then SetDebugLog("No quickly re-attack, need to drop tropies", $COLOR_DEBUG)
Return False
EndIf
If IsSearchModeActive($TS) Then
If Int($g_CurrentCampUtilization) >= $g_iTotalCampSpace * $g_aiSearchCampsPct[$TS] / 100 And $g_abSearchCampsEnable[$TS] Then
If $g_bDebugSetlog Then SetDebugLog("THSnipe: Quickly re-attack " & Int($g_CurrentCampUtilization) & " >= " & $g_iTotalCampSpace & " * " & $g_aiSearchCampsPct[$TS] & "/100 " & "= " & $g_iTotalCampSpace * $g_aiSearchCampsPct[$TS] / 100, $COLOR_DEBUG)
Return True
Else
If $g_bDebugSetlog Then SetDebugLog("THSnipe: No Quickly re-attack:  cur. " & Int($g_CurrentCampUtilization) & "  need " & $g_iTotalCampSpace * $g_aiSearchCampsPct[$TS] / 100 & " firststart = " &($g_bQuicklyFirstStart), $COLOR_DEBUG)
Return False
EndIf
EndIf
EndFunc
Func _RunFunction($action)
SetDebugLog("_RunFunction: " & $action & " BEGIN", $COLOR_DEBUG2)
Switch $action
Case "Collect"
Collect()
_Sleep($DELAYRUNBOT1)
Case "CheckTombs"
CheckTombs()
_Sleep($DELAYRUNBOT3)
Case "CleanYard"
CleanYard()
Case "ReplayShare"
If $g_bChkClanHop Then Return
ReplayShare($g_bShareAttackEnableNow)
_Sleep($DELAYRUNBOT3)
Case "NotifyReport"
If $g_bChkClanHop Then Return
NotifyReport()
_Sleep($DELAYRUNBOT3)
Case "DonateCC"
If $g_bChkClanHop Then Return
If $g_iActiveDonate And $g_bChkDonate Then
If SkipDonateNearFullTroops(True) = False And BalanceDonRec(True) Then DonateCC()
If _Sleep($DELAYRUNBOT1) = False Then checkMainScreen(False)
EndIf
Case "DonateCC,Train"
If $g_iActiveDonate And $g_bChkDonate Then
If $g_bFirstStart Then
getArmyTroopCapacity(True, False)
getArmySpellCapacity(False, True)
EndIf
If SkipDonateNearFullTroops(True) = False And BalanceDonRec(True) Then DonateCC()
EndIf
If _Sleep($DELAYRUNBOT1) = False Then checkMainScreen(False)
If $g_bTrainEnabled Then
If $g_iActualTrainSkip < $g_iMaxTrainSkip Then
TrainSystem()
_Sleep($DELAYRUNBOT1)
Else
SetLog("Humanize bot, prevent to delete and recreate troops " & $g_iActualTrainSkip + 1 & "/" & $g_iMaxTrainSkip, $color_blue)
$g_iActualTrainSkip = $g_iActualTrainSkip + 1
If $g_iActualTrainSkip >= $g_iMaxTrainSkip Then
$g_iActualTrainSkip = 0
EndIf
CheckOverviewFullArmy(True, False)
getArmySpells()
getArmyHeroCount(False, True)
EndIf
Else
If $g_bDebugSetlogTrain Then SetLog("Halt mode - training disabled", $COLOR_DEBUG)
EndIf
Case "BoostBarracks"
BoostBarracks()
Case "BoostSpellFactory"
BoostSpellFactory()
Case "BoostWorkshop"
BoostWorkshop()
Case "BoostKing"
If $g_bChkClanHop Then Return
BoostKing()
Case "BoostQueen"
If $g_bChkClanHop Then Return
BoostQueen()
Case "BoostWarden"
If $g_bChkClanHop Then Return
BoostWarden()
Case "BoostTrainingPotion"
BoostTrainingPotion()
Case "BoostResourcePotion"
BoostResourcePotion()
Case "LabCheck"
LabGuiDisplay()
_Sleep($DELAYRUNBOT3)
Case "RequestCC"
If $g_bChkClanHop Then Return
RequestCC()
If _Sleep($DELAYRUNBOT1) = False Then checkMainScreen(False)
Case "Laboratory"
If $g_bChkClanHop Then Return
Laboratory()
If _Sleep($DELAYRUNBOT3) = False Then checkMainScreen(False)
Case "UpgradeHeroes"
If $g_bChkClanHop Then Return
UpgradeHeroes()
_Sleep($DELAYRUNBOT3)
Case "UpgradeBuilding"
If $g_bChkClanHop Then Return
UpgradeBuilding()
_Sleep($DELAYRUNBOT3)
AutoUpgrade()
_Sleep($DELAYRUNBOT3)
Case "BuilderBase"
If isOnBuilderBase() Or(($g_bChkCollectBuilderBase Or $g_bChkStartClockTowerBoost Or $g_iChkBBSuggestedUpgrades) And SwitchBetweenBases()) Then
BuilderBaseReport()
CollectBuilderBase()
_Sleep($DELAYRUNBOT3)
StartClockTowerBoost()
_Sleep($DELAYRUNBOT3)
StarLaboratory()
_Sleep($DELAYRUNBOT3)
CleanBBYard()
_Sleep($DELAYRUNBOT3)
MainSuggestedUpgradeCode()
BuilderBaseReport()
SwitchBetweenBases()
EndIf
_Sleep($DELAYRUNBOT3)
Case "CollectFreeMagicItems"
CollectFreeMagicItems()
_Sleep($DELAYRUNBOT3)
Case ""
SetDebugLog("Function call doesn't support empty string, please review array size", $COLOR_ERROR)
Case Else
SetLog("Unknown function call: " & $action, $COLOR_ERROR)
EndSwitch
SetDebugLog("_RunFunction: " & $action & " END", $COLOR_DEBUG2)
EndFunc
Func FirstCheck()
SetDebugLog("-- FirstCheck Loop --")
If Not $g_bRunState Then Return
If $g_bChkClanHop Then Return
If ProfileSwitchAccountEnabled() And $g_abDonateOnly[$g_iCurAccount] Then Return
$g_bRestart = False
$g_bFullArmy = False
$g_iCommandStop = -1
VillageReport()
ProfileSwitch()
CheckFarmSchedule()
If Not $g_bRunState Then Return
If $g_bRequestCCDefense Then chkShieldStatus()
If $g_bOutOfGold = True And(Number($g_aiCurrentLoot[$eLootGold]) >= Number($g_iTxtRestartGold)) Then
$g_bOutOfGold = False
SetLog("Switching back to normal after no gold to search ...", $COLOR_SUCCESS)
Return
EndIf
If $g_bOutOfElixir = True And(Number($g_aiCurrentLoot[$eLootElixir]) >= Number($g_iTxtRestartElixir)) And(Number($g_aiCurrentLoot[$eLootDarkElixir]) >= Number($g_iTxtRestartDark)) Then
$g_bOutOfElixir = False
SetLog("Switching back to normal setting after no elixir to train ...", $COLOR_SUCCESS)
Return
EndIf
If _Sleep($DELAYRUNBOT5) Then Return
checkMainScreen(False)
If $g_bRestart = True Then Return
$g_bcanRequestCC = True
RequestCC()
If _Sleep($DELAYRUNBOT1) = False Then checkMainScreen(False)
If BotCommand() Then btnStop()
If $g_iCommandStop <> 0 And $g_iCommandStop <> 3 Then
SetDebugLog("-- FirstCheck on Train --")
TrainSystem()
If Not $g_bRunState Then Return
SetDebugLog("Are you ready? " & String($g_bIsFullArmywithHeroesAndSpells))
If $g_bIsFullArmywithHeroesAndSpells Then
If(isInsideDiamond($g_aiTownHallPos) = False) Then
BotDetectFirstTime()
EndIf
If $g_iCommandStop <> 0 And $g_iCommandStop <> 3 Then
Setlog("Before any other routine let's attack!!", $COLOR_INFO)
If Not $g_bRunState Then Return
AttackMain()
$g_bSkipFirstZoomout = False
If $g_bOutOfGold = True Then
SetLog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_ERROR)
$g_bFirstStart = True
Return
EndIf
If _Sleep($DELAYRUNBOT1) Then Return
EndIf
EndIf
EndIf
EndFunc
